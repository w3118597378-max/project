(self["webpackChunkvue3_nf0"] = self["webpackChunkvue3_nf0"] || []).push([[504],{

/***/ 2:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var IS_PURE = __webpack_require__(6926);
var store = __webpack_require__(9310);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.8.3',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 33:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $3: function() { return /* binding */ hasOwn; },
/* harmony export */   $H: function() { return /* binding */ hasChanged; },
/* harmony export */   BH: function() { return /* binding */ isGloballyAllowed; },
/* harmony export */   BX: function() { return /* binding */ looseEqual; },
/* harmony export */   Bm: function() { return /* binding */ isSymbol; },
/* harmony export */   C4: function() { return /* binding */ normalizeClass; },
/* harmony export */   CE: function() { return /* binding */ isMap; },
/* harmony export */   CP: function() { return /* binding */ isModelListener; },
/* harmony export */   DY: function() { return /* binding */ invokeArrayFns; },
/* harmony export */   Gv: function() { return /* binding */ isObject; },
/* harmony export */   J$: function() { return /* binding */ isSpecialBooleanAttr; },
/* harmony export */   Kg: function() { return /* binding */ isString; },
/* harmony export */   MZ: function() { return /* binding */ EMPTY_OBJ; },
/* harmony export */   Mp: function() { return /* binding */ isOn; },
/* harmony export */   NO: function() { return /* binding */ NO; },
/* harmony export */   Oj: function() { return /* binding */ EMPTY_ARR; },
/* harmony export */   PT: function() { return /* binding */ camelize; },
/* harmony export */   Qd: function() { return /* binding */ isPlainObject; },
/* harmony export */   Ro: function() { return /* binding */ toNumber; },
/* harmony export */   SU: function() { return /* binding */ isReservedProp; },
/* harmony export */   TF: function() { return /* binding */ remove; },
/* harmony export */   Tg: function() { return /* binding */ hyphenate; },
/* harmony export */   Tn: function() { return /* binding */ isFunction; },
/* harmony export */   Tr: function() { return /* binding */ normalizeStyle; },
/* harmony export */   We: function() { return /* binding */ getGlobalThis; },
/* harmony export */   X$: function() { return /* binding */ extend; },
/* harmony export */   Y2: function() { return /* binding */ includeBooleanAttr; },
/* harmony export */   ZH: function() { return /* binding */ capitalize; },
/* harmony export */   Zf: function() { return /* binding */ toRawType; },
/* harmony export */   _B: function() { return /* binding */ normalizeProps; },
/* harmony export */   bB: function() { return /* binding */ looseToNumber; },
/* harmony export */   cy: function() { return /* binding */ isArray; },
/* harmony export */   gd: function() { return /* binding */ isRegExp; },
/* harmony export */   pD: function() { return /* binding */ makeMap; },
/* harmony export */   rU: function() { return /* binding */ toHandlerKey; },
/* harmony export */   tE: function() { return /* binding */ NOOP; },
/* harmony export */   u3: function() { return /* binding */ looseIndexOf; },
/* harmony export */   vM: function() { return /* binding */ isSet; },
/* harmony export */   v_: function() { return /* binding */ toDisplayString; },
/* harmony export */   yI: function() { return /* binding */ isIntegerKey; },
/* harmony export */   yL: function() { return /* binding */ isPromise; },
/* harmony export */   yQ: function() { return /* binding */ def; }
/* harmony export */ });
/* unused harmony exports PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, cssVarNameEscapeSymbolsRE, escapeHtml, escapeHtmlComment, genCacheKey, genPropsAccessExp, generateCodeFrame, getEscapedCssVarName, isBooleanAttr, isBuiltInDirective, isDate, isGloballyWhitelisted, isHTMLTag, isKnownHtmlAttr, isKnownMathMLAttr, isKnownSvgAttr, isMathMLTag, isRenderableAttrValue, isSSRSafeAttrName, isSVGTag, isVoidTag, objectToString, parseStringStyle, propsToAttrMap, slotFlagsText, stringifyStyle, toTypeString */
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}

const EMPTY_OBJ =  false ? 0 : {};
const EMPTY_ARR =  false ? 0 : [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
)));
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : {});
};
const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
function genPropsAccessExp(name) {
  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;
}
function genCacheKey(source, options) {
  return source + JSON.stringify(
    options,
    (_, val) => typeof val === "function" ? val.toString() : val
  );
}

const PatchFlags = {
  "TEXT": 1,
  "1": "TEXT",
  "CLASS": 2,
  "2": "CLASS",
  "STYLE": 4,
  "4": "STYLE",
  "PROPS": 8,
  "8": "PROPS",
  "FULL_PROPS": 16,
  "16": "FULL_PROPS",
  "NEED_HYDRATION": 32,
  "32": "NEED_HYDRATION",
  "STABLE_FRAGMENT": 64,
  "64": "STABLE_FRAGMENT",
  "KEYED_FRAGMENT": 128,
  "128": "KEYED_FRAGMENT",
  "UNKEYED_FRAGMENT": 256,
  "256": "UNKEYED_FRAGMENT",
  "NEED_PATCH": 512,
  "512": "NEED_PATCH",
  "DYNAMIC_SLOTS": 1024,
  "1024": "DYNAMIC_SLOTS",
  "DEV_ROOT_FRAGMENT": 2048,
  "2048": "DEV_ROOT_FRAGMENT",
  "CACHED": -1,
  "-1": "CACHED",
  "BAIL": -2,
  "-2": "BAIL"
};
const PatchFlagNames = {
  [1]: `TEXT`,
  [2]: `CLASS`,
  [4]: `STYLE`,
  [8]: `PROPS`,
  [16]: `FULL_PROPS`,
  [32]: `NEED_HYDRATION`,
  [64]: `STABLE_FRAGMENT`,
  [128]: `KEYED_FRAGMENT`,
  [256]: `UNKEYED_FRAGMENT`,
  [512]: `NEED_PATCH`,
  [1024]: `DYNAMIC_SLOTS`,
  [2048]: `DEV_ROOT_FRAGMENT`,
  [-1]: `CACHED`,
  [-2]: `BAIL`
};

const ShapeFlags = {
  "ELEMENT": 1,
  "1": "ELEMENT",
  "FUNCTIONAL_COMPONENT": 2,
  "2": "FUNCTIONAL_COMPONENT",
  "STATEFUL_COMPONENT": 4,
  "4": "STATEFUL_COMPONENT",
  "TEXT_CHILDREN": 8,
  "8": "TEXT_CHILDREN",
  "ARRAY_CHILDREN": 16,
  "16": "ARRAY_CHILDREN",
  "SLOTS_CHILDREN": 32,
  "32": "SLOTS_CHILDREN",
  "TELEPORT": 64,
  "64": "TELEPORT",
  "SUSPENSE": 128,
  "128": "SUSPENSE",
  "COMPONENT_SHOULD_KEEP_ALIVE": 256,
  "256": "COMPONENT_SHOULD_KEEP_ALIVE",
  "COMPONENT_KEPT_ALIVE": 512,
  "512": "COMPONENT_KEPT_ALIVE",
  "COMPONENT": 6,
  "6": "COMPONENT"
};

const SlotFlags = {
  "STABLE": 1,
  "1": "STABLE",
  "DYNAMIC": 2,
  "2": "DYNAMIC",
  "FORWARDED": 3,
  "3": "FORWARDED"
};
const slotFlagsText = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
};

const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
const isGloballyWhitelisted = (/* unused pure expression or super */ null && (isGloballyAllowed));

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  start = Math.max(0, Math.min(start, source.length));
  end = Math.max(0, Math.min(end, source.length));
  if (start > end) return "";
  let lines = source.split(/(\r?\n)/);
  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
  lines = lines.filter((_, idx) => idx % 2 === 0);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) continue;
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
        if (j === i) {
          const pad = start - (count - (lineLength + newLineSeqLength));
          const length = Math.max(
            1,
            end > count ? lineLength - pad : end - start
          );
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + newLineSeqLength;
        }
      }
      break;
    }
  }
  return res.join("\n");
}

function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function stringifyStyle(styles) {
  if (!styles) return "";
  if (isString(styles)) return styles;
  let ret = "";
  for (const key in styles) {
    const value = styles[key];
    if (isString(value) || typeof value === "number") {
      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
      ret += `${normalizedKey}:${value};`;
    }
  }
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}

const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
const isHTMLTag = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(HTML_TAGS)));
const isSVGTag = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(SVG_TAGS)));
const isMathMLTag = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(MATH_TAGS)));
const isVoidTag = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(VOID_TAGS)));

const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
const isBooleanAttr = /* @__PURE__ */ makeMap(
  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
const attrValidationCache = {};
function isSSRSafeAttrName(name) {
  if (attrValidationCache.hasOwnProperty(name)) {
    return attrValidationCache[name];
  }
  const isUnsafe = unsafeAttrCharRE.test(name);
  if (isUnsafe) {
    console.error(`unsafe attribute name: ${name}`);
  }
  return attrValidationCache[name] = !isUnsafe;
}
const propsToAttrMap = {
  acceptCharset: "accept-charset",
  className: "class",
  htmlFor: "for",
  httpEquiv: "http-equiv"
};
const isKnownHtmlAttr = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
)));
const isKnownSvgAttr = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
)));
const isKnownMathMLAttr = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
)));
function isRenderableAttrValue(value) {
  if (value == null) {
    return false;
  }
  const type = typeof value;
  return type === "string" || type === "number" || type === "boolean";
}

const escapeRE = /["'&<>]/;
function escapeHtml(string) {
  const str = "" + string;
  const match = escapeRE.exec(str);
  if (!match) {
    return str;
  }
  let html = "";
  let escaped;
  let index;
  let lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escaped = "&quot;";
        break;
      case 38:
        escaped = "&amp;";
        break;
      case 39:
        escaped = "&#39;";
        break;
      case 60:
        escaped = "&lt;";
        break;
      case 62:
        escaped = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.slice(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escaped;
  }
  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;
}
const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
function escapeHtmlComment(src) {
  return src.replace(commentStripRE, "");
}
const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function getEscapedCssVarName(key, doubleEscape) {
  return key.replace(
    cssVarNameEscapeSymbolsRE,
    (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
  );
}

function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject(a);
  bValidType = isObject(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}

const isRef = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
  );
};




/***/ }),

/***/ 200:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  // eslint-disable-next-line no-new-func
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 290:
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 641:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $V: function() { return /* binding */ defineAsyncComponent; },
/* harmony export */   $u: function() { return /* binding */ onUpdated; },
/* harmony export */   $y: function() { return /* binding */ resolveDynamicComponent; },
/* harmony export */   BA: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.BA; },
/* harmony export */   Bi: function() { return /* binding */ useId; },
/* harmony export */   Bs: function() { return /* binding */ isMemoSame; },
/* harmony export */   C4: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.C4; },
/* harmony export */   CE: function() { return /* binding */ createElementBlock; },
/* harmony export */   Df: function() { return /* binding */ getTransitionRawChildren; },
/* harmony export */   Dl: function() { return /* binding */ queuePostFlushCb; },
/* harmony export */   E: function() { return /* binding */ withAsyncContext; },
/* harmony export */   E3: function() { return /* binding */ cloneVNode; },
/* harmony export */   EW: function() { return /* binding */ computed; },
/* harmony export */   EY: function() { return /* binding */ Text; },
/* harmony export */   FK: function() { return /* binding */ Fragment; },
/* harmony export */   Fv: function() { return /* binding */ createStaticVNode; },
/* harmony export */   Fw: function() { return /* binding */ ssrContextKey; },
/* harmony export */   GM: function() { return /* binding */ defineOptions; },
/* harmony export */   Gc: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.Gc; },
/* harmony export */   Gt: function() { return /* binding */ provide; },
/* harmony export */   Gw: function() { return /* binding */ ssrUtils; },
/* harmony export */   Gy: function() { return /* binding */ useTransitionState; },
/* harmony export */   H4: function() { return /* binding */ handleError; },
/* harmony export */   HF: function() { return /* binding */ mergeDefaults; },
/* harmony export */   Ht: function() { return /* binding */ useSlots; },
/* harmony export */   IG: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.IG; },
/* harmony export */   IJ: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.IJ; },
/* harmony export */   Ic: function() { return /* binding */ onBeforeUpdate; },
/* harmony export */   Im: function() { return /* binding */ Teleport; },
/* harmony export */   K9: function() { return /* binding */ createRenderer; },
/* harmony export */   KC: function() { return /* binding */ onBeforeMount; },
/* harmony export */   KR: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.KR; },
/* harmony export */   Kf: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.rU; },
/* harmony export */   Kh: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.Kh; },
/* harmony export */   LJ: function() { return /* binding */ resolveFilter; },
/* harmony export */   LM: function() { return /* binding */ useSSRContext; },
/* harmony export */   Lk: function() { return /* binding */ createBaseVNode; },
/* harmony export */   Lu: function() { return /* binding */ defineSlots; },
/* harmony export */   MZ: function() { return /* binding */ setTransitionHooks; },
/* harmony export */   Mw: function() { return /* binding */ Comment; },
/* harmony export */   NP: function() { return /* binding */ defineModel; },
/* harmony export */   Ng: function() { return /* binding */ guardReactiveProps; },
/* harmony export */   OA: function() { return /* binding */ useAttrs; },
/* harmony export */   OW: function() { return /* binding */ resolveTransitionHooks; },
/* harmony export */   PP: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.PP; },
/* harmony export */   PR: function() { return /* binding */ KeepAlive; },
/* harmony export */   PS: function() { return /* binding */ hasInjectionContext; },
/* harmony export */   PT: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.PT; },
/* harmony export */   Pn: function() { return /* binding */ hydrateOnVisible; },
/* harmony export */   Pr: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.Pr; },
/* harmony export */   Q3: function() { return /* binding */ createCommentVNode; },
/* harmony export */   QP: function() { return /* binding */ BaseTransitionPropsValidators; },
/* harmony export */   QW: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.QW; },
/* harmony export */   QZ: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.QZ; },
/* harmony export */   Qi: function() { return /* binding */ pushScopeId; },
/* harmony export */   R1: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.R1; },
/* harmony export */   R8: function() { return /* binding */ warn; },
/* harmony export */   RG: function() { return /* binding */ renderSlot; },
/* harmony export */   SS: function() { return /* binding */ onServerPrefetch; },
/* harmony export */   Tb: function() { return /* binding */ toHandlers; },
/* harmony export */   Tm: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.Tm; },
/* harmony export */   Tq: function() { return /* binding */ hydrateOnInteraction; },
/* harmony export */   Tr: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.Tr; },
/* harmony export */   U4: function() { return /* binding */ assertNumber; },
/* harmony export */   U_: function() { return /* binding */ watchSyncEffect; },
/* harmony export */   Ul: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.Ul; },
/* harmony export */   Vq: function() { return /* binding */ setBlockTracking; },
/* harmony export */   WQ: function() { return /* binding */ inject; },
/* harmony export */   Wv: function() { return /* binding */ createBlock; },
/* harmony export */   X2: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.X2; },
/* harmony export */   Y4: function() { return /* binding */ onDeactivated; },
/* harmony export */   Y5: function() { return /* binding */ compatUtils; },
/* harmony export */   YY: function() { return /* binding */ withScopeId; },
/* harmony export */   Yj: function() { return /* binding */ defineProps; },
/* harmony export */   Yv: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.Yv; },
/* harmony export */   ZH: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.ZH; },
/* harmony export */   ZQ: function() { return /* binding */ ErrorTypeStrings; },
/* harmony export */   _B: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__._B; },
/* harmony export */   aT: function() { return /* binding */ DeprecationTypes; },
/* harmony export */   bF: function() { return /* binding */ createVNode; },
/* harmony export */   bU: function() { return /* binding */ withMemo; },
/* harmony export */   bj: function() { return /* binding */ onRenderTriggered; },
/* harmony export */   bn: function() { return /* binding */ createPropsRestProxy; },
/* harmony export */   bo: function() { return /* binding */ withDirectives; },
/* harmony export */   ch: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ch; },
/* harmony export */   ci: function() { return /* binding */ createHydrationRenderer; },
/* harmony export */   dA: function() { return /* binding */ hydrateOnMediaQuery; },
/* harmony export */   dY: function() { return /* binding */ nextTick; },
/* harmony export */   ds: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ds; },
/* harmony export */   eW: function() { return /* binding */ createTextVNode; },
/* harmony export */   eX: function() { return /* binding */ createSlots; },
/* harmony export */   fE: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.fE; },
/* harmony export */   fn: function() { return /* binding */ useModel; },
/* harmony export */   g2: function() { return /* binding */ resolveComponent; },
/* harmony export */   g8: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.g8; },
/* harmony export */   gN: function() { return /* binding */ resolveDirective; },
/* harmony export */   gW: function() { return /* binding */ transformVNodeArgs; },
/* harmony export */   gh: function() { return /* binding */ callWithErrorHandling; },
/* harmony export */   h: function() { return /* binding */ h; },
/* harmony export */   hi: function() { return /* binding */ onUnmounted; },
/* harmony export */   i9: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.i9; },
/* harmony export */   iD: function() { return /* binding */ setDevtoolsHook; },
/* harmony export */   jC: function() { return /* binding */ Static; },
/* harmony export */   jr: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.jr; },
/* harmony export */   jt: function() { return /* binding */ popScopeId; },
/* harmony export */   ju: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ju; },
/* harmony export */   k6: function() { return /* binding */ withCtx; },
/* harmony export */   lW: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.lW; },
/* harmony export */   lt: function() { return /* binding */ devtools; },
/* harmony export */   mu: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.mu; },
/* harmony export */   n: function() { return /* binding */ onActivated; },
/* harmony export */   nD: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.nD; },
/* harmony export */   nI: function() { return /* binding */ getCurrentInstance; },
/* harmony export */   nT: function() { return /* binding */ watchEffect; },
/* harmony export */   o5: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.o5; },
/* harmony export */   p9: function() { return /* binding */ watchPostEffect; },
/* harmony export */   pI: function() { return /* binding */ renderList; },
/* harmony export */   pM: function() { return /* binding */ defineComponent; },
/* harmony export */   pR: function() { return /* binding */ BaseTransition; },
/* harmony export */   qG: function() { return /* binding */ onErrorCaptured; },
/* harmony export */   qL: function() { return /* binding */ callWithAsyncErrorHandling; },
/* harmony export */   qP: function() { return /* binding */ defineEmits; },
/* harmony export */   qR: function() { return /* binding */ onRenderTracked; },
/* harmony export */   rE: function() { return /* binding */ version; },
/* harmony export */   rO: function() { return /* binding */ withDefaults; },
/* harmony export */   rU: function() { return /* binding */ hydrateOnIdle; },
/* harmony export */   rY: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.rY; },
/* harmony export */   rk: function() { return /* binding */ useTemplateRef; },
/* harmony export */   sV: function() { return /* binding */ onMounted; },
/* harmony export */   tB: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.tB; },
/* harmony export */   tC: function() { return /* binding */ registerRuntimeCompiler; },
/* harmony export */   tG: function() { return /* binding */ ErrorCodes; },
/* harmony export */   tY: function() { return /* binding */ Suspense; },
/* harmony export */   uX: function() { return /* binding */ openBlock; },
/* harmony export */   uY: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.uY; },
/* harmony export */   ux: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.ux; },
/* harmony export */   v6: function() { return /* binding */ mergeProps; },
/* harmony export */   v_: function() { return /* reexport safe */ _vue_shared__WEBPACK_IMPORTED_MODULE_1__.v_; },
/* harmony export */   vv: function() { return /* binding */ isVNode; },
/* harmony export */   wB: function() { return /* binding */ watch; },
/* harmony export */   wX: function() { return /* binding */ isRuntimeOnly; },
/* harmony export */   wk: function() { return /* binding */ defineExpose; },
/* harmony export */   xo: function() { return /* binding */ onBeforeUnmount; },
/* harmony export */   y$: function() { return /* binding */ initCustomFormatter; },
/* harmony export */   yC: function() { return /* reexport safe */ _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__.yC; },
/* harmony export */   zz: function() { return /* binding */ mergeModels; }
/* harmony export */ });
/* harmony import */ var _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(953);
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/





const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a, _b;
          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function assertNumber(val, type) {
  if (true) return;
  // removed by dead control flow
{}
}

const ErrorCodes = {
  "SETUP_FUNCTION": 0,
  "0": "SETUP_FUNCTION",
  "RENDER_FUNCTION": 1,
  "1": "RENDER_FUNCTION",
  "NATIVE_EVENT_HANDLER": 5,
  "5": "NATIVE_EVENT_HANDLER",
  "COMPONENT_EVENT_HANDLER": 6,
  "6": "COMPONENT_EVENT_HANDLER",
  "VNODE_HOOK": 7,
  "7": "VNODE_HOOK",
  "DIRECTIVE_HOOK": 8,
  "8": "DIRECTIVE_HOOK",
  "TRANSITION_HOOK": 9,
  "9": "TRANSITION_HOOK",
  "APP_ERROR_HANDLER": 10,
  "10": "APP_ERROR_HANDLER",
  "APP_WARN_HANDLER": 11,
  "11": "APP_WARN_HANDLER",
  "FUNCTION_REF": 12,
  "12": "FUNCTION_REF",
  "ASYNC_COMPONENT_LOADER": 13,
  "13": "ASYNC_COMPONENT_LOADER",
  "SCHEDULER": 14,
  "14": "SCHEDULER",
  "COMPONENT_UPDATE": 15,
  "15": "COMPONENT_UPDATE",
  "APP_UNMOUNT_CLEANUP": 16,
  "16": "APP_UNMOUNT_CLEANUP"
};
const ErrorTypeStrings$1 = {
  ["sp"]: "serverPrefetch hook",
  ["bc"]: "beforeCreate hook",
  ["c"]: "created hook",
  ["bm"]: "beforeMount hook",
  ["m"]: "mounted hook",
  ["bu"]: "beforeUpdate hook",
  ["u"]: "updated",
  ["bum"]: "beforeUnmount hook",
  ["um"]: "unmounted hook",
  ["a"]: "activated hook",
  ["da"]: "deactivated hook",
  ["ec"]: "errorCaptured hook",
  ["rtc"]: "renderTracked hook",
  ["rtg"]: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush",
  [15]: "component update",
  [16]: "app unmount cleanup function"
};
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isPromise */ .yL)(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  } else if (false) // removed by dead control flow
{}
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo =  false ? 0 : `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .pauseTracking */ .C4)();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .resetTracking */ .bl)();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (false) // removed by dead control flow
{} else if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}

const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p = currentFlushPromise || resolvedPromise;
  return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  if (false) // removed by dead control flow
{}
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      if (false) // removed by dead control flow
{}
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (false) // removed by dead control flow
{}
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (false) // removed by dead control flow
{}
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  if (false) // removed by dead control flow
{}
  const check =  false ? 0 : _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) // removed by dead control flow
{}
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs(seen);
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  const count = seen.get(fn) || 0;
  if (count > RECURSION_LIMIT) {
    const instance = fn.i;
    const componentName = instance && getComponentName(instance.type);
    handleError(
      `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    );
    return true;
  }
  seen.set(fn, count + 1);
  return false;
}

let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Map();
if (false) // removed by dead control flow
{}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record) return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (let i = 0; i < instances.length; i++) {
    const instance = instances[i];
    const oldComp = normalizeClassComponent(instance.type);
    let dirtyInstances = hmrDirtyComponents.get(oldComp);
    if (!dirtyInstances) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
    }
    dirtyInstances.add(instance);
    instance.appContext.propsCache.delete(instance.type);
    instance.appContext.emitsCache.delete(instance.type);
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      dirtyInstances.add(instance);
      instance.ceReload(newComp.styles);
      dirtyInstances.delete(instance);
    } else if (instance.parent) {
      queueJob(() => {
        isHmrUpdating = true;
        instance.parent.update();
        isHmrUpdating = false;
        dirtyInstances.delete(instance);
      });
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      );
    }
    if (instance.root.ce && instance !== instance.root) {
      instance.root.ce._removeChildStyle(oldComp);
    }
  }
  queuePostFlushCb(() => {
    hmrDirtyComponents.clear();
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(
        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`
      );
    }
  };
}

let devtools$1;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools$1) {
    devtools$1.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook$1(hook, target) {
  var _a, _b;
  devtools$1 = hook;
  if (devtools$1) {
    devtools$1.enabled = true;
    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook$1(newHook, target);
    });
    setTimeout(() => {
      if (!devtools$1) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version) {
  emit$1("app:init" /* APP_INIT */, app, version, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /* @__PURE__ */ (/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */)));
const devtoolsComponentUpdated = /* @__PURE__ */ (/* unused pure expression or super */ null && (createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */)));
const _devtoolsComponentRemoved = /* @__PURE__ */ (/* unused pure expression or super */ null && (createDevtoolsComponentHook(
  "component:removed" /* COMPONENT_REMOVED */
)));
const devtoolsComponentRemoved = (component) => {
  if (devtools$1 && typeof devtools$1.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools$1.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(
      hook,
      component.appContext.app,
      component.uid,
      component.parent ? component.parent.uid : void 0,
      component
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */)));
const devtoolsPerfEnd = /* @__PURE__ */ (/* unused pure expression or super */ null && (createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */)));
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1(
    "component:emit" /* COMPONENT_EMIT */,
    component.appContext.app,
    component,
    event,
    params
  );
}

let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (false) // removed by dead control flow
{}
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}

function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn$1("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
     false && 0;
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ] = directives[i];
    if (dir) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .traverse */ .hV)(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .pauseTracking */ .C4)();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .resetTracking */ .bl)();
    }
  }
}

const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(targetSelector)) {
    if (!select) {
       false && 0;
      return null;
    } else {
      const target = select(targetSelector);
      if (false) // removed by dead control flow
{}
      return target;
    }
  } else {
    if (false) // removed by dead control flow
{}
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (false) // removed by dead control flow
{}
    if (n1 == null) {
      const placeholder = n2.el =  false ? 0 : createText("");
      const mainAnchor = n2.anchor =  false ? 0 : createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        } else if (false) // removed by dead control flow
{}
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, !!!("production" !== "production"));
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          } else if (false) // removed by dead control flow
{}
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}

const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .ux)(props);
      const { mode } = rawProps;
      if (false) // removed by dead control flow
{}
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    let hasFound = false;
    for (const c of children) {
      if (c.type !== Comment) {
        if (false) // removed by dead control flow
{}
        child = c;
        hasFound = true;
        if (true) break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook(hook, args);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook(cancelHook, [el]);
        } else {
          callHook(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove();
      }
      callHook(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove();
        if (cancelled) {
          callHook(onLeaveCancelled, [el]);
        } else {
          callHook(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}

/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}

function useId() {
  const i = getCurrentInstance();
  if (i) {
    return (i.appContext.config.idPrefix || "v") + "-" + i.ids[0] + i.ids[1]++;
  } else if (false) // removed by dead control flow
{}
  return "";
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}

const knownTemplateRefs = /* @__PURE__ */ new WeakSet();
function useTemplateRef(key) {
  const i = getCurrentInstance();
  const r = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .shallowRef */ .IJ)(null);
  if (i) {
    const refs = i.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ ? i.refs = {} : i.refs;
    let desc;
    if (false) // removed by dead control flow
{} else {
      Object.defineProperty(refs, key, {
        enumerable: true,
        get: () => r.value,
        set: (val) => r.value = val
      });
    }
  } else if (false) // removed by dead control flow
{}
  const ret =  false ? 0 : r;
  if (false) // removed by dead control flow
{}
  return ret;
}

function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref } = rawRef;
  if (false) // removed by dead control flow
{}
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .ux)(setupState);
  const canSetSetupRef = setupState === _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ ? () => false : (key) => {
    if (false) // removed by dead control flow
{}
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9)(oldRef)) {
      oldRef.value = null;
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(ref)) {
    callWithErrorHandling(ref, owner, 12, [value, refs]);
  } else {
    const _isString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(ref);
    const _isRef = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9)(ref);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref) ? setupState[ref] : refs[ref] : ref.value;
          if (isUnmount) {
            (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(existing) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .remove */ .TF)(existing, refValue);
          } else {
            if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(existing)) {
              if (_isString) {
                refs[ref] = [refValue];
                if (canSetSetupRef(ref)) {
                  setupState[ref] = refs[ref];
                }
              } else {
                ref.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref] = value;
          if (canSetSetupRef(ref)) {
            setupState[ref] = value;
          }
        } else if (_isRef) {
          ref.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else if (false) // removed by dead control flow
{}
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (false) // removed by dead control flow
{}
  }
}

let hasLoggedMismatchError = false;
const logMismatchError = () => {
  if (hasLoggedMismatchError) {
    return;
  }
  console.error("Hydration completed but contains mismatches.");
  hasLoggedMismatchError = true;
};
const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
const getContainerType = (container) => {
  if (container.nodeType !== 1) return void 0;
  if (isSVGContainer(container)) return "svg";
  if (isMathMLContainer(container)) return "mathml";
  return void 0;
};
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp,
      createText,
      nextSibling,
      parentNode,
      remove,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate = (vnode, container) => {
    if (!container.hasChildNodes()) {
      ( false) && 0;
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (false) // removed by dead control flow
{}
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            ( false) && 0;
            logMismatchError();
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            optimized
          );
          if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            getContainerType(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else if (false) // removed by dead control flow
{}
    }
    if (ref != null) {
      setRef(ref, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatch = type === "input" || type === "option";
    if ( false || forcePatch || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(
          null,
          // no need check parentSuspense in hydration
          transition
        ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          const cls = content.getAttribute("class");
          if (cls) content.$cls = cls;
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        let hasWarned = false;
        while (next) {
          if (!isMismatchAllowed(el, 1 /* CHILDREN */)) {
            if (false) // removed by dead control flow
{}
            logMismatchError();
          }
          const cur = next;
          next = next.nextSibling;
          remove(cur);
        }
      } else if (shapeFlag & 8) {
        let clientText = vnode.children;
        if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
          clientText = clientText.slice(1);
        }
        if (el.textContent !== clientText) {
          if (!isMismatchAllowed(el, 0 /* TEXT */)) {
            ( false) && 0;
            logMismatchError();
          }
          el.textContent = vnode.children;
        }
      }
      if (props) {
        if ( false || forcePatch || !optimized || patchFlag & (16 | 32)) {
          const isCustomElement = el.tagName.includes("-");
          for (const key in props) {
            if (false) // removed by dead control flow
{}
            if (forcePatch && (key.endsWith("value") || key === "indeterminate") || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isOn */ .Mp)(key) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isReservedProp */ .SU)(key) || // force hydrate v-bind with .prop modifiers
            key[0] === "." || isCustomElement) {
              patchProp(el, key, null, props[key], void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp(
            el,
            "onClick",
            null,
            props.onClick,
            void 0,
            parentComponent
          );
        } else if (patchFlag & 4 && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isReactive */ .g8)(props.style)) {
          for (const key in props.style) props.style[key];
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    let hasWarned = false;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      const isText = vnode.type === Text;
      if (node) {
        if (isText && !optimized) {
          if (i + 1 < l && normalizeVNode(children[i + 1]).type === Text) {
            insert(
              createText(
                node.data.slice(vnode.children.length)
              ),
              container,
              nextSibling(node)
            );
            node.data = vnode.children;
          }
        }
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (isText && !vnode.children) {
        insert(vnode.el = createText(""), container);
      } else {
        if (!isMismatchAllowed(container, 1 /* CHILDREN */)) {
          if (false) // removed by dead control flow
{}
          logMismatchError();
        }
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      logMismatchError();
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    if (!isMismatchAllowed(node.parentElement, 1 /* CHILDREN */)) {
      ( false) && 0;
      logMismatchError();
    }
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      getContainerType(container),
      slotScopeIds
    );
    if (parentComponent) {
      parentComponent.vnode.el = vnode.el;
      updateHOCHostEl(parentComponent, vnode.el);
    }
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open) match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName === "TEMPLATE";
  };
  return [hydrate, hydrateNode];
}
function propHasMismatch(el, key, clientValue, vnode, instance) {
  let mismatchType;
  let mismatchKey;
  let actual;
  let expected;
  if (key === "class") {
    if (el.$cls) {
      actual = el.$cls;
      delete el.$cls;
    } else {
      actual = el.getAttribute("class");
    }
    expected = normalizeClass(clientValue);
    if (!isSetEqual(toClassSet(actual || ""), toClassSet(expected))) {
      mismatchType = 2 /* CLASS */;
      mismatchKey = `class`;
    }
  } else if (key === "style") {
    actual = el.getAttribute("style") || "";
    expected = isString(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));
    const actualMap = toStyleMap(actual);
    const expectedMap = toStyleMap(expected);
    if (vnode.dirs) {
      for (const { dir, value } of vnode.dirs) {
        if (dir.name === "show" && !value) {
          expectedMap.set("display", "none");
        }
      }
    }
    if (instance) {
      resolveCssVars(instance, vnode, expectedMap);
    }
    if (!isMapEqual(actualMap, expectedMap)) {
      mismatchType = 3 /* STYLE */;
      mismatchKey = "style";
    }
  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {
    if (isBooleanAttr(key)) {
      actual = el.hasAttribute(key);
      expected = includeBooleanAttr(clientValue);
    } else if (clientValue == null) {
      actual = el.hasAttribute(key);
      expected = false;
    } else {
      if (el.hasAttribute(key)) {
        actual = el.getAttribute(key);
      } else if (key === "value" && el.tagName === "TEXTAREA") {
        actual = el.value;
      } else {
        actual = false;
      }
      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;
    }
    if (actual !== expected) {
      mismatchType = 4 /* ATTRIBUTE */;
      mismatchKey = key;
    }
  }
  if (mismatchType != null && !isMismatchAllowed(el, mismatchType)) {
    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}="${v}"`;
    const preSegment = `Hydration ${MismatchTypeString[mismatchType]} mismatch on`;
    const postSegment = `
  - rendered on server: ${format(actual)}
  - expected on client: ${format(expected)}
  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.
  You should fix the source of the mismatch.`;
    {
      warn$1(preSegment, el, postSegment);
    }
    return true;
  }
  return false;
}
function toClassSet(str) {
  return new Set(str.trim().split(/\s+/));
}
function isSetEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const s of a) {
    if (!b.has(s)) {
      return false;
    }
  }
  return true;
}
function toStyleMap(str) {
  const styleMap = /* @__PURE__ */ new Map();
  for (const item of str.split(";")) {
    let [key, value] = item.split(":");
    key = key.trim();
    value = value && value.trim();
    if (key && value) {
      styleMap.set(key, value);
    }
  }
  return styleMap;
}
function isMapEqual(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  for (const [key, value] of a) {
    if (value !== b.get(key)) {
      return false;
    }
  }
  return true;
}
function resolveCssVars(instance, vnode, expectedMap) {
  const root = instance.subTree;
  if (instance.getCssVars && (vnode === root || root && root.type === Fragment && root.children.includes(vnode))) {
    const cssVars = instance.getCssVars();
    for (const key in cssVars) {
      expectedMap.set(
        `--${getEscapedCssVarName(key, false)}`,
        String(cssVars[key])
      );
    }
  }
  if (vnode === root && instance.parent) {
    resolveCssVars(instance.parent, instance.vnode, expectedMap);
  }
}
const allowMismatchAttr = "data-allow-mismatch";
const MismatchTypeString = {
  [0 /* TEXT */]: "text",
  [1 /* CHILDREN */]: "children",
  [2 /* CLASS */]: "class",
  [3 /* STYLE */]: "style",
  [4 /* ATTRIBUTE */]: "attribute"
};
function isMismatchAllowed(el, allowedType) {
  if (allowedType === 0 /* TEXT */ || allowedType === 1 /* CHILDREN */) {
    while (el && !el.hasAttribute(allowMismatchAttr)) {
      el = el.parentElement;
    }
  }
  const allowedAttr = el && el.getAttribute(allowMismatchAttr);
  if (allowedAttr == null) {
    return false;
  } else if (allowedAttr === "") {
    return true;
  } else {
    const list = allowedAttr.split(",");
    if (allowedType === 0 /* TEXT */ && list.includes("children")) {
      return true;
    }
    return list.includes(MismatchTypeString[allowedType]);
  }
}

const requestIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .getGlobalThis */ .We)().requestIdleCallback || ((cb) => setTimeout(cb, 1));
const cancelIdleCallback = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .getGlobalThis */ .We)().cancelIdleCallback || ((id) => clearTimeout(id));
const hydrateOnIdle = (timeout = 1e4) => (hydrate) => {
  const id = requestIdleCallback(hydrate, { timeout });
  return () => cancelIdleCallback(id);
};
function elementIsVisibleInViewport(el) {
  const { top, left, bottom, right } = el.getBoundingClientRect();
  const { innerHeight, innerWidth } = window;
  return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
}
const hydrateOnVisible = (opts) => (hydrate, forEach) => {
  const ob = new IntersectionObserver((entries) => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      ob.disconnect();
      hydrate();
      break;
    }
  }, opts);
  forEach((el) => {
    if (!(el instanceof Element)) return;
    if (elementIsVisibleInViewport(el)) {
      hydrate();
      ob.disconnect();
      return false;
    }
    ob.observe(el);
  });
  return () => ob.disconnect();
};
const hydrateOnMediaQuery = (query) => (hydrate) => {
  if (query) {
    const mql = matchMedia(query);
    if (mql.matches) {
      hydrate();
    } else {
      mql.addEventListener("change", hydrate, { once: true });
      return () => mql.removeEventListener("change", hydrate);
    }
  }
};
const hydrateOnInteraction = (interactions = []) => (hydrate, forEach) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(interactions)) interactions = [interactions];
  let hasHydrated = false;
  const doHydrate = (e) => {
    if (!hasHydrated) {
      hasHydrated = true;
      teardown();
      hydrate();
      e.target.dispatchEvent(new e.constructor(e.type, e));
    }
  };
  const teardown = () => {
    forEach((el) => {
      for (const i of interactions) {
        el.removeEventListener(i, doHydrate);
      }
    });
  };
  forEach((el) => {
    for (const i of interactions) {
      el.addEventListener(i, doHydrate, { once: true });
    }
  });
  return teardown;
};
function forEachElement(node, cb) {
  if (isComment(node) && node.data === "[") {
    let depth = 1;
    let next = node.nextSibling;
    while (next) {
      if (next.nodeType === 1) {
        const result = cb(next);
        if (result === false) {
          break;
        }
      } else if (isComment(next)) {
        if (next.data === "]") {
          if (--depth === 0) break;
        } else if (next.data === "[") {
          depth++;
        }
      }
      next = next.nextSibling;
    }
  } else {
    cb(node);
  }
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    hydrate: hydrateStrategy,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve, reject) => {
          const userRetry = () => resolve(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (false) // removed by dead control flow
{}
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      if (false) // removed by dead control flow
{}
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    __asyncHydrate(el, instance, hydrate) {
      let patched = false;
      const doHydrate = hydrateStrategy ? () => {
        const performHydrate = () => {
          if (false) // removed by dead control flow
{}
          hydrate();
        };
        const teardown = hydrateStrategy(
          performHydrate,
          (cb) => forEachElement(el, cb)
        );
        if (teardown) {
          (instance.bum || (instance.bum = [])).push(teardown);
        }
        (instance.u || (instance.u = [])).push(() => patched = true);
      } : hydrate;
      if (resolvedComp) {
        doHydrate();
      } else {
        load().then(() => !instance.isUnmounted && doHydrate());
      }
    },
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      markAsyncBoundary(instance);
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KR)(false);
      const error = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KR)();
      const delayed = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .ref */ .KR)(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          instance.parent.update();
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props, children, ce } = parent.vnode;
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  vnode.ce = ce;
  delete parent.vnode.ce;
  return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    if (false) // removed by dead control flow
{}
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        namespace,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .invokeArrayFns */ .DY)(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
      if (false) // removed by dead control flow
{}
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      invalidateMount(instance2.m);
      invalidateMount(instance2.a);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .invokeArrayFns */ .DY)(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
      if (false) // removed by dead control flow
{}
      if (false) // removed by dead control flow
{}
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && !filter(name)) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (cached && (!current || !isSameVNodeType(cached, current))) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        if (isSuspense(instance.subTree.type)) {
          queuePostRenderEffect(() => {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }, instance.subTree.suspense);
        } else {
          cache.set(pendingCacheKey, getInnerChild(instance.subTree));
        }
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return current = null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        if (false) // removed by dead control flow
{}
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      if (vnode.type === Comment) {
        current = null;
        return vnode;
      }
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        vnode.shapeFlag &= -257;
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(pattern)) {
    return pattern.some((p) => matches(p, name));
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(pattern)) {
    return pattern.split(",").includes(name);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isRegExp */ .gd)(pattern)) {
    pattern.lastIndex = 0;
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .remove */ .TF)(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= -257;
  vnode.shapeFlag &= -513;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .pauseTracking */ .C4)();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .resetTracking */ .bl)();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (false) // removed by dead control flow
{}
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}

const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(name) || selfName === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .capitalize */ .ZH)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    if (false) // removed by dead control flow
{}
    return res;
  } else if (false) // removed by dead control flow
{}
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(name)] || registry[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .capitalize */ .ZH)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(name))]);
}

function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache && cache[index];
  const sourceIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(source);
  if (sourceIsArray || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(source)) {
    const sourceIsReactiveArray = sourceIsArray && (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isReactive */ .g8)(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !(0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isShallow */ .fE)(source);
      isReadonlySource = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isReadonly */ .Tm)(source);
      source = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .shallowReadArray */ .qA)(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toReadonly */ .a1)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toReactive */ .lJ)(source[i])) : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toReactive */ .lJ)(source[i]) : source[i],
        i,
        void 0,
        cached && cached[i]
      );
    }
  } else if (typeof source === "number") {
    if (false) // removed by dead control flow
{}
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index] = ret;
  }
  return ret;
}

function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}

function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (false) // removed by dead control flow
{}
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .Bm)(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}

function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  if (false) // removed by dead control flow
{}
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toHandlerKey */ .rU)(key)] = obj[key];
  }
  return ret;
}

const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) =>  false ? 0 : i.props,
    $attrs: (i) =>  false ? 0 : i.attrs,
    $slots: (i) =>  false ? 0 : i.slots,
    $refs: (i) =>  false ? 0 : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) =>  true ? resolveMergedOptions(i) : 0,
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) =>  true ? instanceWatch.bind(i) : 0
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ && !state.__isScriptSetup && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (false) // removed by dead control flow
{}
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1 /* SETUP */:
            return setupState[key];
          case 2 /* DATA */:
            return data[key];
          case 4 /* CONTEXT */:
            return ctx[key];
          case 3 /* PROPS */:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1 /* SETUP */;
        return setupState[key];
      } else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(data, key)) {
        accessCache[key] = 2 /* DATA */;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(normalizedProps, key)
      ) {
        accessCache[key] = 3 /* PROPS */;
        return props[key];
      } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if ( false || shouldCacheAccess) {
        accessCache[key] = 0 /* OTHER */;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .track */ .u4)(instance.attrs, "get", "");
         false && 0;
      } else if (false) // removed by dead control flow
{}
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(ctx, key)) {
      accessCache[key] = 4 /* CONTEXT */;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (false) // removed by dead control flow
{}
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (false) // removed by dead control flow
{} else if (data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(data, key)) {
      data[key] = value;
      return true;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(instance.props, key)) {
       false && 0;
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
       false && 0;
      return false;
    } else {
      if (false) // removed by dead control flow
{} else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(normalizedProps, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(ctx, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(publicPropertiesMap, key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (false) // removed by dead control flow
{}
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has = key[0] !== "_" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isGloballyAllowed */ .BH)(key);
    if (false) // removed by dead control flow
{}
    return has;
  }
});
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const {
    ctx,
    propsOptions: [propsOptions]
  } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn$1(
          `setup() return property ${JSON.stringify(
            key
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}

const warnRuntimeUsage = (method) => warn$1(
  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function defineProps() {
  if (false) // removed by dead control flow
{}
  return null;
}
function defineEmits() {
  if (false) // removed by dead control flow
{}
  return null;
}
function defineExpose(exposed) {
  if (false) // removed by dead control flow
{}
}
function defineOptions(options) {
  if (false) // removed by dead control flow
{}
}
function defineSlots() {
  if (false) // removed by dead control flow
{}
  return null;
}
function defineModel() {
  if (false) // removed by dead control flow
{}
}
function withDefaults(props, defaults) {
  if (false) // removed by dead control flow
{}
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  if (false) // removed by dead control flow
{}
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(props) ? props.reduce(
    (normalized, p) => (normalized[p] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else if (false) // removed by dead control flow
{}
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
function mergeModels(a, b) {
  if (!a || !b) return a || b;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(a) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(b)) return a.concat(b);
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  if (false) // removed by dead control flow
{}
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isPromise */ .yL)(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}

function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties =  false ? 0 : null;
  if (false) // removed by dead control flow
{}
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(methodHandler)) {
        if (false) // removed by dead control flow
{} else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (false) // removed by dead control flow
{}
      } else if (false) // removed by dead control flow
{}
    }
  }
  if (dataOptions) {
    if (false) // removed by dead control flow
{}
    const data = dataOptions.call(publicThis, publicThis);
    if (false) // removed by dead control flow
{}
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(data)) {
       false && 0;
    } else {
      instance.data = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .reactive */ .Kh)(data);
      if (false) // removed by dead control flow
{}
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(opt) ? opt.bind(publicThis, publicThis) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(opt.get) ? opt.get.bind(publicThis, publicThis) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
      if (false) // removed by dead control flow
{}
      const set = !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(opt) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(opt.set) ? opt.set.bind(publicThis) :  false ? 0 : _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (false) // removed by dead control flow
{}
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9)(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
    if (false) // removed by dead control flow
{}
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(raw)) {
    const handler = ctx[raw];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(handler)) {
      {
        watch(getter, handler);
      }
    } else if (false) // removed by dead control flow
{}
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(raw)) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(handler)) {
        watch(getter, handler, raw);
      } else if (false) // removed by dead control flow
{}
    }
  } else if (false) // removed by dead control flow
{}
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
       false && 0;
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$))(
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(to) ? to.call(this, this) : to,
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(to) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: _vue_shared__WEBPACK_IMPORTED_MODULE_1__.NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp(rootComponent, rootProps = null) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(rootComponent)) {
      rootComponent = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, rootComponent);
    }
    if (rootProps != null && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(rootProps)) {
       false && 0;
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (false) // removed by dead control flow
{}
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
           false && 0;
        } else if (plugin && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (false) // removed by dead control flow
{}
        return app;
      },
      mixin(mixin) {
        if (true) {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (false) // removed by dead control flow
{}
        } else // removed by dead control flow
{}
        return app;
      },
      component(name, component) {
        if (false) // removed by dead control flow
{}
        if (!component) {
          return context.components[name];
        }
        if (false) // removed by dead control flow
{}
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (false) // removed by dead control flow
{}
        if (!directive) {
          return context.directives[name];
        }
        if (false) // removed by dead control flow
{}
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          if (false) // removed by dead control flow
{}
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          if (false) // removed by dead control flow
{}
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (false) // removed by dead control flow
{}
          return getComponentPublicInstance(vnode.component);
        } else if (false) // removed by dead control flow
{}
      },
      onUnmount(cleanupFn) {
        if (false) // removed by dead control flow
{}
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          if (false) // removed by dead control flow
{}
          delete app._container.__vue_app__;
        } else if (false) // removed by dead control flow
{}
      },
      provide(key, value) {
        if (false) // removed by dead control flow
{}
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;

function provide(key, value) {
  if (!currentInstance) {
    if (false) // removed by dead control flow
{}
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (false) // removed by dead control flow
{}
  } else if (false) // removed by dead control flow
{}
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}

const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;

function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (false) // removed by dead control flow
{}
  if (isStateful) {
    instance.props = isSSR ? props : (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .shallowReactive */ .Gc)(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId) return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .ux)(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
     true && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(key)) === key || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .trigger */ .hZ)(instance.attrs, "set", "");
  }
  if (false) // removed by dead control flow
{}
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isReservedProp */ .SU)(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(options, camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .ux)(props);
    const castValues = rawCastValues || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[0 /* shouldCast */]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache =  true && asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(comp)) {
      cache.set(comp, _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_ARR */ .Oj);
    }
    return _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_ARR */ .Oj;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (false) // removed by dead control flow
{}
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
      }
    }
  } else if (raw) {
    if (false) // removed by dead control flow
{}
    for (const key in raw) {
      const normalizedKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(opt) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(opt) ? { type: opt } : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(propType) && propType.name === "Boolean";
        }
        prop[0 /* shouldCast */] = shouldCast;
        prop[1 /* shouldCastTrue */] = shouldCastTrue;
        if (shouldCast || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isReservedProp */ .SU)(key)) {
    return true;
  } else if (false) // removed by dead control flow
{}
  return false;
}
function getType(ctor) {
  if (ctor === null) {
    return "null";
  }
  if (typeof ctor === "function") {
    return ctor.name || "";
  } else if (typeof ctor === "object") {
    const name = ctor.constructor && ctor.constructor.name;
    return name || "";
  }
  return "";
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  const camelizePropsKey = Object.keys(rawProps).map((key) => camelize(key));
  for (const key in options) {
    let opt = options[key];
    if (opt == null) continue;
    validateProp(
      key,
      resolvedValues[key],
      opt,
       false ? 0 : resolvedValues,
      !camelizePropsKey.includes(key)
    );
  }
}
function validateProp(name, value, prop, props, isAbsent) {
  const { type, required, validator, skipCheck } = prop;
  if (required && isAbsent) {
    warn$1('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !required) {
    return;
  }
  if (type != null && type !== true && !skipCheck) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn$1(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value, props)) {
    warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap(
  "String,Number,Boolean,Function,Symbol,BigInt"
)));
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (expectedType === "null") {
    valid = value === null;
  } else if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  if (expectedTypes.length === 0) {
    return `Prop type [] for prop "${name}" won't match anything. Did you mean to use type Array instead?`;
  }
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}

const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) // removed by dead control flow
{}
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (false) // removed by dead control flow
{}
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (false) // removed by dead control flow
{}
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const cacheIndexes = children.__;
    if (cacheIndexes) (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .def */ .yQ)(slots, "__", cacheIndexes, true);
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .def */ .yQ)(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (false) // removed by dead control flow
{} else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};

let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (false) // removed by dead control flow
{}
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(
      `<${formatComponentName(instance, instance.type)}> ${type}`,
      startTag,
      endTag
    );
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (false) // removed by dead control flow
{}
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}

function initFeatureFlags() {
  const needWarn = [];
  if (false) // removed by dead control flow
{}
  if (false) // removed by dead control flow
{}
  if (false) // removed by dead control flow
{}
  if (false) // removed by dead control flow
{}
}

const queuePostRenderEffect = queueEffectWithSuspense ;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .getGlobalThis */ .We)();
  target.__VUE__ = true;
  if (false) // removed by dead control flow
{}
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized =  false ? 0 : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        } else if (false) // removed by dead control flow
{}
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (false) // removed by dead control flow
{}
    }
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    } else if (ref == null && n1 && n1.ref != null) {
      setRef(n1.ref, null, parentSuspense, n1, true);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const patchStaticNode = (n1, n2, container, namespace) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace
      );
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isReservedProp */ .SU)(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (false) // removed by dead control flow
{}
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (false) // removed by dead control flow
{}
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    if (false) // removed by dead control flow
{}
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
    const newProps = n2.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (false) // removed by dead control flow
{}
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
      if (false) // removed by dead control flow
{}
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ) {
        for (const key in oldProps) {
          if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isReservedProp */ .SU)(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isReservedProp */ .SU)(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (false) // removed by dead control flow
{}
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (false) // removed by dead control flow
{} else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = (initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    ));
    if (false) // removed by dead control flow
{}
    if (false) // removed by dead control flow
{}
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (false) // removed by dead control flow
{}
      setupComponent(instance, false, optimized);
      if (false) // removed by dead control flow
{}
    }
    if (false) // removed by dead control flow
{}
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
    if (false) // removed by dead control flow
{}
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (false) // removed by dead control flow
{}
        updateComponentPreRender(instance, n2, optimized);
        if (false) // removed by dead control flow
{}
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .invokeArrayFns */ .DY)(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (false) // removed by dead control flow
{}
            instance.subTree = renderComponentRoot(instance);
            if (false) // removed by dead control flow
{}
            if (false) // removed by dead control flow
{}
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
            if (false) // removed by dead control flow
{}
          };
          if (isAsyncWrapperVNode && type.__asyncHydrate) {
            type.__asyncHydrate(
              el,
              instance,
              hydrateSubTree
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (root.ce && // @ts-expect-error _def is private
          root.ce._def.shadowRoot !== false) {
            root.ce._injectChildStyle(type);
          }
          if (false) // removed by dead control flow
{}
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (false) // removed by dead control flow
{}
          if (false) // removed by dead control flow
{}
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          if (false) // removed by dead control flow
{}
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (false) // removed by dead control flow
{}
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        if (false) // removed by dead control flow
{}
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .invokeArrayFns */ .DY)(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (false) // removed by dead control flow
{}
        const nextTree = renderComponentRoot(instance);
        if (false) // removed by dead control flow
{}
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (false) // removed by dead control flow
{}
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        if (false) // removed by dead control flow
{}
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
        if (false) // removed by dead control flow
{}
        if (false) // removed by dead control flow
{}
      }
    };
    instance.scope.on();
    const effect = instance.effect = new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .ReactiveEffect */ .X2(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect.run.bind(effect);
    const job = instance.job = effect.runIfDirty.bind(effect);
    job.i = instance;
    job.id = instance.uid;
    effect.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    if (false) // removed by dead control flow
{}
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .pauseTracking */ .C4)();
    flushPreFlushCbs(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .resetTracking */ .bl)();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_ARR */ .Oj;
    c2 = c2 || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_ARR */ .Oj;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (false) // removed by dead control flow
{}
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_ARR */ .Oj;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove2 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          leave(el, () => {
            remove2();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove2, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref != null) {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .pauseTracking */ .C4)();
      setRef(ref, null, parentSuspense, vnode, true);
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .resetTracking */ .bl)();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (false) // removed by dead control flow
{} else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (false) // removed by dead control flow
{}
    const {
      bum,
      scope,
      job,
      subTree,
      um,
      m,
      a,
      parent,
      slots: { __: slotCacheKeys }
    } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .invokeArrayFns */ .DY)(bum);
    }
    if (parent && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(slotCacheKeys)) {
      slotCacheKeys.forEach((v) => {
        parent.renderCache[v] = void 0;
      });
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (false) // removed by dead control flow
{}
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect, job }, allowed) {
  if (allowed) {
    effect.flags |= 32;
    job.flags |= 4;
  } else {
    effect.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(ch1) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
      if (false) // removed by dead control flow
{}
    }
  }
}
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}

const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
       false && 0;
    }
    return ctx;
  }
};

function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(
    effect,
    null,
     false ? 0 : { flush: "post" }
  );
}
function watchSyncEffect(effect, options) {
  return doWatch(
    effect,
    null,
     false ? 0 : { flush: "sync" }
  );
}
function watch(source, cb, options) {
  if (false) // removed by dead control flow
{}
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ) {
  const { immediate, deep, flush, once } = options;
  if (false) // removed by dead control flow
{}
  const baseWatchOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, options);
  if (false) // removed by dead control flow
{}
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
      watchStopHandle.resume = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
      watchStopHandle.pause = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .watch */ .wB)(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}

function useModel(props, name, options = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ) {
  const i = getCurrentInstance();
  if (false) // removed by dead control flow
{}
  const camelizedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(name);
  if (false) // removed by dead control flow
{}
  const hyphenatedName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(name);
  const modifiers = getModelModifiers(props, camelizedName);
  const res = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .customRef */ .rY)((track, trigger) => {
    let localValue;
    let prevSetValue = _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
    let prevEmittedValue;
    watchSyncEffect(() => {
      const propValue = props[camelizedName];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .$H)(localValue, propValue)) {
        localValue = propValue;
        trigger();
      }
    });
    return {
      get() {
        track();
        return options.get ? options.get(localValue) : localValue;
      },
      set(value) {
        const emittedValue = options.set ? options.set(value) : value;
        if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .$H)(emittedValue, localValue) && !(prevSetValue !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .$H)(value, prevSetValue))) {
          return;
        }
        const rawProps = i.vnode.props;
        if (!(rawProps && // check if parent has passed v-model
        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
          localValue = value;
          trigger();
        }
        i.emit(`update:${name}`, emittedValue);
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .$H)(value, emittedValue) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .$H)(value, prevSetValue) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .$H)(emittedValue, prevEmittedValue)) {
          trigger();
        }
        prevSetValue = value;
        prevEmittedValue = emittedValue;
      }
    };
  });
  res[Symbol.iterator] = () => {
    let i2 = 0;
    return {
      next() {
        if (i2 < 2) {
          return { value: i2++ ? modifiers || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ : res, done: false };
        } else {
          return { done: true };
        }
      }
    };
  };
  return res;
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(modelName)}Modifiers`] || props[`${(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(modelName)}Modifiers`];
};

function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
  if (false) // removed by dead control flow
{}
  let args = rawArgs;
  const isModelListener = event.startsWith("update:");
  const modifiers = isModelListener && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseToNumber */ .bB);
    }
  }
  if (false) // removed by dead control flow
{}
  if (false) // removed by dead control flow
{}
  let handlerName;
  let handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toHandlerKey */ .rU)(event)] || // also try camelCase event handler (#2249)
  props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toHandlerKey */ .rU)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(event))];
  if (!handler && isModelListener) {
    handler = props[handlerName = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toHandlerKey */ .rU)((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if ( true && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(normalized, raw);
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isOn */ .Mp)(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(options, key[0].toLowerCase() + key.slice(1)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(options, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(key)) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(options, key);
}

let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  if (false) // removed by dead control flow
{}
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy =  false ? 0 : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
           false ? 0 : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) // removed by dead control flow
{}
      result = normalizeVNode(
        render2.length > 1 ? render2(
           false ? 0 : props,
           false ? 0 : { attrs, slots, emit }
        ) : render2(
           false ? 0 : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (false) // removed by dead control flow
{}
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isModelListener */ .CP)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      } else if (false) // removed by dead control flow
{}
    }
  }
  if (vnode.dirs) {
    if (false) // removed by dead control flow
{}
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (false) // removed by dead control flow
{}
    setTransitionHooks(root, vnode.transition);
  }
  if (false) // removed by dead control flow
{} else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren, false);
  if (!childRoot) {
    return [vnode, void 0];
  } else if (false) // removed by dead control flow
{}
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children, recurse = true) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
          if (false) // removed by dead control flow
{}
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isOn */ .Mp)(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isModelListener */ .CP)(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (false) // removed by dead control flow
{}
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}

const isSuspense = (type) => type.__isSuspense;
let suspenseId = 0;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
        n2.suspense = n1.suspense;
        n2.suspense.vnode = n2;
        n2.el = n1.el;
        return;
      }
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl ;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    namespace,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      namespace,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        if (!isHydrating) {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      }
    } else {
      suspense.pendingId = suspenseId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      if (newBranch.shapeFlag & 512) {
        suspense.pendingId = newBranch.component.suspenseId;
      } else {
        suspense.pendingId = suspenseId++;
      }
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  if (false) // removed by dead control flow
{}
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense && parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toNumber */ .Ro)(vnode.props.timeout) : void 0;
  if (false) // removed by dead control flow
{}
  const initialAnchor = anchor;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    namespace,
    container,
    hiddenContainer,
    deps: 0,
    pendingId: suspenseId++,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !isHydrating,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      if (false) // removed by dead control flow
{}
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(
                pendingBranch,
                container2,
                anchor === initialAnchor ? next(activeBranch) : anchor,
                0
              );
              queuePostFlushCb(effects);
            }
          };
        }
        if (activeBranch) {
          if (parentNode(activeBranch.el) === container2) {
            anchor = next(activeBranch);
          }
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect, optimized2) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        if (false) // removed by dead control flow
{}
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          namespace,
          optimized2
        );
        if (placeholder) {
          remove(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (false) // removed by dead control flow
{}
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    // eslint-disable-next-line no-restricted-globals
    document.createElement("div"),
    null,
    namespace,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(s)) {
    const singleChild = filterSingleRoot(s);
    if (false) // removed by dead control flow
{}
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  let el = branch.el;
  while (!el && branch.component) {
    branch = branch.component.subTree;
    el = branch.el;
  }
  vnode.el = el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  const suspensible = vnode.props && vnode.props.suspensible;
  return suspensible != null && suspensible !== false;
}

const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_ARR */ .Oj : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (false) // removed by dead control flow
{}
  return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
function transformVNodeArgs(transformer) {
  vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(
    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args
  );
};
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref,
  ref_key,
  ref_for
}) => {
  if (typeof ref === "number") {
    ref = "" + ref;
  }
  return ref != null ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(ref) || (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isRef */ .i9)(ref) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(children) ? 8 : 16;
  }
  if (false) // removed by dead control flow
{}
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode =  false ? 0 : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (false) // removed by dead control flow
{}
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(klass)) {
      props.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .normalizeClass */ .C4)(klass);
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(style)) {
      if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isProxy */ .ju)(style) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(style)) {
        style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, style);
      }
      props.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .normalizeStyle */ .Tr)(style);
    }
  }
  const shapeFlag = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(type) ? 4 : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(type) ? 2 : 0;
  if (false) // removed by dead control flow
{}
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isProxy */ .ju)(props) || isInternalObject(props) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children:  false ? 0 : children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .normalizeClass */ .C4)([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .normalizeStyle */ .Tr)([ret.style, toMerge.style]);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isOn */ .Mp)(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}

const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new _vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .EffectScope */ .yC(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    data: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    props: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    attrs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    slots: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    refs: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    setupState: _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (false) // removed by dead control flow
{} else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .getGlobalThis */ .We)();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
const isBuiltInTag = /* @__PURE__ */ (/* unused pure expression or super */ null && (makeMap("slot,component")));
function validateComponentName(name, { isNativeTag }) {
  if (isBuiltInTag(name) || isNativeTag(name)) {
    warn$1(
      "Do not use built-in or reserved HTML elements as component id: " + name
    );
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (false) // removed by dead control flow
{}
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  if (false) // removed by dead control flow
{}
  const { setup } = Component;
  if (setup) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .pauseTracking */ .C4)();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
         false ? 0 : instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isPromise */ .yL)(setupResult);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .resetTracking */ .bl)();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
        if (false) // removed by dead control flow
{}
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(setupResult)) {
    if (false) // removed by dead control flow
{}
    if (false) // removed by dead control flow
{}
    instance.setupState = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .proxyRefs */ .Pr)(setupResult);
    if (false) // removed by dead control flow
{}
  } else if (false) // removed by dead control flow
{}
  finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template ||  true && resolveMergedOptions(instance).template;
      if (template) {
        if (false) // removed by dead control flow
{}
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
        if (false) // removed by dead control flow
{}
      }
    }
    instance.render = Component.render || _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  if (true) {
    const reset = setCurrentInstance(instance);
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .pauseTracking */ .C4)();
    try {
      applyOptions(instance);
    } finally {
      (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .resetTracking */ .bl)();
      reset();
    }
  }
  if (false) // removed by dead control flow
{}
}
const attrsProxyHandlers =  false ? 0 : {
  get(target, key) {
    (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .track */ .u4)(target, "get", "");
    return target[key];
  }
};
function getSlotsProxy(instance) {
  return new Proxy(instance.slots, {
    get(target, key) {
      track(instance, "get", "$slots");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (false) // removed by dead control flow
{}
    instance.exposed = exposed || {};
  };
  if (false) // removed by dead control flow
{} else {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .proxyRefs */ .Pr)((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .markRaw */ .IG)(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(value) && "__vccOpts" in value;
}

const computed = (getterOrOptions, debugOptions) => {
  const c = (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(getterOrOptions, debugOptions, isInSSRComponentSetup);
  if (false) // removed by dead control flow
{}
  return c;
};

function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(propsOrChildren) && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}

function initCustomFormatter() {
  if (true) {
    return;
  }
  // removed by dead control flow
{}
  // removed by dead control flow
{}
  // removed by dead control flow
{}
  // removed by dead control flow
{}
  // removed by dead control flow
{}
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .ux)(instance.props)));
    }
    if (instance.setupState !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ) {
      blocks.push(createInstanceBlock("data", (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .ux)(instance.data)));
    }
    const computed = extractKeys(instance, "computed");
    if (computed) {
      blocks.push(createInstanceBlock("computed", computed));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(v)) {
      return ["object", { object: asRaw ? (0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .toRaw */ .ux)(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(opts) && opts.includes(key) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if ((0,_vue_reactivity__WEBPACK_IMPORTED_MODULE_0__/* .isShallow */ .fE)(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  // removed by dead control flow
{}
}

function withMemo(memo, render, cache, index) {
  const cached = cache[index];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render();
  ret.memo = memo.slice();
  ret.cacheIndex = index;
  return cache[index] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasChanged */ .$H)(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}

const version = "3.5.17";
const warn =  false ? 0 : _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE;
const ErrorTypeStrings = ErrorTypeStrings$1 ;
const devtools =  true ? devtools$1 : 0;
const setDevtoolsHook =  true ? setDevtoolsHook$1 : 0;
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode: isVNode,
  normalizeVNode,
  getComponentPublicInstance,
  ensureValidVNode,
  pushWarningContext,
  popWarningContext
};
const ssrUtils = _ssrUtils ;
const resolveFilter = null;
const compatUtils = null;
const DeprecationTypes = null;




/***/ }),

/***/ 665:
/***/ (function(module) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 874:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5335);

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 953:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BA: function() { return /* binding */ toValue; },
/* harmony export */   C4: function() { return /* binding */ pauseTracking; },
/* harmony export */   EW: function() { return /* binding */ computed; },
/* harmony export */   Gc: function() { return /* binding */ shallowReactive; },
/* harmony export */   IG: function() { return /* binding */ markRaw; },
/* harmony export */   IJ: function() { return /* binding */ shallowRef; },
/* harmony export */   KR: function() { return /* binding */ ref; },
/* harmony export */   Kh: function() { return /* binding */ reactive; },
/* harmony export */   PP: function() { return /* binding */ TriggerOpTypes; },
/* harmony export */   Pr: function() { return /* binding */ proxyRefs; },
/* harmony export */   QW: function() { return /* binding */ toRefs; },
/* harmony export */   QZ: function() { return /* binding */ effect; },
/* harmony export */   R1: function() { return /* binding */ unref; },
/* harmony export */   Tm: function() { return /* binding */ isReadonly; },
/* harmony export */   Ul: function() { return /* binding */ TrackOpTypes; },
/* harmony export */   X2: function() { return /* binding */ ReactiveEffect; },
/* harmony export */   Yv: function() { return /* binding */ getCurrentWatcher; },
/* harmony export */   a1: function() { return /* binding */ toReadonly; },
/* harmony export */   bl: function() { return /* binding */ resetTracking; },
/* harmony export */   ch: function() { return /* binding */ onWatcherCleanup; },
/* harmony export */   ds: function() { return /* binding */ stop; },
/* harmony export */   fE: function() { return /* binding */ isShallow; },
/* harmony export */   g8: function() { return /* binding */ isReactive; },
/* harmony export */   hV: function() { return /* binding */ traverse; },
/* harmony export */   hZ: function() { return /* binding */ trigger; },
/* harmony export */   i9: function() { return /* binding */ isRef; },
/* harmony export */   jr: function() { return /* binding */ onScopeDispose; },
/* harmony export */   ju: function() { return /* binding */ isProxy; },
/* harmony export */   lJ: function() { return /* binding */ toReactive; },
/* harmony export */   lW: function() { return /* binding */ toRef; },
/* harmony export */   mu: function() { return /* binding */ triggerRef; },
/* harmony export */   nD: function() { return /* binding */ shallowReadonly; },
/* harmony export */   o5: function() { return /* binding */ getCurrentScope; },
/* harmony export */   qA: function() { return /* binding */ shallowReadArray; },
/* harmony export */   rY: function() { return /* binding */ customRef; },
/* harmony export */   tB: function() { return /* binding */ readonly; },
/* harmony export */   u4: function() { return /* binding */ track; },
/* harmony export */   uY: function() { return /* binding */ effectScope; },
/* harmony export */   ux: function() { return /* binding */ toRaw; },
/* harmony export */   wB: function() { return /* binding */ watch; },
/* harmony export */   yC: function() { return /* binding */ EffectScope; }
/* harmony export */ });
/* unused harmony exports ARRAY_ITERATE_KEY, EffectFlags, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveFlags, WatchErrorCodes, enableTracking, onEffectCleanup, reactiveReadArray */
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/


function warn(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal track `on` calls, allow `on` call multiple times
     */
    this._on = 0;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (false) // removed by dead control flow
{}
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  } else if (false) // removed by dead control flow
{}
}

let activeSub;
const EffectFlags = {
  "ACTIVE": 1,
  "1": "ACTIVE",
  "RUNNING": 2,
  "2": "RUNNING",
  "TRACKING": 4,
  "4": "TRACKING",
  "NOTIFIED": 8,
  "8": "NOTIFIED",
  "DIRTY": 16,
  "16": "DIRTY",
  "ALLOW_RECURSE": 32,
  "32": "ALLOW_RECURSE",
  "PAUSED": 64,
  "64": "PAUSED",
  "EVALUATED": 128,
  "128": "EVALUATED"
};
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 1 | 4;
    /**
     * @internal
     */
    this.next = void 0;
    /**
     * @internal
     */
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      if (false) // removed by dead control flow
{}
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed) {
  if (computed.flags & 4 && !(computed.flags & 16)) {
    return;
  }
  computed.flags &= -17;
  if (computed.globalVersion === globalVersion) {
    return;
  }
  computed.globalVersion = globalVersion;
  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {
    return;
  }
  computed.flags |= 2;
  const dep = computed.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed;
  shouldTrack = true;
  try {
    prepareDeps(computed);
    const value = computed.fn(computed._value);
    if (dep.version === 0 || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(value, computed._value)) {
      computed.flags |= 128;
      computed._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed);
    computed.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (false) // removed by dead control flow
{}
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const e = new ReactiveEffect(fn);
  if (options) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .extend */ .X$)(e, options);
  }
  try {
    e.run();
  } catch (err) {
    e.stop();
    throw err;
  }
  const runner = e.run.bind(e);
  runner.effect = e;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function onEffectCleanup(fn, failSilently = false) {
  if (activeSub instanceof ReactiveEffect) {
    activeSub.cleanup = fn;
  } else if (false) // removed by dead control flow
{}
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}

let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  // TODO isolatedDeclarations "__v_skip"
  constructor(computed) {
    this.computed = computed;
    this.version = 0;
    /**
     * Link between this dep and the current active effect
     */
    this.activeLink = void 0;
    /**
     * Doubly linked list representing the subscribing effects (tail)
     */
    this.subs = void 0;
    /**
     * For object property deps cleanup
     */
    this.map = void 0;
    this.key = void 0;
    /**
     * Subscriber counter
     */
    this.sc = 0;
    /**
     * @internal
     */
    this.__v_skip = true;
    if (false) // removed by dead control flow
{}
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    if (false) // removed by dead control flow
{}
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) // removed by dead control flow
{}
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed = link.dep.computed;
    if (computed && !link.dep.subs) {
      computed.flags |= 4 | 16;
      for (let l = computed.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    if (false) // removed by dead control flow
{}
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
   false ? 0 : ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
   false ? 0 : ""
);
const ARRAY_ITERATE_KEY = Symbol(
   false ? 0 : ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    if (false) // removed by dead control flow
{} else {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      if (false) // removed by dead control flow
{} else {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(target);
    const isArrayIndex = targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isIntegerKey */ .yI)(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isSymbol */ .Bm)(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isMap */ .CE)(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isMap */ .CE)(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isMap */ .CE)(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}

function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self, method, wrapValue) {
  const arr = shallowReadArray(self);
  const iter = arr[method]();
  if (arr !== self && !isShallow(self)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self);
  const needsWrap = arr !== self && !isShallow(self);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self, method, fn, args) {
  const arr = shallowReadArray(self);
  let wrappedFn = fn;
  if (arr !== self) {
    if (!isShallow(self)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self, method, args) {
  const arr = toRaw(self);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self)[method].apply(self, args);
  endBatch();
  resetTracking();
  return res;
}

const isNonTrackableKeys = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .makeMap */ .pD)(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isSymbol */ .Bm)
);
function hasOwnProperty(key) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isSymbol */ .Bm)(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isSymbol */ .Bm)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isIntegerKey */ .yI)(key) ? res : res.value;
    }
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(target) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isIntegerKey */ .yI)(key) ? Number(key) < target.length : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasOwn */ .$3)(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasOwn */ .$3)(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isSymbol */ .Bm)(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    if (false) // removed by dead control flow
{}
    return true;
  }
  deleteProperty(target, key) {
    if (false) // removed by dead control flow
{}
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isMap */ .CE)(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (false) // removed by dead control flow
{}
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly) {
        if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;
      !readonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .extend */ .X$)(
    instrumentations,
    readonly ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (false) // removed by dead control flow
{}
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        } else if (false) // removed by dead control flow
{}
        const oldValue = get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0, oldValue);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const oldTarget =  false ? 0 : void 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0,
            oldTarget
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasOwn */ .$3)(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has.call(target, rawKey)) {
    const type = toRawType(target);
    warn(
      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}

const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1 /* COMMON */;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2 /* COLLECTION */;
    default:
      return 0 /* INVALID */;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .toRawType */ .Zf)(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(target)) {
    if (false) // removed by dead control flow
{}
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0 /* INVALID */) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasOwn */ .$3)(value, "__v_skip") && Object.isExtensible(value)) {
    (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .def */ .yQ)(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(value) ? reactive(value) : value;
const toReadonly = (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(value) ? readonly(value) : value;

function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    if (false) // removed by dead control flow
{} else {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      if (false) // removed by dead control flow
{} else {
        this.dep.trigger();
      }
    }
  }
}
function triggerRef(ref2) {
  if (ref2.dep) {
    if (false) // removed by dead control flow
{} else {
      ref2.dep.trigger();
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .Tn)(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  if (false) // removed by dead control flow
{}
  const ret = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .Tn)(source)) {
    return new GetterRefImpl(source);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}

class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    /**
     * @internal
     */
    this._value = void 0;
    /**
     * @internal
     */
    this.dep = new Dep(this);
    /**
     * @internal
     */
    this.__v_isRef = true;
    // TODO isolatedDeclarations "__v_isReadonly"
    // A computed is also a subscriber that tracks other deps
    /**
     * @internal
     */
    this.deps = void 0;
    /**
     * @internal
     */
    this.depsTail = void 0;
    /**
     * @internal
     */
    this.flags = 16;
    /**
     * @internal
     */
    this.globalVersion = globalVersion - 1;
    /**
     * @internal
     */
    this.next = void 0;
    // for backwards compat
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    } else if (false) // removed by dead control flow
{}
  }
  get value() {
    const link =  false ? 0 : this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    } else if (false) // removed by dead control flow
{}
  }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .Tn)(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  if (false) // removed by dead control flow
{}
  return cRef;
}

const TrackOpTypes = {
  "GET": "get",
  "HAS": "has",
  "ITERATE": "iterate"
};
const TriggerOpTypes = {
  "SET": "set",
  "ADD": "add",
  "DELETE": "delete",
  "CLEAR": "clear"
};
const ReactiveFlags = {
  "SKIP": "__v_skip",
  "IS_REACTIVE": "__v_isReactive",
  "IS_READONLY": "__v_isReadonly",
  "IS_SHALLOW": "__v_isShallow",
  "RAW": "__v_raw",
  "IS_REF": "__v_isRef"
};

const WatchErrorCodes = {
  "WATCH_GETTER": 2,
  "2": "WATCH_GETTER",
  "WATCH_CALLBACK": 3,
  "3": "WATCH_CALLBACK",
  "WATCH_CLEANUP": 4,
  "4": "WATCH_CLEANUP"
};
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function getCurrentWatcher() {
  return activeWatcher;
}
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  } else if (false) // removed by dead control flow
{}
}
function watch(source, cb, options = _vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .EMPTY_OBJ */ .MZ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const warnInvalidSource = (s) => {
    (options.onWarn || warn)(
      `Invalid watch source: `,
      s,
      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`
    );
  };
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .Tn)(s)) {
        return call ? call(s, 2) : s();
      } else {
         false && 0;
      }
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .Tn)(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = _vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .NOOP */ .tE;
     false && 0;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect.stop();
    if (scope && scope.active) {
      (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .remove */ .TF)(scope.effects, effect);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(v, oldValue[i])) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .hasChanged */ .$H)(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect = new ReactiveEffect(getter);
  effect.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);
  cleanup = effect.onStop = () => {
    const cleanups = cleanupMap.get(effect);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect);
    }
  };
  if (false) // removed by dead control flow
{}
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect.run();
  }
  watchHandle.pause = effect.pause.bind(effect);
  watchHandle.resume = effect.resume.bind(effect);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .cy)(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isSet */ .vM)(value) || (0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isMap */ .CE)(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_0__/* .isPlainObject */ .Qd)(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}




/***/ }),

/***/ 1229:
/***/ (function(module) {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 1332:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(3938);
var iteratorClose = __webpack_require__(9868);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    iteratorClose(iterator);
    throw error;
  }
};


/***/ }),

/***/ 1339:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-iterator-helpers
var $ = __webpack_require__(1605);
var aFunction = __webpack_require__(9085);
var anObject = __webpack_require__(3938);
var createIteratorProxy = __webpack_require__(1523);
var callWithSafeIterationClosing = __webpack_require__(1332);

var IteratorProxy = createIteratorProxy(function (arg) {
  var iterator = this.iterator;
  var result = anObject(this.next.call(iterator, arg));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, result.value);
});

$({ target: 'Iterator', proto: true, real: true }, {
  map: function map(mapper) {
    return new IteratorProxy({
      iterator: anObject(this),
      mapper: aFunction(mapper)
    });
  }
});


/***/ }),

/***/ 1523:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var path = __webpack_require__(9720);
var aFunction = __webpack_require__(9085);
var anObject = __webpack_require__(3938);
var create = __webpack_require__(3105);
var createNonEnumerableProperty = __webpack_require__(7712);
var redefineAll = __webpack_require__(3075);
var wellKnownSymbol = __webpack_require__(1602);
var InternalStateModule = __webpack_require__(9206);

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.get;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $return = function (value) {
  var iterator = getInternalState(this).iterator;
  var $$return = iterator['return'];
  return $$return === undefined ? { done: true, value: value } : anObject($$return.call(iterator, value));
};

var $throw = function (value) {
  var iterator = getInternalState(this).iterator;
  var $$throw = iterator['throw'];
  if ($$throw === undefined) throw value;
  return $$throw.call(iterator, value);
};

module.exports = function (nextHandler, IS_ITERATOR) {
  var IteratorProxy = function Iterator(state) {
    state.next = aFunction(state.iterator.next);
    state.done = false;
    setInternalState(this, state);
  };

  IteratorProxy.prototype = redefineAll(create(path.Iterator.prototype), {
    next: function next() {
      var state = getInternalState(this);
      var result = state.done ? undefined : nextHandler.apply(state, arguments);
      return { done: state.done, value: result };
    },
    'return': $return,
    'throw': $throw
  });

  if (!IS_ITERATOR) {
    createNonEnumerableProperty(IteratorProxy.prototype, TO_STRING_TAG, 'Generator');
  }

  return IteratorProxy;
};


/***/ }),

/***/ 1602:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);
var shared = __webpack_require__(2);
var has = __webpack_require__(1883);
var uid = __webpack_require__(665);
var NATIVE_SYMBOL = __webpack_require__(1849);
var USE_SYMBOL_AS_UID = __webpack_require__(5225);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 1605:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);
var getOwnPropertyDescriptor = (__webpack_require__(7632).f);
var createNonEnumerableProperty = __webpack_require__(7712);
var redefine = __webpack_require__(7485);
var setGlobal = __webpack_require__(5975);
var copyConstructorProperties = __webpack_require__(4361);
var isForced = __webpack_require__(4977);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 1641:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(6347);
var enumBugKeys = __webpack_require__(290);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 1648:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  K: function() { return /* binding */ Editor; },
  M: function() { return /* binding */ Toolbar; }
});

// EXTERNAL MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var runtime_core_esm_bundler = __webpack_require__(641);
// EXTERNAL MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(953);
;// ./node_modules/@wangeditor/editor/dist/index.esm.js
var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function n(e){var t={exports:{}};return e(t,t.exports),t.exports}var r,o,i=function(e){return e&&e.Math==Math&&e},a=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof e&&e)||function(){return this}()||Function("return this")(),u=Function.prototype,s=u.apply,l=u.bind,c=u.call,f="object"==typeof Reflect&&Reflect.apply||(l?c.bind(s):function(){return c.apply(s,arguments)}),d=Function.prototype,p=d.bind,h=d.call,g=p&&p.bind(h),v=p?function(e){return e&&g(h,e)}:function(e){return e&&function(){return h.apply(e,arguments)}},y=function(e){return"function"==typeof e},m=function(e){try{return!!e()}catch(e){return!0}},b=!m((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),w=Function.prototype.call,E=w.bind?w.bind(w):function(){return w.apply(w,arguments)},D={}.propertyIsEnumerable,S=Object.getOwnPropertyDescriptor,x=S&&!D.call({1:2},1)?function(e){var t=S(this,e);return!!t&&t.enumerable}:D,C={f:x},A=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},O=v({}.toString),k=v("".slice),B=function(e){return k(O(e),8,-1)},F=a.Object,T=v("".split),_=m((function(){return!F("z").propertyIsEnumerable(0)}))?function(e){return"String"==B(e)?T(e,""):F(e)}:F,P=a.TypeError,j=function(e){if(null==e)throw P("Can't call method on "+e);return e},N=function(e){return _(j(e))},I=function(e){return"object"==typeof e?null!==e:y(e)},L={},R=function(e){return y(e)?e:void 0},M=function(e,t){return arguments.length<2?R(L[e])||R(a[e]):L[e]&&L[e][t]||a[e]&&a[e][t]},z=v({}.isPrototypeOf),$=M("navigator","userAgent")||"",H=a.process,V=a.Deno,U=H&&H.versions||V&&V.version,W=U&&U.v8;W&&(o=(r=W.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!o&&$&&(!(r=$.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=$.match(/Chrome\/(\d+)/))&&(o=+r[1]);var G,q=o,K=!!Object.getOwnPropertySymbols&&!m((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&q&&q<41})),Y=K&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,X=a.Object,Z=Y?function(e){return"symbol"==typeof e}:function(e){var t=M("Symbol");return y(t)&&z(t.prototype,X(e))},J=a.String,Q=function(e){try{return J(e)}catch(e){return"Object"}},ee=a.TypeError,te=function(e){if(y(e))return e;throw ee(Q(e)+" is not a function")},ne=function(e,t){var n=e[t];return null==n?void 0:te(n)},re=a.TypeError,oe=Object.defineProperty,ie=a["__core-js_shared__"]||function(e,t){try{oe(a,e,{value:t,configurable:!0,writable:!0})}catch(n){a[e]=t}return t}("__core-js_shared__",{}),ae=n((function(e){(e.exports=function(e,t){return ie[e]||(ie[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"pure",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),ue=a.Object,se=function(e){return ue(j(e))},le=v({}.hasOwnProperty),ce=Object.hasOwn||function(e,t){return le(se(e),t)},fe=0,de=Math.random(),pe=v(1..toString),he=function(e){return"Symbol("+(void 0===e?"":e)+")_"+pe(++fe+de,36)},ge=ae("wks"),ve=a.Symbol,ye=ve&&ve.for,me=Y?ve:ve&&ve.withoutSetter||he,be=function(e){if(!ce(ge,e)||!K&&"string"!=typeof ge[e]){var t="Symbol."+e;K&&ce(ve,e)?ge[e]=ve[e]:ge[e]=Y&&ye?ye(t):me(t)}return ge[e]},we=a.TypeError,Ee=be("toPrimitive"),De=function(e,t){if(!I(e)||Z(e))return e;var n,r=ne(e,Ee);if(r){if(void 0===t&&(t="default"),n=E(r,e,t),!I(n)||Z(n))return n;throw we("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&y(n=e.toString)&&!I(r=E(n,e)))return r;if(y(n=e.valueOf)&&!I(r=E(n,e)))return r;if("string"!==t&&y(n=e.toString)&&!I(r=E(n,e)))return r;throw re("Can't convert object to primitive value")}(e,t)},Se=function(e){var t=De(e,"string");return Z(t)?t:t+""},xe=a.document,Ce=I(xe)&&I(xe.createElement),Ae=function(e){return Ce?xe.createElement(e):{}},Oe=!b&&!m((function(){return 7!=Object.defineProperty(Ae("div"),"a",{get:function(){return 7}}).a})),ke=Object.getOwnPropertyDescriptor,Be=b?ke:function(e,t){if(e=N(e),t=Se(t),Oe)try{return ke(e,t)}catch(e){}if(ce(e,t))return A(!E(C.f,e,t),e[t])},Fe={f:Be},Te=/#|\.prototype\./,_e=function(e,t){var n=je[Pe(e)];return n==Ie||n!=Ne&&(y(t)?m(t):!!t)},Pe=_e.normalize=function(e){return String(e).replace(Te,".").toLowerCase()},je=_e.data={},Ne=_e.NATIVE="N",Ie=_e.POLYFILL="P",Le=_e,Re=v(v.bind),Me=function(e,t){return te(e),void 0===t?e:Re?Re(e,t):function(){return e.apply(t,arguments)}},ze=a.String,$e=a.TypeError,He=function(e){if(I(e))return e;throw $e(ze(e)+" is not an object")},Ve=a.TypeError,Ue=Object.defineProperty,We=b?Ue:function(e,t,n){if(He(e),t=Se(t),He(n),Oe)try{return Ue(e,t,n)}catch(e){}if("get"in n||"set"in n)throw Ve("Accessors not supported");return"value"in n&&(e[t]=n.value),e},Ge={f:We},qe=b?function(e,t,n){return Ge.f(e,t,A(1,n))}:function(e,t,n){return e[t]=n,e},Ke=Fe.f,Ye=function(e){var t=function(n,r,o){if(this instanceof t){switch(arguments.length){case 0:return new e;case 1:return new e(n);case 2:return new e(n,r)}return new e(n,r,o)}return f(e,this,arguments)};return t.prototype=e.prototype,t},Xe=function(e,t){var n,r,o,i,u,s,l,c,f=e.target,d=e.global,p=e.stat,h=e.proto,g=d?a:p?a[f]:(a[f]||{}).prototype,m=d?L:L[f]||qe(L,f,{})[f],b=m.prototype;for(o in t)n=!Le(d?o:f+(p?".":"#")+o,e.forced)&&g&&ce(g,o),u=m[o],n&&(s=e.noTargetGet?(c=Ke(g,o))&&c.value:g[o]),i=n&&s?s:t[o],n&&typeof u==typeof i||(l=e.bind&&n?Me(i,a):e.wrap&&n?Ye(i):h&&y(i)?v(i):i,(e.sham||i&&i.sham||u&&u.sham)&&qe(l,"sham",!0),qe(m,o,l),h&&(ce(L,r=f+"Prototype")||qe(L,r,{}),qe(L[r],o,i),e.real&&b&&!b[o]&&qe(b,o,i)))},Ze=ae("keys"),Je=function(e){return Ze[e]||(Ze[e]=he(e))},Qe=!m((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),et=Je("IE_PROTO"),tt=a.Object,nt=tt.prototype,rt=Qe?tt.getPrototypeOf:function(e){var t=se(e);if(ce(t,et))return t[et];var n=t.constructor;return y(n)&&t instanceof n?n.prototype:t instanceof tt?nt:null},ot=a.String,it=a.TypeError,at=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=v(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(n,[]),t=n instanceof Array}catch(e){}return function(n,r){return He(n),function(e){if("object"==typeof e||y(e))return e;throw it("Can't set "+ot(e)+" as a prototype")}(r),t?e(n,r):n.__proto__=r,n}}():void 0),ut=Math.ceil,st=Math.floor,lt=function(e){var t=+e;return t!=t||0===t?0:(t>0?st:ut)(t)},ct=Math.max,ft=Math.min,dt=function(e,t){var n=lt(e);return n<0?ct(n+t,0):ft(n,t)},pt=Math.min,ht=function(e){return(t=e.length)>0?pt(lt(t),9007199254740991):0;// removed by dead control flow
{ var t; }},gt=function(e){return function(t,n,r){var o,i=N(t),a=ht(i),u=dt(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},vt={includes:gt(!0),indexOf:gt(!1)},yt={},mt=vt.indexOf,bt=v([].push),wt=function(e,t){var n,r=N(e),o=0,i=[];for(n in r)!ce(yt,n)&&ce(r,n)&&bt(i,n);for(;t.length>o;)ce(r,n=t[o++])&&(~mt(i,n)||bt(i,n));return i},Et=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],Dt=Et.concat("length","prototype"),St=Object.getOwnPropertyNames||function(e){return wt(e,Dt)},xt={f:St},Ct={f:Object.getOwnPropertySymbols},At=v([].concat),Ot=M("Reflect","ownKeys")||function(e){var t=xt.f(He(e)),n=Ct.f;return n?At(t,n(e)):t},kt=Object.keys||function(e){return wt(e,Et)},Bt=b?Object.defineProperties:function(e,t){He(e);for(var n,r=N(t),o=kt(t),i=o.length,a=0;i>a;)Ge.f(e,n=o[a++],r[n]);return e},Ft=M("document","documentElement"),Tt=Je("IE_PROTO"),_t=function(){},Pt=function(e){return"<script>"+e+"<\/script>"},jt=function(e){e.write(Pt("")),e.close();var t=e.parentWindow.Object;return e=null,t},Nt=function(){try{G=new ActiveXObject("htmlfile")}catch(e){}var e,t;Nt="undefined"!=typeof document?document.domain&&G?jt(G):((t=Ae("iframe")).style.display="none",Ft.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(Pt("document.F=Object")),e.close(),e.F):jt(G);for(var n=Et.length;n--;)delete Nt.prototype[Et[n]];return Nt()};yt[Tt]=!0;var It=Object.create||function(e,t){var n;return null!==e?(_t.prototype=He(e),n=new _t,_t.prototype=null,n[Tt]=e):n=Nt(),void 0===t?n:Bt(n,t)},Lt=function(e,t,n){var r=Se(t);r in e?Ge.f(e,r,A(0,n)):e[r]=n},Rt=a.Array,Mt=Math.max,zt=function(e,t,n){for(var r=ht(e),o=dt(t,r),i=dt(void 0===n?r:n,r),a=Rt(Mt(i-o,0)),u=0;o<i;o++,u++)Lt(a,u,e[o]);return a.length=u,a},$t=v("".replace),Ht=v("".split),Vt=v([].join),Ut=String(Error("zxcasd").stack),Wt=/\n\s*at [^:]*:[^\n]*/,Gt=Wt.test(Ut),qt=/@[^\n]*\n/.test(Ut)&&!/zxcasd/.test(Ut),Kt=function(e,t){if("string"!=typeof e)return e;if(Gt)for(;t--;)e=$t(e,Wt,"");else if(qt)return Vt(zt(Ht(e,"\n"),t),"\n");return e},Yt=function(e,t){I(t)&&"cause"in t&&qe(e,"cause",t.cause)},Xt={},Zt=be("iterator"),Jt=Array.prototype,Qt={};Qt[be("toStringTag")]="z";var en="[object z]"===String(Qt),tn=be("toStringTag"),nn=a.Object,rn="Arguments"==B(function(){return arguments}()),on=en?B:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=nn(e),tn))?n:rn?B(t):"Object"==(r=B(t))&&y(t.callee)?"Arguments":r},an=be("iterator"),un=function(e){if(null!=e)return ne(e,an)||ne(e,"@@iterator")||Xt[on(e)]},sn=a.TypeError,ln=function(e,t,n){var r,o;He(e);try{if(!(r=ne(e,"return"))){if("throw"===t)throw n;return n}r=E(r,e)}catch(e){o=!0,r=e}if("throw"===t)throw n;if(o)throw r;return He(r),n},cn=a.TypeError,fn=function(e,t){this.stopped=e,this.result=t},dn=fn.prototype,pn=function(e,t,n){var r,o,i,a,u,s,l,c=n&&n.that,f=!(!n||!n.AS_ENTRIES),d=!(!n||!n.IS_ITERATOR),p=!(!n||!n.INTERRUPTED),h=Me(t,c),g=function(e){return r&&ln(r,"normal",e),new fn(!0,e)},v=function(e){return f?(He(e),p?h(e[0],e[1],g):h(e[0],e[1])):p?h(e,g):h(e)};if(d)r=e;else{if(!(o=un(e)))throw cn(Q(e)+" is not iterable");if(function(e){return void 0!==e&&(Xt.Array===e||Jt[Zt]===e)}(o)){for(i=0,a=ht(e);a>i;i++)if((u=v(e[i]))&&z(dn,u))return u;return new fn(!1)}r=function(e,t){var n=arguments.length<2?un(e):t;if(te(n))return He(E(n,e));throw sn(Q(e)+" is not iterable")}(e,o)}for(s=r.next;!(l=E(s,r)).done;){try{u=v(l.value)}catch(e){ln(r,"throw",e)}if("object"==typeof u&&u&&z(dn,u))return u}return new fn(!1)},hn=a.String,gn=function(e){if("Symbol"===on(e))throw TypeError("Cannot convert a Symbol value to a string");return hn(e)},vn=function(e,t){return void 0===e?arguments.length<2?"":t:gn(e)},yn=!m((function(){var e=Error("a");return!("stack"in e)||(Object.defineProperty(e,"stack",A(1,7)),7!==e.stack)})),mn=be("toStringTag"),bn=a.Error,wn=[].push,En=function(e,t){var n,r=arguments.length>2?arguments[2]:void 0,o=z(Dn,this);at?n=at(new bn(void 0),o?rt(this):Dn):(n=o?this:It(Dn),qe(n,mn,"Error")),qe(n,"message",vn(t,"")),yn&&qe(n,"stack",Kt(n.stack,1)),Yt(n,r);var i=[];return pn(e,wn,{that:i}),qe(n,"errors",i),n};at?at(En,bn):function(e,t){for(var n=Ot(t),r=Ge.f,o=Fe.f,i=0;i<n.length;i++){var a=n[i];ce(e,a)||r(e,a,o(t,a))}}(En,bn);var Dn=En.prototype=It(bn.prototype,{constructor:A(1,En),message:A(1,""),name:A(1,"AggregateError")});Xe({global:!0},{AggregateError:En});var Sn=v(Function.toString);y(ie.inspectSource)||(ie.inspectSource=function(e){return Sn(e)});var xn,Cn,An,On=ie.inspectSource,kn=a.WeakMap,Bn=y(kn)&&/native code/.test(On(kn)),Fn=a.TypeError,Tn=a.WeakMap;if(Bn||ie.state){var _n=ie.state||(ie.state=new Tn),Pn=v(_n.get),jn=v(_n.has),Nn=v(_n.set);xn=function(e,t){if(jn(_n,e))throw new Fn("Object already initialized");return t.facade=e,Nn(_n,e,t),t},Cn=function(e){return Pn(_n,e)||{}},An=function(e){return jn(_n,e)}}else{var In=Je("state");yt[In]=!0,xn=function(e,t){if(ce(e,In))throw new Fn("Object already initialized");return t.facade=e,qe(e,In,t),t},Cn=function(e){return ce(e,In)?e[In]:{}},An=function(e){return ce(e,In)}}var Ln,Rn,Mn,zn={set:xn,get:Cn,has:An,enforce:function(e){return An(e)?Cn(e):xn(e,{})},getterFor:function(e){return function(t){var n;if(!I(t)||(n=Cn(t)).type!==e)throw Fn("Incompatible receiver, "+e+" required");return n}}},$n=Function.prototype,Hn=b&&Object.getOwnPropertyDescriptor,Vn=ce($n,"name"),Un={EXISTS:Vn,PROPER:Vn&&"something"===function(){}.name,CONFIGURABLE:Vn&&(!b||b&&Hn($n,"name").configurable)},Wn=function(e,t,n,r){r&&r.enumerable?e[t]=n:qe(e,t,n)},Gn=be("iterator"),qn=!1;[].keys&&("next"in(Mn=[].keys())?(Rn=rt(rt(Mn)))!==Object.prototype&&(Ln=Rn):qn=!0);var Kn=null==Ln||m((function(){var e={};return Ln[Gn].call(e)!==e}));Ln=Kn?{}:It(Ln),y(Ln[Gn])||Wn(Ln,Gn,(function(){return this}));var Yn={IteratorPrototype:Ln,BUGGY_SAFARI_ITERATORS:qn},Xn=en?{}.toString:function(){return"[object "+on(this)+"]"},Zn=Ge.f,Jn=be("toStringTag"),Qn=function(e,t,n,r){if(e){var o=n?e:e.prototype;ce(o,Jn)||Zn(o,Jn,{configurable:!0,value:t}),r&&!en&&qe(o,"toString",Xn)}},er=Yn.IteratorPrototype,tr=function(){return this},nr=Un.PROPER,rr=Yn.BUGGY_SAFARI_ITERATORS,or=be("iterator"),ir=function(){return this},ar=function(e,t,n,r,o,i,a){!function(e,t,n,r){var o=t+" Iterator";e.prototype=It(er,{next:A(+!r,n)}),Qn(e,o,!1,!0),Xt[o]=tr}(n,t,r);var u,s,l,c=function(e){if(e===o&&g)return g;if(!rr&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[or]||p["@@iterator"]||o&&p[o],g=!rr&&h||c(o),v="Array"==t&&p.entries||h;if(v&&(u=rt(v.call(new e)))!==Object.prototype&&u.next&&(Qn(u,f,!0,!0),Xt[f]=ir),nr&&"values"==o&&h&&"values"!==h.name&&(d=!0,g=function(){return E(h,this)}),o)if(s={values:c("values"),keys:i?g:c("keys"),entries:c("entries")},a)for(l in s)(rr||d||!(l in p))&&Wn(p,l,s[l]);else Xe({target:t,proto:!0,forced:rr||d},s);return a&&p[or]!==g&&Wn(p,or,g,{name:o}),Xt[t]=g,s},ur=zn.set,sr=zn.getterFor("Array Iterator");ar(Array,"Array",(function(e,t){ur(this,{type:"Array Iterator",target:N(e),index:0,kind:t})}),(function(){var e=sr(this),t=e.target,n=e.kind,r=e.index++;return!t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values"),Xt.Arguments=Xt.Array;var lr=v("".charAt),cr=v("".charCodeAt),fr=v("".slice),dr=function(e){return function(t,n){var r,o,i=gn(j(t)),a=lt(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=cr(i,a))<55296||r>56319||a+1===u||(o=cr(i,a+1))<56320||o>57343?e?lr(i,a):r:e?fr(i,a,a+2):o-56320+(r-55296<<10)+65536}},pr={codeAt:dr(!1),charAt:dr(!0)}.charAt,hr=zn.set,gr=zn.getterFor("String Iterator");ar(String,"String",(function(e){hr(this,{type:"String Iterator",string:gn(e),index:0})}),(function(){var e,t=gr(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=pr(n,r),t.index+=e.length,{value:e,done:!1})}));var vr=L.AggregateError,yr=be("toStringTag");for(var mr in{CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}){var br=a[mr],wr=br&&br.prototype;wr&&on(wr)!==yr&&qe(wr,yr,mr),Xt[mr]=Xt.Array}var Er,Dr,Sr=vr,xr=function(e){return e&&e.Math==Math&&e},Cr=xr("object"==typeof globalThis&&globalThis)||xr("object"==typeof window&&window)||xr("object"==typeof self&&self)||xr("object"==typeof e&&e)||function(){return this}()||Function("return this")(),Ar=function(e){try{return!!e()}catch(e){return!0}},Or=!Ar((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),kr=Function.prototype.call,Br=kr.bind?kr.bind(kr):function(){return kr.apply(kr,arguments)},Fr={}.propertyIsEnumerable,Tr=Object.getOwnPropertyDescriptor,_r=Tr&&!Fr.call({1:2},1)?function(e){var t=Tr(this,e);return!!t&&t.enumerable}:Fr,Pr={f:_r},jr=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},Nr=Function.prototype,Ir=Nr.bind,Lr=Nr.call,Rr=Ir&&Ir.bind(Lr),Mr=Ir?function(e){return e&&Rr(Lr,e)}:function(e){return e&&function(){return Lr.apply(e,arguments)}},zr=Mr({}.toString),$r=Mr("".slice),Hr=function(e){return $r(zr(e),8,-1)},Vr=Cr.Object,Ur=Mr("".split),Wr=Ar((function(){return!Vr("z").propertyIsEnumerable(0)}))?function(e){return"String"==Hr(e)?Ur(e,""):Vr(e)}:Vr,Gr=Cr.TypeError,qr=function(e){if(null==e)throw Gr("Can't call method on "+e);return e},Kr=function(e){return Wr(qr(e))},Yr=function(e){return"function"==typeof e},Xr=function(e){return"object"==typeof e?null!==e:Yr(e)},Zr=function(e){return Yr(e)?e:void 0},Jr=function(e,t){return arguments.length<2?Zr(Cr[e]):Cr[e]&&Cr[e][t]},Qr=Mr({}.isPrototypeOf),eo=Jr("navigator","userAgent")||"",to=Cr.process,no=Cr.Deno,ro=to&&to.versions||no&&no.version,oo=ro&&ro.v8;oo&&(Dr=(Er=oo.split("."))[0]>0&&Er[0]<4?1:+(Er[0]+Er[1])),!Dr&&eo&&(!(Er=eo.match(/Edge\/(\d+)/))||Er[1]>=74)&&(Er=eo.match(/Chrome\/(\d+)/))&&(Dr=+Er[1]);var io=Dr,ao=!!Object.getOwnPropertySymbols&&!Ar((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&io&&io<41})),uo=ao&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,so=Cr.Object,lo=uo?function(e){return"symbol"==typeof e}:function(e){var t=Jr("Symbol");return Yr(t)&&Qr(t.prototype,so(e))},co=Cr.String,fo=function(e){try{return co(e)}catch(e){return"Object"}},po=Cr.TypeError,ho=function(e){if(Yr(e))return e;throw po(fo(e)+" is not a function")},go=function(e,t){var n=e[t];return null==n?void 0:ho(n)},vo=Cr.TypeError,yo=Object.defineProperty,mo=function(e,t){try{yo(Cr,e,{value:t,configurable:!0,writable:!0})}catch(n){Cr[e]=t}return t},bo=Cr["__core-js_shared__"]||mo("__core-js_shared__",{}),wo=n((function(e){(e.exports=function(e,t){return bo[e]||(bo[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),Eo=Cr.Object,Do=function(e){return Eo(qr(e))},So=Mr({}.hasOwnProperty),xo=Object.hasOwn||function(e,t){return So(Do(e),t)},Co=0,Ao=Math.random(),Oo=Mr(1..toString),ko=function(e){return"Symbol("+(void 0===e?"":e)+")_"+Oo(++Co+Ao,36)},Bo=wo("wks"),Fo=Cr.Symbol,To=Fo&&Fo.for,_o=uo?Fo:Fo&&Fo.withoutSetter||ko,Po=function(e){if(!xo(Bo,e)||!ao&&"string"!=typeof Bo[e]){var t="Symbol."+e;ao&&xo(Fo,e)?Bo[e]=Fo[e]:Bo[e]=uo&&To?To(t):_o(t)}return Bo[e]},jo=Cr.TypeError,No=Po("toPrimitive"),Io=function(e,t){if(!Xr(e)||lo(e))return e;var n,r=go(e,No);if(r){if(void 0===t&&(t="default"),n=Br(r,e,t),!Xr(n)||lo(n))return n;throw jo("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&Yr(n=e.toString)&&!Xr(r=Br(n,e)))return r;if(Yr(n=e.valueOf)&&!Xr(r=Br(n,e)))return r;if("string"!==t&&Yr(n=e.toString)&&!Xr(r=Br(n,e)))return r;throw vo("Can't convert object to primitive value")}(e,t)},Lo=function(e){var t=Io(e,"string");return lo(t)?t:t+""},Ro=Cr.document,Mo=Xr(Ro)&&Xr(Ro.createElement),zo=function(e){return Mo?Ro.createElement(e):{}},$o=!Or&&!Ar((function(){return 7!=Object.defineProperty(zo("div"),"a",{get:function(){return 7}}).a})),Ho=Object.getOwnPropertyDescriptor,Vo=Or?Ho:function(e,t){if(e=Kr(e),t=Lo(t),$o)try{return Ho(e,t)}catch(e){}if(xo(e,t))return jr(!Br(Pr.f,e,t),e[t])},Uo={f:Vo},Wo=Cr.String,Go=Cr.TypeError,qo=function(e){if(Xr(e))return e;throw Go(Wo(e)+" is not an object")},Ko=Cr.TypeError,Yo=Object.defineProperty,Xo=Or?Yo:function(e,t,n){if(qo(e),t=Lo(t),qo(n),$o)try{return Yo(e,t,n)}catch(e){}if("get"in n||"set"in n)throw Ko("Accessors not supported");return"value"in n&&(e[t]=n.value),e},Zo={f:Xo},Jo=Or?function(e,t,n){return Zo.f(e,t,jr(1,n))}:function(e,t,n){return e[t]=n,e},Qo=Mr(Function.toString);Yr(bo.inspectSource)||(bo.inspectSource=function(e){return Qo(e)});var ei,ti,ni,ri=bo.inspectSource,oi=Cr.WeakMap,ii=Yr(oi)&&/native code/.test(ri(oi)),ai=wo("keys"),ui=function(e){return ai[e]||(ai[e]=ko(e))},si={},li=Cr.TypeError,ci=Cr.WeakMap;if(ii||bo.state){var fi=bo.state||(bo.state=new ci),di=Mr(fi.get),pi=Mr(fi.has),hi=Mr(fi.set);ei=function(e,t){if(pi(fi,e))throw new li("Object already initialized");return t.facade=e,hi(fi,e,t),t},ti=function(e){return di(fi,e)||{}},ni=function(e){return pi(fi,e)}}else{var gi=ui("state");si[gi]=!0,ei=function(e,t){if(xo(e,gi))throw new li("Object already initialized");return t.facade=e,Jo(e,gi,t),t},ti=function(e){return xo(e,gi)?e[gi]:{}},ni=function(e){return xo(e,gi)}}var vi={set:ei,get:ti,has:ni,enforce:function(e){return ni(e)?ti(e):ei(e,{})},getterFor:function(e){return function(t){var n;if(!Xr(t)||(n=ti(t)).type!==e)throw li("Incompatible receiver, "+e+" required");return n}}},yi=Function.prototype,mi=Or&&Object.getOwnPropertyDescriptor,bi=xo(yi,"name"),wi={EXISTS:bi,PROPER:bi&&"something"===function(){}.name,CONFIGURABLE:bi&&(!Or||Or&&mi(yi,"name").configurable)},Ei=n((function(e){var t=wi.CONFIGURABLE,n=vi.get,r=vi.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;Yr(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!xo(i,"name")||t&&i.name!==f)&&Jo(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==Cr?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:Jo(e,n,i)):l?e[n]=i:mo(n,i)})(Function.prototype,"toString",(function(){return Yr(this)&&n(this).source||ri(this)}))})),Di=Math.ceil,Si=Math.floor,xi=function(e){var t=+e;return t!=t||0===t?0:(t>0?Si:Di)(t)},Ci=Math.max,Ai=Math.min,Oi=function(e,t){var n=xi(e);return n<0?Ci(n+t,0):Ai(n,t)},ki=Math.min,Bi=function(e){return e>0?ki(xi(e),9007199254740991):0},Fi=function(e){return Bi(e.length)},Ti=function(e){return function(t,n,r){var o,i=Kr(t),a=Fi(i),u=Oi(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},_i={includes:Ti(!0),indexOf:Ti(!1)}.indexOf,Pi=Mr([].push),ji=function(e,t){var n,r=Kr(e),o=0,i=[];for(n in r)!xo(si,n)&&xo(r,n)&&Pi(i,n);for(;t.length>o;)xo(r,n=t[o++])&&(~_i(i,n)||Pi(i,n));return i},Ni=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],Ii=Ni.concat("length","prototype"),Li=Object.getOwnPropertyNames||function(e){return ji(e,Ii)},Ri={f:Li},Mi={f:Object.getOwnPropertySymbols},zi=Mr([].concat),$i=Jr("Reflect","ownKeys")||function(e){var t=Ri.f(qo(e)),n=Mi.f;return n?zi(t,n(e)):t},Hi=function(e,t){for(var n=$i(t),r=Zo.f,o=Uo.f,i=0;i<n.length;i++){var a=n[i];xo(e,a)||r(e,a,o(t,a))}},Vi=/#|\.prototype\./,Ui=function(e,t){var n=Gi[Wi(e)];return n==Ki||n!=qi&&(Yr(t)?Ar(t):!!t)},Wi=Ui.normalize=function(e){return String(e).replace(Vi,".").toLowerCase()},Gi=Ui.data={},qi=Ui.NATIVE="N",Ki=Ui.POLYFILL="P",Yi=Ui,Xi=Uo.f,Zi=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?Cr:l?Cr[u]||mo(u,{}):(Cr[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=Xi(n,r))&&a.value:n[r],!Yi(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;Hi(i,o)}(e.sham||o&&o.sham)&&Jo(i,"sham",!0),Ei(n,r,i,e)}},Ji={};Ji[Po("toStringTag")]="z";var Qi,ea="[object z]"===String(Ji),ta=Po("toStringTag"),na=Cr.Object,ra="Arguments"==Hr(function(){return arguments}()),oa=ea?Hr:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=na(e),ta))?n:ra?Hr(t):"Object"==(r=Hr(t))&&Yr(t.callee)?"Arguments":r},ia=Cr.String,aa=function(e){if("Symbol"===oa(e))throw TypeError("Cannot convert a Symbol value to a string");return ia(e)},ua=function(){var e=qo(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},sa=Cr.RegExp,la=Ar((function(){var e=sa("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),ca=la||Ar((function(){return!sa("a","y").sticky})),fa=la||Ar((function(){var e=sa("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),da={BROKEN_CARET:fa,MISSED_STICKY:ca,UNSUPPORTED_Y:la},pa=Object.keys||function(e){return ji(e,Ni)},ha=Or?Object.defineProperties:function(e,t){qo(e);for(var n,r=Kr(t),o=pa(t),i=o.length,a=0;i>a;)Zo.f(e,n=o[a++],r[n]);return e},ga=Jr("document","documentElement"),va=ui("IE_PROTO"),ya=function(){},ma=function(e){return"<script>"+e+"<\/script>"},ba=function(e){e.write(ma("")),e.close();var t=e.parentWindow.Object;return e=null,t},wa=function(){try{Qi=new ActiveXObject("htmlfile")}catch(e){}var e,t;wa="undefined"!=typeof document?document.domain&&Qi?ba(Qi):((t=zo("iframe")).style.display="none",ga.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(ma("document.F=Object")),e.close(),e.F):ba(Qi);for(var n=Ni.length;n--;)delete wa.prototype[Ni[n]];return wa()};si[va]=!0;var Ea,Da,Sa=Object.create||function(e,t){var n;return null!==e?(ya.prototype=qo(e),n=new ya,ya.prototype=null,n[va]=e):n=wa(),void 0===t?n:ha(n,t)},xa=Cr.RegExp,Ca=Ar((function(){var e=xa(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),Aa=Cr.RegExp,Oa=Ar((function(){var e=Aa("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),ka=vi.get,Ba=wo("native-string-replace",String.prototype.replace),Fa=RegExp.prototype.exec,Ta=Fa,_a=Mr("".charAt),Pa=Mr("".indexOf),ja=Mr("".replace),Na=Mr("".slice),Ia=(Da=/b*/g,Br(Fa,Ea=/a/,"a"),Br(Fa,Da,"a"),0!==Ea.lastIndex||0!==Da.lastIndex),La=da.BROKEN_CARET,Ra=void 0!==/()??/.exec("")[1];(Ia||Ra||La||Ca||Oa)&&(Ta=function(e){var t,n,r,o,i,a,u,s=this,l=ka(s),c=aa(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=Br(Ta,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=La&&s.sticky,h=Br(ua,s),g=s.source,v=0,y=c;if(p&&(h=ja(h,"y",""),-1===Pa(h,"g")&&(h+="g"),y=Na(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==_a(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),Ra&&(n=new RegExp("^"+g+"$(?!\\s)",h)),Ia&&(r=s.lastIndex),o=Br(Fa,p?n:s,y),p?o?(o.input=Na(o.input,v),o[0]=Na(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:Ia&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),Ra&&o&&o.length>1&&Br(Ba,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=Sa(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var Ma=Ta;Zi({target:"RegExp",proto:!0,forced:/./.exec!==Ma},{exec:Ma});var za=Po("species"),$a=RegExp.prototype,Ha=Mr("".charAt),Va=Mr("".charCodeAt),Ua=Mr("".slice),Wa=function(e){return function(t,n){var r,o,i=aa(qr(t)),a=xi(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=Va(i,a))<55296||r>56319||a+1===u||(o=Va(i,a+1))<56320||o>57343?e?Ha(i,a):r:e?Ua(i,a,a+2):o-56320+(r-55296<<10)+65536}},Ga={codeAt:Wa(!1),charAt:Wa(!0)},qa=Ga.charAt,Ka=function(e,t,n){return t+(n?qa(e,t).length:1)},Ya=Cr.TypeError,Xa=function(e,t){var n=e.exec;if(Yr(n)){var r=Br(n,e,t);return null!==r&&qo(r),r}if("RegExp"===Hr(e))return Br(Ma,e,t);throw Ya("RegExp#exec called on incompatible receiver")};!function(e,t,n,r){var o=Po(e),i=!Ar((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!Ar((function(){var t=!1,n=/a/;return"split"===e&&((n={}).constructor={},n.constructor[za]=function(){return n},n.flags="",n[o]=/./[o]),n.exec=function(){return t=!0,null},n[o](""),!t}));if(!i||!a||n){var u=Mr(/./[o]),s=t(o,""[e],(function(e,t,n,r,o){var a=Mr(e),s=t.exec;return s===Ma||s===$a.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));Ei(String.prototype,e,s[0]),Ei($a,o,s[1])}r&&Jo($a[o],"sham",!0)}("match",(function(e,t,n){return[function(t){var n=qr(this),r=null==t?void 0:go(t,e);return r?Br(r,t,n):new RegExp(t)[e](aa(n))},function(e){var r=qo(this),o=aa(e),i=n(t,r,o);if(i.done)return i.value;if(!r.global)return Xa(r,o);var a=r.unicode;r.lastIndex=0;for(var u,s=[],l=0;null!==(u=Xa(r,o));){var c=aa(u[0]);s[l]=c,""===c&&(r.lastIndex=Ka(o,Bi(r.lastIndex),a)),l++}return 0===l?null:s}]})),Zi({global:!0},{globalThis:Cr});var Za=!Ar((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),Ja=ui("IE_PROTO"),Qa=Cr.Object,eu=Qa.prototype,tu=Za?Qa.getPrototypeOf:function(e){var t=Do(e);if(xo(t,Ja))return t[Ja];var n=t.constructor;return Yr(n)&&t instanceof n?n.prototype:t instanceof Qa?eu:null},nu=Cr.String,ru=Cr.TypeError,ou=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=Mr(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(n,[]),t=n instanceof Array}catch(e){}return function(n,r){return qo(n),function(e){if("object"==typeof e||Yr(e))return e;throw ru("Can't set "+nu(e)+" as a prototype")}(r),t?e(n,r):n.__proto__=r,n}}():void 0),iu=Cr.Array,au=Math.max,uu=Mr("".replace),su=Mr("".split),lu=Mr([].join),cu=String(Error("zxcasd").stack),fu=/\n\s*at [^:]*:[^\n]*/,du=fu.test(cu),pu=/@[^\n]*\n/.test(cu)&&!/zxcasd/.test(cu),hu=function(e,t){if("string"!=typeof e)return e;if(du)for(;t--;)e=uu(e,fu,"");else if(pu)return lu(function(e,t,n){for(var r,o,i,a,u=Fi(e),s=Oi(t,u),l=Oi(void 0===n?u:n,u),c=iu(au(l-s,0)),f=0;s<l;s++,f++)r=c,o=f,i=e[s],a=void 0,(a=Lo(o))in r?Zo.f(r,a,jr(0,i)):r[a]=i;return c.length=f,c}(su(e,"\n"),t),"\n");return e},gu=function(e,t){Xr(t)&&"cause"in t&&Jo(e,"cause",t.cause)},vu=Mr(Mr.bind),yu=function(e,t){return ho(e),void 0===t?e:vu?vu(e,t):function(){return e.apply(t,arguments)}},mu={},bu=Po("iterator"),wu=Array.prototype,Eu=Po("iterator"),Du=function(e){if(null!=e)return go(e,Eu)||go(e,"@@iterator")||mu[oa(e)]},Su=Cr.TypeError,xu=function(e,t,n){var r,o;qo(e);try{if(!(r=go(e,"return"))){if("throw"===t)throw n;return n}r=Br(r,e)}catch(e){o=!0,r=e}if("throw"===t)throw n;if(o)throw r;return qo(r),n},Cu=Cr.TypeError,Au=function(e,t){this.stopped=e,this.result=t},Ou=Au.prototype,ku=function(e,t,n){var r,o,i,a,u,s,l,c=n&&n.that,f=!(!n||!n.AS_ENTRIES),d=!(!n||!n.IS_ITERATOR),p=!(!n||!n.INTERRUPTED),h=yu(t,c),g=function(e){return r&&xu(r,"normal",e),new Au(!0,e)},v=function(e){return f?(qo(e),p?h(e[0],e[1],g):h(e[0],e[1])):p?h(e,g):h(e)};if(d)r=e;else{if(!(o=Du(e)))throw Cu(fo(e)+" is not iterable");if(function(e){return void 0!==e&&(mu.Array===e||wu[bu]===e)}(o)){for(i=0,a=Fi(e);a>i;i++)if((u=v(e[i]))&&Qr(Ou,u))return u;return new Au(!1)}r=function(e,t){var n=arguments.length<2?Du(e):t;if(ho(n))return qo(Br(n,e));throw Su(fo(e)+" is not iterable")}(e,o)}for(s=r.next;!(l=Br(s,r)).done;){try{u=v(l.value)}catch(e){xu(r,"throw",e)}if("object"==typeof u&&u&&Qr(Ou,u))return u}return new Au(!1)},Bu=function(e,t){return void 0===e?arguments.length<2?"":t:aa(e)},Fu=!Ar((function(){var e=Error("a");return!("stack"in e)||(Object.defineProperty(e,"stack",jr(1,7)),7!==e.stack)})),Tu=Po("toStringTag"),_u=Cr.Error,Pu=[].push,ju=function(e,t){var n,r=arguments.length>2?arguments[2]:void 0,o=Qr(Nu,this);ou?n=ou(new _u(void 0),o?tu(this):Nu):(n=o?this:Sa(Nu),Jo(n,Tu,"Error")),Jo(n,"message",Bu(t,"")),Fu&&Jo(n,"stack",hu(n.stack,1)),gu(n,r);var i=[];return ku(e,Pu,{that:i}),Jo(n,"errors",i),n};ou?ou(ju,_u):Hi(ju,_u);var Nu=ju.prototype=Sa(_u.prototype,{constructor:jr(1,ju),message:jr(1,""),name:jr(1,"AggregateError")});Zi({global:!0},{AggregateError:ju});var Iu=Po("unscopables"),Lu=Array.prototype;null==Lu[Iu]&&Zo.f(Lu,Iu,{configurable:!0,value:Sa(null)});var Ru,Mu,zu,$u=function(e){Lu[Iu][e]=!0},Hu=Po("iterator"),Vu=!1;[].keys&&("next"in(zu=[].keys())?(Mu=tu(tu(zu)))!==Object.prototype&&(Ru=Mu):Vu=!0);var Uu=null==Ru||Ar((function(){var e={};return Ru[Hu].call(e)!==e}));Uu&&(Ru={}),Yr(Ru[Hu])||Ei(Ru,Hu,(function(){return this}));var Wu={IteratorPrototype:Ru,BUGGY_SAFARI_ITERATORS:Vu},Gu=Zo.f,qu=Po("toStringTag"),Ku=function(e,t,n){e&&!xo(e=n?e:e.prototype,qu)&&Gu(e,qu,{configurable:!0,value:t})},Yu=Wu.IteratorPrototype,Xu=function(){return this},Zu=wi.PROPER,Ju=wi.CONFIGURABLE,Qu=Wu.IteratorPrototype,es=Wu.BUGGY_SAFARI_ITERATORS,ts=Po("iterator"),ns=function(){return this},rs=function(e,t,n,r,o,i,a){!function(e,t,n,r){var o=t+" Iterator";e.prototype=Sa(Yu,{next:jr(+!r,n)}),Ku(e,o,!1),mu[o]=Xu}(n,t,r);var u,s,l,c=function(e){if(e===o&&g)return g;if(!es&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[ts]||p["@@iterator"]||o&&p[o],g=!es&&h||c(o),v="Array"==t&&p.entries||h;if(v&&(u=tu(v.call(new e)))!==Object.prototype&&u.next&&(tu(u)!==Qu&&(ou?ou(u,Qu):Yr(u[ts])||Ei(u,ts,ns)),Ku(u,f,!0)),Zu&&"values"==o&&h&&"values"!==h.name&&(Ju?Jo(p,"name","values"):(d=!0,g=function(){return Br(h,this)})),o)if(s={values:c("values"),keys:i?g:c("keys"),entries:c("entries")},a)for(l in s)(es||d||!(l in p))&&Ei(p,l,s[l]);else Zi({target:t,proto:!0,forced:es||d},s);return p[ts]!==g&&Ei(p,ts,g,{name:o}),mu[t]=g,s},os=vi.set,is=vi.getterFor("Array Iterator"),as=rs(Array,"Array",(function(e,t){os(this,{type:"Array Iterator",target:Kr(e),index:0,kind:t})}),(function(){var e=is(this),t=e.target,n=e.kind,r=e.index++;return!t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");mu.Arguments=mu.Array,$u("keys"),$u("values"),$u("entries");var us=Ga.charAt,ss=vi.set,ls=vi.getterFor("String Iterator");rs(String,"String",(function(e){ss(this,{type:"String Iterator",string:aa(e),index:0})}),(function(){var e,t=ls(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=us(n,r),t.index+=e.length,{value:e,done:!1})}));var cs,fs={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},ds=zo("span").classList,ps=ds&&ds.constructor&&ds.constructor.prototype,hs=ps===Object.prototype?void 0:ps,gs=Po("iterator"),vs=Po("toStringTag"),ys=as.values,ms=function(e,t){if(e){if(e[gs]!==ys)try{Jo(e,gs,ys)}catch(t){e[gs]=ys}if(e[vs]||Jo(e,vs,t),fs[t])for(var n in as)if(e[n]!==as[n])try{Jo(e,n,as[n])}catch(t){e[n]=as[n]}}};for(var bs in fs)ms(Cr[bs]&&Cr[bs].prototype,bs);if(ms(hs,"DOMTokenList"),"undefined"==typeof __webpack_require__.g){if("ActiveXObject"in window){"\n Sorry, wangEditor V5+ versions do not support IE browser.",console.error("æ±æ­ï¼wangEditor V5+ çæ¬å¼å§ï¼ä¸å¨æ¯æ IE æµè§å¨\n Sorry, wangEditor V5+ versions do not support IE browser.")}ws(),Es()}else __webpack_require__.g&&(null===(cs=__webpack_require__.g.navigator)||void 0===cs?void 0:cs.userAgent.match("QQBrowser"))&&(ws(),Es());function ws(){"undefined"==typeof globalThis&&(window.globalThis=window)}function Es(){void 0===Sr&&(window.AggregateError=function(e,t){var n=new Error(t);return n.errors=e,n})}var Ds,Ss=Array.isArray||function(e){return"Array"==B(e)},xs=function(){},Cs=[],As=M("Reflect","construct"),Os=/^\s*(?:class|function)\b/,ks=v(Os.exec),Bs=!Os.exec(xs),Fs=function(e){if(!y(e))return!1;try{return As(xs,Cs,e),!0}catch(e){return!1}},Ts=!As||m((function(){var e;return Fs(Fs.call)||!Fs(Object)||!Fs((function(){e=!0}))||e}))?function(e){if(!y(e))return!1;switch(on(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return Bs||!!ks(Os,On(e))}:Fs,_s=be("species"),Ps=a.Array,js=function(e,t){return new(function(e){var t;return Ss(e)&&(t=e.constructor,(Ts(t)&&(t===Ps||Ss(t.prototype))||I(t)&&null===(t=t[_s]))&&(t=void 0)),void 0===t?Ps:t}(e))(0===t?0:t)},Ns=be("species"),Is=be("isConcatSpreadable"),Ls=a.TypeError,Rs=q>=51||!m((function(){var e=[];return e[Is]=!1,e.concat()[0]!==e})),Ms=(Ds="concat",q>=51||!m((function(){var e=[];return(e.constructor={})[Ns]=function(){return{foo:1}},1!==e[Ds](Boolean).foo}))),zs=function(e){if(!I(e))return!1;var t=e[Is];return void 0!==t?!!t:Ss(e)};Xe({target:"Array",proto:!0,forced:!Rs||!Ms},{concat:function(e){var t,n,r,o,i,a=se(this),u=js(a,0),s=0;for(t=-1,r=arguments.length;t<r;t++)if(zs(i=-1===t?a:arguments[t])){if(s+(o=ht(i))>9007199254740991)throw Ls("Maximum allowed index exceeded");for(n=0;n<o;n++,s++)n in i&&Lt(u,s,i[n])}else{if(s>=9007199254740991)throw Ls("Maximum allowed index exceeded");Lt(u,s++,i)}return u.length=s,u}});var $s=xt.f,Hs="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],Vs={f:function(e){return Hs&&"Window"==B(e)?function(e){try{return $s(e)}catch(e){return zt(Hs)}}(e):$s(N(e))}},Us=v([].slice),Ws={f:be},Gs=Ge.f,qs=function(e){var t=L.Symbol||(L.Symbol={});ce(t,e)||Gs(t,e,{value:Ws.f(e)})},Ks=v([].push),Ys=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=se(s),g=_(h),v=Me(l,c),y=ht(g),m=0,b=f||js,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:Ks(w,d)}else switch(e){case 4:return!1;case 7:Ks(w,d)}return i?-1:r||o?o:w}},Xs={forEach:Ys(0),map:Ys(1),filter:Ys(2),some:Ys(3),every:Ys(4),find:Ys(5),findIndex:Ys(6),filterReject:Ys(7)}.forEach,Zs=Je("hidden"),Js=be("toPrimitive"),Qs=zn.set,el=zn.getterFor("Symbol"),tl=Object.prototype,nl=a.Symbol,rl=nl&&nl.prototype,ol=a.TypeError,il=a.QObject,al=M("JSON","stringify"),ul=Fe.f,sl=Ge.f,ll=Vs.f,cl=C.f,fl=v([].push),dl=ae("symbols"),pl=ae("op-symbols"),hl=ae("string-to-symbol-registry"),gl=ae("symbol-to-string-registry"),vl=ae("wks"),yl=!il||!il.prototype||!il.prototype.findChild,ml=b&&m((function(){return 7!=It(sl({},"a",{get:function(){return sl(this,"a",{value:7}).a}})).a}))?function(e,t,n){var r=ul(tl,t);r&&delete tl[t],sl(e,t,n),r&&e!==tl&&sl(tl,t,r)}:sl,bl=function(e,t){var n=dl[e]=It(rl);return Qs(n,{type:"Symbol",tag:e,description:t}),b||(n.description=t),n},wl=function(e,t,n){e===tl&&wl(pl,t,n),He(e);var r=Se(t);return He(n),ce(dl,r)?(n.enumerable?(ce(e,Zs)&&e[Zs][r]&&(e[Zs][r]=!1),n=It(n,{enumerable:A(0,!1)})):(ce(e,Zs)||sl(e,Zs,A(1,{})),e[Zs][r]=!0),ml(e,r,n)):sl(e,r,n)},El=function(e,t){He(e);var n=N(t),r=kt(n).concat(Cl(n));return Xs(r,(function(t){b&&!E(Dl,n,t)||wl(e,t,n[t])})),e},Dl=function(e){var t=Se(e),n=E(cl,this,t);return!(this===tl&&ce(dl,t)&&!ce(pl,t))&&(!(n||!ce(this,t)||!ce(dl,t)||ce(this,Zs)&&this[Zs][t])||n)},Sl=function(e,t){var n=N(e),r=Se(t);if(n!==tl||!ce(dl,r)||ce(pl,r)){var o=ul(n,r);return!o||!ce(dl,r)||ce(n,Zs)&&n[Zs][r]||(o.enumerable=!0),o}},xl=function(e){var t=ll(N(e)),n=[];return Xs(t,(function(e){ce(dl,e)||ce(yt,e)||fl(n,e)})),n},Cl=function(e){var t=e===tl,n=ll(t?pl:N(e)),r=[];return Xs(n,(function(e){!ce(dl,e)||t&&!ce(tl,e)||fl(r,dl[e])})),r};if(K||(rl=(nl=function(){if(z(rl,this))throw ol("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?gn(arguments[0]):void 0,t=he(e),n=function(e){this===tl&&E(n,pl,e),ce(this,Zs)&&ce(this[Zs],t)&&(this[Zs][t]=!1),ml(this,t,A(1,e))};return b&&yl&&ml(tl,t,{configurable:!0,set:n}),bl(t,e)}).prototype,Wn(rl,"toString",(function(){return el(this).tag})),Wn(nl,"withoutSetter",(function(e){return bl(he(e),e)})),C.f=Dl,Ge.f=wl,Fe.f=Sl,xt.f=Vs.f=xl,Ct.f=Cl,Ws.f=function(e){return bl(be(e),e)},b&&sl(rl,"description",{configurable:!0,get:function(){return el(this).description}})),Xe({global:!0,wrap:!0,forced:!K,sham:!K},{Symbol:nl}),Xs(kt(vl),(function(e){qs(e)})),Xe({target:"Symbol",stat:!0,forced:!K},{for:function(e){var t=gn(e);if(ce(hl,t))return hl[t];var n=nl(t);return hl[t]=n,gl[n]=t,n},keyFor:function(e){if(!Z(e))throw ol(e+" is not a symbol");if(ce(gl,e))return gl[e]},useSetter:function(){yl=!0},useSimple:function(){yl=!1}}),Xe({target:"Object",stat:!0,forced:!K,sham:!b},{create:function(e,t){return void 0===t?It(e):El(It(e),t)},defineProperty:wl,defineProperties:El,getOwnPropertyDescriptor:Sl}),Xe({target:"Object",stat:!0,forced:!K},{getOwnPropertyNames:xl,getOwnPropertySymbols:Cl}),Xe({target:"Object",stat:!0,forced:m((function(){Ct.f(1)}))},{getOwnPropertySymbols:function(e){return Ct.f(se(e))}}),al){var Al=!K||m((function(){var e=nl();return"[null]"!=al([e])||"{}"!=al({a:e})||"{}"!=al(Object(e))}));Xe({target:"JSON",stat:!0,forced:Al},{stringify:function(e,t,n){var r=Us(arguments),o=t;if((I(t)||void 0!==e)&&!Z(e))return Ss(t)||(t=function(e,t){if(y(o)&&(t=E(o,this,e,t)),!Z(t))return t}),r[1]=t,f(al,null,r)}})}if(!rl[Js]){var Ol=rl.valueOf;Wn(rl,Js,(function(e){return E(Ol,this)}))}Qn(nl,"Symbol"),yt[Zs]=!0,qs("asyncIterator"),qs("hasInstance"),qs("isConcatSpreadable"),qs("iterator"),qs("match"),qs("matchAll"),qs("replace"),qs("search"),qs("species"),qs("split"),qs("toPrimitive"),qs("toStringTag"),qs("unscopables"),Qn(a.JSON,"JSON",!0);var kl=L.Symbol;qs("asyncDispose"),qs("dispose"),qs("matcher"),qs("metadata"),qs("observable"),qs("patternMatch"),qs("replaceAll");var Bl=kl,Fl=Ws.f("iterator"),Tl=n((function(e){function t(n){return"function"==typeof Bl&&"symbol"==typeof Fl?(e.exports=t=function(e){return typeof e},e.exports.default=e.exports,e.exports.__esModule=!0):(e.exports=t=function(e){return e&&"function"==typeof Bl&&e.constructor===Bl&&e!==Bl.prototype?"symbol":typeof e},e.exports.default=e.exports,e.exports.__esModule=!0),t(n)}e.exports=t,e.exports.default=e.exports,e.exports.__esModule=!0})),_l=t(Tl),Pl=Uo.f,jl=Ar((function(){Pl(1)}));if(Zi({target:"Object",stat:!0,forced:!Or||jl,sham:!Or},{getOwnPropertyDescriptor:function(e,t){return Pl(Kr(e),t)}}),"object"===("undefined"==typeof __webpack_require__.g?"undefined":_l(__webpack_require__.g))){var Nl=Object.getOwnPropertyDescriptor(__webpack_require__.g,"window");__webpack_require__.g.window&&!Nl.set||(__webpack_require__.g.window=__webpack_require__.g,__webpack_require__.g.requestAnimationFrame=function(){},__webpack_require__.g.navigator={userAgent:""},__webpack_require__.g.location={hostname:"0.0.0.0",port:0,protocol:"http:"},__webpack_require__.g.btoa=function(){},__webpack_require__.g.crypto={getRandomValues:function(e){return nodeCrypto.randomFillSync(e)}}),null!=__webpack_require__.g.document&&null==__webpack_require__.g.document.getElementsByTagName&&(__webpack_require__.g.document.getElementsByTagName=function(){return[]})}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */function Il(e){return"[object Object]"===Object.prototype.toString.call(e)}function Ll(e){var t,n;return!1!==Il(e)&&(void 0===(t=e.constructor)||!1!==Il(n=t.prototype)&&!1!==n.hasOwnProperty("isPrototypeOf"))}function Rl(e){for(var t=arguments.length,n=Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];throw Error("[Immer] minified error nr: "+e+(n.length?" "+n.map((function(e){return"'"+e+"'"})).join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function Ml(e){return!!e&&!!e[xc]}function zl(e){return!!e&&(function(e){if(!e||"object"!=typeof e)return!1;var t=Object.getPrototypeOf(e);if(null===t)return!0;var n=Object.hasOwnProperty.call(t,"constructor")&&t.constructor;return n===Object||"function"==typeof n&&Function.toString.call(n)===Cc}(e)||Array.isArray(e)||!!e[Sc]||!!e.constructor[Sc]||Wl(e)||Gl(e))}function $l(e,t,n){void 0===n&&(n=!1),0===Hl(e)?(n?Object.keys:Ac)(e).forEach((function(r){n&&"symbol"==typeof r||t(r,e[r],e)})):e.forEach((function(n,r){return t(r,n,e)}))}function Hl(e){var t=e[xc];return t?t.i>3?t.i-4:t.i:Array.isArray(e)?1:Wl(e)?2:Gl(e)?3:0}function Vl(e,t){return 2===Hl(e)?e.has(t):Object.prototype.hasOwnProperty.call(e,t)}function Ul(e,t,n){var r=Hl(e);2===r?e.set(t,n):3===r?(e.delete(t),e.add(n)):e[t]=n}function Wl(e){return bc&&e instanceof Map}function Gl(e){return wc&&e instanceof Set}function ql(e){return e.o||e.t}function Kl(e){if(Array.isArray(e))return Array.prototype.slice.call(e);var t=Oc(e);delete t[xc];for(var n=Ac(t),r=0;r<n.length;r++){var o=n[r],i=t[o];!1===i.writable&&(i.writable=!0,i.configurable=!0),(i.get||i.set)&&(t[o]={configurable:!0,writable:!0,enumerable:i.enumerable,value:e[o]})}return Object.create(Object.getPrototypeOf(e),t)}function Yl(e,t){return void 0===t&&(t=!1),Zl(e)||Ml(e)||!zl(e)||(Hl(e)>1&&(e.set=e.add=e.clear=e.delete=Xl),Object.freeze(e),t&&$l(e,(function(e,t){return Yl(t,!0)}),!0)),e}function Xl(){Rl(2)}function Zl(e){return null==e||"object"!=typeof e||Object.isFrozen(e)}function Jl(e){var t=kc[e];return t||Rl(18,e),t}function Ql(){return yc}function ec(e,t){t&&(Jl("Patches"),e.u=[],e.s=[],e.v=t)}function tc(e){nc(e),e.p.forEach(oc),e.p=null}function nc(e){e===yc&&(yc=e.l)}function rc(e){return yc={p:[],l:yc,h:e,m:!0,_:0}}function oc(e){var t=e[xc];0===t.i||1===t.i?t.j():t.O=!0}function ic(e,t){t._=t.p.length;var n=t.p[0],r=void 0!==e&&e!==n;return t.h.g||Jl("ES5").S(t,e,r),r?(n[xc].P&&(tc(t),Rl(4)),zl(e)&&(e=ac(t,e),t.l||sc(t,e)),t.u&&Jl("Patches").M(n[xc],e,t.u,t.s)):e=ac(t,n,[]),tc(t),t.u&&t.v(t.u,t.s),e!==Dc?e:void 0}function ac(e,t,n){if(Zl(t))return t;var r=t[xc];if(!r)return $l(t,(function(o,i){return uc(e,r,t,o,i,n)}),!0),t;if(r.A!==e)return t;if(!r.P)return sc(e,r.t,!0),r.t;if(!r.I){r.I=!0,r.A._--;var o=4===r.i||5===r.i?r.o=Kl(r.k):r.o;$l(3===r.i?new Set(o):o,(function(t,i){return uc(e,r,o,t,i,n)})),sc(e,o,!1),n&&e.u&&Jl("Patches").R(r,n,e.u,e.s)}return r.o}function uc(e,t,n,r,o,i){if(Ml(o)){var a=ac(e,o,i&&t&&3!==t.i&&!Vl(t.D,r)?i.concat(r):void 0);if(Ul(n,r,a),!Ml(a))return;e.m=!1}if(zl(o)&&!Zl(o)){if(!e.h.F&&e._<1)return;ac(e,o),t&&t.A.l||sc(e,o)}}function sc(e,t,n){void 0===n&&(n=!1),e.h.F&&e.m&&Yl(t,n)}function lc(e,t){var n=e[xc];return(n?ql(n):e)[t]}function cc(e,t){if(t in e)for(var n=Object.getPrototypeOf(e);n;){var r=Object.getOwnPropertyDescriptor(n,t);if(r)return r;n=Object.getPrototypeOf(n)}}function fc(e){e.P||(e.P=!0,e.l&&fc(e.l))}function dc(e){e.o||(e.o=Kl(e.t))}function pc(e,t,n){var r=Wl(t)?Jl("MapSet").N(t,n):Gl(t)?Jl("MapSet").T(t,n):e.g?function(e,t){var n=Array.isArray(e),r={i:n?1:0,A:t?t.A:Ql(),P:!1,I:!1,D:{},l:t,t:e,k:null,o:null,j:null,C:!1},o=r,i=Bc;n&&(o=[r],i=Fc);var a=Proxy.revocable(o,i),u=a.revoke,s=a.proxy;return r.k=s,r.j=u,s}(t,n):Jl("ES5").J(t,n);return(n?n.A:Ql()).p.push(r),r}function hc(e){return Ml(e)||Rl(22,e),function e(t){if(!zl(t))return t;var n,r=t[xc],o=Hl(t);if(r){if(!r.P&&(r.i<4||!Jl("ES5").K(r)))return r.t;r.I=!0,n=gc(t,o),r.I=!1}else n=gc(t,o);return $l(n,(function(t,o){r&&function(e,t){return 2===Hl(e)?e.get(t):e[t]}(r.t,t)===o||Ul(n,t,e(o))})),3===o?new Set(n):n}(e)}function gc(e,t){switch(t){case 2:return new Map(e);case 3:return Array.from(e)}return Kl(e)}var vc,yc,mc="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),bc="undefined"!=typeof Map,wc="undefined"!=typeof Set,Ec="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,Dc=mc?Symbol.for("immer-nothing"):((vc={})["immer-nothing"]=!0,vc),Sc=mc?Symbol.for("immer-draftable"):"__$immer_draftable",xc=mc?Symbol.for("immer-state"):"__$immer_state",Cc=""+Object.prototype.constructor,Ac="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:Object.getOwnPropertyNames,Oc=Object.getOwnPropertyDescriptors||function(e){var t={};return Ac(e).forEach((function(n){t[n]=Object.getOwnPropertyDescriptor(e,n)})),t},kc={},Bc={get:function(e,t){if(t===xc)return e;var n=ql(e);if(!Vl(n,t))return function(e,t,n){var r,o=cc(t,n);return o?"value"in o?o.value:null===(r=o.get)||void 0===r?void 0:r.call(e.k):void 0}(e,n,t);var r=n[t];return e.I||!zl(r)?r:r===lc(e.t,t)?(dc(e),e.o[t]=pc(e.A.h,r,e)):r},has:function(e,t){return t in ql(e)},ownKeys:function(e){return Reflect.ownKeys(ql(e))},set:function(e,t,n){var r=cc(ql(e),t);if(null==r?void 0:r.set)return r.set.call(e.k,n),!0;if(!e.P){var o=lc(ql(e),t),i=null==o?void 0:o[xc];if(i&&i.t===n)return e.o[t]=n,e.D[t]=!1,!0;if(function(e,t){return e===t?0!==e||1/e==1/t:e!=e&&t!=t}(n,o)&&(void 0!==n||Vl(e.t,t)))return!0;dc(e),fc(e)}return e.o[t]===n&&"number"!=typeof n&&(void 0!==n||t in e.o)||(e.o[t]=n,e.D[t]=!0,!0)},deleteProperty:function(e,t){return void 0!==lc(e.t,t)||t in e.t?(e.D[t]=!1,dc(e),fc(e)):delete e.D[t],e.o&&delete e.o[t],!0},getOwnPropertyDescriptor:function(e,t){var n=ql(e),r=Reflect.getOwnPropertyDescriptor(n,t);return r?{writable:!0,configurable:1!==e.i||"length"!==t,enumerable:r.enumerable,value:n[t]}:r},defineProperty:function(){Rl(11)},getPrototypeOf:function(e){return Object.getPrototypeOf(e.t)},setPrototypeOf:function(){Rl(12)}},Fc={};$l(Bc,(function(e,t){Fc[e]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),Fc.deleteProperty=function(e,t){return Bc.deleteProperty.call(this,e[0],t)},Fc.set=function(e,t,n){return Bc.set.call(this,e[0],t,n,e[0])};var Tc=function(){function e(e){var t=this;this.g=Ec,this.F=!0,this.produce=function(e,n,r){if("function"==typeof e&&"function"!=typeof n){var o=n;n=e;var i=t;return function(e){var t=this;void 0===e&&(e=o);for(var r=arguments.length,a=Array(r>1?r-1:0),u=1;u<r;u++)a[u-1]=arguments[u];return i.produce(e,(function(e){var r;return(r=n).call.apply(r,[t,e].concat(a))}))}}var a;if("function"!=typeof n&&Rl(6),void 0!==r&&"function"!=typeof r&&Rl(7),zl(e)){var u=rc(t),s=pc(t,e,void 0),l=!0;try{a=n(s),l=!1}finally{l?tc(u):nc(u)}return"undefined"!=typeof Promise&&a instanceof Promise?a.then((function(e){return ec(u,r),ic(e,u)}),(function(e){throw tc(u),e})):(ec(u,r),ic(a,u))}if(!e||"object"!=typeof e){if((a=n(e))===Dc)return;return void 0===a&&(a=e),t.F&&Yl(a,!0),a}Rl(21,e)},this.produceWithPatches=function(e,n){return"function"==typeof e?function(n){for(var r=arguments.length,o=Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];return t.produceWithPatches(n,(function(t){return e.apply(void 0,[t].concat(o))}))}:[t.produce(e,n,(function(e,t){r=e,o=t})),r,o];// removed by dead control flow
{ var r, o; }},"boolean"==typeof(null==e?void 0:e.useProxies)&&this.setUseProxies(e.useProxies),"boolean"==typeof(null==e?void 0:e.autoFreeze)&&this.setAutoFreeze(e.autoFreeze)}var t=e.prototype;return t.createDraft=function(e){zl(e)||Rl(8),Ml(e)&&(e=hc(e));var t=rc(this),n=pc(this,e,void 0);return n[xc].C=!0,nc(t),n},t.finishDraft=function(e,t){var n=(e&&e[xc]).A;return ec(n,t),ic(void 0,n)},t.setAutoFreeze=function(e){this.F=e},t.setUseProxies=function(e){e&&!Ec&&Rl(20),this.g=e},t.applyPatches=function(e,t){var n;for(n=t.length-1;n>=0;n--){var r=t[n];if(0===r.path.length&&"replace"===r.op){e=r.value;break}}n>-1&&(t=t.slice(n+1));var o=Jl("Patches").$;return Ml(e)?o(e,t):this.produce(e,(function(e){return o(e,t)}))},e}(),_c=new Tc,Pc=_c.produce;_c.produceWithPatches.bind(_c),_c.setAutoFreeze.bind(_c),_c.setUseProxies.bind(_c),_c.applyPatches.bind(_c);var jc=_c.createDraft.bind(_c),Nc=_c.finishDraft.bind(_c);function Ic(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var Lc=new WeakMap,Rc=new WeakMap,Mc=new WeakMap,zc=new WeakMap,$c=new WeakMap,Hc=new WeakMap;function Vc(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Uc(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Vc(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Vc(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Wc=()=>{var e={children:[],operations:[],selection:null,marks:null,isInline:()=>!1,isVoid:()=>!1,onChange:()=>{},apply:t=>{for(var n of Bf.pathRefs(e))zf.transform(n,t);for(var r of Bf.pointRefs(e))Uf.transform(r,t);for(var o of Bf.rangeRefs(e))Kf.transform(o,t);var i=new Set,a=[],u=e=>{if(e){var t=e.join(",");i.has(t)||(i.add(t),a.push(e))}},s=Lc.get(e)||[],l=Gc(t);for(var c of s){u(Mf.transform(c,t))}for(var f of l)u(f);Lc.set(e,a),md.transform(e,t),e.operations.push(t),Bf.normalize(e),"set_selection"===t.type&&(e.marks=null),Rc.get(e)||(Rc.set(e,!0),Promise.resolve().then((()=>{Rc.set(e,!1),e.onChange(),e.operations=[]})))},addMark:(t,n)=>{var{selection:r}=e;if(r)if(qf.isExpanded(r))md.setNodes(e,{[t]:n},{match:ed.isText,split:!0});else{var o=Uc(Uc({},Bf.marks(e)||{}),{},{[t]:n});e.marks=o,Rc.get(e)||e.onChange()}},deleteBackward:t=>{var{selection:n}=e;n&&qf.isCollapsed(n)&&md.delete(e,{unit:t,reverse:!0})},deleteForward:t=>{var{selection:n}=e;n&&qf.isCollapsed(n)&&md.delete(e,{unit:t})},deleteFragment:t=>{var{selection:n}=e;n&&qf.isExpanded(n)&&md.delete(e,{reverse:"backward"===t})},getFragment:()=>{var{selection:t}=e;return t?Nf.fragment(e,t):[]},insertBreak:()=>{md.splitNodes(e,{always:!0})},insertFragment:t=>{md.insertFragment(e,t)},insertNode:t=>{md.insertNodes(e,t)},insertText:t=>{var{selection:n,marks:r}=e;if(n){if(r){var o=Uc({text:t},r);md.insertNodes(e,o)}else md.insertText(e,t);e.marks=null}},normalizeNode:t=>{var[n,r]=t;if(!ed.isText(n))if(Sf.isElement(n)&&0===n.children.length){md.insertNodes(e,{text:""},{at:r.concat(0),voids:!0})}else for(var o=!Bf.isEditor(n)&&(Sf.isElement(n)&&(e.isInline(n)||0===n.children.length||ed.isText(n.children[0])||e.isInline(n.children[0]))),i=0,a=0;a<n.children.length;a++,i++){var u=Nf.get(e,r);if(!ed.isText(u)){var s=n.children[a],l=u.children[i-1],c=a===n.children.length-1;if((ed.isText(s)||Sf.isElement(s)&&e.isInline(s))!==o)md.removeNodes(e,{at:r.concat(i),voids:!0}),i--;else if(Sf.isElement(s)){if(e.isInline(s))if(null!=l&&ed.isText(l)){if(c){md.insertNodes(e,{text:""},{at:r.concat(i+1),voids:!0}),i++}}else{md.insertNodes(e,{text:""},{at:r.concat(i),voids:!0}),i++}}else null!=l&&ed.isText(l)&&(ed.equals(s,l,{loose:!0})?(md.mergeNodes(e,{at:r.concat(i),voids:!0}),i--):""===l.text?(md.removeNodes(e,{at:r.concat(i-1),voids:!0}),i--):""===s.text&&(md.removeNodes(e,{at:r.concat(i),voids:!0}),i--))}}},removeMark:t=>{var{selection:n}=e;if(n)if(qf.isExpanded(n))md.unsetNodes(e,t,{match:ed.isText,split:!0});else{var r=Uc({},Bf.marks(e)||{});delete r[t],e.marks=r,Rc.get(e)||e.onChange()}}};return e},Gc=e=>{switch(e.type){case"insert_text":case"remove_text":case"set_node":var{path:t}=e;return Mf.levels(t);case"insert_node":var{node:n,path:r}=e,o=Mf.levels(r),i=ed.isText(n)?[]:Array.from(Nf.nodes(n),(e=>{var[,t]=e;return r.concat(t)}));return[...o,...i];case"merge_node":var{path:a}=e;return[...Mf.ancestors(a),Mf.previous(a)];case"move_node":var{path:u,newPath:s}=e;if(Mf.equals(u,s))return[];var l=[],c=[];for(var f of Mf.ancestors(u)){var d=Mf.transform(f,e);l.push(d)}for(var p of Mf.ancestors(s)){var h=Mf.transform(p,e);c.push(h)}var g=c[c.length-1],v=s[s.length-1],y=g.concat(v);return[...l,...c,y];case"remove_node":var{path:m}=e;return[...Mf.ancestors(m)];case"split_node":var{path:b}=e;return[...Mf.levels(b),Mf.next(b)];default:return[]}};function qc(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var Kc,Yc=function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=!t,r=t?tf(e):e,o=Kc.None,i=Kc.None,a=0,u=null;for(var s of r){var l=s.codePointAt(0);if(!l)break;var c=hf(s,l);if([o,i]=n?[i,c]:[c,o],gf(o,Kc.ZWJ)&&gf(i,Kc.ExtPict)&&!bf(n?e.substring(0,a):e.substring(0,e.length-a)))break;if(gf(o,Kc.RI)&&gf(i,Kc.RI)&&!(u=null!==u?!u:!!n||Ef(e.substring(0,e.length-a))))break;if(o!==Kc.None&&i!==Kc.None&&yf(o,i))break;a+=s.length}return a||1},Xc=/\s/,Zc=/[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/,Jc=/['\u2018\u2019]/,Qc=(e,t,n)=>{if(n){var r=e.length-t;return[e.slice(r,e.length),e.slice(0,r)]}return[e.slice(0,t),e.slice(t)]},ef=function e(t,n){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(Xc.test(t))return!1;if(Jc.test(t)){var o=Yc(n,r),[i,a]=Qc(n,o,r);if(e(i,a,r))return!0}return!Zc.test(t)},tf=function*(e){for(var t=e.length-1,n=0;n<e.length;n++){var r=e.charAt(t-n);if(rf(r.charCodeAt(0))){var o=e.charAt(t-n-1);if(nf(o.charCodeAt(0))){yield o+r,n++;continue}}yield r}},nf=e=>e>=55296&&e<=56319,rf=e=>e>=56320&&e<=57343;!function(e){e[e.None=0]="None",e[e.Extend=1]="Extend",e[e.ZWJ=2]="ZWJ",e[e.RI=4]="RI",e[e.Prepend=8]="Prepend",e[e.SpacingMark=16]="SpacingMark",e[e.L=32]="L",e[e.V=64]="V",e[e.T=128]="T",e[e.LV=256]="LV",e[e.LVT=512]="LVT",e[e.ExtPict=1024]="ExtPict",e[e.Any=2048]="Any"}(Kc||(Kc={}));var of=/^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/,af=/^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/,uf=/^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/,sf=/^[\u1100-\u115F\uA960-\uA97C]$/,lf=/^[\u1160-\u11A7\uD7B0-\uD7C6]$/,cf=/^[\u11A8-\u11FF\uD7CB-\uD7FB]$/,ff=/^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/,df=/^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/,pf=/^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/,hf=(e,t)=>{var n=Kc.Any;return-1!==e.search(of)&&(n|=Kc.Extend),8205===t&&(n|=Kc.ZWJ),t>=127462&&t<=127487&&(n|=Kc.RI),-1!==e.search(af)&&(n|=Kc.Prepend),-1!==e.search(uf)&&(n|=Kc.SpacingMark),-1!==e.search(sf)&&(n|=Kc.L),-1!==e.search(lf)&&(n|=Kc.V),-1!==e.search(cf)&&(n|=Kc.T),-1!==e.search(ff)&&(n|=Kc.LV),-1!==e.search(df)&&(n|=Kc.LVT),-1!==e.search(pf)&&(n|=Kc.ExtPict),n};function gf(e,t){return 0!=(e&t)}var vf=[[Kc.L,Kc.L|Kc.V|Kc.LV|Kc.LVT],[Kc.LV|Kc.V,Kc.V|Kc.T],[Kc.LVT|Kc.T,Kc.T],[Kc.Any,Kc.Extend|Kc.ZWJ],[Kc.Any,Kc.SpacingMark],[Kc.Prepend,Kc.Any],[Kc.ZWJ,Kc.ExtPict],[Kc.RI,Kc.RI]];function yf(e,t){return-1===vf.findIndex((n=>gf(e,n[0])&&gf(t,n[1])))}var mf=/(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/,bf=e=>-1!==e.search(mf),wf=/(?:\uD83C[\uDDE6-\uDDFF])+$/g,Ef=e=>{var t=e.match(wf);return null!==t&&t[0].length/2%2==1},Df=e=>Ll(e)&&Nf.isNodeList(e.children)&&!Bf.isEditor(e),Sf={isAncestor:e=>Ll(e)&&Nf.isNodeList(e.children),isElement:Df,isElementList:e=>Array.isArray(e)&&e.every((e=>Sf.isElement(e))),isElementProps:e=>void 0!==e.children,isElementType:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"type";return Df(e)&&e[n]===t},matches(e,t){for(var n in t)if("children"!==n&&e[n]!==t[n])return!1;return!0}},xf=["text"],Cf=["text"];function Af(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Of(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Af(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Af(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var kf=new WeakMap,Bf={above(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{voids:n=!1,mode:r="lowest",at:o=e.selection,match:i}=t;if(o){var a=Bf.path(e,o),u="lowest"===r;for(var[s,l]of Bf.levels(e,{at:a,voids:n,match:i,reverse:u}))if(!ed.isText(s)&&!Mf.equals(a,l))return[s,l]}},addMark(e,t,n){e.addMark(t,n)},after(e,t){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o={anchor:Bf.point(e,t,{edge:"end"}),focus:Bf.end(e,[])},{distance:i=1}=r,a=0;for(var u of Bf.positions(e,Of(Of({},r),{},{at:o}))){if(a>i)break;0!==a&&(n=u),a++}return n},before(e,t){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o={anchor:Bf.start(e,[]),focus:Bf.point(e,t,{edge:"start"})},{distance:i=1}=r,a=0;for(var u of Bf.positions(e,Of(Of({},r),{},{at:o,reverse:!0}))){if(a>i)break;0!==a&&(n=u),a++}return n},deleteBackward(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{unit:n="character"}=t;e.deleteBackward(n)},deleteForward(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{unit:n="character"}=t;e.deleteForward(n)},deleteFragment(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{direction:n="forward"}=t;e.deleteFragment(n)},edges:(e,t)=>[Bf.start(e,t),Bf.end(e,t)],end:(e,t)=>Bf.point(e,t,{edge:"end"}),first(e,t){var n=Bf.path(e,t,{edge:"start"});return Bf.node(e,n)},fragment(e,t){var n=Bf.range(e,t);return Nf.fragment(e,n)},hasBlocks:(e,t)=>t.children.some((t=>Bf.isBlock(e,t))),hasInlines:(e,t)=>t.children.some((t=>ed.isText(t)||Bf.isInline(e,t))),hasTexts:(e,t)=>t.children.every((e=>ed.isText(e))),insertBreak(e){e.insertBreak()},insertFragment(e,t){e.insertFragment(t)},insertNode(e,t){e.insertNode(t)},insertText(e,t){e.insertText(t)},isBlock:(e,t)=>Sf.isElement(t)&&!e.isInline(t),isEditor(e){if(!Ll(e))return!1;var t=kf.get(e);if(void 0!==t)return t;var n="function"==typeof e.addMark&&"function"==typeof e.apply&&"function"==typeof e.deleteBackward&&"function"==typeof e.deleteForward&&"function"==typeof e.deleteFragment&&"function"==typeof e.insertBreak&&"function"==typeof e.insertFragment&&"function"==typeof e.insertNode&&"function"==typeof e.insertText&&"function"==typeof e.isInline&&"function"==typeof e.isVoid&&"function"==typeof e.normalizeNode&&"function"==typeof e.onChange&&"function"==typeof e.removeMark&&(null===e.marks||Ll(e.marks))&&(null===e.selection||qf.isRange(e.selection))&&Nf.isNodeList(e.children)&&Rf.isOperationList(e.operations);return kf.set(e,n),n},isEnd(e,t,n){var r=Bf.end(e,n);return Vf.equals(t,r)},isEdge:(e,t,n)=>Bf.isStart(e,t,n)||Bf.isEnd(e,t,n),isEmpty(e,t){var{children:n}=t,[r]=n;return 0===n.length||1===n.length&&ed.isText(r)&&""===r.text&&!e.isVoid(t)},isInline:(e,t)=>Sf.isElement(t)&&e.isInline(t),isNormalizing(e){var t=Mc.get(e);return void 0===t||t},isStart(e,t,n){if(0!==t.offset)return!1;var r=Bf.start(e,n);return Vf.equals(t,r)},isVoid:(e,t)=>Sf.isElement(t)&&e.isVoid(t),last(e,t){var n=Bf.path(e,t,{edge:"end"});return Bf.node(e,n)},leaf(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=Bf.path(e,t,n);return[Nf.leaf(e,r),r]},*levels(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{at:n=e.selection,reverse:r=!1,voids:o=!1}=t,{match:i}=t;if(null==i&&(i=()=>!0),n){var a=[],u=Bf.path(e,n);for(var[s,l]of Nf.levels(e,u))if(i(s,l)&&(a.push([s,l]),!o&&Bf.isVoid(e,s)))break;r&&a.reverse(),yield*a}},marks(e){var{marks:t,selection:n}=e;if(!n)return null;if(t)return t;if(qf.isExpanded(n)){var[r]=Bf.nodes(e,{match:ed.isText});if(r){var[o]=r;return qc(o,xf)}return{}}var{anchor:i}=n,{path:a}=i,[u]=Bf.leaf(e,a);if(0===i.offset){var s=Bf.previous(e,{at:a,match:ed.isText}),l=Bf.above(e,{match:t=>Bf.isBlock(e,t)});if(s&&l){var[c,f]=s,[,d]=l;Mf.isAncestor(d,f)&&(u=c)}}return qc(u,Cf)},next(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{mode:n="lowest",voids:r=!1}=t,{match:o,at:i=e.selection}=t;if(i){var a=Bf.after(e,i,{voids:r});if(a){var[,u]=Bf.last(e,[]),s=[a.path,u];if(Mf.isPath(i)&&0===i.length)throw new Error("Cannot get the next node from the root node!");if(null==o)if(Mf.isPath(i)){var[l]=Bf.parent(e,i);o=e=>l.children.includes(e)}else o=()=>!0;var[c]=Bf.nodes(e,{at:s,match:o,mode:n,voids:r});return c}}},node(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=Bf.path(e,t,n);return[Nf.get(e,r),r]},*nodes(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{at:n=e.selection,mode:r="all",universal:o=!1,reverse:i=!1,voids:a=!1}=t,{match:u}=t;if(u||(u=()=>!0),n){var s,l;if(Tf.isSpan(n))s=n[0],l=n[1];else{var c=Bf.path(e,n,{edge:"start"}),f=Bf.path(e,n,{edge:"end"});s=i?f:c,l=i?c:f}var d,p=Nf.nodes(e,{reverse:i,from:s,to:l,pass:t=>{var[n]=t;return!a&&Bf.isVoid(e,n)}}),h=[];for(var[g,v]of p){var y=d&&0===Mf.compare(v,d[1]);if("highest"!==r||!y)if(u(g,v))if("lowest"===r&&y)d=[g,v];else{var m="lowest"===r?d:[g,v];m&&(o?h.push(m):yield m),d=[g,v]}else if(o&&!y&&ed.isText(g))return}"lowest"===r&&d&&(o?h.push(d):yield d),o&&(yield*h)}},normalize(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{force:n=!1}=t,r=e=>Lc.get(e)||[];if(Bf.isNormalizing(e)){if(n){var o=Array.from(Nf.nodes(e),(e=>{var[,t]=e;return t}));Lc.set(e,o)}0!==r(e).length&&Bf.withoutNormalizing(e,(()=>{for(var t of r(e))if(Nf.has(e,t)){var n=Bf.node(e,t),[o,i]=n;Sf.isElement(o)&&0===o.children.length&&e.normalizeNode(n)}for(var a=42*r(e).length,u=0;0!==r(e).length;){if(u>a)throw new Error("\n            Could not completely normalize the editor after ".concat(a," iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));var s=r(e).pop();if(Nf.has(e,s)){var l=Bf.node(e,s);e.normalizeNode(l)}u++}}))}},parent(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=Bf.path(e,t,n),o=Mf.parent(r);return Bf.node(e,o)},path(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{depth:r,edge:o}=n;if(Mf.isPath(t))if("start"===o){var[,i]=Nf.first(e,t);t=i}else if("end"===o){var[,a]=Nf.last(e,t);t=a}return qf.isRange(t)&&(t="start"===o?qf.start(t):"end"===o?qf.end(t):Mf.common(t.anchor.path,t.focus.path)),Vf.isPoint(t)&&(t=t.path),null!=r&&(t=t.slice(0,r)),t},hasPath:(e,t)=>Nf.has(e,t),pathRef(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{affinity:r="forward"}=n,o={current:t,affinity:r,unref(){var{current:t}=o;return Bf.pathRefs(e).delete(o),o.current=null,t}};return Bf.pathRefs(e).add(o),o},pathRefs(e){var t=zc.get(e);return t||(t=new Set,zc.set(e,t)),t},point(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{edge:r="start"}=n;if(Mf.isPath(t)){var o;if("end"===r){var[,i]=Nf.last(e,t);o=i}else{var[,a]=Nf.first(e,t);o=a}var u=Nf.get(e,o);if(!ed.isText(u))throw new Error("Cannot get the ".concat(r," point in the node at path [").concat(t,"] because it has no ").concat(r," text node."));return{path:o,offset:"end"===r?u.text.length:0}}if(qf.isRange(t)){var[s,l]=qf.edges(t);return"start"===r?s:l}return t},pointRef(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{affinity:r="forward"}=n,o={current:t,affinity:r,unref(){var{current:t}=o;return Bf.pointRefs(e).delete(o),o.current=null,t}};return Bf.pointRefs(e).add(o),o},pointRefs(e){var t=$c.get(e);return t||(t=new Set,$c.set(e,t)),t},*positions(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{at:n=e.selection,unit:r="offset",reverse:o=!1,voids:i=!1}=t;if(n){var a=Bf.range(e,n),[u,s]=qf.edges(a),l=o?s:u,c=!1,f="",d=0,p=0,h=0;for(var[g,v]of Bf.nodes(e,{at:n,reverse:o,voids:i})){if(Sf.isElement(g)){if(!i&&e.isVoid(g)){yield Bf.start(e,v);continue}if(e.isInline(g))continue;if(Bf.hasInlines(e,g)){var y=Mf.isAncestor(v,s.path)?s:Bf.end(e,v),m=Mf.isAncestor(v,u.path)?u:Bf.start(e,v);f=Bf.string(e,{anchor:m,focus:y},{voids:i}),c=!0}}if(ed.isText(g)){var b=Mf.equals(v,l.path);for(b?(p=o?l.offset:g.text.length-l.offset,h=l.offset):(p=g.text.length,h=o?p:0),(b||c||"offset"===r)&&(yield{path:v,offset:h},c=!1);;){if(0===d){if(""===f)break;d=w(f,r,o),f=Qc(f,d,o)[1]}if(h=o?h-d:h+d,(p-=d)<0){d=-p;break}d=0,yield{path:v,offset:h}}}}}function w(e,t,n){return"character"===t?Yc(e,n):"word"===t?function(e){for(var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=0,r=!1;e.length>0;){var o=Yc(e,t),[i,a]=Qc(e,o,t);if(ef(i,a,t))r=!0,n+=o;else{if(r)break;n+=o}e=a}return n}(e,n):"line"===t||"block"===t?e.length:1}},previous(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{mode:n="lowest",voids:r=!1}=t,{match:o,at:i=e.selection}=t;if(i){var a=Bf.before(e,i,{voids:r});if(a){var[,u]=Bf.first(e,[]),s=[a.path,u];if(Mf.isPath(i)&&0===i.length)throw new Error("Cannot get the previous node from the root node!");if(null==o)if(Mf.isPath(i)){var[l]=Bf.parent(e,i);o=e=>l.children.includes(e)}else o=()=>!0;var[c]=Bf.nodes(e,{reverse:!0,at:s,match:o,mode:n,voids:r});return c}}},range:(e,t,n)=>qf.isRange(t)&&!n?t:{anchor:Bf.start(e,t),focus:Bf.end(e,n||t)},rangeRef(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{affinity:r="forward"}=n,o={current:t,affinity:r,unref(){var{current:t}=o;return Bf.rangeRefs(e).delete(o),o.current=null,t}};return Bf.rangeRefs(e).add(o),o},rangeRefs(e){var t=Hc.get(e);return t||(t=new Set,Hc.set(e,t)),t},removeMark(e,t){e.removeMark(t)},setNormalizing(e,t){Mc.set(e,t)},start:(e,t)=>Bf.point(e,t,{edge:"start"}),string(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{voids:r=!1}=n,o=Bf.range(e,t),[i,a]=qf.edges(o),u="";for(var[s,l]of Bf.nodes(e,{at:o,match:ed.isText,voids:r})){var c=s.text;Mf.equals(l,a.path)&&(c=c.slice(0,a.offset)),Mf.equals(l,i.path)&&(c=c.slice(i.offset)),u+=c}return u},unhangRange(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{voids:r=!1}=n,[o,i]=qf.edges(t);if(0!==o.offset||0!==i.offset||qf.isCollapsed(t))return t;var a=Bf.above(e,{at:i,match:t=>Bf.isBlock(e,t)}),u=a?a[1]:[],s={anchor:Bf.start(e,[]),focus:i},l=!0;for(var[c,f]of Bf.nodes(e,{at:s,match:ed.isText,reverse:!0,voids:r}))if(l)l=!1;else if(""!==c.text||Mf.isBefore(f,u)){i={path:f,offset:c.text.length};break}return{anchor:o,focus:i}},void(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Bf.above(e,Of(Of({},t),{},{match:t=>Bf.isVoid(e,t)}))},withoutNormalizing(e,t){var n=Bf.isNormalizing(e);Bf.setNormalizing(e,!1);try{t()}finally{Bf.setNormalizing(e,n)}Bf.normalize(e)}},Ff={isLocation:e=>Mf.isPath(e)||Vf.isPoint(e)||qf.isRange(e)},Tf={isSpan:e=>Array.isArray(e)&&2===e.length&&e.every(Mf.isPath)},_f=["children"],Pf=["text"],jf=new WeakMap,Nf={ancestor(e,t){var n=Nf.get(e,t);if(ed.isText(n))throw new Error("Cannot get the ancestor node at path [".concat(t,"] because it refers to a text node instead: ").concat(n));return n},*ancestors(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(var r of Mf.ancestors(t,n)){var o=[Nf.ancestor(e,r),r];yield o}},child(e,t){if(ed.isText(e))throw new Error("Cannot get the child of a text node: ".concat(JSON.stringify(e)));var n=e.children[t];if(null==n)throw new Error("Cannot get child at index `".concat(t,"` in node: ").concat(JSON.stringify(e)));return n},*children(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{reverse:r=!1}=n,o=Nf.ancestor(e,t),{children:i}=o,a=r?i.length-1:0;r?a>=0:a<i.length;){var u=Nf.child(o,a),s=t.concat(a);yield[u,s],a=r?a-1:a+1}},common(e,t,n){var r=Mf.common(t,n);return[Nf.get(e,r),r]},descendant(e,t){var n=Nf.get(e,t);if(Bf.isEditor(n))throw new Error("Cannot get the descendant node at path [".concat(t,"] because it refers to the root editor node instead: ").concat(n));return n},*descendants(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(var[n,r]of Nf.nodes(e,t))0!==r.length&&(yield[n,r])},*elements(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(var[n,r]of Nf.nodes(e,t))Sf.isElement(n)&&(yield[n,r])},extractProps:e=>Sf.isAncestor(e)?qc(e,_f):qc(e,Pf),first(e,t){for(var n=t.slice(),r=Nf.get(e,n);r&&!ed.isText(r)&&0!==r.children.length;)r=r.children[0],n.push(0);return[r,n]},fragment(e,t){if(ed.isText(e))throw new Error("Cannot get a fragment starting from a root text node: ".concat(JSON.stringify(e)));var n=Pc({children:e.children},(e=>{var[n,r]=qf.edges(t),o=Nf.nodes(e,{reverse:!0,pass:e=>{var[,n]=e;return!qf.includes(t,n)}});for(var[,i]of o){if(!qf.includes(t,i)){var a=Nf.parent(e,i),u=i[i.length-1];a.children.splice(u,1)}if(Mf.equals(i,r.path)){var s=Nf.leaf(e,i);s.text=s.text.slice(0,r.offset)}if(Mf.equals(i,n.path)){var l=Nf.leaf(e,i);l.text=l.text.slice(n.offset)}}Bf.isEditor(e)&&(e.selection=null)}));return n.children},get(e,t){for(var n=e,r=0;r<t.length;r++){var o=t[r];if(ed.isText(n)||!n.children[o])throw new Error("Cannot find a descendant at path [".concat(t,"] in node: ").concat(JSON.stringify(e)));n=n.children[o]}return n},has(e,t){for(var n=e,r=0;r<t.length;r++){var o=t[r];if(ed.isText(n)||!n.children[o])return!1;n=n.children[o]}return!0},isNode:e=>ed.isText(e)||Sf.isElement(e)||Bf.isEditor(e),isNodeList(e){if(!Array.isArray(e))return!1;var t=jf.get(e);if(void 0!==t)return t;var n=e.every((e=>Nf.isNode(e)));return jf.set(e,n),n},last(e,t){for(var n=t.slice(),r=Nf.get(e,n);r&&!ed.isText(r)&&0!==r.children.length;){var o=r.children.length-1;r=r.children[o],n.push(o)}return[r,n]},leaf(e,t){var n=Nf.get(e,t);if(!ed.isText(n))throw new Error("Cannot get the leaf node at path [".concat(t,"] because it refers to a non-leaf node: ").concat(n));return n},*levels(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(var r of Mf.levels(t,n)){var o=Nf.get(e,r);yield[o,r]}},matches:(e,t)=>Sf.isElement(e)&&Sf.isElementProps(t)&&Sf.matches(e,t)||ed.isText(e)&&ed.isTextProps(t)&&ed.matches(e,t),*nodes(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{pass:n,reverse:r=!1}=t,{from:o=[],to:i}=t,a=new Set,u=[],s=e;!i||!(r?Mf.isBefore(u,i):Mf.isAfter(u,i));)if(a.has(s)||(yield[s,u]),a.has(s)||ed.isText(s)||0===s.children.length||null!=n&&!1!==n([s,u])){if(0===u.length)break;if(!r){var l=Mf.next(u);if(Nf.has(e,l)){u=l,s=Nf.get(e,u);continue}}if(r&&0!==u[u.length-1])u=Mf.previous(u),s=Nf.get(e,u);else u=Mf.parent(u),s=Nf.get(e,u),a.add(s)}else{a.add(s);var c=r?s.children.length-1:0;Mf.isAncestor(u,o)&&(c=o[u.length]),u=u.concat(c),s=Nf.get(e,u)}},parent(e,t){var n=Mf.parent(t),r=Nf.get(e,n);if(ed.isText(r))throw new Error("Cannot get the parent of path [".concat(t,"] because it does not exist in the root."));return r},string:e=>ed.isText(e)?e.text:e.children.map(Nf.string).join(""),*texts(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(var[n,r]of Nf.nodes(e,t))ed.isText(n)&&(yield[n,r])}};function If(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Lf(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?If(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):If(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Rf={isNodeOperation:e=>Rf.isOperation(e)&&e.type.endsWith("_node"),isOperation(e){if(!Ll(e))return!1;switch(e.type){case"insert_node":case"remove_node":return Mf.isPath(e.path)&&Nf.isNode(e.node);case"insert_text":case"remove_text":return"number"==typeof e.offset&&"string"==typeof e.text&&Mf.isPath(e.path);case"merge_node":return"number"==typeof e.position&&Mf.isPath(e.path)&&Ll(e.properties);case"move_node":return Mf.isPath(e.path)&&Mf.isPath(e.newPath);case"set_node":return Mf.isPath(e.path)&&Ll(e.properties)&&Ll(e.newProperties);case"set_selection":return null===e.properties&&qf.isRange(e.newProperties)||null===e.newProperties&&qf.isRange(e.properties)||Ll(e.properties)&&Ll(e.newProperties);case"split_node":return Mf.isPath(e.path)&&"number"==typeof e.position&&Ll(e.properties);default:return!1}},isOperationList:e=>Array.isArray(e)&&e.every((e=>Rf.isOperation(e))),isSelectionOperation:e=>Rf.isOperation(e)&&e.type.endsWith("_selection"),isTextOperation:e=>Rf.isOperation(e)&&e.type.endsWith("_text"),inverse(e){switch(e.type){case"insert_node":return Lf(Lf({},e),{},{type:"remove_node"});case"insert_text":return Lf(Lf({},e),{},{type:"remove_text"});case"merge_node":return Lf(Lf({},e),{},{type:"split_node",path:Mf.previous(e.path)});case"move_node":var{newPath:t,path:n}=e;if(Mf.equals(t,n))return e;if(Mf.isSibling(n,t))return Lf(Lf({},e),{},{path:t,newPath:n});var r=Mf.transform(n,e),o=Mf.transform(Mf.next(n),e);return Lf(Lf({},e),{},{path:r,newPath:o});case"remove_node":return Lf(Lf({},e),{},{type:"insert_node"});case"remove_text":return Lf(Lf({},e),{},{type:"insert_text"});case"set_node":var{properties:i,newProperties:a}=e;return Lf(Lf({},e),{},{properties:a,newProperties:i});case"set_selection":var{properties:u,newProperties:s}=e;return Lf(Lf({},e),{},null==u?{properties:s,newProperties:null}:null==s?{properties:null,newProperties:u}:{properties:s,newProperties:u});case"split_node":return Lf(Lf({},e),{},{type:"merge_node",path:Mf.next(e.path)})}}},Mf={ancestors(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{reverse:n=!1}=t,r=Mf.levels(e,t);return r=n?r.slice(1):r.slice(0,-1)},common(e,t){for(var n=[],r=0;r<e.length&&r<t.length;r++){var o=e[r];if(o!==t[r])break;n.push(o)}return n},compare(e,t){for(var n=Math.min(e.length,t.length),r=0;r<n;r++){if(e[r]<t[r])return-1;if(e[r]>t[r])return 1}return 0},endsAfter(e,t){var n=e.length-1,r=e.slice(0,n),o=t.slice(0,n),i=e[n],a=t[n];return Mf.equals(r,o)&&i>a},endsAt(e,t){var n=e.length,r=e.slice(0,n),o=t.slice(0,n);return Mf.equals(r,o)},endsBefore(e,t){var n=e.length-1,r=e.slice(0,n),o=t.slice(0,n),i=e[n],a=t[n];return Mf.equals(r,o)&&i<a},equals:(e,t)=>e.length===t.length&&e.every(((e,n)=>e===t[n])),hasPrevious:e=>e[e.length-1]>0,isAfter:(e,t)=>1===Mf.compare(e,t),isAncestor:(e,t)=>e.length<t.length&&0===Mf.compare(e,t),isBefore:(e,t)=>-1===Mf.compare(e,t),isChild:(e,t)=>e.length===t.length+1&&0===Mf.compare(e,t),isCommon:(e,t)=>e.length<=t.length&&0===Mf.compare(e,t),isDescendant:(e,t)=>e.length>t.length&&0===Mf.compare(e,t),isParent:(e,t)=>e.length+1===t.length&&0===Mf.compare(e,t),isPath:e=>Array.isArray(e)&&(0===e.length||"number"==typeof e[0]),isSibling(e,t){if(e.length!==t.length)return!1;var n=e.slice(0,-1),r=t.slice(0,-1);return e[e.length-1]!==t[t.length-1]&&Mf.equals(n,r)},levels(e){for(var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{reverse:n=!1}=t,r=[],o=0;o<=e.length;o++)r.push(e.slice(0,o));return n&&r.reverse(),r},next(e){if(0===e.length)throw new Error("Cannot get the next path of a root path [".concat(e,"], because it has no next index."));var t=e[e.length-1];return e.slice(0,-1).concat(t+1)},parent(e){if(0===e.length)throw new Error("Cannot get the parent path of the root path [".concat(e,"]."));return e.slice(0,-1)},previous(e){if(0===e.length)throw new Error("Cannot get the previous path of a root path [".concat(e,"], because it has no previous index."));var t=e[e.length-1];if(t<=0)throw new Error("Cannot get the previous path of a first child path [".concat(e,"] because it would result in a negative index."));return e.slice(0,-1).concat(t-1)},relative(e,t){if(!Mf.isAncestor(t,e)&&!Mf.equals(e,t))throw new Error("Cannot get the relative path of [".concat(e,"] inside ancestor [").concat(t,"], because it is not above or equal to the path."));return e.slice(t.length)},transform(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return Pc(e,(r=>{var{affinity:o="forward"}=n;if(e&&0!==(null==e?void 0:e.length)){if(null===r)return null;switch(t.type){case"insert_node":var{path:i}=t;(Mf.equals(i,r)||Mf.endsBefore(i,r)||Mf.isAncestor(i,r))&&(r[i.length-1]+=1);break;case"remove_node":var{path:a}=t;if(Mf.equals(a,r)||Mf.isAncestor(a,r))return null;Mf.endsBefore(a,r)&&(r[a.length-1]-=1);break;case"merge_node":var{path:u,position:s}=t;Mf.equals(u,r)||Mf.endsBefore(u,r)?r[u.length-1]-=1:Mf.isAncestor(u,r)&&(r[u.length-1]-=1,r[u.length]+=s);break;case"split_node":var{path:l,position:c}=t;if(Mf.equals(l,r)){if("forward"===o)r[r.length-1]+=1;else if("backward"!==o)return null}else Mf.endsBefore(l,r)?r[l.length-1]+=1:Mf.isAncestor(l,r)&&e[l.length]>=c&&(r[l.length-1]+=1,r[l.length]-=c);break;case"move_node":var{path:f,newPath:d}=t;if(Mf.equals(f,d))return;if(Mf.isAncestor(f,r)||Mf.equals(f,r)){var p=d.slice();return Mf.endsBefore(f,d)&&f.length<d.length&&(p[f.length-1]-=1),p.concat(r.slice(f.length))}Mf.isSibling(f,d)&&(Mf.isAncestor(d,r)||Mf.equals(d,r))?Mf.endsBefore(f,r)?r[f.length-1]-=1:r[f.length-1]+=1:Mf.endsBefore(d,r)||Mf.equals(d,r)||Mf.isAncestor(d,r)?(Mf.endsBefore(f,r)&&(r[f.length-1]-=1),r[d.length-1]+=1):Mf.endsBefore(f,r)&&(Mf.equals(d,r)&&(r[d.length-1]+=1),r[f.length-1]-=1)}}}))}},zf={transform(e,t){var{current:n,affinity:r}=e;if(null!=n){var o=Mf.transform(n,t,{affinity:r});e.current=o,null==o&&e.unref()}}};function $f(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Hf(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?$f(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):$f(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var Vf={compare(e,t){var n=Mf.compare(e.path,t.path);return 0===n?e.offset<t.offset?-1:e.offset>t.offset?1:0:n},isAfter:(e,t)=>1===Vf.compare(e,t),isBefore:(e,t)=>-1===Vf.compare(e,t),equals:(e,t)=>e.offset===t.offset&&Mf.equals(e.path,t.path),isPoint:e=>Ll(e)&&"number"==typeof e.offset&&Mf.isPath(e.path),transform(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return Pc(e,(e=>{if(null===e)return null;var{affinity:r="forward"}=n,{path:o,offset:i}=e;switch(t.type){case"insert_node":case"move_node":e.path=Mf.transform(o,t,n);break;case"insert_text":Mf.equals(t.path,o)&&t.offset<=i&&(e.offset+=t.text.length);break;case"merge_node":Mf.equals(t.path,o)&&(e.offset+=t.position),e.path=Mf.transform(o,t,n);break;case"remove_text":Mf.equals(t.path,o)&&t.offset<=i&&(e.offset-=Math.min(i-t.offset,t.text.length));break;case"remove_node":if(Mf.equals(t.path,o)||Mf.isAncestor(t.path,o))return null;e.path=Mf.transform(o,t,n);break;case"split_node":if(Mf.equals(t.path,o)){if(t.position===i&&null==r)return null;(t.position<i||t.position===i&&"forward"===r)&&(e.offset-=t.position,e.path=Mf.transform(o,t,Hf(Hf({},n),{},{affinity:"forward"})))}else e.path=Mf.transform(o,t,n)}}))}},Uf={transform(e,t){var{current:n,affinity:r}=e;if(null!=n){var o=Vf.transform(n,t,{affinity:r});e.current=o,null==o&&e.unref()}}},Wf=["anchor","focus"];function Gf(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}var qf={edges(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{reverse:n=!1}=t,{anchor:r,focus:o}=e;return qf.isBackward(e)===n?[r,o]:[o,r]},end(e){var[,t]=qf.edges(e);return t},equals:(e,t)=>Vf.equals(e.anchor,t.anchor)&&Vf.equals(e.focus,t.focus),includes(e,t){if(qf.isRange(t)){if(qf.includes(e,t.anchor)||qf.includes(e,t.focus))return!0;var[n,r]=qf.edges(e),[o,i]=qf.edges(t);return Vf.isBefore(n,o)&&Vf.isAfter(r,i)}var[a,u]=qf.edges(e),s=!1,l=!1;return Vf.isPoint(t)?(s=Vf.compare(t,a)>=0,l=Vf.compare(t,u)<=0):(s=Mf.compare(t,a.path)>=0,l=Mf.compare(t,u.path)<=0),s&&l},intersection(e,t){var n=qc(e,Wf),[r,o]=qf.edges(e),[i,a]=qf.edges(t),u=Vf.isBefore(r,i)?i:r,s=Vf.isBefore(o,a)?o:a;return Vf.isBefore(s,u)?null:function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Gf(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Gf(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({anchor:u,focus:s},n)},isBackward(e){var{anchor:t,focus:n}=e;return Vf.isAfter(t,n)},isCollapsed(e){var{anchor:t,focus:n}=e;return Vf.equals(t,n)},isExpanded:e=>!qf.isCollapsed(e),isForward:e=>!qf.isBackward(e),isRange:e=>Ll(e)&&Vf.isPoint(e.anchor)&&Vf.isPoint(e.focus),*points(e){yield[e.anchor,"anchor"],yield[e.focus,"focus"]},start(e){var[t]=qf.edges(e);return t},transform(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return Pc(e,(e=>{if(null===e)return null;var r,o,{affinity:i="inward"}=n;if("inward"===i){var a=qf.isCollapsed(e);qf.isForward(e)?(r="forward",o=a?r:"backward"):(r="backward",o=a?r:"forward")}else"outward"===i?qf.isForward(e)?(r="backward",o="forward"):(r="forward",o="backward"):(r=i,o=i);var u=Vf.transform(e.anchor,t,{affinity:r}),s=Vf.transform(e.focus,t,{affinity:o});if(!u||!s)return null;e.anchor=u,e.focus=s}))}},Kf={transform(e,t){var{current:n,affinity:r}=e;if(null!=n){var o=qf.transform(n,t,{affinity:r});e.current=o,null==o&&e.unref()}}},Yf=(e,t)=>{for(var n in e){var r=e[n],o=t[n];if(Ll(r)&&Ll(o)){if(!Yf(r,o))return!1}else if(Array.isArray(r)&&Array.isArray(o)){if(r.length!==o.length)return!1;for(var i=0;i<r.length;i++)if(r[i]!==o[i])return!1}else if(r!==o)return!1}for(var a in t)if(void 0===e[a]&&void 0!==t[a])return!1;return!0},Xf=["text"],Zf=["anchor","focus"];function Jf(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Qf(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Jf(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Jf(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var ed={equals(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{loose:r=!1}=n;function o(e){return qc(e,Xf)}return Yf(r?o(e):e,r?o(t):t)},isText:e=>Ll(e)&&"string"==typeof e.text,isTextList:e=>Array.isArray(e)&&e.every((e=>ed.isText(e))),isTextProps:e=>void 0!==e.text,matches(e,t){for(var n in t)if("text"!==n&&(!e.hasOwnProperty(n)||e[n]!==t[n]))return!1;return!0},decorations(e,t){var n=[Qf({},e)];for(var r of t){var o=qc(r,Zf),[i,a]=qf.edges(r),u=[],s=0;for(var l of n){var{length:c}=l.text,f=s;if(s+=c,i.offset<=f&&a.offset>=s)Object.assign(l,o),u.push(l);else if(i.offset!==a.offset&&(i.offset===s||a.offset===f)||i.offset>s||a.offset<f||a.offset===f&&0!==f)u.push(l);else{var d=l,p=void 0,h=void 0;if(a.offset<s){var g=a.offset-f;h=Qf(Qf({},d),{},{text:d.text.slice(g)}),d=Qf(Qf({},d),{},{text:d.text.slice(0,g)})}if(i.offset>f){var v=i.offset-f;p=Qf(Qf({},d),{},{text:d.text.slice(0,v)}),d=Qf(Qf({},d),{},{text:d.text.slice(v)})}Object.assign(d,o),p&&u.push(p),u.push(d),h&&u.push(h)}}n=u}return n}};function td(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function nd(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?td(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):td(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var rd={transform(e,t){e.children=jc(e.children);var n=e.selection&&jc(e.selection);try{n=((e,t,n)=>{switch(n.type){case"insert_node":var{path:r,node:o}=n,i=Nf.parent(e,r),a=r[r.length-1];if(a>i.children.length)throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r,"] because the destination is past the end of the node."));if(i.children.splice(a,0,o),t)for(var[u,s]of qf.points(t))t[s]=Vf.transform(u,n);break;case"insert_text":var{path:l,offset:c,text:f}=n;if(0===f.length)break;var d=Nf.leaf(e,l),p=d.text.slice(0,c),h=d.text.slice(c);if(d.text=p+f+h,t)for(var[g,v]of qf.points(t))t[v]=Vf.transform(g,n);break;case"merge_node":var{path:y}=n,m=Nf.get(e,y),b=Mf.previous(y),w=Nf.get(e,b),E=Nf.parent(e,y),D=y[y.length-1];if(ed.isText(m)&&ed.isText(w))w.text+=m.text;else{if(ed.isText(m)||ed.isText(w))throw new Error('Cannot apply a "merge_node" operation at path ['.concat(y,"] to nodes of different interfaces: ").concat(m," ").concat(w));w.children.push(...m.children)}if(E.children.splice(D,1),t)for(var[S,x]of qf.points(t))t[x]=Vf.transform(S,n);break;case"move_node":var{path:C,newPath:A}=n;if(Mf.isAncestor(C,A))throw new Error("Cannot move a path [".concat(C,"] to new path [").concat(A,"] because the destination is inside itself."));var O=Nf.get(e,C),k=Nf.parent(e,C),B=C[C.length-1];k.children.splice(B,1);var F=Mf.transform(C,n),T=Nf.get(e,Mf.parent(F)),_=F[F.length-1];if(T.children.splice(_,0,O),t)for(var[P,j]of qf.points(t))t[j]=Vf.transform(P,n);break;case"remove_node":var{path:N}=n,I=N[N.length-1];if(Nf.parent(e,N).children.splice(I,1),t)for(var[L,R]of qf.points(t)){var M=Vf.transform(L,n);if(null!=t&&null!=M)t[R]=M;else{var z=void 0,$=void 0;for(var[H,V]of Nf.texts(e)){if(-1!==Mf.compare(V,N)){$=[H,V];break}z=[H,V]}var U=!1;z&&$&&(U=Mf.equals($[1],N)?!Mf.hasPrevious($[1]):Mf.common(z[1],N).length<Mf.common($[1],N).length),z&&!U?(L.path=z[1],L.offset=z[0].text.length):$?(L.path=$[1],L.offset=0):t=null}}break;case"remove_text":var{path:W,offset:G,text:q}=n;if(0===q.length)break;var K=Nf.leaf(e,W),Y=K.text.slice(0,G),X=K.text.slice(G+q.length);if(K.text=Y+X,t)for(var[Z,J]of qf.points(t))t[J]=Vf.transform(Z,n);break;case"set_node":var{path:Q,properties:ee,newProperties:te}=n;if(0===Q.length)throw new Error("Cannot set properties on the root node!");var ne=Nf.get(e,Q);for(var re in te){if("children"===re||"text"===re)throw new Error('Cannot set the "'.concat(re,'" property of nodes!'));var oe=te[re];null==oe?delete ne[re]:ne[re]=oe}for(var ie in ee)te.hasOwnProperty(ie)||delete ne[ie];break;case"set_selection":var{newProperties:ae}=n;if(null==ae)t=ae;else{if(null==t){if(!qf.isRange(ae))throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(JSON.stringify(ae)," when there is no current selection."));t=nd({},ae)}for(var ue in ae){var se=ae[ue];if(null==se){if("anchor"===ue||"focus"===ue)throw new Error('Cannot remove the "'.concat(ue,'" selection property'));delete t[ue]}else t[ue]=se}}break;case"split_node":var{path:le,position:ce,properties:fe}=n;if(0===le.length)throw new Error('Cannot apply a "split_node" operation at path ['.concat(le,"] because the root node cannot be split."));var de,pe=Nf.get(e,le),he=Nf.parent(e,le),ge=le[le.length-1];if(ed.isText(pe)){var ve=pe.text.slice(0,ce),ye=pe.text.slice(ce);pe.text=ve,de=nd(nd({},fe),{},{text:ye})}else{var me=pe.children.slice(0,ce),be=pe.children.slice(ce);pe.children=me,de=nd(nd({},fe),{},{children:be})}if(he.children.splice(ge+1,0,de),t)for(var[we,Ee]of qf.points(t))t[Ee]=Vf.transform(we,n)}return t})(e,n,t)}finally{e.children=Nc(e.children),e.selection=n?Ml(n)?Nc(n):n:null}}},od=["text"],id=["children"];function ad(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function ud(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?ad(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):ad(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var sd={insertNodes(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Bf.withoutNormalizing(e,(()=>{var{hanging:r=!1,voids:o=!1,mode:i="lowest"}=n,{at:a,match:u,select:s}=n;if(Nf.isNode(t)&&(t=[t]),0!==t.length){var[l]=t;if(a||(a=e.selection?e.selection:e.children.length>0?Bf.end(e,[]):[0],s=!0),null==s&&(s=!1),qf.isRange(a))if(r||(a=Bf.unhangRange(e,a)),qf.isCollapsed(a))a=a.anchor;else{var[,c]=qf.edges(a),f=Bf.pointRef(e,c);md.delete(e,{at:a}),a=f.unref()}if(Vf.isPoint(a)){null==u&&(u=ed.isText(l)?e=>ed.isText(e):e.isInline(l)?t=>ed.isText(t)||Bf.isInline(e,t):t=>Bf.isBlock(e,t));var[d]=Bf.nodes(e,{at:a.path,match:u,mode:i,voids:o});if(!d)return;var[,p]=d,h=Bf.pathRef(e,p),g=Bf.isEnd(e,a,p);md.splitNodes(e,{at:a,match:u,mode:i,voids:o});var v=h.unref();a=g?Mf.next(v):v}var y=Mf.parent(a),m=a[a.length-1];if(o||!Bf.void(e,{at:y})){for(var b of t){var w=y.concat(m);m++,e.apply({type:"insert_node",path:w,node:b}),a=Mf.next(a)}if(a=Mf.previous(a),s){var E=Bf.end(e,a);E&&md.select(e,E)}}}}))},liftNodes(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Bf.withoutNormalizing(e,(()=>{var{at:n=e.selection,mode:r="lowest",voids:o=!1}=t,{match:i}=t;if(null==i&&(i=Mf.isPath(n)?fd(e,n):t=>Bf.isBlock(e,t)),n){var a=Bf.nodes(e,{at:n,match:i,mode:r,voids:o}),u=Array.from(a,(t=>{var[,n]=t;return Bf.pathRef(e,n)}));for(var s of u){var l=s.unref();if(l.length<2)throw new Error("Cannot lift node at a path [".concat(l,"] because it has a depth of less than `2`."));var c=Bf.node(e,Mf.parent(l)),[f,d]=c,p=l[l.length-1],{length:h}=f.children;if(1===h){var g=Mf.next(d);md.moveNodes(e,{at:l,to:g,voids:o}),md.removeNodes(e,{at:d,voids:o})}else if(0===p)md.moveNodes(e,{at:l,to:d,voids:o});else if(p===h-1){var v=Mf.next(d);md.moveNodes(e,{at:l,to:v,voids:o})}else{var y=Mf.next(l),m=Mf.next(d);md.splitNodes(e,{at:y,voids:o}),md.moveNodes(e,{at:l,to:m,voids:o})}}}}))},mergeNodes(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Bf.withoutNormalizing(e,(()=>{var{match:n,at:r=e.selection}=t,{hanging:o=!1,voids:i=!1,mode:a="lowest"}=t;if(r){if(null==n)if(Mf.isPath(r)){var[u]=Bf.parent(e,r);n=e=>u.children.includes(e)}else n=t=>Bf.isBlock(e,t);if(!o&&qf.isRange(r)&&(r=Bf.unhangRange(e,r)),qf.isRange(r))if(qf.isCollapsed(r))r=r.anchor;else{var[,s]=qf.edges(r),l=Bf.pointRef(e,s);md.delete(e,{at:r}),r=l.unref(),null==t.at&&md.select(e,r)}var[c]=Bf.nodes(e,{at:r,match:n,voids:i,mode:a}),f=Bf.previous(e,{at:r,match:n,voids:i,mode:a});if(c&&f){var[d,p]=c,[h,g]=f;if(0!==p.length&&0!==g.length){var v,y,m=Mf.next(g),b=Mf.common(p,g),w=Mf.isSibling(p,g),E=Array.from(Bf.levels(e,{at:p}),(e=>{var[t]=e;return t})).slice(b.length).slice(0,-1),D=Bf.above(e,{at:p,mode:"highest",match:t=>E.includes(t)&&ld(e,t)}),S=D&&Bf.pathRef(e,D[1]);if(ed.isText(d)&&ed.isText(h)){var x=qc(d,od);y=h.text.length,v=x}else{if(!Sf.isElement(d)||!Sf.isElement(h))throw new Error("Cannot merge the node at path [".concat(p,"] with the previous sibling because it is not the same kind: ").concat(JSON.stringify(d)," ").concat(JSON.stringify(h)));x=qc(d,id);y=h.children.length,v=x}w||md.moveNodes(e,{at:p,to:m,voids:i}),S&&md.removeNodes(e,{at:S.current,voids:i}),Sf.isElement(h)&&Bf.isEmpty(e,h)||ed.isText(h)&&""===h.text&&0!==g[g.length-1]?md.removeNodes(e,{at:g,voids:i}):e.apply({type:"merge_node",path:m,position:y,properties:v}),S&&S.unref()}}}}))},moveNodes(e,t){Bf.withoutNormalizing(e,(()=>{var{to:n,at:r=e.selection,mode:o="lowest",voids:i=!1}=t,{match:a}=t;if(r){null==a&&(a=Mf.isPath(r)?fd(e,r):t=>Bf.isBlock(e,t));var u=Bf.pathRef(e,n),s=Bf.nodes(e,{at:r,match:a,mode:o,voids:i}),l=Array.from(s,(t=>{var[,n]=t;return Bf.pathRef(e,n)}));for(var c of l){var f=c.unref(),d=u.current;0!==f.length&&e.apply({type:"move_node",path:f,newPath:d}),u.current&&Mf.isSibling(d,f)&&Mf.isAfter(d,f)&&(u.current=Mf.next(u.current))}u.unref()}}))},removeNodes(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Bf.withoutNormalizing(e,(()=>{var{hanging:n=!1,voids:r=!1,mode:o="lowest"}=t,{at:i=e.selection,match:a}=t;if(i){null==a&&(a=Mf.isPath(i)?fd(e,i):t=>Bf.isBlock(e,t)),!n&&qf.isRange(i)&&(i=Bf.unhangRange(e,i));var u=Bf.nodes(e,{at:i,match:a,mode:o,voids:r}),s=Array.from(u,(t=>{var[,n]=t;return Bf.pathRef(e,n)}));for(var l of s){var c=l.unref();if(c){var[f]=Bf.node(e,c);e.apply({type:"remove_node",path:c,node:f})}}}}))},setNodes(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Bf.withoutNormalizing(e,(()=>{var{match:r,at:o=e.selection}=n,{hanging:i=!1,mode:a="lowest",split:u=!1,voids:s=!1}=n;if(o){if(null==r&&(r=Mf.isPath(o)?fd(e,o):t=>Bf.isBlock(e,t)),!i&&qf.isRange(o)&&(o=Bf.unhangRange(e,o)),u&&qf.isRange(o)){if(qf.isCollapsed(o)&&Bf.leaf(e,o.anchor)[0].text.length>0)return;var l=Bf.rangeRef(e,o,{affinity:"inward"}),[c,f]=qf.edges(o),d="lowest"===a?"lowest":"highest",p=Bf.isEnd(e,f,f.path);md.splitNodes(e,{at:f,match:r,mode:d,voids:s,always:!p});var h=Bf.isStart(e,c,c.path);md.splitNodes(e,{at:c,match:r,mode:d,voids:s,always:!h}),o=l.unref(),null==n.at&&md.select(e,o)}for(var[g,v]of Bf.nodes(e,{at:o,match:r,mode:a,voids:s})){var y={},m={};if(0!==v.length){var b=!1;for(var w in t)"children"!==w&&"text"!==w&&t[w]!==g[w]&&(b=!0,g.hasOwnProperty(w)&&(y[w]=g[w]),null!=t[w]&&(m[w]=t[w]));b&&e.apply({type:"set_node",path:v,properties:y,newProperties:m})}}}}))},splitNodes(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Bf.withoutNormalizing(e,(()=>{var{mode:n="lowest",voids:r=!1}=t,{match:o,at:i=e.selection,height:a=0,always:u=!1}=t;if(null==o&&(o=t=>Bf.isBlock(e,t)),qf.isRange(i)&&(i=cd(e,i)),Mf.isPath(i)){var s=i,l=Bf.point(e,s),[c]=Bf.parent(e,s);o=e=>e===c,a=l.path.length-s.length+1,i=l,u=!0}if(i){var f=Bf.pointRef(e,i,{affinity:"backward"}),[d]=Bf.nodes(e,{at:i,match:o,mode:n,voids:r});if(d){var p=Bf.void(e,{at:i,mode:"highest"});if(!r&&p){var[h,g]=p;if(Sf.isElement(h)&&e.isInline(h)){var v=Bf.after(e,g);if(!v){var y=Mf.next(g);md.insertNodes(e,{text:""},{at:y,voids:r}),v=Bf.point(e,y)}i=v,u=!0}a=i.path.length-g.length+1,u=!0}var m=Bf.pointRef(e,i),b=i.path.length-a,[,w]=d,E=i.path.slice(0,b),D=0===a?i.offset:i.path[b]+0;for(var[S,x]of Bf.levels(e,{at:E,reverse:!0,voids:r})){var C=!1;if(x.length<w.length||0===x.length||!r&&Bf.isVoid(e,S))break;var A=f.current,O=Bf.isEnd(e,A,x);if(u||!f||!Bf.isEdge(e,A,x)){C=!0;var k=Nf.extractProps(S);e.apply({type:"split_node",path:x,position:D,properties:k})}D=x[x.length-1]+(C||O?1:0)}if(null==t.at){var B=m.current||Bf.end(e,[]);md.select(e,B)}f.unref(),m.unref()}}}))},unsetNodes(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Array.isArray(t)||(t=[t]);var r={};for(var o of t)r[o]=null;md.setNodes(e,r,n)},unwrapNodes(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Bf.withoutNormalizing(e,(()=>{var{mode:n="lowest",split:r=!1,voids:o=!1}=t,{at:i=e.selection,match:a}=t;if(i){null==a&&(a=Mf.isPath(i)?fd(e,i):t=>Bf.isBlock(e,t)),Mf.isPath(i)&&(i=Bf.range(e,i));var u=qf.isRange(i)?Bf.rangeRef(e,i):null,s=Bf.nodes(e,{at:i,match:a,mode:n,voids:o}),l=Array.from(s,(t=>{var[,n]=t;return Bf.pathRef(e,n)})).reverse(),c=function(t){var n=t.unref(),[i]=Bf.node(e,n),a=Bf.range(e,n);r&&u&&(a=qf.intersection(u.current,a)),md.liftNodes(e,{at:a,match:e=>Sf.isAncestor(i)&&i.children.includes(e),voids:o})};for(var f of l)c(f);u&&u.unref()}}))},wrapNodes(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Bf.withoutNormalizing(e,(()=>{var{mode:r="lowest",split:o=!1,voids:i=!1}=n,{match:a,at:u=e.selection}=n;if(u){if(null==a&&(a=Mf.isPath(u)?fd(e,u):e.isInline(t)?t=>Bf.isInline(e,t)||ed.isText(t):t=>Bf.isBlock(e,t)),o&&qf.isRange(u)){var[s,l]=qf.edges(u),c=Bf.rangeRef(e,u,{affinity:"inward"});md.splitNodes(e,{at:l,match:a,voids:i}),md.splitNodes(e,{at:s,match:a,voids:i}),u=c.unref(),null==n.at&&md.select(e,u)}var f=Array.from(Bf.nodes(e,{at:u,match:e.isInline(t)?t=>Bf.isBlock(e,t):e=>Bf.isEditor(e),mode:"lowest",voids:i}));for(var[,d]of f){var p=qf.isRange(u)?qf.intersection(u,Bf.range(e,d)):u;if(p){var h=Array.from(Bf.nodes(e,{at:p,match:a,mode:r,voids:i}));if(h.length>0){var g=function(){var[n]=h,r=h[h.length-1],[,o]=n,[,a]=r;if(0===o.length&&0===a.length)return"continue";var u=Mf.equals(o,a)?Mf.parent(o):Mf.common(o,a),s=Bf.range(e,o,a),l=Bf.node(e,u),[c]=l,f=u.length+1,d=Mf.next(a.slice(0,f)),p=ud(ud({},t),{},{children:[]});md.insertNodes(e,p,{at:d,voids:i}),md.moveNodes(e,{at:s,match:e=>Sf.isAncestor(c)&&c.children.includes(e),to:d.concat(0),voids:i})}();if("continue"===g)continue}}}}}))}},ld=(e,t)=>{if(Sf.isElement(t)){var n=t;return!!Bf.isVoid(e,t)||1===n.children.length&&ld(e,n.children[0])}return!Bf.isEditor(t)},cd=(e,t)=>{if(qf.isCollapsed(t))return t.anchor;var[,n]=qf.edges(t),r=Bf.pointRef(e,n);return md.delete(e,{at:t}),r.unref()},fd=(e,t)=>{var[n]=Bf.node(e,t);return e=>e===n};function dd(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function pd(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?dd(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):dd(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var hd={collapse(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{edge:n="anchor"}=t,{selection:r}=e;if(r)if("anchor"===n)md.select(e,r.anchor);else if("focus"===n)md.select(e,r.focus);else if("start"===n){var[o]=qf.edges(r);md.select(e,o)}else if("end"===n){var[,i]=qf.edges(r);md.select(e,i)}},deselect(e){var{selection:t}=e;t&&e.apply({type:"set_selection",properties:t,newProperties:null})},move(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{selection:n}=e,{distance:r=1,unit:o="character",reverse:i=!1}=t,{edge:a=null}=t;if(n){"start"===a&&(a=qf.isBackward(n)?"focus":"anchor"),"end"===a&&(a=qf.isBackward(n)?"anchor":"focus");var{anchor:u,focus:s}=n,l={distance:r,unit:o},c={};if(null==a||"anchor"===a){var f=i?Bf.before(e,u,l):Bf.after(e,u,l);f&&(c.anchor=f)}if(null==a||"focus"===a){var d=i?Bf.before(e,s,l):Bf.after(e,s,l);d&&(c.focus=d)}md.setSelection(e,c)}},select(e,t){var{selection:n}=e;if(t=Bf.range(e,t),n)md.setSelection(e,t);else{if(!qf.isRange(t))throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(JSON.stringify(t)));e.apply({type:"set_selection",properties:n,newProperties:t})}},setPoint(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{selection:r}=e,{edge:o="both"}=n;if(r){"start"===o&&(o=qf.isBackward(r)?"focus":"anchor"),"end"===o&&(o=qf.isBackward(r)?"anchor":"focus");var{anchor:i,focus:a}=r,u="anchor"===o?i:a;md.setSelection(e,{["anchor"===o?"anchor":"focus"]:pd(pd({},u),t)})}},setSelection(e,t){var{selection:n}=e,r={},o={};if(n){for(var i in t)("anchor"===i&&null!=t.anchor&&!Vf.equals(t.anchor,n.anchor)||"focus"===i&&null!=t.focus&&!Vf.equals(t.focus,n.focus)||"anchor"!==i&&"focus"!==i&&t[i]!==n[i])&&(r[i]=n[i],o[i]=t[i]);Object.keys(r).length>0&&e.apply({type:"set_selection",properties:r,newProperties:o})}}},gd={delete(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};Bf.withoutNormalizing(e,(()=>{var{reverse:n=!1,unit:r="character",distance:o=1,voids:i=!1}=t,{at:a=e.selection,hanging:u=!1}=t;if(a){if(qf.isRange(a)&&qf.isCollapsed(a)&&(a=a.anchor),Vf.isPoint(a)){var s=Bf.void(e,{at:a,mode:"highest"});if(!i&&s){var[,l]=s;a=l}else{var c={unit:r,distance:o};a={anchor:a,focus:n?Bf.before(e,a,c)||Bf.start(e,[]):Bf.after(e,a,c)||Bf.end(e,[])},u=!0}}if(Mf.isPath(a))md.removeNodes(e,{at:a,voids:i});else if(!qf.isCollapsed(a)){if(!u){var[,f]=qf.edges(a),d=Bf.end(e,[]);Vf.equals(f,d)||(a=Bf.unhangRange(e,a,{voids:i}))}var[p,h]=qf.edges(a),g=Bf.above(e,{match:t=>Bf.isBlock(e,t),at:p,voids:i}),v=Bf.above(e,{match:t=>Bf.isBlock(e,t),at:h,voids:i}),y=g&&v&&!Mf.equals(g[1],v[1]),m=Mf.equals(p.path,h.path),b=i?null:Bf.void(e,{at:p,mode:"highest"}),w=i?null:Bf.void(e,{at:h,mode:"highest"});if(b){var E=Bf.before(e,p);E&&g&&Mf.isAncestor(g[1],E.path)&&(p=E)}if(w){var D=Bf.after(e,h);D&&v&&Mf.isAncestor(v[1],D.path)&&(h=D)}var S,x=[];for(var C of Bf.nodes(e,{at:a,voids:i})){var[A,O]=C;S&&0===Mf.compare(O,S)||(!i&&Bf.isVoid(e,A)||!Mf.isCommon(O,p.path)&&!Mf.isCommon(O,h.path))&&(x.push(C),S=O)}var k=Array.from(x,(t=>{var[,n]=t;return Bf.pathRef(e,n)})),B=Bf.pointRef(e,p),F=Bf.pointRef(e,h);if(!m&&!b){var T=B.current,[_]=Bf.leaf(e,T),{path:P}=T,{offset:j}=p,N=_.text.slice(j);N.length>0&&e.apply({type:"remove_text",path:P,offset:j,text:N})}for(var I of k){var L=I.unref();md.removeNodes(e,{at:L,voids:i})}if(!w){var R=F.current,[M]=Bf.leaf(e,R),{path:z}=R,$=m?p.offset:0,H=M.text.slice($,h.offset);H.length>0&&e.apply({type:"remove_text",path:z,offset:$,text:H})}!m&&y&&F.current&&B.current&&md.mergeNodes(e,{at:F.current,hanging:!0,voids:i});var V=n?B.unref()||F.unref():F.unref()||B.unref();null==t.at&&V&&md.select(e,V)}}}))},insertFragment(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Bf.withoutNormalizing(e,(()=>{var{hanging:r=!1,voids:o=!1}=n,{at:i=e.selection}=n;if(t.length&&i){if(qf.isRange(i))if(r||(i=Bf.unhangRange(e,i)),qf.isCollapsed(i))i=i.anchor;else{var[,a]=qf.edges(i);if(!o&&Bf.void(e,{at:a}))return;var u=Bf.pointRef(e,a);md.delete(e,{at:i}),i=u.unref()}else Mf.isPath(i)&&(i=Bf.start(e,i));if(o||!Bf.void(e,{at:i})){var s=Bf.above(e,{at:i,match:t=>Bf.isInline(e,t),mode:"highest",voids:o});if(s){var[,l]=s;if(Bf.isEnd(e,i,l))i=Bf.after(e,l);else if(Bf.isStart(e,i,l)){i=Bf.before(e,l)}}var c=Bf.above(e,{match:t=>Bf.isBlock(e,t),at:i,voids:o}),[,f]=c,d=Bf.isStart(e,i,f),p=Bf.isEnd(e,i,f),h=d&&p,g=!d||d&&p,v=!p,[,y]=Nf.first({children:t},[]),[,m]=Nf.last({children:t},[]),b=[],w=t=>{var[n,r]=t;return!(0===r.length)&&(!!h||!(g&&Mf.isAncestor(r,y)&&Sf.isElement(n)&&!e.isVoid(n)&&!e.isInline(n))&&!(v&&Mf.isAncestor(r,m)&&Sf.isElement(n)&&!e.isVoid(n)&&!e.isInline(n)))};for(var E of Nf.nodes({children:t},{pass:w}))w(E)&&b.push(E);var D=[],S=[],x=[],C=!0,A=!1;for(var[O]of b)Sf.isElement(O)&&!e.isInline(O)?(C=!1,A=!0,S.push(O)):C?D.push(O):x.push(O);var[k]=Bf.nodes(e,{at:i,match:t=>ed.isText(t)||Bf.isInline(e,t),mode:"highest",voids:o}),[,B]=k,F=Bf.isStart(e,i,B),T=Bf.isEnd(e,i,B),_=Bf.pathRef(e,p?Mf.next(f):f),P=Bf.pathRef(e,T?Mf.next(B):B),j=Bf.pathRef(e,f);md.splitNodes(e,{at:i,match:t=>A?Bf.isBlock(e,t):ed.isText(t)||Bf.isInline(e,t),mode:A?"lowest":"highest",voids:o});var N=Bf.pathRef(e,!F||F&&T?Mf.next(B):B);if(md.insertNodes(e,D,{at:N.current,match:t=>ed.isText(t)||Bf.isInline(e,t),mode:"highest",voids:o}),h&&S.length&&md.delete(e,{at:j.unref(),voids:o}),md.insertNodes(e,S,{at:_.current,match:t=>Bf.isBlock(e,t),mode:"lowest",voids:o}),md.insertNodes(e,x,{at:P.current,match:t=>ed.isText(t)||Bf.isInline(e,t),mode:"highest",voids:o}),!n.at){var I;I=x.length>0?Mf.previous(P.current):S.length>0?Mf.previous(_.current):Mf.previous(N.current);var L=Bf.end(e,I);md.select(e,L)}N.unref(),_.unref(),P.unref()}}}))},insertText(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Bf.withoutNormalizing(e,(()=>{var{voids:r=!1}=n,{at:o=e.selection}=n;if(o){if(Mf.isPath(o)&&(o=Bf.range(e,o)),qf.isRange(o))if(qf.isCollapsed(o))o=o.anchor;else{var i=qf.end(o);if(!r&&Bf.void(e,{at:i}))return;var a=Bf.pointRef(e,i);md.delete(e,{at:o,voids:r}),o=a.unref(),md.setSelection(e,{anchor:o,focus:o})}if(r||!Bf.void(e,{at:o})){var{path:u,offset:s}=o;t.length>0&&e.apply({type:"insert_text",path:u,offset:s,text:t})}}}))}};function vd(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function yd(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?vd(Object(n),!0).forEach((function(t){Ic(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):vd(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var md=yd(yd(yd(yd({},rd),sd),hd),gd),bd="[object Map]",wd="[object Set]",Ed=/^\[object .+?Constructor\]$/,Dd=/^(?:0|[1-9]\d*)$/,Sd="[\\ud800-\\udfff]",xd="[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]",Cd="\\ud83c[\\udffb-\\udfff]",Ad="[^\\ud800-\\udfff]",Od="(?:\\ud83c[\\udde6-\\uddff]){2}",kd="[\\ud800-\\udbff][\\udc00-\\udfff]",Bd="(?:"+xd+"|"+Cd+")"+"?",Fd="[\\ufe0e\\ufe0f]?"+Bd+("(?:\\u200d(?:"+[Ad,Od,kd].join("|")+")[\\ufe0e\\ufe0f]?"+Bd+")*"),Td="(?:"+[Ad+xd+"?",xd,Od,kd,Sd].join("|")+")",_d=RegExp(Cd+"(?="+Cd+")|"+Td+Fd,"g"),Pd=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"),jd="object"==typeof e&&e&&e.Object===Object&&e,Nd="object"==typeof self&&self&&self.Object===Object&&self,Id=jd||Nd||Function("return this")();function Ld(e,t){return function(e,t){for(var n=-1,r=e?e.length:0,o=Array(r);++n<r;)o[n]=t(e[n],n,e);return o}(t,(function(t){return e[t]}))}function Rd(e){var t=-1,n=Array(e.size);return e.forEach((function(e,r){n[++t]=[r,e]})),n}function Md(e){var t=-1,n=Array(e.size);return e.forEach((function(e){n[++t]=e})),n}function zd(e){return function(e){return Pd.test(e)}(e)?function(e){return e.match(_d)||[]}(e):function(e){return e.split("")}(e)}var $d,Hd,Vd=Function.prototype,Ud=Object.prototype,Wd=Id["__core-js_shared__"],Gd=function(){var e=/[^.]+$/.exec(Wd&&Wd.keys&&Wd.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),qd=Vd.toString,Kd=Ud.hasOwnProperty,Yd=Ud.toString,Xd=RegExp("^"+qd.call(Kd).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Zd=Id.Symbol,Jd=Zd?Zd.iterator:void 0,Qd=Ud.propertyIsEnumerable,ep=($d=Object.keys,Hd=Object,function(e){return $d(Hd(e))}),tp=hp(Id,"DataView"),np=hp(Id,"Map"),rp=hp(Id,"Promise"),op=hp(Id,"Set"),ip=hp(Id,"WeakMap"),ap=yp(tp),up=yp(np),sp=yp(rp),lp=yp(op),cp=yp(ip);function fp(e,t){var n=mp(e)||function(e){return function(e){return Dp(e)&&bp(e)}(e)&&Kd.call(e,"callee")&&(!Qd.call(e,"callee")||"[object Arguments]"==Yd.call(e))}(e)?function(e,t){for(var n=-1,r=Array(e);++n<e;)r[n]=t(n);return r}(e.length,String):[],r=n.length,o=!!r;for(var i in e)!t&&!Kd.call(e,i)||o&&("length"==i||vp(i,r))||n.push(i);return n}function dp(e){if(!Ep(e)||function(e){return!!Gd&&Gd in e}(e))return!1;var t=wp(e)||function(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}(e)?Xd:Ed;return t.test(yp(e))}function pp(e){if(n=(t=e)&&t.constructor,r="function"==typeof n&&n.prototype||Ud,t!==r)return ep(e);var t,n,r,o=[];for(var i in Object(e))Kd.call(e,i)&&"constructor"!=i&&o.push(i);return o}function hp(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return dp(n)?n:void 0}var gp=function(e){return Yd.call(e)};function vp(e,t){return!!(t=null==t?9007199254740991:t)&&("number"==typeof e||Dd.test(e))&&e>-1&&e%1==0&&e<t}function yp(e){if(null!=e){try{return qd.call(e)}catch(e){}try{return e+""}catch(e){}}return""}(tp&&"[object DataView]"!=gp(new tp(new ArrayBuffer(1)))||np&&gp(new np)!=bd||rp&&"[object Promise]"!=gp(rp.resolve())||op&&gp(new op)!=wd||ip&&"[object WeakMap]"!=gp(new ip))&&(gp=function(e){var t=Yd.call(e),n="[object Object]"==t?e.constructor:void 0,r=n?yp(n):void 0;if(r)switch(r){case ap:return"[object DataView]";case up:return bd;case sp:return"[object Promise]";case lp:return wd;case cp:return"[object WeakMap]"}return t});var mp=Array.isArray;function bp(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=9007199254740991}(e.length)&&!wp(e)}function wp(e){var t=Ep(e)?Yd.call(e):"";return"[object Function]"==t||"[object GeneratorFunction]"==t}function Ep(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function Dp(e){return!!e&&"object"==typeof e}function Sp(e){return e?Ld(e,function(e){return bp(e)?fp(e):pp(e)}(e)):[]}var xp=function(e){if(!e)return[];if(bp(e))return function(e){return"string"==typeof e||!mp(e)&&Dp(e)&&"[object String]"==Yd.call(e)}(e)?zd(e):function(e,t){var n=-1,r=e.length;for(t||(t=Array(r));++n<r;)t[n]=e[n];return t}(e);if(Jd&&e[Jd])return function(e){for(var t,n=[];!(t=e.next()).done;)n.push(t.value);return n}(e[Jd]());var t=gp(e);return(t==bd?Rd:t==wd?Md:Sp)(e)};function Cp(e){return null!==e&&"object"==typeof e&&"constructor"in e&&e.constructor===Object}function Ap(e,t){void 0===e&&(e={}),void 0===t&&(t={}),Object.keys(t).forEach((function(n){void 0===e[n]?e[n]=t[n]:Cp(t[n])&&Cp(e[n])&&Object.keys(t[n]).length>0&&Ap(e[n],t[n])}))}var Op={body:{},addEventListener:function(){},removeEventListener:function(){},activeElement:{blur:function(){},nodeName:""},querySelector:function(){return null},querySelectorAll:function(){return[]},getElementById:function(){return null},createEvent:function(){return{initEvent:function(){}}},createElement:function(){return{children:[],childNodes:[],style:{},setAttribute:function(){},getElementsByTagName:function(){return[]}}},createElementNS:function(){return{}},importNode:function(){return null},location:{hash:"",host:"",hostname:"",href:"",origin:"",pathname:"",protocol:"",search:""}};function kp(){var e="undefined"!=typeof document?document:{};return Ap(e,Op),e}var Bp={document:Op,navigator:{userAgent:""},location:{hash:"",host:"",hostname:"",href:"",origin:"",pathname:"",protocol:"",search:""},history:{replaceState:function(){},pushState:function(){},go:function(){},back:function(){}},CustomEvent:function(){return this},addEventListener:function(){},removeEventListener:function(){},getComputedStyle:function(){return{getPropertyValue:function(){return""}}},Image:function(){},Date:function(){},screen:{},setTimeout:function(){},clearTimeout:function(){},matchMedia:function(){return{}},requestAnimationFrame:function(e){return"undefined"==typeof setTimeout?(e(),null):setTimeout(e,0)},cancelAnimationFrame:function(e){"undefined"!=typeof setTimeout&&clearTimeout(e)}};function Fp(){var e="undefined"!=typeof window?window:{};return Ap(e,Bp),e}function Tp(e){return Tp=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},Tp(e)}function _p(e,t){return _p=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},_p(e,t)}function Pp(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function jp(e,t,n){return jp=Pp()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var o=new(Function.bind.apply(e,r));return n&&_p(o,n.prototype),o},jp.apply(null,arguments)}function Np(e){var t="function"==typeof Map?new Map:void 0;return Np=function(e){if(null===e||!function(e){return-1!==Function.toString.call(e).indexOf("[native code]")}(e))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return jp(e,arguments,Tp(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),_p(n,e)},Np(e)}var Ip=function(e){var t,n;function r(t){var n,r,o;return n=e.call.apply(e,[this].concat(t))||this,r=function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(n),o=r.__proto__,Object.defineProperty(r,"__proto__",{get:function(){return o},set:function(e){o.__proto__=e}}),n}return n=e,(t=r).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n,r}(Np(Array));function Lp(e){void 0===e&&(e=[]);var t=[];return e.forEach((function(e){Array.isArray(e)?t.push.apply(t,Lp(e)):t.push(e)})),t}function Rp(e,t){return Array.prototype.filter.call(e,t)}function Mp(e,t){var n=Fp(),r=kp(),o=[];if(!t&&e instanceof Ip)return e;if(!e)return new Ip(o);if("string"==typeof e){var i=e.trim();if(i.indexOf("<")>=0&&i.indexOf(">")>=0){var a="div";0===i.indexOf("<li")&&(a="ul"),0===i.indexOf("<tr")&&(a="tbody"),0!==i.indexOf("<td")&&0!==i.indexOf("<th")||(a="tr"),0===i.indexOf("<tbody")&&(a="table"),0===i.indexOf("<option")&&(a="select");var u=r.createElement(a);u.innerHTML=i;for(var s=0;s<u.childNodes.length;s+=1)o.push(u.childNodes[s])}else o=function(e,t){if("string"!=typeof e)return[e];for(var n=[],r=t.querySelectorAll(e),o=0;o<r.length;o+=1)n.push(r[o]);return n}(e.trim(),t||r)}else if(e.nodeType||e===n||e===r)o.push(e);else if(Array.isArray(e)){if(e instanceof Ip)return e;o=e}return new Ip(function(e){for(var t=[],n=0;n<e.length;n+=1)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(o))}function zp(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=Lp(t.map((function(e){return e.split(" ")})));return this.forEach((function(e){var t;(t=e.classList).add.apply(t,r)})),this}function $p(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=Lp(t.map((function(e){return e.split(" ")})));return this.forEach((function(e){var t;(t=e.classList).remove.apply(t,r)})),this}function Hp(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=Lp(t.map((function(e){return e.split(" ")})));return Rp(this,(function(e){return r.filter((function(t){return e.classList.contains(t)})).length>0})).length>0}function Vp(e,t){if(1===arguments.length&&"string"==typeof e)return this[0]?this[0].getAttribute(e):void 0;for(var n=0;n<this.length;n+=1)if(2===arguments.length)this[n].setAttribute(e,t);else for(var r in e)this[n][r]=e[r],this[n].setAttribute(r,e[r]);return this}function Up(e){for(var t=0;t<this.length;t+=1)this[t].removeAttribute(e);return this}function Wp(){var e=this[0];if(e){var t,n={};if(e.dataset)for(var r in e.dataset)n[r]=e.dataset[r];else for(var o=0;o<e.attributes.length;o+=1){var i=e.attributes[o];i.name.indexOf("data-")>=0&&(n[(t=i.name.split("data-")[1],t.toLowerCase().replace(/-(.)/g,(function(e,t){return t.toUpperCase()})))]=i.value)}for(var a in n)"false"===n[a]?n[a]=!1:"true"===n[a]?n[a]=!0:parseFloat(n[a])===1*n[a]&&(n[a]*=1);return n}}function Gp(e){if(void 0===e){var t=this[0];if(!t)return;if(t.multiple&&"select"===t.nodeName.toLowerCase()){for(var n=[],r=0;r<t.selectedOptions.length;r+=1)n.push(t.selectedOptions[r].value);return n}return t.value}for(var o=0;o<this.length;o+=1){var i=this[o];if(Array.isArray(e)&&i.multiple&&"select"===i.nodeName.toLowerCase())for(var a=0;a<i.options.length;a+=1)i.options[a].selected=e.indexOf(i.options[a].value)>=0;else i.value=e}return this}function qp(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=t[0],o=t[1],i=t[2],a=t[3];function u(e){var t=e.target;if(t){var n=e.target.dom7EventData||[];if(n.indexOf(e)<0&&n.unshift(e),Mp(t).is(o))i.apply(t,n);else for(var r=Mp(t).parents(),a=0;a<r.length;a+=1)Mp(r[a]).is(o)&&i.apply(r[a],n)}}function s(e){var t=e&&e.target&&e.target.dom7EventData||[];t.indexOf(e)<0&&t.unshift(e),i.apply(this,t)}"function"==typeof t[1]&&(r=t[0],i=t[1],a=t[2],o=void 0),a||(a=!1);for(var l,c=r.split(" "),f=0;f<this.length;f+=1){var d=this[f];if(o)for(l=0;l<c.length;l+=1){var p=c[l];d.dom7LiveListeners||(d.dom7LiveListeners={}),d.dom7LiveListeners[p]||(d.dom7LiveListeners[p]=[]),d.dom7LiveListeners[p].push({listener:i,proxyListener:u}),d.addEventListener(p,u,a)}else for(l=0;l<c.length;l+=1){var h=c[l];d.dom7Listeners||(d.dom7Listeners={}),d.dom7Listeners[h]||(d.dom7Listeners[h]=[]),d.dom7Listeners[h].push({listener:i,proxyListener:s}),d.addEventListener(h,s,a)}}return this}function Kp(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=t[0],o=t[1],i=t[2],a=t[3];"function"==typeof t[1]&&(r=t[0],i=t[1],a=t[2],o=void 0),a||(a=!1);for(var u=r.split(" "),s=0;s<u.length;s+=1)for(var l=u[s],c=0;c<this.length;c+=1){var f=this[c],d=void 0;if(!o&&f.dom7Listeners?d=f.dom7Listeners[l]:o&&f.dom7LiveListeners&&(d=f.dom7LiveListeners[l]),d&&d.length)for(var p=d.length-1;p>=0;p-=1){var h=d[p];i&&h.listener===i||i&&h.listener&&h.listener.dom7proxy&&h.listener.dom7proxy===i?(f.removeEventListener(l,h.proxyListener,a),d.splice(p,1)):i||(f.removeEventListener(l,h.proxyListener,a),d.splice(p,1))}}return this}function Yp(){var e=Fp();return this[0]===e?e.innerWidth:this.length>0?parseFloat(this.css("width")):null}function Xp(){var e=Fp();return this[0]===e?e.innerHeight:this.length>0?parseFloat(this.css("height")):null}function Zp(){if(this.length>0){var e=Fp(),t=kp(),n=this[0],r=n.getBoundingClientRect(),o=t.body,i=n.clientTop||o.clientTop||0,a=n.clientLeft||o.clientLeft||0,u=n===e?e.scrollY:n.scrollTop,s=n===e?e.scrollX:n.scrollLeft;return{top:r.top+u-i,left:r.left+s-a}}return null}function Jp(){for(var e=0;e<this.length;e+=1)this[e].style.display="none";return this}function Qp(){for(var e=Fp(),t=0;t<this.length;t+=1){var n=this[t];"none"===n.style.display&&(n.style.display=""),"none"===e.getComputedStyle(n,null).getPropertyValue("display")&&(n.style.display="block")}return this}function eh(e,t){var n,r=Fp();if(1===arguments.length){if("string"!=typeof e){for(n=0;n<this.length;n+=1)for(var o in e)this[n].style[o]=e[o];return this}if(this[0])return r.getComputedStyle(this[0],null).getPropertyValue(e)}if(2===arguments.length&&"string"==typeof e){for(n=0;n<this.length;n+=1)this[n].style[e]=t;return this}return this}function th(e){return e?(this.forEach((function(t,n){e.apply(t,[t,n])})),this):this}function nh(e){return Mp(Rp(this,e))}function rh(e){if(void 0===e)return this[0]?this[0].innerHTML:null;for(var t=0;t<this.length;t+=1)this[t].innerHTML=e;return this}function oh(e){if(void 0===e)return this[0]?this[0].textContent.trim():null;for(var t=0;t<this.length;t+=1)this[t].textContent=e;return this}function ih(e){var t,n,r=Fp(),o=kp(),i=this[0];if(!i||void 0===e)return!1;if("string"==typeof e){if(i.matches)return i.matches(e);if(i.webkitMatchesSelector)return i.webkitMatchesSelector(e);if(i.msMatchesSelector)return i.msMatchesSelector(e);for(t=Mp(e),n=0;n<t.length;n+=1)if(t[n]===i)return!0;return!1}if(e===o)return i===o;if(e===r)return i===r;if(e.nodeType||e instanceof Ip){for(t=e.nodeType?[e]:e,n=0;n<t.length;n+=1)if(t[n]===i)return!0;return!1}return!1}function ah(){for(var e,t=kp(),n=0;n<arguments.length;n+=1){e=n<0||arguments.length<=n?void 0:arguments[n];for(var r=0;r<this.length;r+=1)if("string"==typeof e){var o=t.createElement("div");for(o.innerHTML=e;o.firstChild;)this[r].appendChild(o.firstChild)}else if(e instanceof Ip)for(var i=0;i<e.length;i+=1)this[r].appendChild(e[i]);else this[r].appendChild(e)}return this}function uh(e){var t,n,r=kp();for(t=0;t<this.length;t+=1)if("string"==typeof e){var o=r.createElement("div");for(o.innerHTML=e,n=o.childNodes.length-1;n>=0;n-=1)this[t].insertBefore(o.childNodes[n],this[t].childNodes[0])}else if(e instanceof Ip)for(n=0;n<e.length;n+=1)this[t].insertBefore(e[n],this[t].childNodes[0]);else this[t].insertBefore(e,this[t].childNodes[0]);return this}function sh(e){for(var t=[],n=0;n<this.length;n+=1)null!==this[n].parentNode&&(e?Mp(this[n].parentNode).is(e)&&t.push(this[n].parentNode):t.push(this[n].parentNode));return Mp(t)}function lh(e){for(var t=[],n=0;n<this.length;n+=1)for(var r=this[n].parentNode;r;)e?Mp(r).is(e)&&t.push(r):t.push(r),r=r.parentNode;return Mp(t)}function ch(e){for(var t=[],n=0;n<this.length;n+=1)for(var r=this[n].querySelectorAll(e),o=0;o<r.length;o+=1)t.push(r[o]);return Mp(t)}function fh(e){for(var t=[],n=0;n<this.length;n+=1)for(var r=this[n].children,o=0;o<r.length;o+=1)e&&!Mp(r[o]).is(e)||t.push(r[o]);return Mp(t)}function dh(){for(var e=0;e<this.length;e+=1)this[e].parentNode&&this[e].parentNode.removeChild(this[e]);return this}function ph(){for(var e=0;e<this.length;e+=1){var t=this[e];if(1===t.nodeType){for(var n=0;n<t.childNodes.length;n+=1)t.childNodes[n].parentNode&&t.childNodes[n].parentNode.removeChild(t.childNodes[n]);t.textContent=""}}return this}Mp.fn=Ip.prototype;var hh="resize scroll".split(" ");function gh(e){return function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];if(void 0===n[0]){for(var o=0;o<this.length;o+=1)hh.indexOf(e)<0&&(e in this[o]?this[o][e]():Mp(this[o]).trigger(e));return this}return this.on.apply(this,[e].concat(n))}}var vh=gh("click"),yh=gh("focus"),mh="[object GeneratorFunction]",bh=/^(?:0|[1-9]\d*)$/;function wh(e,t){for(var n=-1,r=e?e.length:0;++n<r&&!1!==t(e[n],n,e););return e}var Eh=Object.prototype,Dh=Eh.hasOwnProperty,Sh=Eh.toString,xh=Eh.propertyIsEnumerable,Ch=function(e,t){return function(n){return e(t(n))}}(Object.keys,Object);function Ah(e,t){var n=Ph(e)||function(e){return function(e){return function(e){return!!e&&"object"==typeof e}(e)&&jh(e)}(e)&&Dh.call(e,"callee")&&(!xh.call(e,"callee")||"[object Arguments]"==Sh.call(e))}(e)?function(e,t){for(var n=-1,r=Array(e);++n<e;)r[n]=t(n);return r}(e.length,String):[],r=n.length,o=!!r;for(var i in e)!t&&!Dh.call(e,i)||o&&("length"==i||_h(i,r))||n.push(i);return n}var Oh,kh,Bh=(Oh=function(e,t){return e&&Fh(e,t,Nh)},function(e,t){if(null==e)return e;if(!jh(e))return Oh(e,t);for(var n=e.length,r=kh?n:-1,o=Object(e);(kh?r--:++r<n)&&!1!==t(o[r],r,o););return e}),Fh=function(e){return function(t,n,r){for(var o=-1,i=Object(t),a=r(t),u=a.length;u--;){var s=a[e?u:++o];if(!1===n(i[s],s,i))break}return t}}();function Th(e){if(n=(t=e)&&t.constructor,r="function"==typeof n&&n.prototype||Eh,t!==r)return Ch(e);var t,n,r,o=[];for(var i in Object(e))Dh.call(e,i)&&"constructor"!=i&&o.push(i);return o}function _h(e,t){return!!(t=null==t?9007199254740991:t)&&("number"==typeof e||bh.test(e))&&e>-1&&e%1==0&&e<t}var Ph=Array.isArray;function jh(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=9007199254740991}(e.length)&&!function(e){var t=function(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}(e)?Sh.call(e):"";return"[object Function]"==t||t==mh}(e)}function Nh(e){return jh(e)?Ah(e):Th(e)}function Ih(e){return e}var Lh=function(e,t){return(Ph(e)?wh:Bh)(e,"function"==typeof t?t:Ih)};let Rh=(e=21)=>{let t="",n=crypto.getRandomValues(new Uint8Array(e));for(;e--;){let r=63&n[e];t+=r<36?r.toString(36):r<62?(r-26).toString(36).toUpperCase():r<63?"_":"-"}return t};var Mh=/^\s+|\s+$/g,zh=/^[-+]0x[0-9a-f]+$/i,$h=/^0b[01]+$/i,Hh=/^0o[0-7]+$/i,Vh=parseInt,Uh="object"==typeof e&&e&&e.Object===Object&&e,Wh="object"==typeof self&&self&&self.Object===Object&&self,Gh=Uh||Wh||Function("return this")(),qh=Object.prototype.toString,Kh=Math.max,Yh=Math.min,Xh=function(){return Gh.Date.now()};function Zh(e,t,n){var r,o,i,a,u,s,l=0,c=!1,f=!1,d=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function p(t){var n=r,i=o;return r=o=void 0,l=t,a=e.apply(i,n)}function h(e){return l=e,u=setTimeout(v,t),c?p(e):a}function g(e){var n=e-s;return void 0===s||n>=t||n<0||f&&e-l>=i}function v(){var e=Xh();if(g(e))return y(e);u=setTimeout(v,function(e){var n=t-(e-s);return f?Yh(n,i-(e-l)):n}(e))}function y(e){return u=void 0,d&&r?p(e):(r=o=void 0,a)}function m(){var e=Xh(),n=g(e);if(r=arguments,o=this,s=e,n){if(void 0===u)return h(s);if(f)return u=setTimeout(v,t),p(s)}return void 0===u&&(u=setTimeout(v,t)),a}return t=Qh(t)||0,Jh(n)&&(c=!!n.leading,i=(f="maxWait"in n)?Kh(Qh(n.maxWait)||0,t):i,d="trailing"in n?!!n.trailing:d),m.cancel=function(){void 0!==u&&clearTimeout(u),l=0,r=s=o=u=void 0},m.flush=function(){return void 0===u?a:y(Xh())},m}function Jh(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function Qh(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==qh.call(e)}(e))return NaN;if(Jh(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=Jh(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(Mh,"");var n=$h.test(e);return n||Hh.test(e)?Vh(e.slice(2),n?2:8):zh.test(e)?NaN:+e}var eg=function(e,t,n){var r=!0,o=!0;if("function"!=typeof e)throw new TypeError("Expected a function");return Jh(n)&&(r="leading"in n?!!n.leading:r,o="trailing"in n?!!n.trailing:o),Zh(e,t,{leading:r,maxWait:t,trailing:o})};const tg={createElement:function(e,t){return document.createElement(e,t)},createElementNS:function(e,t,n){return document.createElementNS(e,t,n)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},getTextContent:function(e){return e.textContent},isElement:function(e){return 1===e.nodeType},isText:function(e){return 3===e.nodeType},isComment:function(e){return 8===e.nodeType}};function ng(e,t,n,r,o){return{sel:e,data:t,children:n,text:r,elm:o,key:void 0===t?void 0:t.key}}const rg=Array.isArray;function og(e){return"string"==typeof e||"number"==typeof e||e instanceof String||e instanceof Number}function ig(e){return void 0===e}function ag(e){return void 0!==e}const ug=ng("",{},[],void 0,void 0);function sg(e,t){var n,r;const o=e.key===t.key,i=(null===(n=e.data)||void 0===n?void 0:n.is)===(null===(r=t.data)||void 0===r?void 0:r.is);return e.sel===t.sel&&o&&i}function lg(e,t,n){var r;const o={};for(let i=t;i<=n;++i){const t=null===(r=e[i])||void 0===r?void 0:r.key;void 0!==t&&(o[t]=i)}return o}const cg=["create","update","remove","destroy","pre","post"];function fg(e,t){const n={create:[],update:[],remove:[],destroy:[],pre:[],post:[]},r=void 0!==t?t:tg;for(const t of cg)for(const r of e){const e=r[t];void 0!==e&&n[t].push(e)}function o(e){const t=e.id?"#"+e.id:"",n=e.getAttribute("class"),o=n?"."+n.split(" ").join("."):"";return ng(r.tagName(e).toLowerCase()+t+o,{},[],void 0,e)}function i(e,t){return function(){if(0==--t){const t=r.parentNode(e);r.removeChild(t,e)}}}function a(e,t){var o,i;let u,s=e.data;if(void 0!==s){const t=null===(o=s.hook)||void 0===o?void 0:o.init;ag(t)&&(t(e),s=e.data)}const l=e.children,c=e.sel;if("!"===c)ig(e.text)&&(e.text=""),e.elm=r.createComment(e.text);else if(void 0!==c){const o=c.indexOf("#"),f=c.indexOf(".",o),d=o>0?o:c.length,p=f>0?f:c.length,h=-1!==o||-1!==f?c.slice(0,Math.min(d,p)):c,g=e.elm=ag(s)&&ag(u=s.ns)?r.createElementNS(u,h,s):r.createElement(h,s);for(d<p&&g.setAttribute("id",c.slice(d+1,p)),f>0&&g.setAttribute("class",c.slice(p+1).replace(/\./g," ")),u=0;u<n.create.length;++u)n.create[u](ug,e);if(rg(l))for(u=0;u<l.length;++u){const e=l[u];null!=e&&r.appendChild(g,a(e,t))}else og(e.text)&&r.appendChild(g,r.createTextNode(e.text));const v=e.data.hook;ag(v)&&(null===(i=v.create)||void 0===i||i.call(v,ug,e),v.insert&&t.push(e))}else e.elm=r.createTextNode(e.text);return e.elm}function u(e,t,n,o,i,u){for(;o<=i;++o){const i=n[o];null!=i&&r.insertBefore(e,a(i,u),t)}}function s(e){var t,r;const o=e.data;if(void 0!==o){null===(r=null===(t=null==o?void 0:o.hook)||void 0===t?void 0:t.destroy)||void 0===r||r.call(t,e);for(let t=0;t<n.destroy.length;++t)n.destroy[t](e);if(void 0!==e.children)for(let t=0;t<e.children.length;++t){const n=e.children[t];null!=n&&"string"!=typeof n&&s(n)}}}function l(e,t,o,a){for(var u,l;o<=a;++o){let a,c;const f=t[o];if(null!=f)if(ag(f.sel)){s(f),a=n.remove.length+1,c=i(f.elm,a);for(let e=0;e<n.remove.length;++e)n.remove[e](f,c);const e=null===(l=null===(u=null==f?void 0:f.data)||void 0===u?void 0:u.hook)||void 0===l?void 0:l.remove;ag(e)?e(f,c):c()}else r.removeChild(e,f.elm)}}function c(e,t,o){var i,s,f,d,p;const h=null===(i=t.data)||void 0===i?void 0:i.hook;null===(s=null==h?void 0:h.prepatch)||void 0===s||s.call(h,e,t);const g=t.elm=e.elm,v=e.children,y=t.children;if(e!==t){if(void 0!==t.data){for(let r=0;r<n.update.length;++r)n.update[r](e,t);null===(d=null===(f=t.data.hook)||void 0===f?void 0:f.update)||void 0===d||d.call(f,e,t)}ig(t.text)?ag(v)&&ag(y)?v!==y&&function(e,t,n,o){let i,s,f,d,p=0,h=0,g=t.length-1,v=t[0],y=t[g],m=n.length-1,b=n[0],w=n[m];for(;p<=g&&h<=m;)null==v?v=t[++p]:null==y?y=t[--g]:null==b?b=n[++h]:null==w?w=n[--m]:sg(v,b)?(c(v,b,o),v=t[++p],b=n[++h]):sg(y,w)?(c(y,w,o),y=t[--g],w=n[--m]):sg(v,w)?(c(v,w,o),r.insertBefore(e,v.elm,r.nextSibling(y.elm)),v=t[++p],w=n[--m]):sg(y,b)?(c(y,b,o),r.insertBefore(e,y.elm,v.elm),y=t[--g],b=n[++h]):(void 0===i&&(i=lg(t,p,g)),s=i[b.key],ig(s)?r.insertBefore(e,a(b,o),v.elm):(f=t[s],f.sel!==b.sel?r.insertBefore(e,a(b,o),v.elm):(c(f,b,o),t[s]=void 0,r.insertBefore(e,f.elm,v.elm))),b=n[++h]);(p<=g||h<=m)&&(p>g?(d=null==n[m+1]?null:n[m+1].elm,u(e,d,n,h,m,o)):l(e,t,p,g))}(g,v,y,o):ag(y)?(ag(e.text)&&r.setTextContent(g,""),u(g,null,y,0,y.length-1,o)):ag(v)?l(g,v,0,v.length-1):ag(e.text)&&r.setTextContent(g,""):e.text!==t.text&&(ag(v)&&l(g,v,0,v.length-1),r.setTextContent(g,t.text)),null===(p=null==h?void 0:h.postpatch)||void 0===p||p.call(h,e,t)}}return function(e,t){let i,u,s;const f=[];for(i=0;i<n.pre.length;++i)n.pre[i]();for(function(e){return void 0!==e.sel}(e)||(e=o(e)),sg(e,t)?c(e,t,f):(u=e.elm,s=r.parentNode(u),a(t,f),null!==s&&(r.insertBefore(s,t.elm,r.nextSibling(u)),l(s,[e],0,0))),i=0;i<f.length;++i)f[i].data.hook.insert(f[i]);for(i=0;i<n.post.length;++i)n.post[i]();return t}}function dg(e,t,n){if(e.ns="http://www.w3.org/2000/svg","foreignObject"!==n&&void 0!==t)for(let e=0;e<t.length;++e){const n=t[e].data;void 0!==n&&dg(n,t[e].children,t[e].sel)}}function pg(e,t,n){let r,o,i,a={};if(void 0!==n?(null!==t&&(a=t),rg(n)?r=n:og(n)?o=n.toString():n&&n.sel&&(r=[n])):null!=t&&(rg(t)?r=t:og(t)?o=t.toString():t&&t.sel?r=[t]:a=t),void 0!==r)for(i=0;i<r.length;++i)og(r[i])&&(r[i]=ng(void 0,void 0,void 0,r[i],void 0));return"s"!==e[0]||"v"!==e[1]||"g"!==e[2]||3!==e.length&&"."!==e[3]&&"#"!==e[3]||dg(a,r,e),ng(e,a,r,o,void 0)}function hg(e,t){let n;const r=t.elm;let o=e.data.attrs,i=t.data.attrs;if((o||i)&&o!==i){for(n in o=o||{},i=i||{},i){const e=i[n];o[n]!==e&&(!0===e?r.setAttribute(n,""):!1===e?r.removeAttribute(n):120!==n.charCodeAt(0)?r.setAttribute(n,e):58===n.charCodeAt(3)?r.setAttributeNS("http://www.w3.org/XML/1998/namespace",n,e):58===n.charCodeAt(5)?r.setAttributeNS("http://www.w3.org/1999/xlink",n,e):r.setAttribute(n,e))}for(n in o)n in i||r.removeAttribute(n)}}const gg={create:hg,update:hg};function vg(e,t){let n,r;const o=t.elm;let i=e.data.class,a=t.data.class;if((i||a)&&i!==a){for(r in i=i||{},a=a||{},i)i[r]&&!Object.prototype.hasOwnProperty.call(a,r)&&o.classList.remove(r);for(r in a)n=a[r],n!==i[r]&&o.classList[n?"add":"remove"](r)}}const yg={create:vg,update:vg},mg=/[A-Z]/g;function bg(e,t){const n=t.elm;let r,o=e.data.dataset,i=t.data.dataset;if(!o&&!i)return;if(o===i)return;o=o||{},i=i||{};const a=n.dataset;for(r in o)i[r]||(a?r in a&&delete a[r]:n.removeAttribute("data-"+r.replace(mg,"-$&").toLowerCase()));for(r in i)o[r]!==i[r]&&(a?a[r]=i[r]:n.setAttribute("data-"+r.replace(mg,"-$&").toLowerCase(),i[r]))}const wg={create:bg,update:bg};function Eg(e,t,n){if("function"==typeof e)e.call(t,n,t);else if("object"==typeof e)for(let r=0;r<e.length;r++)Eg(e[r],t,n)}function Dg(e,t){const n=e.type,r=t.data.on;r&&r[n]&&Eg(r[n],t,e)}function Sg(e,t){const n=e.data.on,r=e.listener,o=e.elm,i=t&&t.data.on,a=t&&t.elm;let u;if(n!==i){if(n&&r)if(i)for(u in n)i[u]||o.removeEventListener(u,r,!1);else for(u in n)o.removeEventListener(u,r,!1);if(i){const r=t.listener=e.listener||function e(t){Dg(t,e.vnode)};if(r.vnode=t,n)for(u in i)n[u]||a.addEventListener(u,r,!1);else for(u in i)a.addEventListener(u,r,!1)}}}const xg={create:Sg,update:Sg,destroy:Sg};function Cg(e,t){let n,r,o;const i=t.elm;let a=e.data.props,u=t.data.props;if((a||u)&&a!==u)for(n in a=a||{},u=u||{},u)r=u[n],o=a[n],o===r||"value"===n&&i[n]===r||(i[n]=r)}const Ag={create:Cg,update:Cg},Og="undefined"!=typeof window&&window.requestAnimationFrame.bind(window)||setTimeout;let kg=!1;function Bg(e,t,n){!function(e){Og((function(){Og(e)}))}((function(){e[t]=n}))}function Fg(e,t){let n,r;const o=t.elm;let i=e.data.style,a=t.data.style;if(!i&&!a)return;if(i===a)return;i=i||{},a=a||{};const u="delayed"in i;for(r in i)a[r]||("-"===r[0]&&"-"===r[1]?o.style.removeProperty(r):o.style[r]="");for(r in a)if(n=a[r],"delayed"===r&&a.delayed)for(const e in a.delayed)n=a.delayed[e],u&&n===i.delayed[e]||Bg(o.style,e,n);else"remove"!==r&&n!==i[r]&&("-"===r[0]&&"-"===r[1]?o.style.setProperty(r,n):o.style[r]=n)}const Tg={pre:function(){kg=!1},create:Fg,update:Fg,destroy:function(e){let t,n;const r=e.elm,o=e.data.style;if(o&&(t=o.destroy))for(n in t)r.style[n]=t[n]},remove:function(e,t){const n=e.data.style;if(!n||!n.remove)return void t();let r;kg||(e.elm.offsetLeft,kg=!0);const o=e.elm;let i=0;const a=n.remove;let u=0;const s=[];for(r in a)s.push(r),o.style[r]=a[r];const l=getComputedStyle(o)["transition-property"].split(", ");for(;i<l.length;++i)-1!==s.indexOf(l[i])&&u++;o.addEventListener("transitionend",(function(e){e.target===o&&--u,0===u&&t()}))}};function _g(e,t){for(const n of e)null!=n&&!1!==n&&""!==n&&(Array.isArray(n)?_g(n,t):"string"==typeof n||"number"==typeof n||"boolean"==typeof n?t.push(ng(void 0,void 0,void 0,String(n),void 0)):t.push(n));return t}function Pg(e,t,...n){const r=_g(n,[]);return"function"==typeof e?e(t,r):1===r.length&&!r[0].sel&&r[0].text?pg(e,t,r[0].text):pg(e,t,r)}Pg||(Pg={});var jg=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Ng=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ig="\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",Lg="[\\ud800-\\udfff]",Rg="["+Ig+"]",Mg="[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]",zg="\\d+",$g="[\\u2700-\\u27bf]",Hg="[a-z\\xdf-\\xf6\\xf8-\\xff]",Vg="[^\\ud800-\\udfff"+Ig+zg+"\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",Ug="\\ud83c[\\udffb-\\udfff]",Wg="[^\\ud800-\\udfff]",Gg="(?:\\ud83c[\\udde6-\\uddff]){2}",qg="[\\ud800-\\udbff][\\udc00-\\udfff]",Kg="[A-Z\\xc0-\\xd6\\xd8-\\xde]",Yg="(?:"+Hg+"|"+Vg+")",Xg="(?:"+Kg+"|"+Vg+")",Zg="(?:"+Mg+"|"+Ug+")"+"?",Jg="[\\ufe0e\\ufe0f]?"+Zg+("(?:\\u200d(?:"+[Wg,Gg,qg].join("|")+")[\\ufe0e\\ufe0f]?"+Zg+")*"),Qg="(?:"+[$g,Gg,qg].join("|")+")"+Jg,ev="(?:"+[Wg+Mg+"?",Mg,Gg,qg,Lg].join("|")+")",tv=RegExp("['â]","g"),nv=RegExp(Mg,"g"),rv=RegExp(Ug+"(?="+Ug+")|"+ev+Jg,"g"),ov=RegExp([Kg+"?"+Hg+"+(?:['â](?:d|ll|m|re|s|t|ve))?(?="+[Rg,Kg,"$"].join("|")+")",Xg+"+(?:['â](?:D|LL|M|RE|S|T|VE))?(?="+[Rg,Kg+Yg,"$"].join("|")+")",Kg+"?"+Yg+"+(?:['â](?:d|ll|m|re|s|t|ve))?",Kg+"+(?:['â](?:D|LL|M|RE|S|T|VE))?",zg,Qg].join("|"),"g"),iv=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"),av=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,uv="object"==typeof e&&e&&e.Object===Object&&e,sv="object"==typeof self&&self&&self.Object===Object&&self,lv=uv||sv||Function("return this")();var cv,fv=(cv={"Ã":"A","Ã":"A","Ã":"A","Ã":"A","Ã":"A","Ã":"A","Ã ":"a","Ã¡":"a","Ã¢":"a","Ã£":"a","Ã¤":"a","Ã¥":"a","Ã":"C","Ã§":"c","Ã":"D","Ã°":"d","Ã":"E","Ã":"E","Ã":"E","Ã":"E","Ã¨":"e","Ã©":"e","Ãª":"e","Ã«":"e","Ã":"I","Ã":"I","Ã":"I","Ã":"I","Ã¬":"i","Ã­":"i","Ã®":"i","Ã¯":"i","Ã":"N","Ã±":"n","Ã":"O","Ã":"O","Ã":"O","Ã":"O","Ã":"O","Ã":"O","Ã²":"o","Ã³":"o","Ã´":"o","Ãµ":"o","Ã¶":"o","Ã¸":"o","Ã":"U","Ã":"U","Ã":"U","Ã":"U","Ã¹":"u","Ãº":"u","Ã»":"u","Ã¼":"u","Ã":"Y","Ã½":"y","Ã¿":"y","Ã":"Ae","Ã¦":"ae","Ã":"Th","Ã¾":"th","Ã":"ss","Ä":"A","Ä":"A","Ä":"A","Ä":"a","Ä":"a","Ä":"a","Ä":"C","Ä":"C","Ä":"C","Ä":"C","Ä":"c","Ä":"c","Ä":"c","Ä":"c","Ä":"D","Ä":"D","Ä":"d","Ä":"d","Ä":"E","Ä":"E","Ä":"E","Ä":"E","Ä":"E","Ä":"e","Ä":"e","Ä":"e","Ä":"e","Ä":"e","Ä":"G","Ä":"G","Ä ":"G","Ä¢":"G","Ä":"g","Ä":"g","Ä¡":"g","Ä£":"g","Ä¤":"H","Ä¦":"H","Ä¥":"h","Ä§":"h","Ä¨":"I","Äª":"I","Ä¬":"I","Ä®":"I","Ä°":"I","Ä©":"i","Ä«":"i","Ä­":"i","Ä¯":"i","Ä±":"i","Ä´":"J","Äµ":"j","Ä¶":"K","Ä·":"k","Ä¸":"k","Ä¹":"L","Ä»":"L","Ä½":"L","Ä¿":"L","Å":"L","Äº":"l","Ä¼":"l","Ä¾":"l","Å":"l","Å":"l","Å":"N","Å":"N","Å":"N","Å":"N","Å":"n","Å":"n","Å":"n","Å":"n","Å":"O","Å":"O","Å":"O","Å":"o","Å":"o","Å":"o","Å":"R","Å":"R","Å":"R","Å":"r","Å":"r","Å":"r","Å":"S","Å":"S","Å":"S","Å ":"S","Å":"s","Å":"s","Å":"s","Å¡":"s","Å¢":"T","Å¤":"T","Å¦":"T","Å£":"t","Å¥":"t","Å§":"t","Å¨":"U","Åª":"U","Å¬":"U","Å®":"U","Å°":"U","Å²":"U","Å©":"u","Å«":"u","Å­":"u","Å¯":"u","Å±":"u","Å³":"u","Å´":"W","Åµ":"w","Å¶":"Y","Å·":"y","Å¸":"Y","Å¹":"Z","Å»":"Z","Å½":"Z","Åº":"z","Å¼":"z","Å¾":"z","Ä²":"IJ","Ä³":"ij","Å":"Oe","Å":"oe","Å":"'n","Å¿":"ss"},function(e){return null==cv?void 0:cv[e]});function dv(e){return iv.test(e)}function pv(e){return dv(e)?function(e){return e.match(rv)||[]}(e):function(e){return e.split("")}(e)}var hv=Object.prototype.toString,gv=lv.Symbol,vv=gv?gv.prototype:void 0,yv=vv?vv.toString:void 0;function mv(e){if("string"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==hv.call(e)}(e))return yv?yv.call(e):"";var t=e+"";return"0"==t&&1/e==-Infinity?"-0":t}function bv(e,t,n){var r=e.length;return n=void 0===n?r:n,!t&&n>=r?e:function(e,t,n){var r=-1,o=e.length;t<0&&(t=-t>o?0:o+t),(n=n>o?o:n)<0&&(n+=o),o=t>n?0:n-t>>>0,t>>>=0;for(var i=Array(o);++r<o;)i[r]=e[r+t];return i}(e,t,n)}function wv(e){return null==e?"":mv(e)}var Ev,Dv=(Ev=function(e,t,n){return t=t.toLowerCase(),e+(n?xv(wv(t).toLowerCase()):t)},function(e){return function(e,t,n,r){var o=-1,i=e?e.length:0;for(r&&i&&(n=e[++o]);++o<i;)n=t(n,e[o],o,e);return n}(function(e,t,n){return e=wv(e),void 0===(t=n?void 0:t)?function(e){return av.test(e)}(e)?function(e){return e.match(ov)||[]}(e):function(e){return e.match(jg)||[]}(e):e.match(t)||[]}(function(e){return(e=wv(e))&&e.replace(Ng,fv).replace(nv,"")}(e).replace(tv,"")),Ev,"")});var Sv,xv=(Sv="toUpperCase",function(e){var t=dv(e=wv(e))?pv(e):void 0,n=t?t[0]:e.charAt(0),r=t?bv(t,1).join(""):e.slice(1);return n[Sv]()+r});for(var Cv=Dv,Av="undefined"!=typeof window&&/Mac|iPod|iPhone|iPad/.test(window.navigator.platform),Ov={alt:"altKey",control:"ctrlKey",meta:"metaKey",shift:"shiftKey"},kv={add:"+",break:"pause",cmd:"meta",command:"meta",ctl:"control",ctrl:"control",del:"delete",down:"arrowdown",esc:"escape",ins:"insert",left:"arrowleft",mod:Av?"meta":"control",opt:"alt",option:"alt",return:"enter",right:"arrowright",space:" ",spacebar:" ",up:"arrowup",win:"meta",windows:"meta"},Bv={backspace:8,tab:9,enter:13,shift:16,control:17,alt:18,pause:19,capslock:20,escape:27," ":32,pageup:33,pagedown:34,end:35,home:36,arrowleft:37,arrowup:38,arrowright:39,arrowdown:40,insert:45,delete:46,meta:91,numlock:144,scrolllock:145,";":186,"=":187,",":188,"-":189,".":190,"/":191,"`":192,"[":219,"\\":220,"]":221,"'":222},Fv=1;Fv<20;Fv++)Bv["f"+Fv]=111+Fv;function Tv(e,t,n){t&&!("byKey"in t)&&(n=t,t=null),Array.isArray(e)||(e=[e]);var r=e.map((function(e){return function(e,t){var n=t&&t.byKey,r={},o=(e=e.replace("++","+add")).split("+"),i=o.length;for(var a in Ov)r[Ov[a]]=!1;var u=!0,s=!1,l=void 0;try{for(var c,f=o[Symbol.iterator]();!(u=(c=f.next()).done);u=!0){var d=c.value,p=d.endsWith("?")&&d.length>1;p&&(d=d.slice(0,-1));var h=Pv(d),g=Ov[h];if(d.length>1&&!g&&!kv[d]&&!Bv[h])throw new TypeError('Unknown modifier: "'+d+'"');1!==i&&g||(n?r.key=h:r.which=_v(d)),g&&(r[g]=!p||null)}}catch(e){s=!0,l=e}finally{try{!u&&f.return&&f.return()}finally{if(s)throw l}}return r}(e,t)})),o=function(e){return r.some((function(t){return function(e,t){for(var n in e){var r=e[n],o=void 0;if(null!=r&&((null!=(o="key"===n&&null!=t.key?t.key.toLowerCase():"which"===n?91===r&&93===t.which?91:t.which:t[n])||!1!==r)&&o!==r))return!1}return!0}(t,e)}))};return null==n?o:o(n)}function _v(e){return e=Pv(e),Bv[e]||e.toUpperCase().charCodeAt(0)}function Pv(e){return e=e.toLowerCase(),e=kv[e]||e}var jv=Tv,Nv=function(e,t){return Tv(e,{byKey:!0},t)},Iv=/^\s+|\s+$/g,Lv=/^[-+]0x[0-9a-f]+$/i,Rv=/^0b[01]+$/i,Mv=/^0o[0-7]+$/i,zv=parseInt,$v="object"==typeof e&&e&&e.Object===Object&&e,Hv="object"==typeof self&&self&&self.Object===Object&&self,Vv=$v||Hv||Function("return this")(),Uv=Object.prototype.toString,Wv=Math.max,Gv=Math.min,qv=function(){return Vv.Date.now()};function Kv(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function Yv(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==Uv.call(e)}(e))return NaN;if(Kv(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=Kv(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(Iv,"");var n=Rv.test(e);return n||Mv.test(e)?zv(e.slice(2),n?2:8):Lv.test(e)?NaN:+e}var Xv,Zv=function(e,t,n){var r,o,i,a,u,s,l=0,c=!1,f=!1,d=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function p(t){var n=r,i=o;return r=o=void 0,l=t,a=e.apply(i,n)}function h(e){return l=e,u=setTimeout(v,t),c?p(e):a}function g(e){var n=e-s;return void 0===s||n>=t||n<0||f&&e-l>=i}function v(){var e=qv();if(g(e))return y(e);u=setTimeout(v,function(e){var n=t-(e-s);return f?Gv(n,i-(e-l)):n}(e))}function y(e){return u=void 0,d&&r?p(e):(r=o=void 0,a)}function m(){var e=qv(),n=g(e);if(r=arguments,o=this,s=e,n){if(void 0===u)return h(s);if(f)return u=setTimeout(v,t),p(s)}return void 0===u&&(u=setTimeout(v,t)),a}return t=Yv(t)||0,Kv(n)&&(c=!!n.leading,i=(f="maxWait"in n)?Wv(Yv(n.maxWait)||0,t):i,d="trailing"in n?!!n.trailing:d),m.cancel=function(){void 0!==u&&clearTimeout(u),l=0,r=s=o=u=void 0},m.flush=function(){return void 0===u?a:y(qv())},m},Jv=n((function(t,n){var r="__lodash_hash_undefined__",o=9007199254740991,i="[object Arguments]",a="[object Boolean]",u="[object Date]",s="[object Function]",l="[object GeneratorFunction]",c="[object Map]",f="[object Number]",d="[object Object]",p="[object Promise]",h="[object RegExp]",g="[object Set]",v="[object String]",y="[object Symbol]",m="[object WeakMap]",b="[object ArrayBuffer]",w="[object DataView]",E="[object Float32Array]",D="[object Float64Array]",S="[object Int8Array]",x="[object Int16Array]",C="[object Int32Array]",A="[object Uint8Array]",O="[object Uint8ClampedArray]",k="[object Uint16Array]",B="[object Uint32Array]",F=/\w*$/,T=/^\[object .+?Constructor\]$/,_=/^(?:0|[1-9]\d*)$/,P={};P[i]=P["[object Array]"]=P[b]=P[w]=P[a]=P[u]=P[E]=P[D]=P[S]=P[x]=P[C]=P[c]=P[f]=P[d]=P[h]=P[g]=P[v]=P[y]=P[A]=P[O]=P[k]=P[B]=!0,P["[object Error]"]=P[s]=P[m]=!1;var j="object"==typeof e&&e&&e.Object===Object&&e,N="object"==typeof self&&self&&self.Object===Object&&self,I=j||N||Function("return this")(),L=n&&!n.nodeType&&n,R=L&&t&&!t.nodeType&&t,M=R&&R.exports===L;function z(e,t){return e.set(t[0],t[1]),e}function $(e,t){return e.add(t),e}function H(e,t,n,r){var o=-1,i=e?e.length:0;for(r&&i&&(n=e[++o]);++o<i;)n=t(n,e[o],o,e);return n}function V(e){var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(e){}return t}function U(e){var t=-1,n=Array(e.size);return e.forEach((function(e,r){n[++t]=[r,e]})),n}function W(e,t){return function(n){return e(t(n))}}function G(e){var t=-1,n=Array(e.size);return e.forEach((function(e){n[++t]=e})),n}var q=Array.prototype,K=Function.prototype,Y=Object.prototype,X=I["__core-js_shared__"],Z=function(){var e=/[^.]+$/.exec(X&&X.keys&&X.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),J=K.toString,Q=Y.hasOwnProperty,ee=Y.toString,te=RegExp("^"+J.call(Q).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ne=M?I.Buffer:void 0,re=I.Symbol,oe=I.Uint8Array,ie=W(Object.getPrototypeOf,Object),ae=Object.create,ue=Y.propertyIsEnumerable,se=q.splice,le=Object.getOwnPropertySymbols,ce=ne?ne.isBuffer:void 0,fe=W(Object.keys,Object),de=Le(I,"DataView"),pe=Le(I,"Map"),he=Le(I,"Promise"),ge=Le(I,"Set"),ve=Le(I,"WeakMap"),ye=Le(Object,"create"),me=He(de),be=He(pe),we=He(he),Ee=He(ge),De=He(ve),Se=re?re.prototype:void 0,xe=Se?Se.valueOf:void 0;function Ce(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}function Ae(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}function Oe(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}function ke(e){this.__data__=new Ae(e)}function Be(e,t){var n=Ue(e)||function(e){return function(e){return function(e){return!!e&&"object"==typeof e}(e)&&We(e)}(e)&&Q.call(e,"callee")&&(!ue.call(e,"callee")||ee.call(e)==i)}(e)?function(e,t){for(var n=-1,r=Array(e);++n<e;)r[n]=t(n);return r}(e.length,String):[],r=n.length,o=!!r;for(var a in e)!t&&!Q.call(e,a)||o&&("length"==a||ze(a,r))||n.push(a);return n}function Fe(e,t,n){var r=e[t];Q.call(e,t)&&Ve(r,n)&&(void 0!==n||t in e)||(e[t]=n)}function Te(e,t){for(var n=e.length;n--;)if(Ve(e[n][0],t))return n;return-1}function _e(e,t,n,r,o,p,m){var T;if(r&&(T=p?r(e,o,p,m):r(e)),void 0!==T)return T;if(!Ke(e))return e;var _=Ue(e);if(_){if(T=function(e){var t=e.length,n=e.constructor(t);t&&"string"==typeof e[0]&&Q.call(e,"index")&&(n.index=e.index,n.input=e.input);return n}(e),!t)return function(e,t){var n=-1,r=e.length;t||(t=Array(r));for(;++n<r;)t[n]=e[n];return t}(e,T)}else{var j=Me(e),N=j==s||j==l;if(Ge(e))return function(e,t){if(t)return e.slice();var n=new e.constructor(e.length);return e.copy(n),n}(e,t);if(j==d||j==i||N&&!p){if(V(e))return p?e:{};if(T=function(e){return"function"!=typeof e.constructor||$e(e)?{}:(t=ie(e),Ke(t)?ae(t):{});// removed by dead control flow
{ var t; }}(N?{}:e),!t)return function(e,t){return Ne(e,Re(e),t)}(e,function(e,t){return e&&Ne(t,Ye(t),e)}(T,e))}else{if(!P[j])return p?e:{};T=function(e,t,n,r){var o=e.constructor;switch(t){case b:return je(e);case a:case u:return new o(+e);case w:return function(e,t){var n=t?je(e.buffer):e.buffer;return new e.constructor(n,e.byteOffset,e.byteLength)}(e,r);case E:case D:case S:case x:case C:case A:case O:case k:case B:return function(e,t){var n=t?je(e.buffer):e.buffer;return new e.constructor(n,e.byteOffset,e.length)}(e,r);case c:return function(e,t,n){return H(t?n(U(e),!0):U(e),z,new e.constructor)}(e,r,n);case f:case v:return new o(e);case h:return function(e){var t=new e.constructor(e.source,F.exec(e));return t.lastIndex=e.lastIndex,t}(e);case g:return function(e,t,n){return H(t?n(G(e),!0):G(e),$,new e.constructor)}(e,r,n);case y:return function(e){return xe?Object(xe.call(e)):{}}(e)}}(e,j,_e,t)}}m||(m=new ke);var I=m.get(e);if(I)return I;if(m.set(e,T),!_)var L=n?function(e){return function(e,t,n){var r=t(e);return Ue(e)?r:function(e,t){for(var n=-1,r=t.length,o=e.length;++n<r;)e[o+n]=t[n];return e}(r,n(e))}(e,Ye,Re)}(e):Ye(e);return function(e,t){for(var n=-1,r=e?e.length:0;++n<r&&!1!==t(e[n],n,e););}(L||e,(function(o,i){L&&(o=e[i=o]),Fe(T,i,_e(o,t,n,r,i,e,m))})),T}function Pe(e){return!(!Ke(e)||function(e){return!!Z&&Z in e}(e))&&(qe(e)||V(e)?te:T).test(He(e))}function je(e){var t=new e.constructor(e.byteLength);return new oe(t).set(new oe(e)),t}function Ne(e,t,n,r){n||(n={});for(var o=-1,i=t.length;++o<i;){var a=t[o],u=r?r(n[a],e[a],a,n,e):void 0;Fe(n,a,void 0===u?e[a]:u)}return n}function Ie(e,t){var n,r,o=e.__data__;return("string"==(r=typeof(n=t))||"number"==r||"symbol"==r||"boolean"==r?"__proto__"!==n:null===n)?o["string"==typeof t?"string":"hash"]:o.map}function Le(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return Pe(n)?n:void 0}Ce.prototype.clear=function(){this.__data__=ye?ye(null):{}},Ce.prototype.delete=function(e){return this.has(e)&&delete this.__data__[e]},Ce.prototype.get=function(e){var t=this.__data__;if(ye){var n=t[e];return n===r?void 0:n}return Q.call(t,e)?t[e]:void 0},Ce.prototype.has=function(e){var t=this.__data__;return ye?void 0!==t[e]:Q.call(t,e)},Ce.prototype.set=function(e,t){return this.__data__[e]=ye&&void 0===t?r:t,this},Ae.prototype.clear=function(){this.__data__=[]},Ae.prototype.delete=function(e){var t=this.__data__,n=Te(t,e);return!(n<0)&&(n==t.length-1?t.pop():se.call(t,n,1),!0)},Ae.prototype.get=function(e){var t=this.__data__,n=Te(t,e);return n<0?void 0:t[n][1]},Ae.prototype.has=function(e){return Te(this.__data__,e)>-1},Ae.prototype.set=function(e,t){var n=this.__data__,r=Te(n,e);return r<0?n.push([e,t]):n[r][1]=t,this},Oe.prototype.clear=function(){this.__data__={hash:new Ce,map:new(pe||Ae),string:new Ce}},Oe.prototype.delete=function(e){return Ie(this,e).delete(e)},Oe.prototype.get=function(e){return Ie(this,e).get(e)},Oe.prototype.has=function(e){return Ie(this,e).has(e)},Oe.prototype.set=function(e,t){return Ie(this,e).set(e,t),this},ke.prototype.clear=function(){this.__data__=new Ae},ke.prototype.delete=function(e){return this.__data__.delete(e)},ke.prototype.get=function(e){return this.__data__.get(e)},ke.prototype.has=function(e){return this.__data__.has(e)},ke.prototype.set=function(e,t){var n=this.__data__;if(n instanceof Ae){var r=n.__data__;if(!pe||r.length<199)return r.push([e,t]),this;n=this.__data__=new Oe(r)}return n.set(e,t),this};var Re=le?W(le,Object):function(){return[]},Me=function(e){return ee.call(e)};function ze(e,t){return!!(t=null==t?o:t)&&("number"==typeof e||_.test(e))&&e>-1&&e%1==0&&e<t}function $e(e){var t=e&&e.constructor;return e===("function"==typeof t&&t.prototype||Y)}function He(e){if(null!=e){try{return J.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function Ve(e,t){return e===t||e!=e&&t!=t}(de&&Me(new de(new ArrayBuffer(1)))!=w||pe&&Me(new pe)!=c||he&&Me(he.resolve())!=p||ge&&Me(new ge)!=g||ve&&Me(new ve)!=m)&&(Me=function(e){var t=ee.call(e),n=t==d?e.constructor:void 0,r=n?He(n):void 0;if(r)switch(r){case me:return w;case be:return c;case we:return p;case Ee:return g;case De:return m}return t});var Ue=Array.isArray;function We(e){return null!=e&&function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=o}(e.length)&&!qe(e)}var Ge=ce||function(){return!1};function qe(e){var t=Ke(e)?ee.call(e):"";return t==s||t==l}function Ke(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function Ye(e){return We(e)?Be(e):function(e){if(!$e(e))return fe(e);var t=[];for(var n in Object(e))Q.call(e,n)&&"constructor"!=n&&t.push(n);return t}(e)}t.exports=function(e){return _e(e,!0,!0)}}));function Qv(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var ey=0;function ty(e){return"__private_"+ey+++"_"+e}function ny(e,t,n){const r=[];return e.forEach((e=>"string"!=typeof e?r.push(e):t[Symbol.split](e).forEach(((e,t,o)=>{""!==e&&r.push(e),t<o.length-1&&r.push(n)})))),r}
/**
 * Takes a string with placeholder variables like `%{smart_count} file selected`
 * and replaces it with values from options `{smart_count: 5}`
 *
 * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE
 * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299
 *
 * @param {string} phrase that needs interpolation, with placeholders
 * @param {object} options with values that will be used to replace placeholders
 * @returns {any[]} interpolated
 */function ry(e,t){const n=/\$/g;let r=[e];if(null==t)return r;for(const e of Object.keys(t))if("_"!==e){let o=t[e];"string"==typeof o&&(o=n[Symbol.replace](o,"$$$$")),r=ny(r,new RegExp(`%\\{${e}\\}`,"g"),o)}return r}var oy=(Xv=ty("apply"),class{constructor(e){Object.defineProperty(this,Xv,{value:iy}),this.locale={strings:{},pluralize:e=>1===e?0:1},Array.isArray(e)?e.forEach(Qv(this,Xv)[Xv],this):Qv(this,Xv)[Xv](e)}translate(e,t){return this.translateArray(e,t).join("")}translateArray(e,t){if(!function(e,t){return Object.prototype.hasOwnProperty.call(e,t)}(this.locale.strings,e))throw new Error(`missing string: ${e}`);const n=this.locale.strings[e];if("object"==typeof n){if(t&&void 0!==t.smart_count){return ry(n[this.locale.pluralize(t.smart_count)],t)}throw new Error("Attempted to use a string with plural forms, but no value was given for %{smart_count}")}return ry(n,t)}});function iy(e){if(null==e||!e.strings)return;const t=this.locale;this.locale={...t,strings:{...t.strings,...e.strings}},this.locale.pluralize=e.pluralize||t.pluralize}var ay=function(){var e={},t=e._fns={};return e.emit=function(e,n,r,o,i,a,u){var s=function(e){var n=t[e]?t[e]:[],r=e.indexOf(":"),o=-1===r?[e]:[e.substring(0,r),e.substring(r+1)],i=Object.keys(t),a=0,u=i.length;for(;a<u;a++){var s=i[a];if("*"===s&&(n=n.concat(t[s])),2===o.length&&o[0]===s){n=n.concat(t[s]);break}}return n}(e);s.length&&function(e,t,n){var r=0,o=t.length;for(;r<o&&t[r];r++)t[r].event=e,t[r].apply(t[r],n)}(e,s,[n,r,o,i,a,u])},e.on=function(e,n){t[e]||(t[e]=[]),t[e].push(n)},e.once=function(t,n){this.on(t,(function r(){n.apply(this,arguments),e.off(t,r)}))},e.off=function(e,t){var n=[];if(e&&t)for(var r=this._fns[e],o=0,i=r?r.length:0;o<i;o++)r[o]!==t&&n.push(r[o]);n.length?this._fns[e]=n:delete this._fns[e]},e};var uy={urlAlphabet:"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"};let{urlAlphabet:sy}=uy,ly=e=>crypto.getRandomValues(new Uint8Array(e)),cy=(e,t,n)=>{let r=(2<<Math.log(e.length-1)/Math.LN2)-1,o=-~(1.6*r*t/e.length);return()=>{let i="";for(;;){let a=n(o),u=o;for(;u--;)if(i+=e[a[u]&r]||"",i.length===t)return i}}};var fy={nanoid:(e=21)=>{let t="",n=crypto.getRandomValues(new Uint8Array(e));for(;e--;){let r=63&n[e];t+=r<36?r.toString(36):r<62?(r-26).toString(36).toUpperCase():r<63?"_":"-"}return t},customAlphabet:(e,t)=>cy(e,t,ly),customRandom:cy,urlAlphabet:sy,random:ly},dy=function(e){if("number"!=typeof e||isNaN(e))throw new TypeError("Expected a number, got "+typeof e);var t=e<0,n=["B","KB","MB","GB","TB","PB","EB","ZB","YB"];if(t&&(e=-e),e<1)return(t?"-":"")+e+" B";var r=Math.min(Math.floor(Math.log(e)/Math.log(1024)),n.length-1);e=Number(e/Math.pow(1024,r));var o=n[r];return e>=10||e%1==0?(t?"-":"")+e.toFixed(0)+" "+o:(t?"-":"")+e.toFixed(1)+" "+o};function py(e,t){this.text=e=e||"",this.hasWild=~e.indexOf("*"),this.separator=t,this.parts=e.split(t)}py.prototype.match=function(e){var t,n,r=!0,o=this.parts,i=o.length;if("string"==typeof e||e instanceof String)if(this.hasWild||this.text==e){for(n=(e||"").split(this.separator),t=0;r&&t<i;t++)"*"!==o[t]&&(r=t<n.length&&o[t]===n[t]);r=r&&n}else r=!1;else if("function"==typeof e.splice)for(r=[],t=e.length;t--;)this.match(e[t])&&(r[r.length]=e[t]);else if("object"==typeof e)for(var a in r={},e)this.match(a)&&(r[a]=e[a]);return r};var hy=/[\/\+\.]/,gy=function(e,t){function n(t){var n=function(e,t,n){var r=new py(e,n||/[\/\.]/);return void 0!==t?r.match(t):r}(t,e,hy);return n&&n.length>=2}return t?n(t.split(";")[0]):n};var vy=0;function yy(e){return"__private_"+vy+++"_"+e}var my=yy("publish");class by{constructor(){Object.defineProperty(this,my,{value:wy}),this.state={},this.callbacks=[]}getState(){return this.state}setState(e){const t={...this.state},n={...this.state,...e};this.state=n,function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}(this,my)[my](t,n,e)}subscribe(e){return this.callbacks.push(e),()=>{this.callbacks.splice(this.callbacks.indexOf(e),1)}}}function wy(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this.callbacks.forEach((e=>{e(...t)}))}by.VERSION="2.0.3";var Ey=function(e){const t=e.lastIndexOf(".");return-1===t||t===e.length-1?{name:e,extension:void 0}:{name:e.slice(0,t),extension:e.slice(t+1)}},Dy={md:"text/markdown",markdown:"text/markdown",mp4:"video/mp4",mp3:"audio/mp3",svg:"image/svg+xml",jpg:"image/jpeg",png:"image/png",gif:"image/gif",heic:"image/heic",heif:"image/heif",yaml:"text/yaml",yml:"text/yaml",csv:"text/csv",tsv:"text/tab-separated-values",tab:"text/tab-separated-values",avi:"video/x-msvideo",mks:"video/x-matroska",mkv:"video/x-matroska",mov:"video/quicktime",doc:"application/msword",docm:"application/vnd.ms-word.document.macroenabled.12",docx:"application/vnd.openxmlformats-officedocument.wordprocessingml.document",dot:"application/msword",dotm:"application/vnd.ms-word.template.macroenabled.12",dotx:"application/vnd.openxmlformats-officedocument.wordprocessingml.template",xla:"application/vnd.ms-excel",xlam:"application/vnd.ms-excel.addin.macroenabled.12",xlc:"application/vnd.ms-excel",xlf:"application/x-xliff+xml",xlm:"application/vnd.ms-excel",xls:"application/vnd.ms-excel",xlsb:"application/vnd.ms-excel.sheet.binary.macroenabled.12",xlsm:"application/vnd.ms-excel.sheet.macroenabled.12",xlsx:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",xlt:"application/vnd.ms-excel",xltm:"application/vnd.ms-excel.template.macroenabled.12",xltx:"application/vnd.openxmlformats-officedocument.spreadsheetml.template",xlw:"application/vnd.ms-excel",txt:"text/plain",text:"text/plain",conf:"text/plain",log:"text/plain",pdf:"application/pdf",zip:"application/zip","7z":"application/x-7z-compressed",rar:"application/x-rar-compressed",tar:"application/x-tar",gz:"application/gzip",dmg:"application/x-apple-diskimage"};function Sy(e){let t="";return e.replace(/[^A-Z0-9]/gi,(e=>(t+=`-${function(e){return e.charCodeAt(0).toString(32)}(e)}`,"/")))+t}var xy=function(e){if(null==e&&(e="undefined"!=typeof navigator?navigator.userAgent:null),!e)return!0;const t=/Edge\/(\d+\.\d+)/.exec(e);if(!t)return!0;const n=t[1];let[r,o]=n.split(".");return r=parseInt(r,10),o=parseInt(o,10),r<15||15===r&&o<15063||(r>18||18===r&&o>=18218)};function Cy(e){return e<10?`0${e}`:e.toString()}var Ay=function(){const e=new Date;return`${Cy(e.getHours())}:${Cy(e.getMinutes())}:${Cy(e.getSeconds())}`};var Oy={justErrorsLogger:{debug:()=>{},warn:()=>{},error:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return console.error(`[Uppy] [${Ay()}]`,...t)}},debugLogger:{debug:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return console.debug(`[Uppy] [${Ay()}]`,...t)},warn:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return console.warn(`[Uppy] [${Ay()}]`,...t)},error:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return console.error(`[Uppy] [${Ay()}]`,...t)}}},ky={strings:{addBulkFilesFailed:{0:"Failed to add %{smart_count} file due to an internal error",1:"Failed to add %{smart_count} files due to internal errors"},youCanOnlyUploadX:{0:"You can only upload %{smart_count} file",1:"You can only upload %{smart_count} files"},youHaveToAtLeastSelectX:{0:"You have to select at least %{smart_count} file",1:"You have to select at least %{smart_count} files"},exceedsSize:"%{file} exceeds maximum allowed size of %{size}",missingRequiredMetaField:"Missing required meta fields",missingRequiredMetaFieldOnFile:"Missing required meta fields in %{fileName}",inferiorSize:"This file is smaller than the allowed size of %{size}",youCanOnlyUploadFileTypes:"You can only upload: %{types}",noMoreFilesAllowed:"Cannot add more files",noDuplicates:"Cannot add the duplicate file '%{fileName}', it already exists",companionError:"Connection with Companion failed",authAborted:"Authentication aborted",companionUnauthorizeHint:"To unauthorize to your %{provider} account, please go to %{url}",failedToUpload:"Failed to upload %{file}",noInternetConnection:"No Internet connection",connectedToInternet:"Connected to the Internet",noFilesFound:"You have no files or folders here",selectX:{0:"Select %{smart_count}",1:"Select %{smart_count}"},allFilesFromFolderNamed:"All files from folder %{name}",openFolderNamed:"Open folder %{name}",cancel:"Cancel",logOut:"Log out",filter:"Filter",resetFilter:"Reset filter",loading:"Loading...",authenticateWithTitle:"Please authenticate with %{pluginName} to select files",authenticateWith:"Connect to %{pluginName}",signInWithGoogle:"Sign in with Google",searchImages:"Search for images",enterTextToSearch:"Enter text to search for images",backToSearch:"Back to Search",emptyFolderAdded:"No files were added from empty folder",folderAlreadyAdded:'The folder "%{folder}" was already added',folderAdded:{0:"Added %{smart_count} file from %{folder}",1:"Added %{smart_count} files from %{folder}"}}},By=fy;let Fy,Ty;function _y(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var Py=0;function jy(e){return"__private_"+Py+++"_"+e}const{nanoid:Ny}=By,{justErrorsLogger:Iy,debugLogger:Ly}=Oy;class Ry extends Error{constructor(){super(...arguments),this.isRestriction=!0}}"undefined"==typeof AggregateError&&(globalThis.AggregateError=class extends Error{constructor(e,t){super(t),this.errors=e}});class My extends AggregateError{constructor(){super(...arguments),this.isRestriction=!0}}var zy=jy("plugins"),$y=jy("storeUnsubscribe"),Hy=jy("emitter"),Vy=jy("preProcessors"),Uy=jy("uploaders"),Wy=jy("postProcessors"),Gy=jy("checkRestrictions"),qy=jy("checkMinNumberOfFiles"),Ky=jy("checkRequiredMetaFieldsOnFile"),Yy=jy("checkRequiredMetaFields"),Xy=jy("showOrLogErrorAndThrow"),Zy=jy("assertNewUploadAllowed"),Jy=jy("checkAndCreateFileStateObject"),Qy=jy("startIfAutoProceed"),em=jy("addListeners"),tm=jy("updateOnlineStatus"),nm=jy("createUpload"),rm=jy("getUpload"),om=jy("removeUpload"),im=jy("runUpload");Fy=Symbol.for("uppy test: getPlugins"),Ty=Symbol.for("uppy test: createUpload");class am{constructor(e){Object.defineProperty(this,im,{value:bm}),Object.defineProperty(this,om,{value:mm}),Object.defineProperty(this,rm,{value:ym}),Object.defineProperty(this,nm,{value:vm}),Object.defineProperty(this,em,{value:gm}),Object.defineProperty(this,Qy,{value:hm}),Object.defineProperty(this,Jy,{value:pm}),Object.defineProperty(this,Zy,{value:dm}),Object.defineProperty(this,Xy,{value:fm}),Object.defineProperty(this,Yy,{value:cm}),Object.defineProperty(this,Ky,{value:lm}),Object.defineProperty(this,qy,{value:sm}),Object.defineProperty(this,Gy,{value:um}),Object.defineProperty(this,zy,{writable:!0,value:Object.create(null)}),Object.defineProperty(this,$y,{writable:!0,value:void 0}),Object.defineProperty(this,Hy,{writable:!0,value:ay()}),Object.defineProperty(this,Vy,{writable:!0,value:new Set}),Object.defineProperty(this,Uy,{writable:!0,value:new Set}),Object.defineProperty(this,Wy,{writable:!0,value:new Set}),Object.defineProperty(this,tm,{writable:!0,value:this.updateOnlineStatus.bind(this)}),this.defaultLocale=ky;const t={id:"uppy",autoProceed:!1,allowMultipleUploads:!0,allowMultipleUploadBatches:!0,debug:!1,restrictions:{maxFileSize:null,minFileSize:null,maxTotalFileSize:null,maxNumberOfFiles:null,minNumberOfFiles:null,allowedFileTypes:null,requiredMetaFields:[]},meta:{},onBeforeFileAdded:e=>e,onBeforeUpload:e=>e,store:new by,logger:Iy,infoTimeout:5e3};if(this.opts={...t,...e,restrictions:{...t.restrictions,...e&&e.restrictions}},e&&e.logger&&e.debug?this.log("You are using a custom `logger`, but also set `debug: true`, which uses built-in logger to output logs to console. Ignoring `debug: true` and using your custom `logger`.","warning"):e&&e.debug&&(this.opts.logger=Ly),this.log(`Using Core v${this.constructor.VERSION}`),this.opts.restrictions.allowedFileTypes&&null!==this.opts.restrictions.allowedFileTypes&&!Array.isArray(this.opts.restrictions.allowedFileTypes))throw new TypeError("`restrictions.allowedFileTypes` must be an array");this.i18nInit(),this.calculateProgress=eg(this.calculateProgress.bind(this),500,{leading:!0,trailing:!0}),this.store=this.opts.store,this.setState({plugins:{},files:{},currentUploads:{},allowNewUpload:!0,capabilities:{uploadProgress:xy(),individualCancellation:!0,resumableUploads:!1},totalProgress:0,meta:{...this.opts.meta},info:[],recoveredState:null}),_y(this,$y)[$y]=this.store.subscribe(((e,t,n)=>{this.emit("state-update",e,t,n),this.updateAll(t)})),this.opts.debug&&"undefined"!=typeof window&&(window[this.opts.id]=this),_y(this,em)[em]()}emit(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];_y(this,Hy)[Hy].emit(e,...n)}on(e,t){return _y(this,Hy)[Hy].on(e,t),this}once(e,t){return _y(this,Hy)[Hy].once(e,t),this}off(e,t){return _y(this,Hy)[Hy].off(e,t),this}updateAll(e){this.iteratePlugins((t=>{t.update(e)}))}setState(e){this.store.setState(e)}getState(){return this.store.getState()}get state(){return this.getState()}setFileState(e,t){if(!this.getState().files[e])throw new Error(`Canât set state for ${e} (the file could have been removed)`);this.setState({files:{...this.getState().files,[e]:{...this.getState().files[e],...t}}})}i18nInit(){const e=new oy([this.defaultLocale,this.opts.locale]);this.i18n=e.translate.bind(e),this.i18nArray=e.translateArray.bind(e),this.locale=e.locale}setOptions(e){this.opts={...this.opts,...e,restrictions:{...this.opts.restrictions,...e&&e.restrictions}},e.meta&&this.setMeta(e.meta),this.i18nInit(),e.locale&&this.iteratePlugins((e=>{e.setOptions()})),this.setState()}resetProgress(){const e={percentage:0,bytesUploaded:0,uploadComplete:!1,uploadStarted:null},t={...this.getState().files},n={};Object.keys(t).forEach((r=>{const o={...t[r]};o.progress={...o.progress,...e},n[r]=o})),this.setState({files:n,totalProgress:0}),this.emit("reset-progress")}addPreProcessor(e){_y(this,Vy)[Vy].add(e)}removePreProcessor(e){return _y(this,Vy)[Vy].delete(e)}addPostProcessor(e){_y(this,Wy)[Wy].add(e)}removePostProcessor(e){return _y(this,Wy)[Wy].delete(e)}addUploader(e){_y(this,Uy)[Uy].add(e)}removeUploader(e){return _y(this,Uy)[Uy].delete(e)}setMeta(e){const t={...this.getState().meta,...e},n={...this.getState().files};Object.keys(n).forEach((t=>{n[t]={...n[t],meta:{...n[t].meta,...e}}})),this.log("Adding metadata:"),this.log(e),this.setState({meta:t,files:n})}setFileMeta(e,t){const n={...this.getState().files};if(!n[e])return void this.log("Was trying to set metadata for a file that has been removed: ",e);const r={...n[e].meta,...t};n[e]={...n[e],meta:r},this.setState({files:n})}getFile(e){return this.getState().files[e]}getFiles(){const{files:e}=this.getState();return Object.values(e)}getObjectOfFilesPerState(){const{files:e,totalProgress:t,error:n}=this.getState(),r=Object.values(e),o=r.filter((e=>{let{progress:t}=e;return!t.uploadComplete&&t.uploadStarted})),i=r.filter((e=>!e.progress.uploadStarted)),a=r.filter((e=>e.progress.uploadStarted||e.progress.preprocess||e.progress.postprocess)),u=r.filter((e=>e.progress.uploadStarted)),s=r.filter((e=>e.isPaused)),l=r.filter((e=>e.progress.uploadComplete)),c=r.filter((e=>e.error)),f=o.filter((e=>!e.isPaused)),d=r.filter((e=>e.progress.preprocess||e.progress.postprocess));return{newFiles:i,startedFiles:a,uploadStartedFiles:u,pausedFiles:s,completeFiles:l,erroredFiles:c,inProgressFiles:o,inProgressNotPausedFiles:f,processingFiles:d,isUploadStarted:u.length>0,isAllComplete:100===t&&l.length===r.length&&0===d.length,isAllErrored:!!n&&c.length===r.length,isAllPaused:0!==o.length&&s.length===o.length,isUploadInProgress:o.length>0,isSomeGhost:r.some((e=>e.isGhost))}}validateRestrictions(e,t){try{return _y(this,Gy)[Gy](e,t),{result:!0}}catch(e){return{result:!1,reason:e.message}}}checkIfFileAlreadyExists(e){const{files:t}=this.getState();return!(!t[e]||t[e].isGhost)}addFile(e){_y(this,Zy)[Zy](e);const{files:t}=this.getState();let n=_y(this,Jy)[Jy](t,e);return t[n.id]&&t[n.id].isGhost&&(n={...t[n.id],data:e.data,isGhost:!1},this.log(`Replaced the blob in the restored ghost file: ${n.name}, ${n.id}`)),this.setState({files:{...t,[n.id]:n}}),this.emit("file-added",n),this.emit("files-added",[n]),this.log(`Added file: ${n.name}, ${n.id}, mime type: ${n.type}`),_y(this,Qy)[Qy](),n.id}addFiles(e){_y(this,Zy)[Zy]();const t={...this.getState().files},n=[],r=[];for(let o=0;o<e.length;o++)try{let r=_y(this,Jy)[Jy](t,e[o]);t[r.id]&&t[r.id].isGhost&&(r={...t[r.id],data:e[o].data,isGhost:!1},this.log(`Replaced blob in a ghost file: ${r.name}, ${r.id}`)),t[r.id]=r,n.push(r)}catch(e){e.isRestriction||r.push(e)}if(this.setState({files:t}),n.forEach((e=>{this.emit("file-added",e)})),this.emit("files-added",n),n.length>5?this.log(`Added batch of ${n.length} files`):Object.keys(n).forEach((e=>{this.log(`Added file: ${n[e].name}\n id: ${n[e].id}\n type: ${n[e].type}`)})),n.length>0&&_y(this,Qy)[Qy](),r.length>0){let e="Multiple errors occurred while adding files:\n";if(r.forEach((t=>{e+=`\n * ${t.message}`})),this.info({message:this.i18n("addBulkFilesFailed",{smart_count:r.length}),details:e},"error",this.opts.infoTimeout),"function"==typeof AggregateError)throw new AggregateError(r,e);{const t=new Error(e);throw t.errors=r,t}}}removeFiles(e,t){const{files:n,currentUploads:r}=this.getState(),o={...n},i={...r},a=Object.create(null);function u(e){return void 0===a[e]}e.forEach((e=>{n[e]&&(a[e]=n[e],delete o[e])})),Object.keys(i).forEach((e=>{const t=r[e].fileIDs.filter(u);0!==t.length?i[e]={...r[e],fileIDs:t}:delete i[e]}));const s={currentUploads:i,files:o};0===Object.keys(o).length&&(s.allowNewUpload=!0,s.error=null,s.recoveredState=null),this.setState(s),this.calculateTotalProgress();const l=Object.keys(a);l.forEach((e=>{this.emit("file-removed",a[e],t)})),l.length>5?this.log(`Removed ${l.length} files`):this.log(`Removed files: ${l.join(", ")}`)}removeFile(e,t){void 0===t&&(t=null),this.removeFiles([e],t)}pauseResume(e){if(!this.getState().capabilities.resumableUploads||this.getFile(e).uploadComplete)return;const t=!(this.getFile(e).isPaused||!1);return this.setFileState(e,{isPaused:t}),this.emit("upload-pause",e,t),t}pauseAll(){const e={...this.getState().files};Object.keys(e).filter((t=>!e[t].progress.uploadComplete&&e[t].progress.uploadStarted)).forEach((t=>{const n={...e[t],isPaused:!0};e[t]=n})),this.setState({files:e}),this.emit("pause-all")}resumeAll(){const e={...this.getState().files};Object.keys(e).filter((t=>!e[t].progress.uploadComplete&&e[t].progress.uploadStarted)).forEach((t=>{const n={...e[t],isPaused:!1,error:null};e[t]=n})),this.setState({files:e}),this.emit("resume-all")}retryAll(){const e={...this.getState().files},t=Object.keys(e).filter((t=>e[t].error));if(t.forEach((t=>{const n={...e[t],isPaused:!1,error:null};e[t]=n})),this.setState({files:e,error:null}),this.emit("retry-all",t),0===t.length)return Promise.resolve({successful:[],failed:[]});const n=_y(this,nm)[nm](t,{forceAllowNewUpload:!0});return _y(this,im)[im](n)}cancelAll(){this.emit("cancel-all");const{files:e}=this.getState(),t=Object.keys(e);t.length&&this.removeFiles(t,"cancel-all"),this.setState({totalProgress:0,error:null,recoveredState:null})}retryUpload(e){this.setFileState(e,{error:null,isPaused:!1}),this.emit("upload-retry",e);const t=_y(this,nm)[nm]([e],{forceAllowNewUpload:!0});return _y(this,im)[im](t)}reset(){this.cancelAll()}logout(){this.iteratePlugins((e=>{e.provider&&e.provider.logout&&e.provider.logout()}))}calculateProgress(e,t){if(!this.getFile(e.id))return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);const n=Number.isFinite(t.bytesTotal)&&t.bytesTotal>0;this.setFileState(e.id,{progress:{...this.getFile(e.id).progress,bytesUploaded:t.bytesUploaded,bytesTotal:t.bytesTotal,percentage:n?Math.round(t.bytesUploaded/t.bytesTotal*100):0}}),this.calculateTotalProgress()}calculateTotalProgress(){const e=this.getFiles().filter((e=>e.progress.uploadStarted||e.progress.preprocess||e.progress.postprocess));if(0===e.length)return this.emit("progress",0),void this.setState({totalProgress:0});const t=e.filter((e=>null!=e.progress.bytesTotal)),n=e.filter((e=>null==e.progress.bytesTotal));if(0===t.length){const t=100*e.length,r=n.reduce(((e,t)=>e+t.progress.percentage),0),o=Math.round(r/t*100);return void this.setState({totalProgress:o})}let r=t.reduce(((e,t)=>e+t.progress.bytesTotal),0);const o=r/t.length;r+=o*n.length;let i=0;t.forEach((e=>{i+=e.progress.bytesUploaded})),n.forEach((e=>{i+=o*(e.progress.percentage||0)/100}));let a=0===r?0:Math.round(i/r*100);a>100&&(a=100),this.setState({totalProgress:a}),this.emit("progress",a)}updateOnlineStatus(){void 0===window.navigator.onLine||window.navigator.onLine?(this.emit("is-online"),this.wasOffline&&(this.emit("back-online"),this.info(this.i18n("connectedToInternet"),"success",3e3),this.wasOffline=!1)):(this.emit("is-offline"),this.info(this.i18n("noInternetConnection"),"error",0),this.wasOffline=!0)}getID(){return this.opts.id}use(e,t){if("function"!=typeof e){throw new TypeError(`Expected a plugin class, but got ${null===e?"null":typeof e}. Please verify that the plugin was imported and spelled correctly.`)}const n=new e(this,t),r=n.id;if(!r)throw new Error("Your plugin must have an id");if(!n.type)throw new Error("Your plugin must have a type");const o=this.getPlugin(r);if(o){const e=`Already found a plugin named '${o.id}'. Tried to use: '${r}'.\nUppy plugins must have unique \`id\` options. See https://uppy.io/docs/plugins/#id.`;throw new Error(e)}return e.VERSION&&this.log(`Using ${r} v${e.VERSION}`),n.type in _y(this,zy)[zy]?_y(this,zy)[zy][n.type].push(n):_y(this,zy)[zy][n.type]=[n],n.install(),this}getPlugin(e){for(const t of Object.values(_y(this,zy)[zy])){const n=t.find((t=>t.id===e));if(null!=n)return n}}[Fy](e){return _y(this,zy)[zy][e]}iteratePlugins(e){Object.values(_y(this,zy)[zy]).flat(1).forEach(e)}removePlugin(e){this.log(`Removing plugin ${e.id}`),this.emit("plugin-remove",e),e.uninstall&&e.uninstall();const t=_y(this,zy)[zy][e.type],n=t.findIndex((t=>t.id===e.id));-1!==n&&t.splice(n,1);const r={plugins:{...this.getState().plugins,[e.id]:void 0}};this.setState(r)}close(){this.log(`Closing Uppy instance ${this.opts.id}: removing all files and uninstalling plugins`),this.reset(),_y(this,$y)[$y](),this.iteratePlugins((e=>{this.removePlugin(e)})),"undefined"!=typeof window&&window.removeEventListener&&(window.removeEventListener("online",_y(this,tm)[tm]),window.removeEventListener("offline",_y(this,tm)[tm]))}hideInfo(){const{info:e}=this.getState();this.setState({info:e.slice(1)}),this.emit("info-hidden")}info(e,t,n){void 0===t&&(t="info"),void 0===n&&(n=3e3);const r="object"==typeof e;this.setState({info:[...this.getState().info,{type:t,message:r?e.message:e,details:r?e.details:null}]}),setTimeout((()=>this.hideInfo()),n),this.emit("info-visible")}log(e,t){const{logger:n}=this.opts;switch(t){case"error":n.error(e);break;case"warning":n.warn(e);break;default:n.debug(e)}}restore(e){return this.log(`Core: attempting to restore upload "${e}"`),this.getState().currentUploads[e]?_y(this,im)[im](e):(_y(this,om)[om](e),Promise.reject(new Error("Nonexistent upload")))}[Ty](){return _y(this,nm)[nm](...arguments)}addResultData(e,t){if(!_y(this,rm)[rm](e))return void this.log(`Not setting result for an upload that has been removed: ${e}`);const{currentUploads:n}=this.getState(),r={...n[e],result:{...n[e].result,...t}};this.setState({currentUploads:{...n,[e]:r}})}upload(){var e;null!=(e=_y(this,zy)[zy].uploader)&&e.length||this.log("No uploader type plugins are used","warning");let{files:t}=this.getState();const n=this.opts.onBeforeUpload(t);return!1===n?Promise.reject(new Error("Not starting the upload because onBeforeUpload returned false")):(n&&"object"==typeof n&&(t=n,this.setState({files:t})),Promise.resolve().then((()=>{_y(this,qy)[qy](t),_y(this,Yy)[Yy](t)})).catch((e=>{_y(this,Xy)[Xy](e)})).then((()=>{const{currentUploads:e}=this.getState(),n=Object.values(e).flatMap((e=>e.fileIDs)),r=[];Object.keys(t).forEach((e=>{const t=this.getFile(e);t.progress.uploadStarted||-1!==n.indexOf(e)||r.push(t.id)}));const o=_y(this,nm)[nm](r);return _y(this,im)[im](o)})).catch((e=>{_y(this,Xy)[Xy](e,{showInformer:!1})})))}}function um(e,t){void 0===t&&(t=this.getFiles());const{maxFileSize:n,minFileSize:r,maxTotalFileSize:o,maxNumberOfFiles:i,allowedFileTypes:a}=this.opts.restrictions;if(i&&t.length+1>i)throw new Ry(`${this.i18n("youCanOnlyUploadX",{smart_count:i})}`);if(a){if(!a.some((t=>t.indexOf("/")>-1?!!e.type&&gy(e.type.replace(/;.*?$/,""),t):!("."!==t[0]||!e.extension)&&e.extension.toLowerCase()===t.substr(1).toLowerCase()))){const e=a.join(", ");throw new Ry(this.i18n("youCanOnlyUploadFileTypes",{types:e}))}}if(o&&null!=e.size){let n=0;if(n+=e.size,t.forEach((e=>{n+=e.size})),n>o)throw new Ry(this.i18n("exceedsSize",{size:dy(o),file:e.name}))}if(n&&null!=e.size&&e.size>n)throw new Ry(this.i18n("exceedsSize",{size:dy(n),file:e.name}));if(r&&null!=e.size&&e.size<r)throw new Ry(this.i18n("inferiorSize",{size:dy(r)}))}function sm(e){const{minNumberOfFiles:t}=this.opts.restrictions;if(Object.keys(e).length<t)throw new Ry(`${this.i18n("youHaveToAtLeastSelectX",{smart_count:t})}`)}function lm(e){const{requiredMetaFields:t}=this.opts.restrictions,{hasOwnProperty:n}=Object.prototype,r=[],o=[];for(let i=0;i<t.length;i++)if(!n.call(e.meta,t[i])||""===e.meta[t[i]]){const n=new Ry(`${this.i18n("missingRequiredMetaFieldOnFile",{fileName:e.name})}`);r.push(n),o.push(t[i]),_y(this,Xy)[Xy](n,{file:e,showInformer:!1,throwErr:!1})}return this.setFileState(e.id,{missingRequiredMetaFields:o}),r}function cm(e){const t=Object.keys(e).flatMap((e=>{const t=this.getFile(e);return _y(this,Ky)[Ky](t)}));if(t.length)throw new My(t,`${this.i18n("missingRequiredMetaField")}`)}function fm(e,t){let{showInformer:n=!0,file:r=null,throwErr:o=!0}=void 0===t?{}:t;const i="object"==typeof e?e.message:e,a="object"==typeof e&&e.details?e.details:"";let u=i;if(a&&(u+=` ${a}`),e.isRestriction?(this.log(u),this.emit("restriction-failed",r,e)):this.log(u,"error"),n&&this.info({message:i,details:a},"error",this.opts.infoTimeout),o)throw"object"==typeof e?e:new Error(e)}function dm(e){const{allowNewUpload:t}=this.getState();!1===t&&_y(this,Xy)[Xy](new Ry(this.i18n("noMoreFilesAllowed")),{file:e})}function pm(e,t){const n=function(e){var t;if(e.type)return e.type;const n=e.name?null==(t=Ey(e.name).extension)?void 0:t.toLowerCase():null;return n&&n in Dy?Dy[n]:"application/octet-stream"}(t),r=function(e,t){return t.name?t.name:"image"===e.split("/")[0]?`${e.split("/")[0]}.${e.split("/")[1]}`:"noname"}(n,t),o=Ey(r).extension,i=Boolean(t.isRemote),a=function(e){let t="uppy";return"string"==typeof e.name&&(t+=`-${Sy(e.name.toLowerCase())}`),void 0!==e.type&&(t+=`-${e.type}`),e.meta&&"string"==typeof e.meta.relativePath&&(t+=`-${Sy(e.meta.relativePath.toLowerCase())}`),void 0!==e.data.size&&(t+=`-${e.data.size}`),void 0!==e.data.lastModified&&(t+=`-${e.data.lastModified}`),t}({...t,type:n});if(this.checkIfFileAlreadyExists(a)){const e=new Ry(this.i18n("noDuplicates",{fileName:r}));_y(this,Xy)[Xy](e,{file:t})}const u=t.meta||{};u.name=r,u.type=n;const s=Number.isFinite(t.data.size)?t.data.size:null;let l={source:t.source||"",id:a,name:r,extension:o||"",meta:{...this.getState().meta,...u},type:n,data:t.data,progress:{percentage:0,bytesUploaded:0,bytesTotal:s,uploadComplete:!1,uploadStarted:null},size:s,isRemote:i,remote:t.remote||"",preview:t.preview};const c=this.opts.onBeforeFileAdded(l,e);!1===c?_y(this,Xy)[Xy](new Ry("Cannot add the file because onBeforeFileAdded returned false."),{showInformer:!1,fileDescriptor:t}):"object"==typeof c&&null!==c&&(l=c);try{const t=Object.keys(e).map((t=>e[t]));_y(this,Gy)[Gy](l,t)}catch(e){_y(this,Xy)[Xy](e,{file:l})}return l}function hm(){this.opts.autoProceed&&!this.scheduledAutoProceed&&(this.scheduledAutoProceed=setTimeout((()=>{this.scheduledAutoProceed=null,this.upload().catch((e=>{e.isRestriction||this.log(e.stack||e.message||e)}))}),4))}function gm(){const e=(e,t,n)=>{let r=e.message||"Unknown error";e.details&&(r+=` ${e.details}`),this.setState({error:r}),null!=t&&t.id in this.getState().files&&this.setFileState(t.id,{error:r,response:n})};this.on("error",e),this.on("upload-error",((t,n,r)=>{if(e(n,t,r),"object"==typeof n&&n.message){const e=new Error(n.message);e.details=n.message,n.details&&(e.details+=` ${n.details}`),e.message=this.i18n("failedToUpload",{file:t.name}),_y(this,Xy)[Xy](e,{throwErr:!1})}else _y(this,Xy)[Xy](n,{throwErr:!1})})),this.on("upload",(()=>{this.setState({error:null})})),this.on("upload-started",(e=>{this.getFile(e.id)?this.setFileState(e.id,{progress:{uploadStarted:Date.now(),uploadComplete:!1,percentage:0,bytesUploaded:0,bytesTotal:e.size}}):this.log(`Not setting progress for a file that has been removed: ${e.id}`)})),this.on("upload-progress",this.calculateProgress),this.on("upload-success",((e,t)=>{if(!this.getFile(e.id))return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);const n=this.getFile(e.id).progress;this.setFileState(e.id,{progress:{...n,postprocess:_y(this,Wy)[Wy].size>0?{mode:"indeterminate"}:null,uploadComplete:!0,percentage:100,bytesUploaded:n.bytesTotal},response:t,uploadURL:t.uploadURL,isPaused:!1}),null==e.size&&this.setFileState(e.id,{size:t.bytesUploaded||n.bytesTotal}),this.calculateTotalProgress()})),this.on("preprocess-progress",((e,t)=>{this.getFile(e.id)?this.setFileState(e.id,{progress:{...this.getFile(e.id).progress,preprocess:t}}):this.log(`Not setting progress for a file that has been removed: ${e.id}`)})),this.on("preprocess-complete",(e=>{if(!this.getFile(e.id))return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);const t={...this.getState().files};t[e.id]={...t[e.id],progress:{...t[e.id].progress}},delete t[e.id].progress.preprocess,this.setState({files:t})})),this.on("postprocess-progress",((e,t)=>{this.getFile(e.id)?this.setFileState(e.id,{progress:{...this.getState().files[e.id].progress,postprocess:t}}):this.log(`Not setting progress for a file that has been removed: ${e.id}`)})),this.on("postprocess-complete",(e=>{if(!this.getFile(e.id))return void this.log(`Not setting progress for a file that has been removed: ${e.id}`);const t={...this.getState().files};t[e.id]={...t[e.id],progress:{...t[e.id].progress}},delete t[e.id].progress.postprocess,this.setState({files:t})})),this.on("restored",(()=>{this.calculateTotalProgress()})),this.on("dashboard:file-edit-complete",(e=>{e&&_y(this,Ky)[Ky](e)})),"undefined"!=typeof window&&window.addEventListener&&(window.addEventListener("online",_y(this,tm)[tm]),window.addEventListener("offline",_y(this,tm)[tm]),setTimeout(_y(this,tm)[tm],3e3))}function vm(e,t){void 0===t&&(t={});const{forceAllowNewUpload:n=!1}=t,{allowNewUpload:r,currentUploads:o}=this.getState();if(!r&&!n)throw new Error("Cannot create a new upload: already uploading.");const i=Ny();return this.emit("upload",{id:i,fileIDs:e}),this.setState({allowNewUpload:!1!==this.opts.allowMultipleUploadBatches&&!1!==this.opts.allowMultipleUploads,currentUploads:{...o,[i]:{fileIDs:e,step:0,result:{}}}}),i}function ym(e){const{currentUploads:t}=this.getState();return t[e]}function mm(e){const t={...this.getState().currentUploads};delete t[e],this.setState({currentUploads:t})}async function bm(e){let{currentUploads:t}=this.getState(),n=t[e];const r=n.step||0,o=[..._y(this,Vy)[Vy],..._y(this,Uy)[Uy],..._y(this,Wy)[Wy]];try{for(let i=r;i<o.length&&n;i++){const r=o[i],a={...n,step:i};this.setState({currentUploads:{...t,[e]:a}}),await r(a.fileIDs,e),t=this.getState().currentUploads,n=t[e]}}catch(t){throw this.emit("error",t),_y(this,om)[om](e),t}if(n){n.fileIDs.forEach((e=>{const t=this.getFile(e);t&&t.progress.postprocess&&this.emit("postprocess-complete",t)}));const r=n.fileIDs.map((e=>this.getFile(e))),o=r.filter((e=>!e.error)),i=r.filter((e=>e.error));await this.addResultData(e,{successful:o,failed:i,uploadID:e}),t=this.getState().currentUploads,n=t[e]}let i;return n&&(i=n.result,this.emit("complete",i),_y(this,om)[om](e)),null==i&&this.log(`Not setting result for an upload that has been removed: ${e}`),i}am.VERSION="2.1.3";var wm=am,Em=n((function(e,t){var n,r,o,i,a,u,s,l,c={},f=[],d=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function p(e,t){for(var n in t)e[n]=t[n];return e}function h(e){var t=e.parentNode;t&&t.removeChild(e)}function g(e,t,r){var o,i,a,u={};for(a in t)"key"==a?o=t[a]:"ref"==a?i=t[a]:u[a]=t[a];if(arguments.length>2&&(u.children=arguments.length>3?n.call(arguments,2):r),"function"==typeof e&&null!=e.defaultProps)for(a in e.defaultProps)void 0===u[a]&&(u[a]=e.defaultProps[a]);return v(e,u,o,i,null)}function v(e,t,n,i,a){var u={type:e,props:t,key:n,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==a?++o:a};return null==a&&null!=r.vnode&&r.vnode(u),u}function y(e){return e.children}function m(e,t){this.props=e,this.context=t}function b(e,t){if(null==t)return e.__?b(e.__,e.__.__k.indexOf(e)+1):null;for(var n;t<e.__k.length;t++)if(null!=(n=e.__k[t])&&null!=n.__e)return n.__e;return"function"==typeof e.type?b(e):null}function w(e){var t,n;if(null!=(e=e.__)&&null!=e.__c){for(e.__e=e.__c.base=null,t=0;t<e.__k.length;t++)if(null!=(n=e.__k[t])&&null!=n.__e){e.__e=e.__c.base=n.__e;break}return w(e)}}function E(e){(!e.__d&&(e.__d=!0)&&a.push(e)&&!D.__r++||s!==r.debounceRendering)&&((s=r.debounceRendering)||u)(D)}function D(){for(var e;D.__r=a.length;)e=a.sort((function(e,t){return e.__v.__b-t.__v.__b})),a=[],e.some((function(e){var t,n,r,o,i,a;e.__d&&(i=(o=(t=e).__v).__e,(a=t.__P)&&(n=[],(r=p({},o)).__v=o.__v+1,F(a,o,r,t.__n,void 0!==a.ownerSVGElement,null!=o.__h?[i]:null,n,null==i?b(o):i,o.__h),T(n,o),o.__e!=i&&w(o)))}))}function S(e,t,n,r,o,i,a,u,s,l){var d,p,h,g,m,w,E,D=r&&r.__k||f,S=D.length;for(n.__k=[],d=0;d<t.length;d++)if(null!=(g=n.__k[d]=null==(g=t[d])||"boolean"==typeof g?null:"string"==typeof g||"number"==typeof g||"bigint"==typeof g?v(null,g,null,null,g):Array.isArray(g)?v(y,{children:g},null,null,null):g.__b>0?v(g.type,g.props,g.key,null,g.__v):g)){if(g.__=n,g.__b=n.__b+1,null===(h=D[d])||h&&g.key==h.key&&g.type===h.type)D[d]=void 0;else for(p=0;p<S;p++){if((h=D[p])&&g.key==h.key&&g.type===h.type){D[p]=void 0;break}h=null}F(e,g,h=h||c,o,i,a,u,s,l),m=g.__e,(p=g.ref)&&h.ref!=p&&(E||(E=[]),h.ref&&E.push(h.ref,null,g),E.push(p,g.__c||m,g)),null!=m?(null==w&&(w=m),"function"==typeof g.type&&g.__k===h.__k?g.__d=s=x(g,s,e):s=C(e,g,h,D,m,s),"function"==typeof n.type&&(n.__d=s)):s&&h.__e==s&&s.parentNode!=e&&(s=b(h))}for(n.__e=w,d=S;d--;)null!=D[d]&&("function"==typeof n.type&&null!=D[d].__e&&D[d].__e==n.__d&&(n.__d=b(r,d+1)),j(D[d],D[d]));if(E)for(d=0;d<E.length;d++)P(E[d],E[++d],E[++d])}function x(e,t,n){for(var r,o=e.__k,i=0;o&&i<o.length;i++)(r=o[i])&&(r.__=e,t="function"==typeof r.type?x(r,t,n):C(n,r,r,o,r.__e,t));return t}function C(e,t,n,r,o,i){var a,u,s;if(void 0!==t.__d)a=t.__d,t.__d=void 0;else if(null==n||o!=i||null==o.parentNode)e:if(null==i||i.parentNode!==e)e.appendChild(o),a=null;else{for(u=i,s=0;(u=u.nextSibling)&&s<r.length;s+=2)if(u==o)break e;e.insertBefore(o,i),a=i}return void 0!==a?a:o.nextSibling}function A(e,t,n){"-"===t[0]?e.setProperty(t,n):e[t]=null==n?"":"number"!=typeof n||d.test(t)?n:n+"px"}function O(e,t,n,r,o){var i;e:if("style"===t)if("string"==typeof n)e.style.cssText=n;else{if("string"==typeof r&&(e.style.cssText=r=""),r)for(t in r)n&&t in n||A(e.style,t,"");if(n)for(t in n)r&&n[t]===r[t]||A(e.style,t,n[t])}else if("o"===t[0]&&"n"===t[1])i=t!==(t=t.replace(/Capture$/,"")),t=t.toLowerCase()in e?t.toLowerCase().slice(2):t.slice(2),e.l||(e.l={}),e.l[t+i]=n,n?r||e.addEventListener(t,i?B:k,i):e.removeEventListener(t,i?B:k,i);else if("dangerouslySetInnerHTML"!==t){if(o)t=t.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==t&&"list"!==t&&"form"!==t&&"tabIndex"!==t&&"download"!==t&&t in e)try{e[t]=null==n?"":n;break e}catch(e){}"function"==typeof n||(null!=n&&(!1!==n||"a"===t[0]&&"r"===t[1])?e.setAttribute(t,n):e.removeAttribute(t))}}function k(e){this.l[e.type+!1](r.event?r.event(e):e)}function B(e){this.l[e.type+!0](r.event?r.event(e):e)}function F(e,t,n,o,i,a,u,s,l){var c,f,d,h,g,v,b,w,E,D,x,C=t.type;if(void 0!==t.constructor)return null;null!=n.__h&&(l=n.__h,s=t.__e=n.__e,t.__h=null,a=[s]),(c=r.__b)&&c(t);try{e:if("function"==typeof C){if(w=t.props,E=(c=C.contextType)&&o[c.__c],D=c?E?E.props.value:c.__:o,n.__c?b=(f=t.__c=n.__c).__=f.__E:("prototype"in C&&C.prototype.render?t.__c=f=new C(w,D):(t.__c=f=new m(w,D),f.constructor=C,f.render=N),E&&E.sub(f),f.props=w,f.state||(f.state={}),f.context=D,f.__n=o,d=f.__d=!0,f.__h=[]),null==f.__s&&(f.__s=f.state),null!=C.getDerivedStateFromProps&&(f.__s==f.state&&(f.__s=p({},f.__s)),p(f.__s,C.getDerivedStateFromProps(w,f.__s))),h=f.props,g=f.state,d)null==C.getDerivedStateFromProps&&null!=f.componentWillMount&&f.componentWillMount(),null!=f.componentDidMount&&f.__h.push(f.componentDidMount);else{if(null==C.getDerivedStateFromProps&&w!==h&&null!=f.componentWillReceiveProps&&f.componentWillReceiveProps(w,D),!f.__e&&null!=f.shouldComponentUpdate&&!1===f.shouldComponentUpdate(w,f.__s,D)||t.__v===n.__v){f.props=w,f.state=f.__s,t.__v!==n.__v&&(f.__d=!1),f.__v=t,t.__e=n.__e,t.__k=n.__k,t.__k.forEach((function(e){e&&(e.__=t)})),f.__h.length&&u.push(f);break e}null!=f.componentWillUpdate&&f.componentWillUpdate(w,f.__s,D),null!=f.componentDidUpdate&&f.__h.push((function(){f.componentDidUpdate(h,g,v)}))}f.context=D,f.props=w,f.state=f.__s,(c=r.__r)&&c(t),f.__d=!1,f.__v=t,f.__P=e,c=f.render(f.props,f.state,f.context),f.state=f.__s,null!=f.getChildContext&&(o=p(p({},o),f.getChildContext())),d||null==f.getSnapshotBeforeUpdate||(v=f.getSnapshotBeforeUpdate(h,g)),x=null!=c&&c.type===y&&null==c.key?c.props.children:c,S(e,Array.isArray(x)?x:[x],t,n,o,i,a,u,s,l),f.base=t.__e,t.__h=null,f.__h.length&&u.push(f),b&&(f.__E=f.__=null),f.__e=!1}else null==a&&t.__v===n.__v?(t.__k=n.__k,t.__e=n.__e):t.__e=_(n.__e,t,n,o,i,a,u,l);(c=r.diffed)&&c(t)}catch(e){t.__v=null,(l||null!=a)&&(t.__e=s,t.__h=!!l,a[a.indexOf(s)]=null),r.__e(e,t,n)}}function T(e,t){r.__c&&r.__c(t,e),e.some((function(t){try{e=t.__h,t.__h=[],e.some((function(e){e.call(t)}))}catch(e){r.__e(e,t.__v)}}))}function _(e,t,r,o,i,a,u,s){var l,f,d,p=r.props,g=t.props,v=t.type,y=0;if("svg"===v&&(i=!0),null!=a)for(;y<a.length;y++)if((l=a[y])&&"setAttribute"in l==!!v&&(v?l.localName===v:3===l.nodeType)){e=l,a[y]=null;break}if(null==e){if(null===v)return document.createTextNode(g);e=i?document.createElementNS("http://www.w3.org/2000/svg",v):document.createElement(v,g.is&&g),a=null,s=!1}if(null===v)p===g||s&&e.data===g||(e.data=g);else{if(a=a&&n.call(e.childNodes),f=(p=r.props||c).dangerouslySetInnerHTML,d=g.dangerouslySetInnerHTML,!s){if(null!=a)for(p={},y=0;y<e.attributes.length;y++)p[e.attributes[y].name]=e.attributes[y].value;(d||f)&&(d&&(f&&d.__html==f.__html||d.__html===e.innerHTML)||(e.innerHTML=d&&d.__html||""))}if(function(e,t,n,r,o){var i;for(i in n)"children"===i||"key"===i||i in t||O(e,i,null,n[i],r);for(i in t)o&&"function"!=typeof t[i]||"children"===i||"key"===i||"value"===i||"checked"===i||n[i]===t[i]||O(e,i,t[i],n[i],r)}(e,g,p,i,s),d)t.__k=[];else if(y=t.props.children,S(e,Array.isArray(y)?y:[y],t,r,o,i&&"foreignObject"!==v,a,u,a?a[0]:r.__k&&b(r,0),s),null!=a)for(y=a.length;y--;)null!=a[y]&&h(a[y]);s||("value"in g&&void 0!==(y=g.value)&&(y!==p.value||y!==e.value||"progress"===v&&!y)&&O(e,"value",y,p.value,!1),"checked"in g&&void 0!==(y=g.checked)&&y!==e.checked&&O(e,"checked",y,p.checked,!1))}return e}function P(e,t,n){try{"function"==typeof e?e(t):e.current=t}catch(e){r.__e(e,n)}}function j(e,t,n){var o,i;if(r.unmount&&r.unmount(e),(o=e.ref)&&(o.current&&o.current!==e.__e||P(o,null,t)),null!=(o=e.__c)){if(o.componentWillUnmount)try{o.componentWillUnmount()}catch(e){r.__e(e,t)}o.base=o.__P=null}if(o=e.__k)for(i=0;i<o.length;i++)o[i]&&j(o[i],t,"function"!=typeof e.type);n||null==e.__e||h(e.__e),e.__e=e.__d=void 0}function N(e,t,n){return this.constructor(e,n)}function I(e,t,o){var i,a,u;r.__&&r.__(e,t),a=(i="function"==typeof o)?null:o&&o.__k||t.__k,u=[],F(t,e=(!i&&o||t).__k=g(y,null,[e]),a||c,c,void 0!==t.ownerSVGElement,!i&&o?[o]:a?null:t.firstChild?n.call(t.childNodes):null,u,!i&&o?o:a?a.__e:t.firstChild,i),T(u,e)}n=f.slice,r={__e:function(e,t){for(var n,r,o;t=t.__;)if((n=t.__c)&&!n.__)try{if((r=n.constructor)&&null!=r.getDerivedStateFromError&&(n.setState(r.getDerivedStateFromError(e)),o=n.__d),null!=n.componentDidCatch&&(n.componentDidCatch(e),o=n.__d),o)return n.__E=n}catch(t){e=t}throw e}},o=0,i=function(e){return null!=e&&void 0===e.constructor},m.prototype.setState=function(e,t){var n;n=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=p({},this.state),"function"==typeof e&&(e=e(p({},n),this.props)),e&&p(n,e),null!=e&&this.__v&&(t&&this.__h.push(t),E(this))},m.prototype.forceUpdate=function(e){this.__v&&(this.__e=!0,e&&this.__h.push(e),E(this))},m.prototype.render=y,a=[],u="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,D.__r=0,l=0,t.Component=m,t.Fragment=y,t.cloneElement=function(e,t,r){var o,i,a,u=p({},e.props);for(a in t)"key"==a?o=t[a]:"ref"==a?i=t[a]:u[a]=t[a];return arguments.length>2&&(u.children=arguments.length>3?n.call(arguments,2):r),v(e.type,u,o||e.key,i||e.ref,null)},t.createContext=function(e,t){var n={__c:t="__cC"+l++,__:e,Consumer:function(e,t){return e.children(t)},Provider:function(e){var n,r;return this.getChildContext||(n=[],(r={})[t]=this,this.getChildContext=function(){return r},this.shouldComponentUpdate=function(e){this.props.value!==e.value&&n.some(E)},this.sub=function(e){n.push(e);var t=e.componentWillUnmount;e.componentWillUnmount=function(){n.splice(n.indexOf(e),1),t&&t.call(e)}}),e.children}};return n.Provider.__=n.Consumer.contextType=n},t.createElement=g,t.createRef=function(){return{current:null}},t.h=g,t.hydrate=function e(t,n){I(t,n,e)},t.isValidElement=i,t.options=r,t.render=I,t.toChildArray=function e(t,n){return n=n||[],null==t||"boolean"==typeof t||(Array.isArray(t)?t.some((function(t){e(t,n)})):n.push(t)),n}})),Dm=function(e,t){return void 0===t&&(t=document),"string"==typeof e?t.querySelector(e):(null==(n=e)?void 0:n.nodeType)===Node.ELEMENT_NODE?e:null;// removed by dead control flow
{ var n; }},Sm=class{constructor(e,t){void 0===t&&(t={}),this.uppy=e,this.opts=t}getPluginState(){const{plugins:e}=this.uppy.getState();return e[this.id]||{}}setPluginState(e){const{plugins:t}=this.uppy.getState();this.uppy.setState({plugins:{...t,[this.id]:{...t[this.id],...e}}})}setOptions(e){this.opts={...this.opts,...e},this.setPluginState(),this.i18nInit()}i18nInit(){const e=new oy([this.defaultLocale,this.uppy.locale,this.opts.locale]);this.i18n=e.translate.bind(e),this.i18nArray=e.translateArray.bind(e),this.setPluginState()}addTarget(){throw new Error("Extend the addTarget method to add your plugin to another plugin's target")}install(){}uninstall(){}render(){throw new Error("Extend the render method to add your plugin to a DOM element")}update(){}afterUpdate(){}};function xm(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var Cm=0;function Am(e){return"__private_"+Cm+++"_"+e}const{render:Om}=Em;var km=Am("updateUI");class Bm extends Sm{constructor(){super(...arguments),Object.defineProperty(this,km,{writable:!0,value:void 0})}mount(e,t){const n=t.id,r=Dm(e);if(r){this.isTargetDOMEl=!0;const t=document.createDocumentFragment();return xm(this,km)[km]=function(e){let t=null,n=null;return function(){for(var r=arguments.length,o=new Array(r),i=0;i<r;i++)o[i]=arguments[i];return n=o,t||(t=Promise.resolve().then((()=>(t=null,e(...n))))),t}}((e=>{this.uppy.getPlugin(this.id)&&(Om(this.render(e),t),this.afterUpdate())})),this.uppy.log(`Installing ${n} to a DOM element '${e}'`),this.opts.replaceTargetContent&&(r.innerHTML=""),Om(this.render(this.uppy.getState()),t),this.el=t.firstElementChild,r.appendChild(t),this.onMount(),this.el}let o;if("object"==typeof e&&e instanceof Bm)o=e;else if("function"==typeof e){const t=e;this.uppy.iteratePlugins((e=>{if(e instanceof t)return o=e,!1}))}if(o)return this.uppy.log(`Installing ${n} to ${o.id}`),this.parent=o,this.el=o.addTarget(t),this.onMount(),this.el;this.uppy.log(`Not installing ${n}`);let i=`Invalid target option given to ${n}.`;throw i+="function"==typeof e?" The given target is not a Plugin class. Please check that you're not specifying a React Component instead of a plugin. If you are using @uppy/* packages directly, make sure you have only 1 version of @uppy/core installed: run `npm ls @uppy/core` on the command line and verify that all the versions match and are deduped correctly.":"If you meant to target an HTML element, please make sure that the element exists. Check that the <script> tag initializing Uppy is right before the closing </body> tag at the end of the page. (see https://github.com/transloadit/uppy/issues/1042)\n\nIf you meant to target a plugin, please confirm that your `import` statements or `require` calls are correct.",new Error(i)}update(e){var t,n;null!=this.el&&(null==(t=(n=xm(this,km))[km])||t.call(n,e))}unmount(){var e;this.isTargetDOMEl&&(null==(e=this.el)||e.remove());this.onUnmount()}onMount(){}onUnmount(){}}var Fm=Bm;const{debugLogger:Tm}=Oy;var _m=wm,Pm=wm,jm=Fm,Nm=Sm,Im=Tm;_m.Uppy=Pm,_m.UIPlugin=jm,_m.BasePlugin=Nm,_m.debugLogger=Im;class Lm extends Error{constructor(e,t){void 0===t&&(t=null),super("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."),this.cause=e,this.isNetworkError=!0,this.request=t}}var Rm=Lm,Mm=function(){return fetch(...arguments).catch((e=>{throw"AbortError"===e.name?e:new Rm(e)}))};class zm extends Error{constructor(){super("Authorization required"),this.name="AuthError",this.isAuthError=!0}}var $m,Hm,Vm,Um,Wm,Gm=zm;function qm(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var Km=0;function Ym(e){return"__private_"+Km+++"_"+e}async function Xm(e){if(401===e.status)throw new Gm;const t=e.json();if(e.status<200||e.status>300){let n=`Failed request with status: ${e.status}. ${e.statusText}`;try{const e=await t;n=e.message?`${n} message: ${e.message}`:n,n=e.requestId?`${n} request-Id: ${e.requestId}`:n}finally{throw new Error(n)}}return t}var Zm=(Hm=Ym("getPostResponseFunc"),Vm=Ym("getUrl"),Um=Ym("errorHandler"),Wm=$m=class e{constructor(e,t){Object.defineProperty(this,Um,{value:Qm}),Object.defineProperty(this,Vm,{value:Jm}),Object.defineProperty(this,Hm,{writable:!0,value:e=>t=>e?t:this.onReceiveResponse(t)}),this.uppy=e,this.opts=t,this.onReceiveResponse=this.onReceiveResponse.bind(this),this.allowedHeaders=["accept","content-type","uppy-auth-token"],this.preflightDone=!1}get hostname(){const{companion:e}=this.uppy.getState(),t=this.opts.companionUrl;return(e&&e[t]?e[t]:t).replace(/\/$/,"")}headers(){const t=this.opts.companionHeaders||{};return Promise.resolve({...e.defaultHeaders,...t})}onReceiveResponse(e){const t=this.uppy.getState().companion||{},n=this.opts.companionUrl,{headers:r}=e;return r.has("i-am")&&r.get("i-am")!==t[n]&&this.uppy.setState({companion:{...t,[n]:r.get("i-am")}}),e}preflight(e){return this.preflightDone?Promise.resolve(this.allowedHeaders.slice()):fetch(qm(this,Vm)[Vm](e),{method:"OPTIONS"}).then((e=>(e.headers.has("access-control-allow-headers")&&(this.allowedHeaders=e.headers.get("access-control-allow-headers").split(",").map((e=>e.trim().toLowerCase()))),this.preflightDone=!0,this.allowedHeaders.slice()))).catch((e=>(this.uppy.log(`[CompanionClient] unable to make preflight request ${e}`,"warning"),this.preflightDone=!0,this.allowedHeaders.slice())))}preflightAndHeaders(e){return Promise.all([this.preflight(e),this.headers()]).then((e=>{let[t,n]=e;return Object.keys(n).forEach((e=>{t.includes(e.toLowerCase())||(this.uppy.log(`[CompanionClient] excluding disallowed header ${e}`),delete n[e])})),n}))}get(e,t){return this.preflightAndHeaders(e).then((t=>Mm(qm(this,Vm)[Vm](e),{method:"get",headers:t,credentials:this.opts.companionCookiesRule||"same-origin"}))).then(qm(this,Hm)[Hm](t)).then(Xm).catch(qm(this,Um)[Um]("get",e))}post(e,t,n){const r="post";return this.preflightAndHeaders(e).then((n=>Mm(qm(this,Vm)[Vm](e),{method:r,headers:n,credentials:this.opts.companionCookiesRule||"same-origin",body:JSON.stringify(t)}))).then(qm(this,Hm)[Hm](n)).then(Xm).catch(qm(this,Um)[Um](r,e))}delete(e,t,n){const r="delete";return this.preflightAndHeaders(e).then((n=>Mm(`${this.hostname}/${e}`,{method:r,headers:n,credentials:this.opts.companionCookiesRule||"same-origin",body:t?JSON.stringify(t):null}))).then(qm(this,Hm)[Hm](n)).then(Xm).catch(qm(this,Um)[Um](r,e))}},$m.VERSION="2.0.4",$m.defaultHeaders={Accept:"application/json","Content-Type":"application/json","Uppy-Versions":`@uppy/companion-client=${$m.VERSION}`},Wm);function Jm(e){return/^(https?:|)\/\//.test(e)?e:`${this.hostname}/${e}`}function Qm(e,t){return n=>{var r;if(null==(r=n)||!r.isAuthError){const r=new Error(`Could not ${e} ${qm(this,Vm)[Vm](t)}`);r.cause=n,n=r}return Promise.reject(n)}}var eb={setItem:(e,t)=>new Promise((n=>{localStorage.setItem(e,t),n()})),getItem:e=>Promise.resolve(localStorage.getItem(e)),removeItem:e=>new Promise((t=>{localStorage.removeItem(e),t()}))};var tb,nb,rb,ob,ib;let ab,ub;function sb(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var lb=0;function cb(e){return"__private_"+lb+++"_"+e}var fb=(tb=cb("queued"),nb=cb("emitter"),rb=cb("isOpen"),ob=cb("socket"),ib=cb("handleMessage"),ab=Symbol.for("uppy test: getSocket"),ub=Symbol.for("uppy test: getQueued"),class{constructor(e){Object.defineProperty(this,tb,{writable:!0,value:[]}),Object.defineProperty(this,nb,{writable:!0,value:ay()}),Object.defineProperty(this,rb,{writable:!0,value:!1}),Object.defineProperty(this,ob,{writable:!0,value:void 0}),Object.defineProperty(this,ib,{writable:!0,value:e=>{try{const t=JSON.parse(e.data);this.emit(t.action,t.payload)}catch(e){console.log(e)}}}),this.opts=e,e&&!1===e.autoOpen||this.open()}get isOpen(){return sb(this,rb)[rb]}[ab](){return sb(this,ob)[ob]}[ub](){return sb(this,tb)[tb]}open(){sb(this,ob)[ob]=new WebSocket(this.opts.target),sb(this,ob)[ob].onopen=()=>{for(sb(this,rb)[rb]=!0;sb(this,tb)[tb].length>0&&sb(this,rb)[rb];){const e=sb(this,tb)[tb].shift();this.send(e.action,e.payload)}},sb(this,ob)[ob].onclose=()=>{sb(this,rb)[rb]=!1},sb(this,ob)[ob].onmessage=sb(this,ib)[ib]}close(){var e;null==(e=sb(this,ob)[ob])||e.close()}send(e,t){sb(this,rb)[rb]?sb(this,ob)[ob].send(JSON.stringify({action:e,payload:t})):sb(this,tb)[tb].push({action:e,payload:t})}on(e,t){sb(this,nb)[nb].on(e,t)}emit(e,t){sb(this,nb)[nb].emit(e,t)}once(e,t){sb(this,nb)[nb].once(e,t)}}),db={RequestClient:Zm,Provider:class extends Zm{constructor(e,t){super(e,t),this.provider=t.provider,this.id=this.provider,this.name=this.opts.name||(e=>e.split("-").map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join(" "))(this.id),this.pluginId=this.opts.pluginId,this.tokenKey=`companion-${this.pluginId}-auth-token`,this.companionKeysParams=this.opts.companionKeysParams,this.preAuthToken=null}headers(){return Promise.all([super.headers(),this.getAuthToken()]).then((e=>{let[t,n]=e;const r={};return n&&(r["uppy-auth-token"]=n),this.companionKeysParams&&(r["uppy-credentials-params"]=btoa(JSON.stringify({params:this.companionKeysParams}))),{...t,...r}}))}onReceiveResponse(e){e=super.onReceiveResponse(e);const t=this.uppy.getPlugin(this.pluginId),n=t.getPluginState().authenticated?401!==e.status:e.status<400;return t.setPluginState({authenticated:n}),e}setAuthToken(e){return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey,e)}getAuthToken(){return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey)}authUrl(e){return void 0===e&&(e={}),this.preAuthToken&&(e.uppyPreAuthToken=this.preAuthToken),`${this.hostname}/${this.id}/connect?${new URLSearchParams(e)}`}fileUrl(e){return`${this.hostname}/${this.id}/get/${e}`}fetchPreAuthToken(){return this.companionKeysParams?this.post(`${this.id}/preauth/`,{params:this.companionKeysParams}).then((e=>{this.preAuthToken=e.token})).catch((e=>{this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${e}`,"warning")})):Promise.resolve()}list(e){return this.get(`${this.id}/list/${e||""}`)}logout(){return this.get(`${this.id}/logout`).then((e=>Promise.all([e,this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)]))).then((e=>{let[t]=e;return t}))}static initPlugin(e,t,n){if(e.type="acquirer",e.files=[],n&&(e.opts={...n,...t}),t.serverUrl||t.serverPattern)throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");if(t.companionAllowedHosts){const n=t.companionAllowedHosts;if(!("string"==typeof n||Array.isArray(n)||n instanceof RegExp))throw new TypeError(`${e.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);e.opts.companionAllowedHosts=n}else/^(?!https?:\/\/).*$/i.test(t.companionUrl)?e.opts.companionAllowedHosts=`https://${t.companionUrl.replace(/^\/\//,"")}`:e.opts.companionAllowedHosts=new URL(t.companionUrl).origin;e.storage=e.opts.storage||eb}},SearchProvider:class extends Zm{constructor(e,t){super(e,t),this.provider=t.provider,this.id=this.provider,this.name=this.opts.name||(e=>e.split("-").map((e=>e.charAt(0).toUpperCase()+e.slice(1))).join(" "))(this.id),this.pluginId=this.opts.pluginId}fileUrl(e){return`${this.hostname}/search/${this.id}/get/${e}`}search(e,t){return t=t?`&${t}`:"",this.get(`search/${this.id}/list?q=${encodeURIComponent(e)}${t}`)}},Socket:fb};var pb,hb,gb=eg((function(e,t,n){const{progress:r,bytesUploaded:o,bytesTotal:i}=t;r&&(e.uppy.log(`Upload progress: ${r}`),e.uppy.emit("upload-progress",n,{uploader:e,bytesUploaded:o,bytesTotal:i}))}),300,{leading:!0,trailing:!0});function vb(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var yb=0;function mb(e){return"__private_"+yb+++"_"+e}var bb=(pb=mb("emitter"),hb=mb("events"),class{constructor(e){Object.defineProperty(this,pb,{writable:!0,value:void 0}),Object.defineProperty(this,hb,{writable:!0,value:[]}),vb(this,pb)[pb]=e}on(e,t){return vb(this,hb)[hb].push([e,t]),vb(this,pb)[pb].on(e,t)}remove(){for(const[e,t]of vb(this,hb)[hb].splice(0))vb(this,pb)[pb].off(e,t)}});function wb(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var Eb=0;function Db(e){return"__private_"+Eb+++"_"+e}var Sb=Db("aliveTimer"),xb=Db("isDone"),Cb=Db("onTimedOut"),Ab=Db("timeout");var Ob=class{constructor(e,t){Object.defineProperty(this,Sb,{writable:!0,value:void 0}),Object.defineProperty(this,xb,{writable:!0,value:!1}),Object.defineProperty(this,Cb,{writable:!0,value:void 0}),Object.defineProperty(this,Ab,{writable:!0,value:void 0}),wb(this,Ab)[Ab]=e,wb(this,Cb)[Cb]=t}progress(){wb(this,xb)[xb]||wb(this,Ab)[Ab]>0&&(clearTimeout(wb(this,Sb)[Sb]),wb(this,Sb)[Sb]=setTimeout(wb(this,Cb)[Cb],wb(this,Ab)[Ab]))}done(){wb(this,xb)[xb]||(clearTimeout(wb(this,Sb)[Sb]),wb(this,Sb)[Sb]=null,wb(this,xb)[xb]=!0)}};function kb(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var Bb=0;function Fb(e){return"__private_"+Bb+++"_"+e}function Tb(){return new Error("Cancelled")}var _b=Fb("activeRequests"),Pb=Fb("queuedHandlers"),jb=Fb("call"),Nb=Fb("queueNext"),Ib=Fb("next"),Lb=Fb("queue"),Rb=Fb("dequeue");function Mb(e){kb(this,_b)[_b]+=1;let t,n=!1;try{t=e()}catch(e){throw kb(this,_b)[_b]-=1,e}return{abort:()=>{n||(n=!0,kb(this,_b)[_b]-=1,t(),kb(this,Nb)[Nb]())},done:()=>{n||(n=!0,kb(this,_b)[_b]-=1,kb(this,Nb)[Nb]())}}}function zb(){queueMicrotask((()=>kb(this,Ib)[Ib]()))}function $b(){if(kb(this,_b)[_b]>=this.limit)return;if(0===kb(this,Pb)[Pb].length)return;const e=kb(this,Pb)[Pb].shift(),t=kb(this,jb)[jb](e.fn);e.abort=t.abort,e.done=t.done}function Hb(e,t){void 0===t&&(t={});const n={fn:e,priority:t.priority||0,abort:()=>{kb(this,Rb)[Rb](n)},done:()=>{throw new Error("Cannot mark a queued request as done: this indicates a bug")}},r=kb(this,Pb)[Pb].findIndex((e=>n.priority>e.priority));return-1===r?kb(this,Pb)[Pb].push(n):kb(this,Pb)[Pb].splice(r,0,n),n}function Vb(e){const t=kb(this,Pb)[Pb].indexOf(e);-1!==t&&kb(this,Pb)[Pb].splice(t,1)}var Ub={RateLimitedQueue:class{constructor(e){Object.defineProperty(this,Rb,{value:Vb}),Object.defineProperty(this,Lb,{value:Hb}),Object.defineProperty(this,Ib,{value:$b}),Object.defineProperty(this,Nb,{value:zb}),Object.defineProperty(this,jb,{value:Mb}),Object.defineProperty(this,_b,{writable:!0,value:0}),Object.defineProperty(this,Pb,{writable:!0,value:[]}),this.limit="number"!=typeof e||0===e?1/0:e}run(e,t){return kb(this,_b)[_b]<this.limit?kb(this,jb)[jb](e):kb(this,Lb)[Lb](e,t)}wrapPromiseFunction(e,t){var n=this;return function(){for(var r=arguments.length,o=new Array(r),i=0;i<r;i++)o[i]=arguments[i];let a;const u=new Promise(((r,i)=>{a=n.run((()=>{let t,n;try{n=Promise.resolve(e(...o))}catch(e){n=Promise.reject(e)}return n.then((e=>{t?i(t):(a.done(),r(e))}),(e=>{t?i(t):(a.done(),i(e))})),()=>{t=Tb()}}),t)}));return u.abort=()=>{a.abort()},u}}},internalRateLimitedQueue:Symbol("__queue")};var Wb,Gb,qb=function(e){return!!e&&(0!==e.readyState&&4!==e.readyState||0===e.status)},Kb={strings:{timedOut:"Upload stalled for %{seconds} seconds, aborting."}};const{nanoid:Yb}=By,{Provider:Xb,RequestClient:Zb,Socket:Jb}=db,{RateLimitedQueue:Qb,internalRateLimitedQueue:ew}=Ub;function tw(e,t){let n=t;return n||(n=new Error("Upload error")),"string"==typeof n&&(n=new Error(n)),n instanceof Error||(n=Object.assign(new Error("Upload error"),{data:n})),qb(e)?(n=new Rm(n,e),n):(n.request=e,n)}function nw(e){return e.data.slice(0,e.data.size,e.meta.type)}var rw=(Gb=Wb=class extends Sm{constructor(e,t){super(e,t),this.type="uploader",this.id=this.opts.id||"XHRUpload",this.title="XHRUpload",this.defaultLocale=Kb;const n={formData:!0,fieldName:t.bundle?"files[]":"file",method:"post",metaFields:null,responseUrlFieldName:"url",bundle:!1,headers:{},timeout:3e4,limit:5,withCredentials:!1,responseType:"",getResponseData(t){let n={};try{n=JSON.parse(t)}catch(t){e.log(t)}return n},getResponseError(e,t){let n=new Error("Upload error");return qb(t)&&(n=new Rm(n,t)),n},validateStatus:e=>e>=200&&e<300};if(this.opts={...n,...t},this.i18nInit(),this.handleUpload=this.handleUpload.bind(this),ew in this.opts?this.requests=this.opts[ew]:this.requests=new Qb(this.opts.limit),this.opts.bundle&&!this.opts.formData)throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");this.uploaderEvents=Object.create(null)}getOptions(e){const t=this.uppy.getState().xhrUpload,{headers:n}=this.opts,r={...this.opts,...t||{},...e.xhrUpload||{},headers:{}};return"function"==typeof n?r.headers=n(e):Object.assign(r.headers,this.opts.headers),t&&Object.assign(r.headers,t.headers),e.xhrUpload&&Object.assign(r.headers,e.xhrUpload.headers),r}addMetadata(e,t,n){(Array.isArray(n.metaFields)?n.metaFields:Object.keys(t)).forEach((n=>{e.append(n,t[n])}))}createFormDataUpload(e,t){const n=new FormData;this.addMetadata(n,e.meta,t);const r=nw(e);return e.name?n.append(t.fieldName,r,e.meta.name):n.append(t.fieldName,r),n}createBundledUpload(e,t){const n=new FormData,{meta:r}=this.uppy.getState();return this.addMetadata(n,r,t),e.forEach((e=>{const t=this.getOptions(e),r=nw(e);e.name?n.append(t.fieldName,r,e.name):n.append(t.fieldName,r)})),n}upload(e,t,n){const r=this.getOptions(e);return this.uppy.log(`uploading ${t} of ${n}`),new Promise(((t,n)=>{this.uppy.emit("upload-started",e);const o=r.formData?this.createFormDataUpload(e,r):e.data,i=new XMLHttpRequest;this.uploaderEvents[e.id]=new bb(this.uppy);const a=new Ob(r.timeout,(()=>{i.abort(),s.done();const t=new Error(this.i18n("timedOut",{seconds:Math.ceil(r.timeout/1e3)}));this.uppy.emit("upload-error",e,t),n(t)})),u=Yb();i.upload.addEventListener("loadstart",(()=>{this.uppy.log(`[XHRUpload] ${u} started`)})),i.upload.addEventListener("progress",(t=>{this.uppy.log(`[XHRUpload] ${u} progress: ${t.loaded} / ${t.total}`),a.progress(),t.lengthComputable&&this.uppy.emit("upload-progress",e,{uploader:this,bytesUploaded:t.loaded,bytesTotal:t.total})})),i.addEventListener("load",(o=>{if(this.uppy.log(`[XHRUpload] ${u} finished`),a.done(),s.done(),this.uploaderEvents[e.id]&&(this.uploaderEvents[e.id].remove(),this.uploaderEvents[e.id]=null),r.validateStatus(o.target.status,i.responseText,i)){const n=r.getResponseData(i.responseText,i),a=n[r.responseUrlFieldName],u={status:o.target.status,body:n,uploadURL:a};return this.uppy.emit("upload-success",e,u),a&&this.uppy.log(`Download ${e.name} from ${a}`),t(e)}const l=r.getResponseData(i.responseText,i),c=tw(i,r.getResponseError(i.responseText,i)),f={status:o.target.status,body:l};return this.uppy.emit("upload-error",e,c,f),n(c)})),i.addEventListener("error",(()=>{this.uppy.log(`[XHRUpload] ${u} errored`),a.done(),s.done(),this.uploaderEvents[e.id]&&(this.uploaderEvents[e.id].remove(),this.uploaderEvents[e.id]=null);const t=tw(i,r.getResponseError(i.responseText,i));return this.uppy.emit("upload-error",e,t),n(t)})),i.open(r.method.toUpperCase(),r.endpoint,!0),i.withCredentials=r.withCredentials,""!==r.responseType&&(i.responseType=r.responseType);const s=this.requests.run((()=>{this.uppy.emit("upload-started",e);const t=this.getOptions(e);return Object.keys(t.headers).forEach((e=>{i.setRequestHeader(e,t.headers[e])})),i.send(o),()=>{a.done(),i.abort()}}));this.onFileRemove(e.id,(()=>{s.abort(),n(new Error("File removed"))})),this.onCancelAll(e.id,(()=>{s.abort(),n(new Error("Upload cancelled"))}))}))}uploadRemote(e){const t=this.getOptions(e);return new Promise(((n,r)=>{this.uppy.emit("upload-started",e);const o={};(Array.isArray(t.metaFields)?t.metaFields:Object.keys(e.meta)).forEach((t=>{o[t]=e.meta[t]}));new(e.remote.providerOptions.provider?Xb:Zb)(this.uppy,e.remote.providerOptions).post(e.remote.url,{...e.remote.body,endpoint:t.endpoint,size:e.data.size,fieldname:t.fieldName,metadata:o,httpMethod:t.method,useFormData:t.formData,headers:t.headers}).then((o=>{const{token:i}=o,a=function(e){const t=/^(?:https?:\/\/|\/\/)?(?:[^@\n]+@)?(?:www\.)?([^\n]+)/i.exec(e)[1];return`${/^http:\/\//i.test(e)?"ws":"wss"}://${t}`}(e.remote.companionUrl),u=new Jb({target:`${a}/api/${i}`,autoOpen:!1});this.uploaderEvents[e.id]=new bb(this.uppy),this.onFileRemove(e.id,(()=>{u.send("cancel",{}),s.abort(),n(`upload ${e.id} was removed`)})),this.onCancelAll(e.id,(()=>{u.send("cancel",{}),s.abort(),n(`upload ${e.id} was canceled`)})),this.onRetry(e.id,(()=>{u.send("pause",{}),u.send("resume",{})})),this.onRetryAll(e.id,(()=>{u.send("pause",{}),u.send("resume",{})})),u.on("progress",(t=>gb(this,t,e))),u.on("success",(r=>{const o=t.getResponseData(r.response.responseText,r.response),i=o[t.responseUrlFieldName],a={status:r.response.status,body:o,uploadURL:i};return this.uppy.emit("upload-success",e,a),s.done(),this.uploaderEvents[e.id]&&(this.uploaderEvents[e.id].remove(),this.uploaderEvents[e.id]=null),n()})),u.on("error",(n=>{const o=n.response,i=o?t.getResponseError(o.responseText,o):Object.assign(new Error(n.error.message),{cause:n.error});this.uppy.emit("upload-error",e,i),s.done(),this.uploaderEvents[e.id]&&(this.uploaderEvents[e.id].remove(),this.uploaderEvents[e.id]=null),r(i)}));const s=this.requests.run((()=>(u.open(),e.isPaused&&u.send("pause",{}),()=>u.close())))})).catch((t=>{this.uppy.emit("upload-error",e,t),r(t)}))}))}uploadBundle(e){return new Promise(((t,n)=>{const{endpoint:r}=this.opts,{method:o}=this.opts,i=this.uppy.getState().xhrUpload,a=this.createBundledUpload(e,{...this.opts,...i||{}}),u=new XMLHttpRequest,s=new Ob(this.opts.timeout,(()=>{u.abort();const e=new Error(this.i18n("timedOut",{seconds:Math.ceil(this.opts.timeout/1e3)}));l(e),n(e)})),l=t=>{e.forEach((e=>{this.uppy.emit("upload-error",e,t)}))};u.upload.addEventListener("loadstart",(()=>{this.uppy.log("[XHRUpload] started uploading bundle"),s.progress()})),u.upload.addEventListener("progress",(t=>{s.progress(),t.lengthComputable&&e.forEach((e=>{this.uppy.emit("upload-progress",e,{uploader:this,bytesUploaded:t.loaded/t.total*e.size,bytesTotal:e.size})}))})),u.addEventListener("load",(r=>{if(s.done(),this.opts.validateStatus(r.target.status,u.responseText,u)){const n=this.opts.getResponseData(u.responseText,u),o={status:r.target.status,body:n};return e.forEach((e=>{this.uppy.emit("upload-success",e,o)})),t()}const o=this.opts.getResponseError(u.responseText,u)||new Error("Upload error");return o.request=u,l(o),n(o)})),u.addEventListener("error",(()=>{s.done();const e=this.opts.getResponseError(u.responseText,u)||new Error("Upload error");return l(e),n(e)})),this.uppy.on("cancel-all",(()=>{s.done(),u.abort()})),u.open(o.toUpperCase(),r,!0),u.withCredentials=this.opts.withCredentials,""!==this.opts.responseType&&(u.responseType=this.opts.responseType),Object.keys(this.opts.headers).forEach((e=>{u.setRequestHeader(e,this.opts.headers[e])})),u.send(a),e.forEach((e=>{this.uppy.emit("upload-started",e)}))}))}uploadFiles(e){const t=e.map(((t,n)=>{const r=parseInt(n,10)+1,o=e.length;return t.error?Promise.reject(new Error(t.error)):t.isRemote?this.uploadRemote(t,r,o):this.upload(t,r,o)}));return function(e){const t=[],n=[];function r(e){t.push(e)}function o(e){n.push(e)}return Promise.all(e.map((e=>e.then(r,o)))).then((()=>({successful:t,failed:n})))}(t)}onFileRemove(e,t){this.uploaderEvents[e].on("file-removed",(n=>{e===n.id&&t(n.id)}))}onRetry(e,t){this.uploaderEvents[e].on("upload-retry",(n=>{e===n&&t()}))}onRetryAll(e,t){this.uploaderEvents[e].on("retry-all",(()=>{this.uppy.getFile(e)&&t()}))}onCancelAll(e,t){this.uploaderEvents[e].on("cancel-all",(()=>{this.uppy.getFile(e)&&t()}))}handleUpload(e){if(0===e.length)return this.uppy.log("[XHRUpload] No files to upload!"),Promise.resolve();0!==this.opts.limit||this.opts[ew]||this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0","warning"),this.uppy.log("[XHRUpload] Uploading...");const t=e.map((e=>this.uppy.getFile(e)));if(this.opts.bundle){if(t.some((e=>e.isRemote)))throw new Error("Canât upload remote files when the `bundle: true` option is set");if("function"==typeof this.opts.headers)throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");return this.uploadBundle(t)}return this.uploadFiles(t).then((()=>null))}install(){if(this.opts.bundle){const{capabilities:e}=this.uppy.getState();this.uppy.setState({capabilities:{...e,individualCancellation:!1}})}this.uppy.addUploader(this.handleUpload)}uninstall(){if(this.opts.bundle){const{capabilities:e}=this.uppy.getState();this.uppy.setState({capabilities:{...e,individualCancellation:!0}})}this.uppy.removeUploader(this.handleUpload)}},Wb.VERSION="2.0.6",Gb),ow="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function iw(e){var t={exports:{}};return e(t,t.exports),t.exports}var aw,uw,sw=function(e){return e&&e.Math==Math&&e},lw=sw("object"==typeof globalThis&&globalThis)||sw("object"==typeof window&&window)||sw("object"==typeof self&&self)||sw("object"==typeof ow&&ow)||function(){return this}()||Function("return this")(),cw=Object.defineProperty,fw=function(e,t){try{cw(lw,e,{value:t,configurable:!0,writable:!0})}catch(n){lw[e]=t}return t},dw=lw["__core-js_shared__"]||fw("__core-js_shared__",{}),pw=iw((function(e){(e.exports=function(e,t){return dw[e]||(dw[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),hw=Function.prototype,gw=hw.bind,vw=hw.call,yw=gw&&gw.bind(vw),mw=gw?function(e){return e&&yw(vw,e)}:function(e){return e&&function(){return vw.apply(e,arguments)}},bw=lw.TypeError,ww=function(e){if(null==e)throw bw("Can't call method on "+e);return e},Ew=lw.Object,Dw=function(e){return Ew(ww(e))},Sw=mw({}.hasOwnProperty),xw=Object.hasOwn||function(e,t){return Sw(Dw(e),t)},Cw=0,Aw=Math.random(),Ow=mw(1..toString),kw=function(e){return"Symbol("+(void 0===e?"":e)+")_"+Ow(++Cw+Aw,36)},Bw=function(e){return"function"==typeof e},Fw=function(e){return Bw(e)?e:void 0},Tw=function(e,t){return arguments.length<2?Fw(lw[e]):lw[e]&&lw[e][t]},_w=Tw("navigator","userAgent")||"",Pw=lw.process,jw=lw.Deno,Nw=Pw&&Pw.versions||jw&&jw.version,Iw=Nw&&Nw.v8;Iw&&(uw=(aw=Iw.split("."))[0]>0&&aw[0]<4?1:+(aw[0]+aw[1])),!uw&&_w&&(!(aw=_w.match(/Edge\/(\d+)/))||aw[1]>=74)&&(aw=_w.match(/Chrome\/(\d+)/))&&(uw=+aw[1]);var Lw=uw,Rw=function(e){try{return!!e()}catch(e){return!0}},Mw=!!Object.getOwnPropertySymbols&&!Rw((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&Lw&&Lw<41})),zw=Mw&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,$w=pw("wks"),Hw=lw.Symbol,Vw=Hw&&Hw.for,Uw=zw?Hw:Hw&&Hw.withoutSetter||kw,Ww=function(e){if(!xw($w,e)||!Mw&&"string"!=typeof $w[e]){var t="Symbol."+e;Mw&&xw(Hw,e)?$w[e]=Hw[e]:$w[e]=zw&&Vw?Vw(t):Uw(t)}return $w[e]},Gw={};Gw[Ww("toStringTag")]="z";var qw="[object z]"===String(Gw),Kw=!Rw((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),Yw=function(e){return"object"==typeof e?null!==e:Bw(e)},Xw=lw.document,Zw=Yw(Xw)&&Yw(Xw.createElement),Jw=function(e){return Zw?Xw.createElement(e):{}},Qw=!Kw&&!Rw((function(){return 7!=Object.defineProperty(Jw("div"),"a",{get:function(){return 7}}).a})),eE=lw.String,tE=lw.TypeError,nE=function(e){if(Yw(e))return e;throw tE(eE(e)+" is not an object")},rE=Function.prototype.call,oE=rE.bind?rE.bind(rE):function(){return rE.apply(rE,arguments)},iE=mw({}.isPrototypeOf),aE=lw.Object,uE=zw?function(e){return"symbol"==typeof e}:function(e){var t=Tw("Symbol");return Bw(t)&&iE(t.prototype,aE(e))},sE=lw.String,lE=function(e){try{return sE(e)}catch(e){return"Object"}},cE=lw.TypeError,fE=function(e){if(Bw(e))return e;throw cE(lE(e)+" is not a function")},dE=function(e,t){var n=e[t];return null==n?void 0:fE(n)},pE=lw.TypeError,hE=lw.TypeError,gE=Ww("toPrimitive"),vE=function(e){var t=function(e,t){if(!Yw(e)||uE(e))return e;var n,r=dE(e,gE);if(r){if(void 0===t&&(t="default"),n=oE(r,e,t),!Yw(n)||uE(n))return n;throw hE("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&Bw(n=e.toString)&&!Yw(r=oE(n,e)))return r;if(Bw(n=e.valueOf)&&!Yw(r=oE(n,e)))return r;if("string"!==t&&Bw(n=e.toString)&&!Yw(r=oE(n,e)))return r;throw pE("Can't convert object to primitive value")}(e,t)}(e,"string");return uE(t)?t:t+""},yE=lw.TypeError,mE=Object.defineProperty,bE={f:Kw?mE:function(e,t,n){if(nE(e),t=vE(t),nE(n),Qw)try{return mE(e,t,n)}catch(e){}if("get"in n||"set"in n)throw yE("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},wE=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},EE=Kw?function(e,t,n){return bE.f(e,t,wE(1,n))}:function(e,t,n){return e[t]=n,e},DE=mw(Function.toString);Bw(dw.inspectSource)||(dw.inspectSource=function(e){return DE(e)});var SE,xE,CE,AE=dw.inspectSource,OE=lw.WeakMap,kE=Bw(OE)&&/native code/.test(AE(OE)),BE=pw("keys"),FE=function(e){return BE[e]||(BE[e]=kw(e))},TE={},_E=lw.TypeError,PE=lw.WeakMap;if(kE||dw.state){var jE=dw.state||(dw.state=new PE),NE=mw(jE.get),IE=mw(jE.has),LE=mw(jE.set);SE=function(e,t){if(IE(jE,e))throw new _E("Object already initialized");return t.facade=e,LE(jE,e,t),t},xE=function(e){return NE(jE,e)||{}},CE=function(e){return IE(jE,e)}}else{var RE=FE("state");TE[RE]=!0,SE=function(e,t){if(xw(e,RE))throw new _E("Object already initialized");return t.facade=e,EE(e,RE,t),t},xE=function(e){return xw(e,RE)?e[RE]:{}},CE=function(e){return xw(e,RE)}}var ME={set:SE,get:xE,has:CE,enforce:function(e){return CE(e)?xE(e):SE(e,{})},getterFor:function(e){return function(t){var n;if(!Yw(t)||(n=xE(t)).type!==e)throw _E("Incompatible receiver, "+e+" required");return n}}},zE=Function.prototype,$E=Kw&&Object.getOwnPropertyDescriptor,HE=xw(zE,"name"),VE={EXISTS:HE,PROPER:HE&&"something"===function(){}.name,CONFIGURABLE:HE&&(!Kw||Kw&&$E(zE,"name").configurable)},UE=iw((function(e){var t=VE.CONFIGURABLE,n=ME.get,r=ME.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;Bw(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!xw(i,"name")||t&&i.name!==f)&&EE(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==lw?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:EE(e,n,i)):l?e[n]=i:fw(n,i)})(Function.prototype,"toString",(function(){return Bw(this)&&n(this).source||AE(this)}))})),WE=mw({}.toString),GE=mw("".slice),qE=function(e){return GE(WE(e),8,-1)},KE=Ww("toStringTag"),YE=lw.Object,XE="Arguments"==qE(function(){return arguments}()),ZE=qw?qE:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=YE(e),KE))?n:XE?qE(t):"Object"==(r=qE(t))&&Bw(t.callee)?"Arguments":r},JE=qw?{}.toString:function(){return"[object "+ZE(this)+"]"};qw||UE(Object.prototype,"toString",JE,{unsafe:!0});var QE={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},eD=Jw("span").classList,tD=eD&&eD.constructor&&eD.constructor.prototype,nD=tD===Object.prototype?void 0:tD,rD=mw(mw.bind),oD=function(e,t){return fE(e),void 0===t?e:rD?rD(e,t):function(){return e.apply(t,arguments)}},iD=lw.Object,aD=mw("".split),uD=Rw((function(){return!iD("z").propertyIsEnumerable(0)}))?function(e){return"String"==qE(e)?aD(e,""):iD(e)}:iD,sD=Math.ceil,lD=Math.floor,cD=function(e){var t=+e;return t!=t||0===t?0:(t>0?lD:sD)(t)},fD=Math.min,dD=function(e){return e>0?fD(cD(e),9007199254740991):0},pD=function(e){return dD(e.length)},hD=Array.isArray||function(e){return"Array"==qE(e)},gD=function(){},vD=[],yD=Tw("Reflect","construct"),mD=/^\s*(?:class|function)\b/,bD=mw(mD.exec),wD=!mD.exec(gD),ED=function(e){if(!Bw(e))return!1;try{return yD(gD,vD,e),!0}catch(e){return!1}},DD=!yD||Rw((function(){var e;return ED(ED.call)||!ED(Object)||!ED((function(){e=!0}))||e}))?function(e){if(!Bw(e))return!1;switch(ZE(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return wD||!!bD(mD,AE(e))}:ED,SD=Ww("species"),xD=lw.Array,CD=function(e,t){return new(function(e){var t;return hD(e)&&(t=e.constructor,(DD(t)&&(t===xD||hD(t.prototype))||Yw(t)&&null===(t=t[SD]))&&(t=void 0)),void 0===t?xD:t}(e))(0===t?0:t)},AD=mw([].push),OD=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=Dw(s),g=uD(h),v=oD(l,c),y=pD(g),m=0,b=f||CD,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:AD(w,d)}else switch(e){case 4:return!1;case 7:AD(w,d)}return i?-1:r||o?o:w}},kD={forEach:OD(0),map:OD(1),filter:OD(2),some:OD(3),every:OD(4),find:OD(5),findIndex:OD(6),filterReject:OD(7)},BD=function(e,t){var n=[][e];return!!n&&Rw((function(){n.call(null,t||function(){throw 1},1)}))},FD=kD.forEach,TD=BD("forEach")?[].forEach:function(e){return FD(this,e,arguments.length>1?arguments[1]:void 0)},_D=function(e){if(e&&e.forEach!==TD)try{EE(e,"forEach",TD)}catch(t){e.forEach=TD}};for(var PD in QE)QE[PD]&&_D(lw[PD]&&lw[PD].prototype);_D(nD);var jD={}.propertyIsEnumerable,ND=Object.getOwnPropertyDescriptor,ID=ND&&!jD.call({1:2},1)?function(e){var t=ND(this,e);return!!t&&t.enumerable}:jD,LD={f:ID},RD=function(e){return uD(ww(e))},MD=Object.getOwnPropertyDescriptor,zD={f:Kw?MD:function(e,t){if(e=RD(e),t=vE(t),Qw)try{return MD(e,t)}catch(e){}if(xw(e,t))return wE(!oE(LD.f,e,t),e[t])}},$D=Math.max,HD=Math.min,VD=function(e,t){var n=cD(e);return n<0?$D(n+t,0):HD(n,t)},UD=function(e){return function(t,n,r){var o,i=RD(t),a=pD(i),u=VD(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},WD={includes:UD(!0),indexOf:UD(!1)},GD=WD.indexOf,qD=mw([].push),KD=function(e,t){var n,r=RD(e),o=0,i=[];for(n in r)!xw(TE,n)&&xw(r,n)&&qD(i,n);for(;t.length>o;)xw(r,n=t[o++])&&(~GD(i,n)||qD(i,n));return i},YD=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],XD=YD.concat("length","prototype"),ZD={f:Object.getOwnPropertyNames||function(e){return KD(e,XD)}},JD={f:Object.getOwnPropertySymbols},QD=mw([].concat),eS=Tw("Reflect","ownKeys")||function(e){var t=ZD.f(nE(e)),n=JD.f;return n?QD(t,n(e)):t},tS=function(e,t){for(var n=eS(t),r=bE.f,o=zD.f,i=0;i<n.length;i++){var a=n[i];xw(e,a)||r(e,a,o(t,a))}},nS=/#|\.prototype\./,rS=function(e,t){var n=iS[oS(e)];return n==uS||n!=aS&&(Bw(t)?Rw(t):!!t)},oS=rS.normalize=function(e){return String(e).replace(nS,".").toLowerCase()},iS=rS.data={},aS=rS.NATIVE="N",uS=rS.POLYFILL="P",sS=rS,lS=zD.f,cS=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?lw:l?lw[u]||fw(u,{}):(lw[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=lS(n,r))&&a.value:n[r],!sS(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;tS(i,o)}(e.sham||o&&o.sham)&&EE(i,"sham",!0),UE(n,r,i,e)}},fS=Object.keys||function(e){return KD(e,YD)},dS=Rw((function(){fS(1)}));
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */function pS(e){return"[object Object]"===Object.prototype.toString.call(e)}cS({target:"Object",stat:!0,forced:dS},{keys:function(e){return fS(Dw(e))}});var hS={isHistory(e){return!1!==pS(t=e)&&(void 0===(n=t.constructor)||!1!==pS(r=n.prototype)&&!1!==r.hasOwnProperty("isPrototypeOf"))&&Array.isArray(e.redos)&&Array.isArray(e.undos)&&(0===e.redos.length||Rf.isOperationList(e.redos[0]))&&(0===e.undos.length||Rf.isOperationList(e.undos[0]));// removed by dead control flow
{ var t, n, r; }}},gS=new WeakMap,vS=new WeakMap,yS={isHistoryEditor:e=>hS.isHistory(e.history)&&Bf.isEditor(e),isMerging:e=>vS.get(e),isSaving:e=>gS.get(e),redo(e){e.redo()},undo(e){e.undo()},withoutMerging(e,t){var n=yS.isMerging(e);vS.set(e,!1),t(),vS.set(e,n)},withoutSaving(e,t){var n=yS.isSaving(e);gS.set(e,!1),t(),gS.set(e,n)}},mS=lw.String,bS=function(e){if("Symbol"===ZE(e))throw TypeError("Cannot convert a Symbol value to a string");return mS(e)},wS=function(){var e=nE(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},ES=VE.PROPER,DS=RegExp.prototype,SS=DS.toString,xS=mw(wS),CS=Rw((function(){return"/a/b"!=SS.call({source:"a",flags:"b"})})),AS=ES&&"toString"!=SS.name;(CS||AS)&&UE(RegExp.prototype,"toString",(function(){var e=nE(this),t=bS(e.source),n=e.flags;return"/"+t+"/"+bS(void 0===n&&iE(DS,e)&&!("flags"in DS)?xS(e):n)}),{unsafe:!0});var OS,kS=Kw?Object.defineProperties:function(e,t){nE(e);for(var n,r=RD(t),o=fS(t),i=o.length,a=0;i>a;)bE.f(e,n=o[a++],r[n]);return e},BS=Tw("document","documentElement"),FS=FE("IE_PROTO"),TS=function(){},_S=function(e){return"<script>"+e+"<\/script>"},PS=function(e){e.write(_S("")),e.close();var t=e.parentWindow.Object;return e=null,t},jS=function(){try{OS=new ActiveXObject("htmlfile")}catch(e){}var e,t;jS="undefined"!=typeof document?document.domain&&OS?PS(OS):((t=Jw("iframe")).style.display="none",BS.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(_S("document.F=Object")),e.close(),e.F):PS(OS);for(var n=YD.length;n--;)delete jS.prototype[YD[n]];return jS()};TE[FS]=!0;var NS=Object.create||function(e,t){var n;return null!==e?(TS.prototype=nE(e),n=new TS,TS.prototype=null,n[FS]=e):n=jS(),void 0===t?n:kS(n,t)},IS=Ww("unscopables"),LS=Array.prototype;null==LS[IS]&&bE.f(LS,IS,{configurable:!0,value:NS(null)});var RS=function(e){LS[IS][e]=!0},MS=WD.includes;cS({target:"Array",proto:!0},{includes:function(e){return MS(this,e,arguments.length>1?arguments[1]:void 0)}}),RS("includes");var zS=Ww("match"),$S=function(e){var t;return Yw(e)&&(void 0!==(t=e[zS])?!!t:"RegExp"==qE(e))},HS=lw.TypeError,VS=function(e){if($S(e))throw HS("The method doesn't accept regular expressions");return e},US=Ww("match"),WS=function(e){var t=/./;try{"/./"[e](t)}catch(n){try{return t[US]=!1,"/./"[e](t)}catch(e){}}return!1},GS=mw("".indexOf);cS({target:"String",proto:!0,forced:!WS("includes")},{includes:function(e){return!!~GS(bS(ww(this)),bS(VS(e)),arguments.length>1?arguments[1]:void 0)}});var qS=/"/g,KS=mw("".replace);cS({target:"String",proto:!0,forced:("anchor",Rw((function(){var e="".anchor('"');return e!==e.toLowerCase()||e.split('"').length>3})))},{anchor:function(e){return"a","name",t=e,n=bS(ww(this)),r="<a",(r+=' name="'+KS(bS(t),qS,"&quot;")+'"')+">"+n+"</a>";// removed by dead control flow
{ var t, n, r; }}});var YS=function(e,t,n){var r,o;nE(e);try{if(!(r=dE(e,"return"))){if("throw"===t)throw n;return n}r=oE(r,e)}catch(e){o=!0,r=e}if("throw"===t)throw n;if(o)throw r;return nE(r),n},XS=function(e,t,n,r){try{return r?t(nE(n)[0],n[1]):t(n)}catch(t){YS(e,"throw",t)}},ZS={},JS=Ww("iterator"),QS=Array.prototype,ex=function(e){return void 0!==e&&(ZS.Array===e||QS[JS]===e)},tx=function(e,t,n){var r=vE(t);r in e?bE.f(e,r,wE(0,n)):e[r]=n},nx=Ww("iterator"),rx=function(e){if(null!=e)return dE(e,nx)||dE(e,"@@iterator")||ZS[ZE(e)]},ox=lw.TypeError,ix=function(e,t){var n=arguments.length<2?rx(e):t;if(fE(n))return nE(oE(n,e));throw ox(lE(e)+" is not iterable")},ax=lw.Array,ux=Ww("iterator"),sx=!1;try{var lx=0,cx={next:function(){return{done:!!lx++}},return:function(){sx=!0}};cx[ux]=function(){return this},Array.from(cx,(function(){throw 2}))}catch(jO){}var fx=function(e,t){if(!t&&!sx)return!1;var n=!1;try{var r={};r[ux]=function(){return{next:function(){return{done:n=!0}}}},e(r)}catch(e){}return n},dx=!fx((function(e){Array.from(e)}));cS({target:"Array",stat:!0,forced:dx},{from:function(e){var t=Dw(e),n=DD(this),r=arguments.length,o=r>1?arguments[1]:void 0,i=void 0!==o;i&&(o=oD(o,r>2?arguments[2]:void 0));var a,u,s,l,c,f,d=rx(t),p=0;if(!d||this==ax&&ex(d))for(a=pD(t),u=n?new this(a):ax(a);a>p;p++)f=i?o(t[p],p):t[p],tx(u,p,f);else for(c=(l=ix(t,d)).next,u=n?new this:[];!(s=oE(c,l)).done;p++)f=i?XS(l,o,[s.value,p],!0):s.value,tx(u,p,f);return u.length=p,u}});var px,hx,gx,vx=mw("".charAt),yx=mw("".charCodeAt),mx=mw("".slice),bx=function(e){return function(t,n){var r,o,i=bS(ww(t)),a=cD(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=yx(i,a))<55296||r>56319||a+1===u||(o=yx(i,a+1))<56320||o>57343?e?vx(i,a):r:e?mx(i,a,a+2):o-56320+(r-55296<<10)+65536}},wx={codeAt:bx(!1),charAt:bx(!0)},Ex=!Rw((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),Dx=FE("IE_PROTO"),Sx=lw.Object,xx=Sx.prototype,Cx=Ex?Sx.getPrototypeOf:function(e){var t=Dw(e);if(xw(t,Dx))return t[Dx];var n=t.constructor;return Bw(n)&&t instanceof n?n.prototype:t instanceof Sx?xx:null},Ax=Ww("iterator"),Ox=!1;[].keys&&("next"in(gx=[].keys())?(hx=Cx(Cx(gx)))!==Object.prototype&&(px=hx):Ox=!0);var kx=null==px||Rw((function(){var e={};return px[Ax].call(e)!==e}));kx&&(px={}),Bw(px[Ax])||UE(px,Ax,(function(){return this}));var Bx={IteratorPrototype:px,BUGGY_SAFARI_ITERATORS:Ox},Fx=bE.f,Tx=Ww("toStringTag"),_x=function(e,t,n){e&&!xw(e=n?e:e.prototype,Tx)&&Fx(e,Tx,{configurable:!0,value:t})},Px=Bx.IteratorPrototype,jx=function(){return this},Nx=lw.String,Ix=lw.TypeError,Lx=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=mw(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(n,[]),t=n instanceof Array}catch(e){}return function(n,r){return nE(n),function(e){if("object"==typeof e||Bw(e))return e;throw Ix("Can't set "+Nx(e)+" as a prototype")}(r),t?e(n,r):n.__proto__=r,n}}():void 0),Rx=VE.PROPER,Mx=VE.CONFIGURABLE,zx=Bx.IteratorPrototype,$x=Bx.BUGGY_SAFARI_ITERATORS,Hx=Ww("iterator"),Vx=function(){return this},Ux=function(e,t,n,r,o,i,a){!function(e,t,n,r){var o=t+" Iterator";e.prototype=NS(Px,{next:wE(1,n)}),_x(e,o,!1),ZS[o]=jx}(n,t,r);var u,s,l,c=function(e){if(e===o&&g)return g;if(!$x&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[Hx]||p["@@iterator"]||o&&p[o],g=!$x&&h||c(o),v="Array"==t&&p.entries||h;if(v&&(u=Cx(v.call(new e)))!==Object.prototype&&u.next&&(Cx(u)!==zx&&(Lx?Lx(u,zx):Bw(u[Hx])||UE(u,Hx,Vx)),_x(u,f,!0)),Rx&&"values"==o&&h&&"values"!==h.name&&(Mx?EE(p,"name","values"):(d=!0,g=function(){return oE(h,this)})),o)if(s={values:c("values"),keys:i?g:c("keys"),entries:c("entries")},a)for(l in s)($x||d||!(l in p))&&UE(p,l,s[l]);else cS({target:t,proto:!0,forced:$x||d},s);return p[Hx]!==g&&UE(p,Hx,g,{name:o}),ZS[t]=g,s},Wx=wx.charAt,Gx=ME.set,qx=ME.getterFor("String Iterator");Ux(String,"String",(function(e){Gx(this,{type:"String Iterator",string:bS(e),index:0})}),(function(){var e,t=qx(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=Wx(n,r),t.index+=e.length,{value:e,done:!1})}));var Kx,Yx=zD.f,Xx=mw("".endsWith),Zx=mw("".slice),Jx=Math.min,Qx=WS("endsWith"),eC=!(Qx||(Kx=Yx(String.prototype,"endsWith"),!Kx||Kx.writable));cS({target:"String",proto:!0,forced:!eC&&!Qx},{endsWith:function(e){var t=bS(ww(this));VS(e);var n=arguments.length>1?arguments[1]:void 0,r=t.length,o=void 0===n?r:Jx(dD(n),r),i=bS(e);return Xx?Xx(t,i,o):Zx(t,o-i.length,o)===i}});var tC=mw([].join),nC=uD!=Object,rC=BD("join",",");cS({target:"Array",proto:!0,forced:nC||!rC},{join:function(e){return tC(RD(this),void 0===e?",":e)}});var oC=Ww("species"),iC=function(e){return Lw>=51||!Rw((function(){var t=[];return(t.constructor={})[oC]=function(){return{foo:1}},1!==t[e](Boolean).foo}))},aC=kD.map,uC=iC("map");cS({target:"Array",proto:!0,forced:!uC},{map:function(e){return aC(this,e,arguments.length>1?arguments[1]:void 0)}});var sC=lw.RegExp,lC=Rw((function(){var e=sC("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),cC=lC||Rw((function(){return!sC("a","y").sticky})),fC={BROKEN_CARET:lC||Rw((function(){var e=sC("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:cC,UNSUPPORTED_Y:lC},dC=lw.RegExp,pC=Rw((function(){var e=dC(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),hC=lw.RegExp,gC=Rw((function(){var e=hC("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),vC=ME.get,yC=pw("native-string-replace",String.prototype.replace),mC=RegExp.prototype.exec,bC=mC,wC=mw("".charAt),EC=mw("".indexOf),DC=mw("".replace),SC=mw("".slice),xC=function(){var e=/a/,t=/b*/g;return oE(mC,e,"a"),oE(mC,t,"a"),0!==e.lastIndex||0!==t.lastIndex}(),CC=fC.BROKEN_CARET,AC=void 0!==/()??/.exec("")[1];(xC||AC||CC||pC||gC)&&(bC=function(e){var t,n,r,o,i,a,u,s=this,l=vC(s),c=bS(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=oE(bC,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=CC&&s.sticky,h=oE(wS,s),g=s.source,v=0,y=c;if(p&&(h=DC(h,"y",""),-1===EC(h,"g")&&(h+="g"),y=SC(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==wC(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),AC&&(n=new RegExp("^"+g+"$(?!\\s)",h)),xC&&(r=s.lastIndex),o=oE(mC,p?n:s,y),p?o?(o.input=SC(o.input,v),o[0]=SC(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:xC&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),AC&&o&&o.length>1&&oE(yC,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=NS(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var OC=bC;cS({target:"RegExp",proto:!0,forced:/./.exec!==OC},{exec:OC});var kC=Function.prototype,BC=kC.apply,FC=kC.bind,TC=kC.call,_C="object"==typeof Reflect&&Reflect.apply||(FC?TC.bind(BC):function(){return TC.apply(BC,arguments)}),PC=Ww("species"),jC=RegExp.prototype,NC=function(e,t,n,r){var o=Ww(e),i=!Rw((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!Rw((function(){var t=!1,n=/a/;return"split"===e&&((n={}).constructor={},n.constructor[PC]=function(){return n},n.flags="",n[o]=/./[o]),n.exec=function(){return t=!0,null},n[o](""),!t}));if(!i||!a||n){var u=mw(/./[o]),s=t(o,""[e],(function(e,t,n,r,o){var a=mw(e),s=t.exec;return s===OC||s===jC.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));UE(String.prototype,e,s[0]),UE(jC,o,s[1])}r&&EE(jC[o],"sham",!0)},IC=wx.charAt,LC=function(e,t,n){return t+(n?IC(e,t).length:1)},RC=Math.floor,MC=mw("".charAt),zC=mw("".replace),$C=mw("".slice),HC=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,VC=/\$([$&'`]|\d{1,2})/g,UC=function(e,t,n,r,o,i){var a=n+e.length,u=r.length,s=VC;return void 0!==o&&(o=Dw(o),s=HC),zC(i,s,(function(i,s){var l;switch(MC(s,0)){case"$":return"$";case"&":return e;case"`":return $C(t,0,n);case"'":return $C(t,a);case"<":l=o[$C(s,1,-1)];break;default:var c=+s;if(0===c)return i;if(c>u){var f=RC(c/10);return 0===f?i:f<=u?void 0===r[f-1]?MC(s,1):r[f-1]+MC(s,1):i}l=r[c-1]}return void 0===l?"":l}))},WC=lw.TypeError,GC=function(e,t){var n=e.exec;if(Bw(n)){var r=oE(n,e,t);return null!==r&&nE(r),r}if("RegExp"===qE(e))return oE(OC,e,t);throw WC("RegExp#exec called on incompatible receiver")},qC=Ww("replace"),KC=Math.max,YC=Math.min,XC=mw([].concat),ZC=mw([].push),JC=mw("".indexOf),QC=mw("".slice),eA="$0"==="a".replace(/./,"$0"),tA=!!/./[qC]&&""===/./[qC]("a","$0");NC("replace",(function(e,t,n){var r=tA?"$":"$0";return[function(e,n){var r=ww(this),o=null==e?void 0:dE(e,qC);return o?oE(o,e,r,n):oE(t,bS(r),e,n)},function(e,o){var i=nE(this),a=bS(e);if("string"==typeof o&&-1===JC(o,r)&&-1===JC(o,"$<")){var u=n(t,i,a,o);if(u.done)return u.value}var s=Bw(o);s||(o=bS(o));var l=i.global;if(l){var c=i.unicode;i.lastIndex=0}for(var f=[];;){var d=GC(i,a);if(null===d)break;if(ZC(f,d),!l)break;""===bS(d[0])&&(i.lastIndex=LC(a,dD(i.lastIndex),c))}for(var p,h="",g=0,v=0;v<f.length;v++){for(var y=bS((d=f[v])[0]),m=KC(YC(cD(d.index),a.length),0),b=[],w=1;w<d.length;w++)ZC(b,void 0===(p=d[w])?p:String(p));var E=d.groups;if(s){var D=XC([y],b,m,a);void 0!==E&&ZC(D,E);var S=bS(_C(o,void 0,D))}else S=UC(y,a,m,b,E,o);m>=g&&(h+=QC(a,g,m)+S,g=m+y.length)}return h+QC(a,g)}]}),!!Rw((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!eA||tA);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var nA=function(e,t){return nA=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},nA(e,t)};function rA(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}nA(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var oA=function(){return oA=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e},oA.apply(this,arguments)};function iA(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function aA(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return a}function uA(e,t){for(var n=0,r=t.length,o=e.length;n<r;n++,o++)e[o]=t[n];return e}var sA=0,lA=function(){this.id=""+sA++},cA=ME.set,fA=ME.getterFor("Array Iterator"),dA=Ux(Array,"Array",(function(e,t){cA(this,{type:"Array Iterator",target:RD(e),index:0,kind:t})}),(function(){var e=fA(this),t=e.target,n=e.kind,r=e.index++;return!t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");ZS.Arguments=ZS.Array,RS("keys"),RS("values"),RS("entries");var pA=function(e,t,n){for(var r in t)UE(e,r,t[r],n);return e},hA=lw.Array,gA=Math.max,vA=function(e,t,n){for(var r=pD(e),o=VD(t,r),i=VD(void 0===n?r:n,r),a=hA(gA(i-o,0)),u=0;o<i;o++,u++)tx(a,u,e[o]);return a.length=u,a},yA=ZD.f,mA="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],bA={f:function(e){return mA&&"Window"==qE(e)?function(e){try{return yA(e)}catch(e){return vA(mA)}}(e):yA(RD(e))}},wA=Rw((function(){if("function"==typeof ArrayBuffer){var e=new ArrayBuffer(8);Object.isExtensible(e)&&Object.defineProperty(e,"a",{value:8})}})),EA=Object.isExtensible,DA=Rw((function(){EA(1)}))||wA?function(e){return!!Yw(e)&&(!wA||"ArrayBuffer"!=qE(e))&&(!EA||EA(e))}:EA,SA=!Rw((function(){return Object.isExtensible(Object.preventExtensions({}))})),xA=iw((function(e){var t=bE.f,n=!1,r=kw("meta"),o=0,i=function(e){t(e,r,{value:{objectID:"O"+o++,weakData:{}}})},a=e.exports={enable:function(){a.enable=function(){},n=!0;var e=ZD.f,t=mw([].splice),o={};o[r]=1,e(o).length&&(ZD.f=function(n){for(var o=e(n),i=0,a=o.length;i<a;i++)if(o[i]===r){t(o,i,1);break}return o},cS({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:bA.f}))},fastKey:function(e,t){if(!Yw(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!xw(e,r)){if(!DA(e))return"F";if(!t)return"E";i(e)}return e[r].objectID},getWeakData:function(e,t){if(!xw(e,r)){if(!DA(e))return!0;if(!t)return!1;i(e)}return e[r].weakData},onFreeze:function(e){return SA&&n&&DA(e)&&!xw(e,r)&&i(e),e}};TE[r]=!0})),CA=lw.TypeError,AA=function(e,t){this.stopped=e,this.result=t},OA=AA.prototype,kA=function(e,t,n){var r,o,i,a,u,s,l,c=n&&n.that,f=!(!n||!n.AS_ENTRIES),d=!(!n||!n.IS_ITERATOR),p=!(!n||!n.INTERRUPTED),h=oD(t,c),g=function(e){return r&&YS(r,"normal",e),new AA(!0,e)},v=function(e){return f?(nE(e),p?h(e[0],e[1],g):h(e[0],e[1])):p?h(e,g):h(e)};if(d)r=e;else{if(!(o=rx(e)))throw CA(lE(e)+" is not iterable");if(ex(o)){for(i=0,a=pD(e);a>i;i++)if((u=v(e[i]))&&iE(OA,u))return u;return new AA(!1)}r=ix(e,o)}for(s=r.next;!(l=oE(s,r)).done;){try{u=v(l.value)}catch(e){YS(r,"throw",e)}if("object"==typeof u&&u&&iE(OA,u))return u}return new AA(!1)},BA=lw.TypeError,FA=function(e,t){if(iE(t,e))return e;throw BA("Incorrect invocation")},TA=function(e,t,n){var r,o;return Lx&&Bw(r=t.constructor)&&r!==n&&Yw(o=r.prototype)&&o!==n.prototype&&Lx(e,o),e},_A=function(e,t,n){var r=-1!==e.indexOf("Map"),o=-1!==e.indexOf("Weak"),i=r?"set":"add",a=lw[e],u=a&&a.prototype,s=a,l={},c=function(e){var t=mw(u[e]);UE(u,e,"add"==e?function(e){return t(this,0===e?0:e),this}:"delete"==e?function(e){return!(o&&!Yw(e))&&t(this,0===e?0:e)}:"get"==e?function(e){return o&&!Yw(e)?void 0:t(this,0===e?0:e)}:"has"==e?function(e){return!(o&&!Yw(e))&&t(this,0===e?0:e)}:function(e,n){return t(this,0===e?0:e,n),this})};if(sS(e,!Bw(a)||!(o||u.forEach&&!Rw((function(){(new a).entries().next()})))))s=n.getConstructor(t,e,r,i),xA.enable();else if(sS(e,!0)){var f=new s,d=f[i](o?{}:-0,1)!=f,p=Rw((function(){f.has(1)})),h=fx((function(e){new a(e)})),g=!o&&Rw((function(){for(var e=new a,t=5;t--;)e[i](t,t);return!e.has(-0)}));h||((s=t((function(e,t){FA(e,u);var n=TA(new a,e,s);return null!=t&&kA(t,n[i],{that:n,AS_ENTRIES:r}),n}))).prototype=u,u.constructor=s),(p||g)&&(c("delete"),c("has"),r&&c("get")),(g||d)&&c(i),o&&u.clear&&delete u.clear}return l[e]=s,cS({global:!0,forced:s!=a},l),_x(s,e),o||n.setStrong(s,e,r),s},PA=xA.getWeakData,jA=ME.set,NA=ME.getterFor,IA=kD.find,LA=kD.findIndex,RA=mw([].splice),MA=0,zA=function(e){return e.frozen||(e.frozen=new $A)},$A=function(){this.entries=[]},HA=function(e,t){return IA(e.entries,(function(e){return e[0]===t}))};$A.prototype={get:function(e){var t=HA(this,e);if(t)return t[1]},has:function(e){return!!HA(this,e)},set:function(e,t){var n=HA(this,e);n?n[1]=t:this.entries.push([e,t])},delete:function(e){var t=LA(this.entries,(function(t){return t[0]===e}));return~t&&RA(this.entries,t,1),!!~t}};var VA,UA={getConstructor:function(e,t,n,r){var o=e((function(e,o){FA(e,i),jA(e,{type:t,id:MA++,frozen:void 0}),null!=o&&kA(o,e[r],{that:e,AS_ENTRIES:n})})),i=o.prototype,a=NA(t),u=function(e,t,n){var r=a(e),o=PA(nE(t),!0);return!0===o?zA(r).set(t,n):o[r.id]=n,e};return pA(i,{delete:function(e){var t=a(this);if(!Yw(e))return!1;var n=PA(e);return!0===n?zA(t).delete(e):n&&xw(n,t.id)&&delete n[t.id]},has:function(e){var t=a(this);if(!Yw(e))return!1;var n=PA(e);return!0===n?zA(t).has(e):n&&xw(n,t.id)}}),pA(i,n?{get:function(e){var t=a(this);if(Yw(e)){var n=PA(e);return!0===n?zA(t).get(e):n?n[t.id]:void 0}},set:function(e,t){return u(this,e,t)}}:{add:function(e){return u(this,e,!0)}}),o}},WA=ME.enforce,GA=!lw.ActiveXObject&&"ActiveXObject"in lw,qA=function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},KA=_A("WeakMap",qA,UA);if(kE&&GA){VA=UA.getConstructor(qA,"WeakMap",!0),xA.enable();var YA=KA.prototype,XA=mw(YA.delete),ZA=mw(YA.has),JA=mw(YA.get),QA=mw(YA.set);pA(YA,{delete:function(e){if(Yw(e)&&!DA(e)){var t=WA(this);return t.frozen||(t.frozen=new VA),XA(this,e)||t.frozen.delete(e)}return XA(this,e)},has:function(e){if(Yw(e)&&!DA(e)){var t=WA(this);return t.frozen||(t.frozen=new VA),ZA(this,e)||t.frozen.has(e)}return ZA(this,e)},get:function(e){if(Yw(e)&&!DA(e)){var t=WA(this);return t.frozen||(t.frozen=new VA),ZA(this,e)?JA(this,e):t.frozen.get(e)}return JA(this,e)},set:function(e,t){if(Yw(e)&&!DA(e)){var n=WA(this);n.frozen||(n.frozen=new VA),ZA(this,e)?QA(this,e,t):n.frozen.set(e,t)}else QA(this,e,t);return this}})}var eO=Ww("iterator"),tO=Ww("toStringTag"),nO=dA.values,rO=function(e,t){if(e){if(e[eO]!==nO)try{EE(e,eO,nO)}catch(t){e[eO]=nO}if(e[tO]||EE(e,tO,t),QE[t])for(var n in dA)if(e[n]!==dA[n])try{EE(e,n,dA[n])}catch(t){e[n]=dA[n]}}};for(var oO in QE)rO(lw[oO]&&lw[oO].prototype,oO);rO(nD,"DOMTokenList");var iO=new WeakMap,aO=new WeakMap,uO=new WeakMap,sO=new WeakMap,lO=new WeakMap,cO=new WeakMap,fO=new WeakMap,dO=new WeakMap,pO=new WeakMap,hO=new WeakMap,gO=new WeakMap,vO=new WeakMap,yO=new WeakMap,mO=new WeakMap,bO=new WeakMap,wO=new WeakMap,EO=new WeakMap,DO=new WeakMap,SO=new WeakMap,xO=new WeakMap,CO=new WeakMap,AO=new WeakMap,OO=new WeakMap,kO=new WeakMap,BO=new WeakMap,FO=kD.find,TO=!0;"find"in[]&&Array(1).find((function(){TO=!1})),cS({target:"Array",proto:!0,forced:TO},{find:function(e){return FO(this,e,arguments.length>1?arguments[1]:void 0)}}),RS("find"),cS({global:!0},{globalThis:lw});const _O=["area","base","basefont","bgsound","br","col","command","embed","frame","hr","image","img","input","isindex","keygen","link","menuitem","meta","nextid","param","source","track","wbr"];eh&&(Mp.fn.css=eh),ah&&(Mp.fn.append=ah),zp&&(Mp.fn.addClass=zp),$p&&(Mp.fn.removeClass=$p),Hp&&(Mp.fn.hasClass=Hp),qp&&(Mp.fn.on=qp),yh&&(Mp.fn.focus=yh),Vp&&(Mp.fn.attr=Vp),Up&&(Mp.fn.removeAttr=Up),Jp&&(Mp.fn.hide=Jp),Qp&&(Mp.fn.show=Qp),Zp&&(Mp.fn.offset=Zp),Yp&&(Mp.fn.width=Yp),Xp&&(Mp.fn.height=Xp),sh&&(Mp.fn.parent=sh),lh&&(Mp.fn.parents=lh),ih&&(Mp.fn.is=ih),Wp&&(Mp.fn.dataset=Wp),Gp&&(Mp.fn.val=Gp),oh&&(Mp.fn.text=oh),rh&&(Mp.fn.html=rh),fh&&(Mp.fn.children=fh),dh&&(Mp.fn.remove=dh),ch&&(Mp.fn.find=ch),th&&(Mp.fn.each=th),ph&&(Mp.fn.empty=ph);var PO,jO,NO=function(e){return e&&e.ownerDocument&&e.ownerDocument.defaultView||null},IO=function(e){return LO(e)&&1===e.nodeType},LO=function(e){var t=NO(e);return!!t&&e instanceof t.Node},RO=function(e){var t=e&&e.anchorNode&&NO(e.anchorNode);return!!t&&e instanceof t.Selection},MO=function(e){return LO(e)&&3===e.nodeType},zO=function(e){var t,n,r;return null!==(t=window.document.getElementById(e))&&void 0!==t?t:(null===(r=null===(n=window.document.activeElement)||void 0===n?void 0:n.shadowRoot)||void 0===r?void 0:r.getElementById(e))||null},$O=function(e,t,n){for(var r,o=e.childNodes,i=o[t],a=t,u=!1,s=!1;(LO(r=i)&&8===r.nodeType||IO(i)&&0===i.childNodes.length||IO(i)&&"false"===i.getAttribute("contenteditable"))&&(!u||!s);)a>=o.length?(u=!0,a=t-1,n="backward"):a<0?(s=!0,a=t+1,n="forward"):(i=o[a],t=a,a+="forward"===n?1:-1);return[i,t]},HO=function(e,t,n){return aA($O(e,t,n),1)[0]},VO=function e(t){var n,r,o="";if(MO(t)&&t.nodeValue)return t.nodeValue;if(IO(t)){try{for(var i=iA(Array.from(t.childNodes)),a=i.next();!a.done;a=i.next())o+=e(a.value)}catch(e){n={error:e}}finally{try{a&&!a.done&&(r=i.return)&&r.call(i)}finally{if(n)throw n.error}}var u=getComputedStyle(t).getPropertyValue("display");"block"!==u&&"list"!==u&&"table-row"!==u&&"BR"!==t.tagName||(o+="\n")}return o};function UO(e,t){if(!(e instanceof HTMLElement&&"true"===e.dataset.slateVoid))for(var n=e.childNodes,r=n.length;r--;){var o=n[r],i=o.nodeType;3==i?t(o,e):1!=i&&9!=i&&11!=i||UO(o,t)}}function WO(e){if(0===e.length)return"";var t=e[0];return t.nodeType!==PO.ELEMENT_NODE?"":t.tagName.toLowerCase()}(jO=PO||(PO={}))[jO.ELEMENT_NODE=1]="ELEMENT_NODE",jO[jO.TEXT_NODE=3]="TEXT_NODE",jO[jO.CDATA_SECTION_NODE=4]="CDATA_SECTION_NODE",jO[jO.PROCESSING_INSTRUCTION_NODE=7]="PROCESSING_INSTRUCTION_NODE",jO[jO.COMMENT_NODE=8]="COMMENT_NODE",jO[jO.DOCUMENT_NODE=9]="DOCUMENT_NODE",jO[jO.DOCUMENT_TYPE_NODE=10]="DOCUMENT_TYPE_NODE",jO[jO.DOCUMENT_FRAGMENT_NODE=11]="DOCUMENT_FRAGMENT_NODE",void 0!==globalThis.navigator&&void 0!==globalThis.window&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&globalThis.window.MSStream;var GO="undefined"!=typeof navigator&&/Mac OS X/.test(navigator.userAgent),qO="undefined"!=typeof navigator&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);"undefined"!=typeof navigator&&/^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);var KO="undefined"!=typeof navigator&&/Version\/[\d\.]+.*Safari/.test(navigator.userAgent),YO="undefined"!=typeof navigator&&/Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent),XO="undefined"!=typeof navigator&&/Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent),ZO="undefined"!=typeof navigator&&/Chrome/i.test(navigator.userAgent);"undefined"!=typeof navigator&&/.*QQBrowser/.test(navigator.userAgent);var JO=!XO&&!YO&&"undefined"!=typeof globalThis&&globalThis.InputEvent&&"function"==typeof globalThis.InputEvent.prototype.getTargetRanges,QO={getWindow:function(e){var t=CO.get(e);if(!t)throw new Error("Unable to find a host window element for this editor");return t},findKey:function(e,t){var n=xO.get(t);return n||(n=new lA,xO.set(t,n)),n},setNewKey:function(e){var t=new lA;xO.set(e,t)},findPath:function(e,t){for(var n=[],r=t;;){var o=bO.get(r);if(null==o){if(Bf.isEditor(r))return n;break}var i=mO.get(r);if(null==i)break;n.unshift(i),r=o}throw new Error("Unable to find the path for Slate node: "+JSON.stringify(t))},findDocumentOrShadowRoot:function(e){if(e.isDestroyed)return window.document;var t=QO.toDOMNode(e,e),n=t.getRootNode();return(n instanceof Document||n instanceof ShadowRoot)&&null!=n.getSelection?n:t.ownerDocument},getParentNode:function(e,t){return bO.get(t)||null},getParentsNodes:function(e,t){for(var n=[],r=t;r!==e&&null!=r;){var o=QO.getParentNode(e,r);if(null==o)break;n.push(o),r=o}return n},getTopNode:function(e,t){var n=[QO.findPath(e,t)[0]];return Nf.get(e,n)},toDOMNode:function(e,t){var n;if(Bf.isEditor(t))n=wO.get(e);else{var r=QO.findKey(e,t);n=DO.get(r)}if(!n)throw new Error("Cannot resolve a DOM node from Slate node: "+JSON.stringify(t));return n},hasDOMNode:function(e,t,n){void 0===n&&(n={});var r,o=n.editable,i=void 0!==o&&o,a=QO.toDOMNode(e,e);try{r=IO(t)?t:t.parentElement}catch(e){if(!e.message.includes('Permission denied to access property "nodeType"'))throw e}return!!r&&r.closest("[data-slate-editor]")===a&&(!i||r.isContentEditable||!!r.getAttribute("data-slate-zero-width"))},toDOMRange:function(e,t){var n=t.anchor,r=t.focus,o=qf.isBackward(t),i=QO.toDOMPoint(e,n),a=qf.isCollapsed(t)?i:QO.toDOMPoint(e,r),u=QO.getWindow(e).document.createRange(),s=aA(o?a:i,2),l=s[0],c=s[1],f=aA(o?i:a,2),d=f[0],p=f[1],h=!!(IO(l)?l:l.parentElement).getAttribute("data-slate-zero-width"),g=!!(IO(d)?d:d.parentElement).getAttribute("data-slate-zero-width");return u.setStart(l,h?1:c),u.setEnd(d,g?1:p),u},toDOMPoint:function(e,t){var n,r,o,i=aA(Bf.node(e,t.path),1)[0],a=QO.toDOMNode(e,i);Bf.void(e,{at:t})&&(t={path:t.path,offset:0});var u=Array.from(a.querySelectorAll("[data-slate-string], [data-slate-zero-width]")),s=0;try{for(var l=iA(u),c=l.next();!c.done;c=l.next()){var f=c.value,d=f.childNodes[0];if(null!=d&&null!=d.textContent){var p=d.textContent.length,h=f.getAttribute("data-slate-length"),g=s+(null==h?p:parseInt(h,10));if(t.offset<=g){o=[d,Math.min(p,Math.max(0,t.offset-s))];break}s=g}}}catch(e){n={error:e}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(n)throw n.error}}if(!o)throw new Error("Cannot resolve a DOM point from Slate point: "+JSON.stringify(t));return o},toSlateNode:function(e,t){var n=IO(t)?t:t.parentElement;n&&!n.hasAttribute("data-slate-node")&&(n=n.closest("[data-slate-node]"));var r=n?EO.get(n):null;if(!r)throw new Error("Cannot resolve a Slate node from DOM node: "+n);return r},findEventRange:function(e,t){"nativeEvent"in t&&(t=t.nativeEvent);var n=t.clientX,r=t.clientY,o=t.target;if(null==n||null==r)throw new Error("Cannot resolve a Slate range from a DOM event: "+t);var i,a=QO.toSlateNode(e,t.target),u=QO.findPath(e,a);if(Bf.isVoid(e,a)){var s=o.getBoundingClientRect(),l=e.isInline(a)?n-s.left<s.left+s.width-n:r-s.top<s.top+s.height-r,c=Bf.point(e,u,{edge:l?"start":"end"}),f=l?Bf.before(e,c):Bf.after(e,c);if(f)return Bf.range(e,f)}var d=this.getWindow(e).document;if(d.caretRangeFromPoint)i=d.caretRangeFromPoint(n,r);else{var p=d.caretPositionFromPoint(n,r);p&&((i=d.createRange()).setStart(p.offsetNode,p.offset),i.setEnd(p.offsetNode,p.offset))}if(!i)throw new Error("Cannot resolve a Slate range from a DOM event: "+t);return QO.toSlateRange(e,i,{exactMatch:!1,suppressThrow:!1})},toSlateRange:function(e,t,n){var r,o,i,a,u,s=n.exactMatch,l=n.suppressThrow;if((RO(t)?t.anchorNode:t.startContainer)&&(RO(t)?(r=t.anchorNode,o=t.anchorOffset,i=t.focusNode,a=t.focusOffset,u=ZO&&window.document.activeElement&&window.document.activeElement.shadowRoot?t.anchorNode===t.focusNode&&t.anchorOffset===t.focusOffset:t.isCollapsed):(r=t.startContainer,o=t.startOffset,i=t.endContainer,a=t.endOffset,u=t.collapsed)),null==r||null==i||null==o||null==a)throw new Error("Cannot resolve a Slate range from DOM range: "+t);var c=QO.toSlatePoint(e,[r,o],{exactMatch:s,suppressThrow:l});if(!c)return null;var f=u?c:QO.toSlatePoint(e,[i,a],{exactMatch:s,suppressThrow:l});if(!f)return null;var d={anchor:c,focus:f};return qf.isExpanded(d)&&qf.isForward(d)&&IO(i)&&Bf.void(e,{at:d.focus,mode:"highest"})&&(d=Bf.unhangRange(e,d,{voids:!0})),d},toSlatePoint:function(e,t,n){var r,o=n.exactMatch,i=n.suppressThrow,a=aA(o?t:function(e){var t,n=aA(e,2),r=n[0],o=n[1];if(IO(r)&&r.childNodes.length){var i=o===r.childNodes.length,a=i?o-1:o;for(r=(t=aA($O(r,a,i?"backward":"forward"),2))[0],i=(a=t[1])<o;IO(r)&&r.childNodes.length;){var u=i?r.childNodes.length-1:0;r=HO(r,u,i?"backward":"forward")}o=i&&null!=r.textContent?r.textContent.length:0}return[r,o]}(t),2),u=a[0],s=a[1],l=u.parentNode,c=null,f=0;if(l){var d=l.closest('[data-slate-void="true"]'),p=l.closest("[data-slate-leaf]"),h=null;if(p){c=p.closest('[data-slate-node="text"]');var g=QO.getWindow(e).document.createRange();g.setStart(c,0),g.setEnd(u,s);var v=g.cloneContents();uA(uA([],aA(xp(v.querySelectorAll("[data-slate-zero-width]")))),aA(xp(v.querySelectorAll("[contenteditable=false]")))).forEach((function(e){e.parentNode.removeChild(e)})),f=v.textContent.length,h=c}else d&&((p=d.querySelector("[data-slate-leaf]"))?(c=p.closest('[data-slate-node="text"]'),f=(h=p).textContent.length,h.querySelectorAll("[data-slate-zero-width]").forEach((function(e){f-=e.textContent.length}))):f=1);h&&f===h.textContent.length&&(l.hasAttribute("data-slate-zero-width")||qO&&(null===(r=h.textContent)||void 0===r?void 0:r.endsWith("\n")))&&f--}if(!c){if(i)return null;throw new Error("Cannot resolve a Slate point from DOM point: "+t)}var y=QO.toSlateNode(e,c);return{path:QO.findPath(e,y),offset:f}},hasRange:function(e,t){var n=t.anchor,r=t.focus;return Bf.hasPath(e,n.path)&&Bf.hasPath(e,r.path)},getNodeType:function(e){return Sf.isElement(e)?e.type:""},checkNodeType:function(e,t){return this.getNodeType(e)===t},getNodesStr:function(e){return e.map((function(e){return Nf.string(e)})).join("")},getSelectedElems:function(e){var t,n,r=[],o=Bf.nodes(e,{universal:!0});try{for(var i=iA(o),a=i.next();!a.done;a=i.next()){var u=aA(a.value,1)[0];Sf.isElement(u)&&r.push(u)}}catch(e){t={error:e}}finally{try{a&&!a.done&&(n=i.return)&&n.call(i)}finally{if(t)throw t.error}}return r},getSelectedNodeByType:function(e,t){var n=this,r=aA(Bf.nodes(e,{match:function(e){return n.checkNodeType(e,t)},universal:!0}),1),o=r[0];return null==o?null:o[0]},getSelectedTextNode:function(e){var t=aA(Bf.nodes(e,{match:function(e){return ed.isText(e)},universal:!0}),1),n=t[0];return null==n?null:n[0]},isNodeSelected:function(e,t){var n=aA(Bf.nodes(e,{match:function(e){return e===t},universal:!0}),1),r=n[0];return null!=r&&aA(r,1)[0]===t},isSelectionAtLineEnd:function(e,t){var n=e.selection;return!!n&&(Bf.isEnd(e,n.anchor,t)||Bf.isEnd(e,n.focus,t))},getTextarea:function(e){var t=iO.get(e);if(null==t)throw new Error("Cannot find textarea instance by editor");return t},getToolbar:function(e){return sO.get(e)||null},getHoverbar:function(e){return cO.get(e)||null},normalizeContent:function(e){e.children.forEach((function(t,n){e.normalizeNode([t,[n]])}))},getLeftLengthOfMaxLength:function(e){var t=e.getConfig(),n=t.maxLength,r=t.onMaxLength;if("number"!=typeof n||n<=0)return 1/0;var o=n-e.getText().replace(/\r|\n|(\r\n)/g,"").length;return o<=0&&r&&r(e),o},cleanExposedTexNodeInSelectionBlock:function(e){var t,n,r,o,i=QO.getTextarea(e).$textArea,a=null==i?void 0:i[0].childNodes;if(a)try{for(var u=iA(Array.from(a)),s=u.next();!s.done;s=u.next()){var l=s.value;if(3!==l.nodeType)break;l.remove()}}catch(e){t={error:e}}finally{try{s&&!s.done&&(n=u.return)&&n.call(u)}finally{if(t)throw t.error}}var c=Bf.nodes(e,{match:function(t){return!(!Sf.isElement(t)||e.isInline(t))},universal:!0});try{for(var f=iA(c),d=f.next();!d.done;d=f.next()){var p=d.value;if(null!=p){var h=p[0];UO(QO.toDOMNode(e,h),(function(e,t){var n=Mp(t);n.attr("data-slate-string")||n.attr("data-slate-zero-width")||n.attr("data-w-e-reserve")||t.removeChild(e)}))}}}catch(e){r={error:e}}finally{try{d&&!d.done&&(o=f.return)&&o.call(f)}finally{if(r)throw r.error}}},isLastNode:function(e,t){var n=e.children||[];return n[n.length-1]===t},genEmptyParagraph:function(){return{type:"paragraph",children:[{text:""}]}},isSelectedVoidNode:function(e){var t,n,r=Bf.nodes(e,{match:function(t){return e.isVoid(t)}}),o=0;try{for(var i=iA(r),a=i.next();!a.done;a=i.next())a.value,o++}catch(e){t={error:e}}finally{try{a&&!a.done&&(n=i.return)&&n.call(i)}finally{if(t)throw t.error}}return o>0},isSelectedEmptyParagraph:function(e){var t=e.selection;if(null==t)return!1;if(qf.isExpanded(t))return!1;var n=QO.getSelectedNodeByType(e,"paragraph");if(null===n)return!1;var r=n.children;return 1===r.length&&(""===r[0].text||void 0)},isEmptyPath:function(e,t){var n=Bf.node(e,t);if(null==n)return!1;var r=aA(n,1)[0].children;return 1===r.length&&""===r[0].text}},ek=1,tk={},nk={};var rk=kD.filter,ok=iC("filter");cS({target:"Array",proto:!0,forced:!ok},{filter:function(e){return rk(this,e,arguments.length>1?arguments[1]:void 0)}});var ik="\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff",ak=mw("".replace),uk="["+ik+"]",sk=RegExp("^"+uk+uk+"*"),lk=RegExp(uk+uk+"*$"),ck=function(e){return function(t){var n=bS(ww(t));return 1&e&&(n=ak(n,sk,"")),2&e&&(n=ak(n,lk,"")),n}},fk={start:ck(1),end:ck(2),trim:ck(3)},dk=VE.PROPER,pk=fk.trim;cS({target:"String",proto:!0,forced:function(e){return Rw((function(){return!!ik[e]()||"âÂá "!=="âÂá "[e]()||dk&&ik[e].name!==e}))}("trim")},{trim:function(){return pk(this)}});var hk=[];var gk={};function vk(e,t,n){var r=n.isInline(e)?"span":"div";return"<"+r+">"+t+"</"+r+">"}var yk,mk,bk,wk,Ek=lw.Promise,Dk=Ww("species"),Sk=function(e){var t=Tw(e),n=bE.f;Kw&&t&&!t[Dk]&&n(t,Dk,{configurable:!0,get:function(){return this}})},xk=lw.TypeError,Ck=Ww("species"),Ak=function(e,t){var n,r=nE(e).constructor;return void 0===r||null==(n=nE(r)[Ck])?t:function(e){if(DD(e))return e;throw xk(lE(e)+" is not a constructor")}(n)},Ok=mw([].slice),kk=/(?:ipad|iphone|ipod).*applewebkit/i.test(_w),Bk="process"==qE(lw.process),Fk=lw.setImmediate,Tk=lw.clearImmediate,_k=lw.process,Pk=lw.Dispatch,jk=lw.Function,Nk=lw.MessageChannel,Ik=lw.String,Lk=0,Rk={};try{yk=lw.location}catch(jO){}var Mk=function(e){if(xw(Rk,e)){var t=Rk[e];delete Rk[e],t()}},zk=function(e){return function(){Mk(e)}},$k=function(e){Mk(e.data)},Hk=function(e){lw.postMessage(Ik(e),yk.protocol+"//"+yk.host)};Fk&&Tk||(Fk=function(e){var t=Ok(arguments,1);return Rk[++Lk]=function(){_C(Bw(e)?e:jk(e),void 0,t)},mk(Lk),Lk},Tk=function(e){delete Rk[e]},Bk?mk=function(e){_k.nextTick(zk(e))}:Pk&&Pk.now?mk=function(e){Pk.now(zk(e))}:Nk&&!kk?(wk=(bk=new Nk).port2,bk.port1.onmessage=$k,mk=oD(wk.postMessage,wk)):lw.addEventListener&&Bw(lw.postMessage)&&!lw.importScripts&&yk&&"file:"!==yk.protocol&&!Rw(Hk)?(mk=Hk,lw.addEventListener("message",$k,!1)):mk="onreadystatechange"in Jw("script")?function(e){BS.appendChild(Jw("script")).onreadystatechange=function(){BS.removeChild(this),Mk(e)}}:function(e){setTimeout(zk(e),0)});var Vk,Uk,Wk,Gk,qk,Kk,Yk,Xk,Zk={set:Fk,clear:Tk},Jk=/ipad|iphone|ipod/i.test(_w)&&void 0!==lw.Pebble,Qk=/web0s(?!.*chrome)/i.test(_w),eB=zD.f,tB=Zk.set,nB=lw.MutationObserver||lw.WebKitMutationObserver,rB=lw.document,oB=lw.process,iB=lw.Promise,aB=eB(lw,"queueMicrotask"),uB=aB&&aB.value;uB||(Vk=function(){var e,t;for(Bk&&(e=oB.domain)&&e.exit();Uk;){t=Uk.fn,Uk=Uk.next;try{t()}catch(e){throw Uk?Gk():Wk=void 0,e}}Wk=void 0,e&&e.enter()},kk||Bk||Qk||!nB||!rB?!Jk&&iB&&iB.resolve?((Yk=iB.resolve(void 0)).constructor=iB,Xk=oD(Yk.then,Yk),Gk=function(){Xk(Vk)}):Bk?Gk=function(){oB.nextTick(Vk)}:(tB=oD(tB,lw),Gk=function(){tB(Vk)}):(qk=!0,Kk=rB.createTextNode(""),new nB(Vk).observe(Kk,{characterData:!0}),Gk=function(){Kk.data=qk=!qk}));var sB,lB,cB,fB,dB=uB||function(e){var t={fn:e,next:void 0};Wk&&(Wk.next=t),Uk||(Uk=t,Gk()),Wk=t},pB=function(e){var t,n;this.promise=new e((function(e,r){if(void 0!==t||void 0!==n)throw TypeError("Bad Promise constructor");t=e,n=r})),this.resolve=fE(t),this.reject=fE(n)},hB={f:function(e){return new pB(e)}},gB=function(e){try{return{error:!1,value:e()}}catch(e){return{error:!0,value:e}}},vB="object"==typeof window,yB=Zk.set,mB=Ww("species"),bB="Promise",wB=ME.getterFor(bB),EB=ME.set,DB=ME.getterFor(bB),SB=Ek&&Ek.prototype,xB=Ek,CB=SB,AB=lw.TypeError,OB=lw.document,kB=lw.process,BB=hB.f,FB=BB,TB=!!(OB&&OB.createEvent&&lw.dispatchEvent),_B=Bw(lw.PromiseRejectionEvent),PB=!1,jB=sS(bB,(function(){var e=AE(xB),t=e!==String(xB);if(!t&&66===Lw)return!0;if(Lw>=51&&/native code/.test(e))return!1;var n=new xB((function(e){e(1)})),r=function(e){e((function(){}),(function(){}))};return(n.constructor={})[mB]=r,!(PB=n.then((function(){}))instanceof r)||!t&&vB&&!_B})),NB=jB||!fx((function(e){xB.all(e).catch((function(){}))})),IB=function(e){var t;return!(!Yw(e)||!Bw(t=e.then))&&t},LB=function(e,t){if(!e.notified){e.notified=!0;var n=e.reactions;dB((function(){for(var r=e.value,o=1==e.state,i=0;n.length>i;){var a,u,s,l=n[i++],c=o?l.ok:l.fail,f=l.resolve,d=l.reject,p=l.domain;try{c?(o||(2===e.rejection&&$B(e),e.rejection=1),!0===c?a=r:(p&&p.enter(),a=c(r),p&&(p.exit(),s=!0)),a===l.promise?d(AB("Promise-chain cycle")):(u=IB(a))?oE(u,a,f,d):f(a)):d(r)}catch(e){p&&!s&&p.exit(),d(e)}}e.reactions=[],e.notified=!1,t&&!e.rejection&&MB(e)}))}},RB=function(e,t,n){var r,o;TB?((r=OB.createEvent("Event")).promise=t,r.reason=n,r.initEvent(e,!1,!0),lw.dispatchEvent(r)):r={promise:t,reason:n},!_B&&(o=lw["on"+e])?o(r):"unhandledrejection"===e&&function(e,t){var n=lw.console;n&&n.error&&(1==arguments.length?n.error(e):n.error(e,t))}("Unhandled promise rejection",n)},MB=function(e){oE(yB,lw,(function(){var t,n=e.facade,r=e.value;if(zB(e)&&(t=gB((function(){Bk?kB.emit("unhandledRejection",r,n):RB("unhandledrejection",n,r)})),e.rejection=Bk||zB(e)?2:1,t.error))throw t.value}))},zB=function(e){return 1!==e.rejection&&!e.parent},$B=function(e){oE(yB,lw,(function(){var t=e.facade;Bk?kB.emit("rejectionHandled",t):RB("rejectionhandled",t,e.value)}))},HB=function(e,t,n){return function(r){e(t,r,n)}},VB=function(e,t,n){e.done||(e.done=!0,n&&(e=n),e.value=t,e.state=2,LB(e,!0))},UB=function(e,t,n){if(!e.done){e.done=!0,n&&(e=n);try{if(e.facade===t)throw AB("Promise can't be resolved itself");var r=IB(t);r?dB((function(){var n={done:!1};try{oE(r,t,HB(UB,n,e),HB(VB,n,e))}catch(t){VB(n,t,e)}})):(e.value=t,e.state=1,LB(e,!1))}catch(t){VB({done:!1},t,e)}}};if(jB&&(CB=(xB=function(e){FA(this,CB),fE(e),oE(sB,this);var t=wB(this);try{e(HB(UB,t),HB(VB,t))}catch(e){VB(t,e)}}).prototype,(sB=function(e){EB(this,{type:bB,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=pA(CB,{then:function(e,t){var n=DB(this),r=n.reactions,o=BB(Ak(this,xB));return o.ok=!Bw(e)||e,o.fail=Bw(t)&&t,o.domain=Bk?kB.domain:void 0,n.parent=!0,r[r.length]=o,0!=n.state&&LB(n,!1),o.promise},catch:function(e){return this.then(void 0,e)}}),lB=function(){var e=new sB,t=wB(e);this.promise=e,this.resolve=HB(UB,t),this.reject=HB(VB,t)},hB.f=BB=function(e){return e===xB||e===cB?new lB(e):FB(e)},Bw(Ek)&&SB!==Object.prototype)){fB=SB.then,PB||(UE(SB,"then",(function(e,t){var n=this;return new xB((function(e,t){oE(fB,n,e,t)})).then(e,t)}),{unsafe:!0}),UE(SB,"catch",CB.catch,{unsafe:!0}));try{delete SB.constructor}catch(jO){}Lx&&Lx(SB,CB)}cS({global:!0,wrap:!0,forced:jB},{Promise:xB}),_x(xB,bB,!1),Sk(bB),cB=Tw(bB),cS({target:bB,stat:!0,forced:jB},{reject:function(e){var t=BB(this);return oE(t.reject,void 0,e),t.promise}}),cS({target:bB,stat:!0,forced:jB},{resolve:function(e){return function(e,t){if(nE(e),Yw(t)&&t.constructor===e)return t;var n=hB.f(e);return(0,n.resolve)(t),n.promise}(this,e)}}),cS({target:bB,stat:!0,forced:NB},{all:function(e){var t=this,n=BB(t),r=n.resolve,o=n.reject,i=gB((function(){var n=fE(t.resolve),i=[],a=0,u=1;kA(e,(function(e){var s=a++,l=!1;u++,oE(n,t,e).then((function(e){l||(l=!0,i[s]=e,--u||r(i))}),o)})),--u||r(i)}));return i.error&&o(i.value),n.promise},race:function(e){var t=this,n=BB(t),r=n.reject,o=gB((function(){var o=fE(t.resolve);kA(e,(function(e){oE(o,t,e).then(n.resolve,r)}))}));return o.error&&r(o.value),n.promise}});var WB=fC.UNSUPPORTED_Y,GB=Math.min,qB=[].push,KB=mw(/./.exec),YB=mw(qB),XB=mw("".slice);function ZB(e){Promise.resolve().then(e)}function JB(e,t){return Sf.isElement(e)?function(e,t){var n=e.type,r=void 0===n?"":n,o=e.children,i=void 0===o?[]:o,a=Bf.isVoid(t,e),u="";a||(u=i.map((function(e){return JB(e,t)})).join(""));var s=function(e){return gk[e]||vk}(r),l=s(e,u,t),c="";if(c="string"==typeof l?l:l.html||"",a||hk.forEach((function(t){return c=t(e,c)})),"string"==typeof l)return c;var f=l.prefix,d=void 0===f?"":f,p=l.suffix,h=void 0===p?"":p;return d&&(c=d+c),h&&(c+=h),c}(e,t):function(e,t){var n=e.text;if(null==n)throw new Error("Current node is not slate Text "+JSON.stringify(e));var r=n;r=function(e){return e.replace(/ {2}/g," &nbsp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/Â®/g,"&reg;").replace(/Â©/g,"&copy;").replace(/â¢/g,"&trade;")}(r);var o=QO.getParentsNodes(t,e).some((function(e){return"pre"===QO.getNodeType(e)}));if(o||(r=r.replace(/\r\n|\r|\n/g,"<br>")),o&&(r=r.replace(/&nbsp;/g," ")),""===r){var i=QO.getParentNode(null,e);if(!i||0!==i.children.length)return r;r="<br>"}return hk.forEach((function(t){return r=t(e,r)})),r}(e,t)}function QB(e){return"w-e-element-"+e}NC("split",(function(e,t,n){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(e,n){var r=bS(ww(this)),o=void 0===n?4294967295:n>>>0;if(0===o)return[];if(void 0===e)return[r];if(!$S(e))return oE(t,r,e,o);for(var i,a,u,s=[],l=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),c=0,f=new RegExp(e.source,l+"g");(i=oE(OC,f,r))&&!((a=f.lastIndex)>c&&(YB(s,XB(r,c,i.index)),i.length>1&&i.index<r.length&&_C(qB,s,vA(i,1)),u=i[0].length,c=a,s.length>=o));)f.lastIndex===i.index&&f.lastIndex++;return c===r.length?!u&&KB(f,"")||YB(s,""):YB(s,XB(r,c)),s.length>o?vA(s,0,o):s}:"0".split(void 0,0).length?function(e,n){return void 0===e&&0===n?[]:oE(t,this,e,n)}:t,[function(t,n){var o=ww(this),i=null==t?void 0:dE(t,e);return i?oE(i,t,o,n):oE(r,bS(o),t,n)},function(e,o){var i=nE(this),a=bS(e),u=n(r,i,a,o,r!==t);if(u.done)return u.value;var s=Ak(i,RegExp),l=i.unicode,c=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(WB?"g":"y"),f=new s(WB?"^(?:"+i.source+")":i,c),d=void 0===o?4294967295:o>>>0;if(0===d)return[];if(0===a.length)return null===GC(f,a)?[a]:[];for(var p=0,h=0,g=[];h<a.length;){f.lastIndex=WB?0:h;var v,y=GC(f,WB?XB(a,h):a);if(null===y||(v=GB(dD(f.lastIndex+(WB?h:0)),a.length))===p)h=LC(a,h,l);else{if(YB(g,XB(a,p,h)),g.length===d)return g;for(var m=1;m<=y.length-1;m++)if(YB(g,y[m]),g.length===d)return g;h=p=v}}return YB(g,XB(a,p)),g}]}),!!Rw((function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var n="ab".split(e);return 2!==n.length||"a"!==n[0]||"b"!==n[1]})),WB);var eF=function(e,t){var n=(t.top+t.bottom)/2;return e.top<=n&&e.bottom>=n},tF=function(e,t,n){var r=QO.toDOMRange(e,t).getBoundingClientRect(),o=QO.toDOMRange(e,n).getBoundingClientRect();return eF(r,o)&&eF(o,r)},nF=["span","b","strong","i","em","s","strike","u","font","sub","sup"],rF=[];var oF=[];var iF={};var aF=bE.f,uF=ZD.f,sF=ME.enforce,lF=Ww("match"),cF=lw.RegExp,fF=cF.prototype,dF=lw.SyntaxError,pF=mw(wS),hF=mw(fF.exec),gF=mw("".charAt),vF=mw("".replace),yF=mw("".indexOf),mF=mw("".slice),bF=/^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,wF=/a/g,EF=/a/g,DF=new cF(wF)!==wF,SF=fC.MISSED_STICKY,xF=fC.UNSUPPORTED_Y,CF=Kw&&(!DF||SF||pC||gC||Rw((function(){return EF[lF]=!1,cF(wF)!=wF||cF(EF)==EF||"/a/i"!=cF(wF,"i")})));if(sS("RegExp",CF)){for(var AF=function(e,t){var n,r,o,i,a,u,s=iE(fF,this),l=$S(e),c=void 0===t,f=[],d=e;if(!s&&l&&c&&e.constructor===AF)return e;if((l||iE(fF,e))&&(e=e.source,c&&(t="flags"in d?d.flags:pF(d))),e=void 0===e?"":bS(e),t=void 0===t?"":bS(t),d=e,pC&&"dotAll"in wF&&(r=!!t&&yF(t,"s")>-1)&&(t=vF(t,/s/g,"")),n=t,SF&&"sticky"in wF&&(o=!!t&&yF(t,"y")>-1)&&xF&&(t=vF(t,/y/g,"")),gC&&(i=function(e){for(var t,n=e.length,r=0,o="",i=[],a={},u=!1,s=!1,l=0,c="";r<=n;r++){if("\\"===(t=gF(e,r)))t+=gF(e,++r);else if("]"===t)u=!1;else if(!u)switch(!0){case"["===t:u=!0;break;case"("===t:hF(bF,mF(e,r+1))&&(r+=2,s=!0),o+=t,l++;continue;case">"===t&&s:if(""===c||xw(a,c))throw new dF("Invalid capture group name");a[c]=!0,i[i.length]=[c,l],s=!1,c="";continue}s?c+=t:o+=t}return[o,i]}(e),e=i[0],f=i[1]),a=TA(cF(e,t),s?this:fF,AF),(r||o||f.length)&&(u=sF(a),r&&(u.dotAll=!0,u.raw=AF(function(e){for(var t,n=e.length,r=0,o="",i=!1;r<=n;r++)"\\"!==(t=gF(e,r))?i||"."!==t?("["===t?i=!0:"]"===t&&(i=!1),o+=t):o+="[\\s\\S]":o+=t+gF(e,++r);return o}(e),n)),o&&(u.sticky=!0),f.length&&(u.groups=f)),e!==d)try{EE(a,"source",""===d?"(?:)":d)}catch(e){}return a},OF=function(e){e in AF||aF(AF,e,{configurable:!0,get:function(){return cF[e]},set:function(t){cF[e]=t}})},kF=uF(cF),BF=0;kF.length>BF;)OF(kF[BF++]);fF.constructor=AF,AF.prototype=fF,UE(lw,"RegExp",AF)}Sk("RegExp");var FF=new RegExp(String.fromCharCode(160),"g");function TF(e){return e.replace(FF," ")}function _F(e,t){var n=e.length;if(n){var r=e[n-1];if(ed.isText(r)){var o=Object.keys(r);if(1===o.length&&"text"===o[0])return r.text=r.text+t,!0}}return!1}function PF(e,t,n){return{type:"paragraph",children:[{text:Mp(e).text().replace(/\s+/gm," ")}]}}function jF(e,t){var n=function(e,t){var n=[];if(null!=e.attr("data-w-e-is-void"))return n;var r=e[0].childNodes;return 1===r.length&&"BR"===r[0].nodeName?(n.push({text:""}),n):(r.forEach((function(e){if(e.nodeType!==PO.ELEMENT_NODE)if(e.nodeType!==PO.TEXT_NODE);else{var r=e.textContent||"";if(""===r.trim()&&r.indexOf("\n")>=0)return;r&&(r=TF(r),_F(n,r)||n.push({text:r}))}else{if("BR"===e.nodeName)return void(_F(n,"\n")||n.push({text:"\n"}));var o=IF(Mp(e),t);Array.isArray(o)?o.forEach((function(e){return n.push(e)})):n.push(o)}})),n)}(e,t),r=function(e){for(var t in iF)if(e[0].matches(t))return iF[t];return PF}(e),o=r(e[0],n,t);return Array.isArray(o)||(o=[o]),o.forEach((function(r){Bf.isVoid(t,r)||(0===n.length&&(r.children=[{text:e.text().replace(/\s+/gm," ")}]),oF.forEach((function(n){r=n(e[0],r,t)})))})),o}function NF(e,t){0===e.parents("pre").length&&(e[0].innerHTML=e[0].innerHTML.replace(/\s+/gm," ").replace(/<br>/g,"\n"));var n=e[0].textContent||"";n=function(e){return e.replace(/&nbsp;/g," ").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&reg;/g,"Â®").replace(/&copy;/g,"Â©").replace(/&trade;/g,"â¢").replace(/&quot;/g,'"')}(n);var r={text:n=TF(n)};return oF.forEach((function(n){r=n(e[0],r,t)})),r}function IF(e,t){rF.forEach((function(t){var n=t.selector,r=t.preParseHtml;e[0].matches(n)&&(e=Mp(r(e[0])))}));var n=WO(e);return"span"===n?e.attr("data-w-e-type")?jF(e,t):NF(e,t):"code"===n?"pre"===WO(e.parent())?jF(e,t):NF(e,t):nF.includes(n)?NF(e,t):jF(e,t)}function LF(e,t,n){var r=Mp(n);return!!r.attr(t)||(r.attr(t,"true"),e.on("destroyed",(function(){r.removeAttr(t)})),!1)}function RF(e,t){void 0===t&&(t="");var n=[];""===t&&(t="<p><br></p>"),0!==t.indexOf("<")&&(t=t.split(/\n/).map((function(e){return"<p>"+e+"</p>"})).join(""));var r=Mp("<div>"+t+"</div>");return Array.from(r.children()).forEach((function(t){var r=IF(Mp(t),e);Array.isArray(r)?r.forEach((function(e){return n.push(e)})):n.push(r)})),n}var MF=bE.f,zF=xA.fastKey,$F=ME.set,HF=ME.getterFor,VF={getConstructor:function(e,t,n,r){var o=e((function(e,o){FA(e,i),$F(e,{type:t,index:NS(null),first:void 0,last:void 0,size:0}),Kw||(e.size=0),null!=o&&kA(o,e[r],{that:e,AS_ENTRIES:n})})),i=o.prototype,a=HF(t),u=function(e,t,n){var r,o,i=a(e),u=s(e,t);return u?u.value=n:(i.last=u={index:o=zF(t,!0),key:t,value:n,previous:r=i.last,next:void 0,removed:!1},i.first||(i.first=u),r&&(r.next=u),Kw?i.size++:e.size++,"F"!==o&&(i.index[o]=u)),e},s=function(e,t){var n,r=a(e),o=zF(t);if("F"!==o)return r.index[o];for(n=r.first;n;n=n.next)if(n.key==t)return n};return pA(i,{clear:function(){for(var e=a(this),t=e.index,n=e.first;n;)n.removed=!0,n.previous&&(n.previous=n.previous.next=void 0),delete t[n.index],n=n.next;e.first=e.last=void 0,Kw?e.size=0:this.size=0},delete:function(e){var t=this,n=a(t),r=s(t,e);if(r){var o=r.next,i=r.previous;delete n.index[r.index],r.removed=!0,i&&(i.next=o),o&&(o.previous=i),n.first==r&&(n.first=o),n.last==r&&(n.last=i),Kw?n.size--:t.size--}return!!r},forEach:function(e){for(var t,n=a(this),r=oD(e,arguments.length>1?arguments[1]:void 0);t=t?t.next:n.first;)for(r(t.value,t.key,this);t&&t.removed;)t=t.previous},has:function(e){return!!s(this,e)}}),pA(i,n?{get:function(e){var t=s(this,e);return t&&t.value},set:function(e,t){return u(this,0===e?0:e,t)}}:{add:function(e){return u(this,e=0===e?0:e,e)}}),Kw&&MF(i,"size",{get:function(){return a(this).size}}),o},setStrong:function(e,t,n){var r=t+" Iterator",o=HF(t),i=HF(r);Ux(e,t,(function(e,t){$F(this,{type:r,target:e,state:o(e),kind:t,last:void 0})}),(function(){for(var e=i(this),t=e.kind,n=e.last;n&&n.removed;)n=n.previous;return e.target&&(e.last=n=n?n.next:e.state.first)?"keys"==t?{value:n.key,done:!1}:"values"==t?{value:n.value,done:!1}:{value:[n.key,n.value],done:!1}:(e.target=void 0,{value:void 0,done:!0})}),n?"entries":"values",!n,!0),Sk(t)}};_A("Set",(function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}}),VF);var UF=new Set(["doctype","!doctype","meta","script","style","link","frame","iframe","title","svg"]);function WF(e,t){e.isInline(t)?(e.insertNode(t),"link"===t.type&&e.insertFragment([{text:""}])):md.insertNodes(e,t,{mode:"highest"})}var GF=function(e){var t=e,n=t.insertText;return t.insertFragment,t.setFragmentData=function(e){var n=t.selection;if(n){var r=aA(qf.edges(n),2),o=r[0],i=r[1],a=Bf.void(t,{at:o.path}),u=Bf.void(t,{at:i.path});if(!qf.isCollapsed(n)||a){var s=QO.toDOMRange(t,n),l=s.cloneContents(),c=l.childNodes[0];if(l.childNodes.forEach((function(e){e.textContent&&""!==e.textContent.trim()&&(c=e)})),u){var f=aA(u,1)[0],d=s.cloneRange(),p=QO.toDOMNode(t,f);d.setEndAfter(p),l=d.cloneContents()}if(a&&(c=l.querySelector("[data-slate-spacer]")),Array.from(l.querySelectorAll("[data-slate-zero-width]")).forEach((function(e){var t="n"===e.getAttribute("data-slate-zero-width");e.textContent=t?"\n":""})),MO(c)){var h=c.ownerDocument.createElement("span");h.style.whiteSpace="pre",h.appendChild(c),l.appendChild(h),c=h}var g=t.getFragment(),v=JSON.stringify(g),y=window.btoa(encodeURIComponent(v));c.setAttribute("data-slate-fragment",y),e.setData("application/x-slate-fragment",y);var m=l.ownerDocument.createElement("div");return m.appendChild(l),m.setAttribute("hidden","true"),l.ownerDocument.body.appendChild(m),e.setData("text/html",m.innerHTML),e.setData("text/plain",VO(m)),l.ownerDocument.body.removeChild(m),e}}},t.insertData=function(e){var r,o,i=e.getData("application/x-slate-fragment");if(i){var a=decodeURIComponent(window.atob(i)),u=JSON.parse(a);t.insertFragment(u)}else{var s=e.getData("text/plain"),l=e.getData("text/html");if(l)t.dangerouslyInsertHtml(l);else if(s){var c=s.split(/\r\n|\r|\n/),f=!1;try{for(var d=iA(c),p=d.next();!p.done;p=d.next()){var h=p.value;f&&md.splitNodes(t,{always:!0}),n(h),f=!0}}catch(e){r={error:e}}finally{try{p&&!p.done&&(o=d.return)&&o.call(d)}finally{if(r)throw r.error}}}}},t},qF=function(e){return null!=e},KF={object:!0,function:!0,undefined:!0},YF=/^\s*class[\s{/}]/,XF=Function.prototype.toString,ZF=function(e){return!!function(e){if("function"!=typeof e)return!1;if(!hasOwnProperty.call(e,"length"))return!1;try{if("number"!=typeof e.length)return!1;if("function"!=typeof e.call)return!1;if("function"!=typeof e.apply)return!1}catch(e){return!1}return!function(e){if(!function(e){return!!qF(e)&&hasOwnProperty.call(KF,typeof e)}(e))return!1;try{return!!e.constructor&&e.constructor.prototype===e}catch(e){return!1}}(e)}(e)&&!YF.test(XF.call(e))},JF=function(e){return null!=e},QF=Object.keys,eT=function(){try{return Object.keys("primitive"),!0}catch(e){return!1}}()?Object.keys:function(e){return QF(JF(e)?Object(e):e)},tT=function(e){if(!JF(e))throw new TypeError("Cannot use null or undefined");return e},nT=Math.max,rT=function(){var e,t=Object.assign;return"function"==typeof t&&(t(e={foo:"raz"},{bar:"dwa"},{trzy:"trzy"}),e.foo+e.bar+e.trzy==="razdwatrzy")}()?Object.assign:function(e,t){var n,r,o,i=nT(arguments.length,2);for(e=Object(tT(e)),o=function(r){try{e[r]=t[r]}catch(e){n||(n=e)}},r=1;r<i;++r)eT(t=arguments[r]).forEach(o);if(void 0!==n)throw n;return e},oT=Array.prototype.forEach,iT=Object.create,aT=function(e,t){var n;for(n in e)t[n]=e[n]},uT=function(e){var t=iT(null);return oT.call(arguments,(function(e){JF(e)&&aT(Object(e),t)})),t},sT="razdwatrzy",lT=String.prototype.indexOf,cT="function"==typeof sT.contains&&!0===sT.contains("dwa")&&!1===sT.contains("foo")?String.prototype.contains:function(e){return lT.call(this,e,arguments[1])>-1},fT=iw((function(e){var t=e.exports=function(e,t){var n,r,o,i,a;return arguments.length<2||"string"!=typeof e?(i=t,t=e,e=null):i=arguments[2],qF(e)?(n=cT.call(e,"c"),r=cT.call(e,"e"),o=cT.call(e,"w")):(n=o=!0,r=!1),a={value:t,configurable:n,enumerable:r,writable:o},i?rT(uT(i),a):a};t.gs=function(e,t,n){var r,o,i,a;return"string"!=typeof e?(i=n,n=t,t=e,e=null):i=arguments[3],qF(t)?ZF(t)?qF(n)?ZF(n)||(i=n,n=void 0):n=void 0:(i=t,t=n=void 0):t=void 0,qF(e)?(r=cT.call(e,"c"),o=cT.call(e,"e")):(r=!0,o=!1),a={get:t,set:n,configurable:r,enumerable:o},i?rT(uT(i),a):a}})),dT=function(e){if("function"!=typeof e)throw new TypeError(e+" is not a function");return e},pT=iw((function(e,t){var n,r,o,i,a,u,s,l=Function.prototype.apply,c=Function.prototype.call,f=Object.create,d=Object.defineProperty,p=Object.defineProperties,h=Object.prototype.hasOwnProperty,g={configurable:!0,enumerable:!1,writable:!0};n=function(e,t){var n;return dT(t),h.call(this,"__ee__")?n=this.__ee__:(n=g.value=f(null),d(this,"__ee__",g),g.value=null),n[e]?"object"==typeof n[e]?n[e].push(t):n[e]=[n[e],t]:n[e]=t,this},r=function(e,t){var r,i;return dT(t),i=this,n.call(this,e,r=function(){o.call(i,e,r),l.call(t,this,arguments)}),r.__eeOnceListener__=t,this},o=function(e,t){var n,r,o,i;if(dT(t),!h.call(this,"__ee__"))return this;if(!(n=this.__ee__)[e])return this;if("object"==typeof(r=n[e]))for(i=0;o=r[i];++i)o!==t&&o.__eeOnceListener__!==t||(2===r.length?n[e]=r[i?0:1]:r.splice(i,1));else r!==t&&r.__eeOnceListener__!==t||delete n[e];return this},i=function(e){var t,n,r,o,i;if(h.call(this,"__ee__")&&(o=this.__ee__[e]))if("object"==typeof o){for(n=arguments.length,i=new Array(n-1),t=1;t<n;++t)i[t-1]=arguments[t];for(o=o.slice(),t=0;r=o[t];++t)l.call(r,this,i)}else switch(arguments.length){case 1:c.call(o,this);break;case 2:c.call(o,this,arguments[1]);break;case 3:c.call(o,this,arguments[1],arguments[2]);break;default:for(n=arguments.length,i=new Array(n-1),t=1;t<n;++t)i[t-1]=arguments[t];l.call(o,this,i)}},a={on:n,once:r,off:o,emit:i},u={on:fT(n),once:fT(r),off:fT(o),emit:fT(i)},s=p({},u),e.exports=t=function(e){return null==e?f(s):p(Object(e),u)},t.methods=a}));function hT(e){var t=kO.get(e);return null==t&&(t=pT(),kO.set(e,t)),t}var gT=new WeakMap;function vT(e,t){var n=gT.get(e);null==n&&(n=new Set,gT.set(e,n)),n.add(t)}function yT(e){return gT.get(e)||new Set}function mT(e){gT.set(e,new Set)}function bT(e){var t=QO.getTextarea(e).$textAreaContainer,n=t.width(),r=t.height(),o=t.offset();return{top:o.top,left:o.left,width:n,height:r}}function wT(e){var t={top:"0",left:"0"},n=e.selection;if(null==n)return t;var r=bT(e);if(null==r)return t;var o=r.top,i=r.left,a=r.width,u=r.height,s=QO.toDOMRange(e,n).getClientRects()[0];if(null==s)return t;s.width;var l=s.height,c={},f=s.top-o,d=s.left-i;if(d>a/2){var p=a-d;c.right=p+5+"px"}else c.left=d+5+"px";if(f>u/2){var h=u-f;c.bottom=h+5+"px"}else{var g=f+l;g<0&&(g=0),c.top=g+5+"px"}return c}function ET(e,t,n){void 0===n&&(n="modal");var r={top:"0",left:"0"};if(null==e.selection)return r;var o=Sf.isElement(t)&&e.isVoid(t),i=Sf.isElement(t)&&e.isInline(t),a=SO.get(t);if(null==a)return r;var u=a.getBoundingClientRect(),s=u.top,l=u.left,c=u.height,f=u.width;if(o){var d=function(e){var t=[];t.push(e);for(var n=0;t.length>0;){var r=t.pop();if(null==r)break;if(++n>1e4)break;var o=r.nodeName;if(1===r.nodeType){var i=o.toLowerCase();if(_O.includes(i)||"iframe"===i||"video"===i)return r;var a=r.children||[],u=a.length;if(u)for(var s=u-1;s>=0;s--)t.push(a[s])}}return null}(a);if(null!=d){var p=d.getBoundingClientRect();s=p.top,c=p.height}}var h=bT(e);if(null==h)return r;var g,v=h.top,y=h.left,m=h.width,b=h.height,w={},E=s-v,D=l-y;if("bar"===n)return w.left=D+"px",E>40?w.bottom=b-E+5+"px":w.top=E+c+5+"px",w;if("modal"===n)return o?i?D>(m-f)/2?w.right=m-D+5+"px":w.left=D+f+5+"px":w.left="20px":w.left=D+"px",o?((g=E)<0&&(g=0),w.top=g+"px"):E>(b-c)/2?w.bottom=b-E+5+"px":((g=E+c)<0&&(g=0),w.top=g+5+"px"),w;throw new Error("type '"+n+"' is invalid")}function DT(e,t){ZB((function(){var n=bT(e);if(null!=n){var r,o=n.top,i=n.left,a=n.width,u=n.height,s=t.offset(),l=s.top,c=s.left,f=t.width(),d=t.height(),p=l-o,h=c-i,g=t.attr("style");if(g.indexOf("top")>=0&&(r=p+d-u)>0){var v=t.css("top"),y=parseInt(v.toString())-r;y<0&&(y=0),t.css("top",y+"px")}if(g.indexOf("bottom")>=0&&l<0){var m=t.css("bottom"),b=parseInt(m.toString())-Math.abs(l);t.css("bottom",b+"px")}if(g.indexOf("left")>=0&&(r=h+f-a)>0){var w=t.css("left"),E=parseInt(w.toString())-r;E<0&&(E=0),t.css("left",E+"px")}if(g.indexOf("right")>=0&&c<0){var D=t.css("right"),S=parseInt(D.toString())-Math.abs(c);t.css("right",S+"px")}}}))}var ST=iC("slice"),xT=Ww("species"),CT=lw.Array,AT=Math.max;cS({target:"Array",proto:!0,forced:!ST},{slice:function(e,t){var n,r,o,i=RD(this),a=pD(i),u=VD(e,a),s=VD(void 0===t?a:t,a);if(hD(i)&&(n=i.constructor,(DD(n)&&(n===CT||hD(n.prototype))||Yw(n)&&null===(n=n[xT]))&&(n=void 0),n===CT||void 0===n))return Ok(i,u,s);for(r=new(void 0===n?CT:n)(AT(s-u,0)),o=0;u<s;u++,o++)u in i&&tx(r,o,i[u]);return r.length=o,r}});var OT=zD.f,kT=mw("".startsWith),BT=mw("".slice),FT=Math.min,TT=WS("startsWith"),_T=!TT&&!!function(){var e=OT(String.prototype,"startsWith");return e&&!e.writable}();cS({target:"String",proto:!0,forced:!_T&&!TT},{startsWith:function(e){var t=bS(ww(this));VS(e);var n=dD(FT(arguments.length>1?arguments[1]:void 0,t.length)),r=bS(e);return kT?kT(t,r,n):BT(t,n,n+r.length)===r}});var PT=Object.assign,jT=Object.defineProperty,NT=mw([].concat),IT=!PT||Rw((function(){if(Kw&&1!==PT({b:1},PT(jT({},"a",{enumerable:!0,get:function(){jT(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var e={},t={},n=Symbol(),r="abcdefghijklmnopqrst";return e[n]=7,r.split("").forEach((function(e){t[e]=e})),7!=PT({},e)[n]||fS(PT({},t)).join("")!=r}))?function(e,t){for(var n=Dw(e),r=arguments.length,o=1,i=JD.f,a=LD.f;r>o;)for(var u,s=uD(arguments[o++]),l=i?NT(fS(s),i(s)):fS(s),c=l.length,f=0;c>f;)u=l[f++],Kw&&!oE(a,s,u)||(n[u]=s[u]);return n}:PT;cS({target:"Object",stat:!0,forced:Object.assign!==IT},{assign:IT});var LT=["props","attrs","style","dataset","on","hook"];function RT(e){var t=e.data,n=void 0===t?{}:t,r=e.children,o=void 0===r?[]:r;Object.keys(n).forEach((function(t){var r,o,i=n[t];if("key"!==t){if(!LT.includes(t)){if(t.startsWith("data-")){var a=t.slice(5);return a=Cv(a),function(e,t){null==e.data&&(e.data={});var n=e.data;null==n.dataset&&(n.dataset={}),Object.assign(n.dataset,t)}(e,((r={})[a]=i,r)),void delete n[t]}!function(e,t){null==e.data&&(e.data={});var n=e.data;null==n.props&&(n.props={}),Object.assign(n.props,t)}(e,(o={},o[t]=i,o)),delete n[t]}}else e.key=i})),o.length>0&&o.forEach((function(e){"string"!=typeof e&&RT(e)}))}var MT=[];var zT={};function $T(e,t,n){return Pg(n.isInline(e)?"span":"div",null,t)}function HT(e,t){return void 0===t&&(t=!1),Pg("span",{"data-slate-string":!0},t?e+"\n":e)}function VT(e,t){return void 0===e&&(e=0),void 0===t&&(t=!1),Pg("span",{"data-slate-zero-width":t?"n":"z","data-slate-length":e},"\ufeff",t?Pg("br",null):null)}function UT(e,t,n,r){return mO.set(e,t),bO.set(e,n),Sf.isElement(e)?function(e,t){var n,r=QO.findKey(t,e),o=t.isInline(e),i=Bf.isVoid(t,e),a=QB(r.id),u={id:a,key:r.id,"data-slate-node":"element","data-slate-inline":o},s=e.type,l=e.children,c=void 0===l?[]:l,f=function(e){return zT[e]||$T}(s);n=i?null:c.map((function(n,r){return UT(n,r,e,t)}));var d=f(e,n,t);if(i){u["data-slate-void"]=!0;var p=o?"span":"div",h=aA(Nf.texts(e),1),g=aA(h[0],1)[0],v=Pg(p,{"data-slate-spacer":!0,style:{height:"0",color:"transparent",outline:"none",position:"absolute"}},UT(g,0,e,t));d=Pg(p,{style:{position:"relative"}},d,v),mO.set(g,0),bO.set(g,e)}return null==d.data&&(d.data={}),Object.assign(d.data,u),i||o||(d=function(e,t){var n=t;return MT.forEach((function(r){n=r(e,t)})),n}(e,d)),ZB((function(){var t=zO(a);null!=t&&(DO.set(r,t),SO.set(e,t),EO.set(t,e))})),d}(e,r):function(e,t,n){if(null==e.text)throw new Error("Current node is not slate Text "+JSON.stringify(e));var r=QO.findKey(n,e),o=n.getConfig().decorate;if(null==o)throw new Error("Can not get config.decorate");var i=QO.findPath(n,e),a=o([e,i]),u=ed.decorations(e,a),s=u.map((function(r,o){var i=function(e,t,n,r,o){void 0===t&&(t=!1);var i=e.text,a=QO.findPath(o,n),u=Mf.parent(a);if(Bf.isEditor(r))throw new Error("Text node "+JSON.stringify(n)+" parent is Editor");return o.isVoid(r)?VT(Nf.string(r).length):""!==i||r.children[r.children.length-1]!==n||o.isInline(r)||""!==Bf.string(o,u)?""===i?VT():t&&"\n"===i.slice(-1)?HT(i,!0):HT(i):VT(0,!0)}(r,o===u.length-1,e,t,n);return i=function(e,t){var n=t;return MT.forEach((function(t){n=t(e,n)})),n}(r,i),Pg("span",{"data-slate-leaf":!0},i)})),l=function(e){return"w-e-text-"+e}(r.id),c=Pg("span",{"data-slate-node":"text",id:l,key:r.id},s);return ZB((function(){var t=zO(l);null!=t&&(DO.set(r,t),SO.set(e,t),EO.set(t,e))})),c}(e,n,r)}function WT(e,t){var n,r=e.$scroll,o=function(e){return"w-e-textarea-"+e}(e.id),i=t.getConfig(),a=i.readOnly,u=i.autoFocus,s=function(e,t){return void 0===t&&(t=!1),pg("div#"+e,{props:{contentEditable:!t}})}(o,a),l=t.children||[];s.children=l.map((function(e,n){var r=UT(e,n,t,t);return RT(r),r}));var c=gO.get(e);if(null==c&&(c=!0),c){var f=function(e,t){return Mp('<div\n        id="'+e+'"\n        data-slate-editor\n        data-slate-node="value"\n        suppressContentEditableWarning\n        role="textarea"\n        spellCheck="true"\n        autoCorrect="true"\n        autoCapitalize="true"\n    ></div>')}(o);r.append(f),e.$textArea=f,n=f[0],(p=fg([yg,Ag,Tg,wg,xg,gg]))(n,s),gO.set(e,!1),vO.set(e,p)}else{var d=yO.get(e),p=vO.get(e);if(null==d||null==p)return;n=d.elm,p(d,s)}if(null!=n||null!=(n=zO(o))){if((c?u:t.isFocused())&&n.focus({preventScroll:!0}),c){var h=NO(n);h&&CO.set(t,h)}wO.set(t,n),SO.set(t,n),EO.set(n,t),yO.set(e,s)}}function GT(e){return"object"==typeof e&&null!=e&&1===e.nodeType}function qT(e,t){return(!t||"hidden"!==e)&&"visible"!==e&&"clip"!==e}function KT(e,t){if(e.clientHeight<e.scrollHeight||e.clientWidth<e.scrollWidth){var n=getComputedStyle(e,null);return qT(n.overflowY,t)||qT(n.overflowX,t)||function(e){var t=function(e){if(!e.ownerDocument||!e.ownerDocument.defaultView)return null;try{return e.ownerDocument.defaultView.frameElement}catch(e){return null}}(e);return!!t&&(t.clientHeight<e.scrollHeight||t.clientWidth<e.scrollWidth)}(e)}return!1}function YT(e,t,n,r,o,i,a,u){return i<e&&a>t||i>e&&a<t?0:i<=e&&u<=n||a>=t&&u>=n?i-e-r:a>t&&u<n||i<e&&u>n?a-t+o:0}function XT(e,t){var n=window,r=t.scrollMode,o=t.block,i=t.inline,a=t.boundary,u=t.skipOverflowHiddenElements,s="function"==typeof a?a:function(e){return e!==a};if(!GT(e))throw new TypeError("Invalid target");for(var l=document.scrollingElement||document.documentElement,c=[],f=e;GT(f)&&s(f);){if((f=f.parentElement)===l){c.push(f);break}null!=f&&f===document.body&&KT(f)&&!KT(document.documentElement)||null!=f&&KT(f,u)&&c.push(f)}for(var d=n.visualViewport?n.visualViewport.width:innerWidth,p=n.visualViewport?n.visualViewport.height:innerHeight,h=window.scrollX||pageXOffset,g=window.scrollY||pageYOffset,v=e.getBoundingClientRect(),y=v.height,m=v.width,b=v.top,w=v.right,E=v.bottom,D=v.left,S="start"===o||"nearest"===o?b:"end"===o?E:b+y/2,x="center"===i?D+m/2:"end"===i?w:D,C=[],A=0;A<c.length;A++){var O=c[A],k=O.getBoundingClientRect(),B=k.height,F=k.width,T=k.top,_=k.right,P=k.bottom,j=k.left;if("if-needed"===r&&b>=0&&D>=0&&E<=p&&w<=d&&b>=T&&E<=P&&D>=j&&w<=_)return C;var N=getComputedStyle(O),I=parseInt(N.borderLeftWidth,10),L=parseInt(N.borderTopWidth,10),R=parseInt(N.borderRightWidth,10),M=parseInt(N.borderBottomWidth,10),z=0,$=0,H="offsetWidth"in O?O.offsetWidth-O.clientWidth-I-R:0,V="offsetHeight"in O?O.offsetHeight-O.clientHeight-L-M:0;if(l===O)z="start"===o?S:"end"===o?S-p:"nearest"===o?YT(g,g+p,p,L,M,g+S,g+S+y,y):S-p/2,$="start"===i?x:"center"===i?x-d/2:"end"===i?x-d:YT(h,h+d,d,I,R,h+x,h+x+m,m),z=Math.max(0,z+g),$=Math.max(0,$+h);else{z="start"===o?S-T-L:"end"===o?S-P+M+V:"nearest"===o?YT(T,P,B,L,M+V,S,S+y,y):S-(T+B/2)+V/2,$="start"===i?x-j-I:"center"===i?x-(j+F/2)+H/2:"end"===i?x-_+R+H:YT(j,_,F,I,R+H,x,x+m,m);var U=O.scrollLeft,W=O.scrollTop;S+=W-(z=Math.max(0,Math.min(W+z,O.scrollHeight-B+V))),x+=U-($=Math.max(0,Math.min(U+$,O.scrollWidth-F+H)))}C.push({el:O,top:z,left:$})}return C}function ZT(e){return e===Object(e)&&0!==Object.keys(e).length}function JT(e,t){return LO(t)&&QO.hasDOMNode(e,t,{editable:!0})}function QT(e,t){if(e.getConfig().readOnly)return!1;var n=e_(e,t)&&QO.toSlateNode(e,t);return Bf.isVoid(e,n)}function e_(e,t){return LO(t)&&QO.hasDOMNode(e,t)}function t_(e,t,n){void 0===n&&(n=!1);var r=t.selection,o=t.getConfig(),i=QO.findDocumentOrShadowRoot(t).getSelection();if(i&&(!e.isComposing||n)&&t.isFocused()){var a="None"!==i.type;if(r||a){var u=wO.get(t),s=!1;if(u.contains(i.anchorNode)&&u.contains(i.focusNode)&&(s=!0),a&&s&&r){var l=QO.toSlateRange(t,i,{exactMatch:!0,suppressThrow:!0});if(l&&qf.equals(l,r)){var c=!0;if(qf.isCollapsed(r)){var f=i.anchorNode,d=i.anchorOffset;if(f===u){var p=u.childNodes,h=void 0;(h=p[d])&&h.matches("table")&&(c=!1),(h=p[d-1])&&h.matches("table")&&(c=!1)}}if(c)return}}if(!r||QO.hasRange(t,r)){e.isUpdatingSelection=!0;var g=r&&QO.toDOMRange(t,r);if(g){qf.isBackward(r)?i.setBaseAndExtent(g.endContainer,g.endOffset,g.startContainer,g.startOffset):i.setBaseAndExtent(g.startContainer,g.startOffset,g.endContainer,g.endOffset);var v=g.startContainer.parentElement;if(!v.closest("[data-slate-spacer]")){v.getBoundingClientRect=g.getBoundingClientRect.bind(g);var y=document.body;(function(e,t){var n=!e.ownerDocument.documentElement.contains(e);if(ZT(t)&&"function"==typeof t.behavior)return t.behavior(n?[]:XT(e,t));if(!n){var r=function(e){return!1===e?{block:"end",inline:"nearest"}:ZT(e)?e:{block:"start",inline:"nearest"}}(t);(function(e,t){void 0===t&&(t="auto");var n="scrollBehavior"in document.body.style;e.forEach((function(e){var r=e.el,o=e.top,i=e.left;r.scroll&&n?r.scroll({top:o,left:i,behavior:t}):(r.scrollTop=o,r.scrollLeft=i)}))})(XT(e,r),r.behavior)}})(v,{scrollMode:"if-needed",boundary:o.scroll?u.parentElement:y,block:"end",behavior:"smooth"}),delete v.getBoundingClientRect}}else i.removeAllRanges();setTimeout((function(){g&&qO&&u.focus(),e.isUpdatingSelection=!1}))}else t.selection=QO.toSlateRange(t,i,{exactMatch:!1,suppressThrow:!1})}}}var n_=new WeakMap,r_=new WeakMap,o_={bold:"mod+b",compose:["down","left","right","up","backspace","enter"],moveBackward:"left",moveForward:"right",moveWordBackward:"ctrl+left",moveWordForward:"ctrl+right",deleteBackward:"shift?+backspace",deleteForward:"shift?+delete",extendBackward:"shift+left",extendForward:"shift+right",italic:"mod+i",splitBlock:"shift?+enter",undo:"mod+z",tab:"tab",selectAll:"mod+a"},i_={moveLineBackward:"opt+up",moveLineForward:"opt+down",moveWordBackward:"opt+left",moveWordForward:"opt+right",deleteBackward:["ctrl+backspace","ctrl+h"],deleteForward:["ctrl+delete","ctrl+d"],deleteLineBackward:"cmd+shift?+backspace",deleteLineForward:["cmd+shift?+delete","ctrl+k"],deleteWordBackward:"opt+shift?+backspace",deleteWordForward:"opt+shift?+delete",extendLineBackward:"opt+shift+up",extendLineForward:"opt+shift+down",redo:"cmd+shift+z",transposeCharacter:"ctrl+t"},a_={deleteWordBackward:"ctrl+shift?+backspace",deleteWordForward:"ctrl+shift?+delete",redo:["ctrl+y","ctrl+shift+z"]},u_=function(e){var t=o_[e],n=i_[e],r=a_[e],o=t&&Nv(t),i=n&&Nv(n),a=r&&Nv(r);return function(e){return!(!o||!o(e))||!!(GO&&i&&i(e))||!(GO||!a||!a(e))}},s_={isBold:u_("bold"),isCompose:u_("compose"),isMoveBackward:u_("moveBackward"),isMoveForward:u_("moveForward"),isDeleteBackward:u_("deleteBackward"),isDeleteForward:u_("deleteForward"),isDeleteLineBackward:u_("deleteLineBackward"),isDeleteLineForward:u_("deleteLineForward"),isDeleteWordBackward:u_("deleteWordBackward"),isDeleteWordForward:u_("deleteWordForward"),isExtendBackward:u_("extendBackward"),isExtendForward:u_("extendForward"),isExtendLineBackward:u_("extendLineBackward"),isExtendLineForward:u_("extendLineForward"),isItalic:u_("italic"),isMoveLineBackward:u_("moveLineBackward"),isMoveLineForward:u_("moveLineForward"),isMoveWordBackward:u_("moveWordBackward"),isMoveWordForward:u_("moveWordForward"),isRedo:u_("redo"),isSplitBlock:u_("splitBlock"),isTransposeCharacter:u_("transposeCharacter"),isUndo:u_("undo"),isTab:u_("tab"),isSelectAll:u_("selectAll")};function l_(e){e.preventDefault()}var c_={beforeinput:function(e,t,n){var r=e,o=n.getConfig().readOnly;if(JO&&!o&&JT(n,r.target)){var i=n.selection,a=r.inputType,u=r.dataTransfer||r.data||void 0;if("insertCompositionText"!==a&&"deleteCompositionText"!==a){if(r.preventDefault(),!a.startsWith("delete")||a.startsWith("deleteBy")){var s=aA(r.getTargetRanges(),1)[0];if(s){var l=QO.toSlateRange(n,s,{exactMatch:!1,suppressThrow:!1});i&&qf.equals(i,l)||md.select(n,l)}}if(i&&qf.isExpanded(i)&&a.startsWith("delete")){var c=a.endsWith("Backward")?"backward":"forward";Bf.deleteFragment(n,{direction:c})}else switch(a){case"deleteByComposition":case"deleteByCut":case"deleteByDrag":Bf.deleteFragment(n);break;case"deleteContent":case"deleteContentForward":Bf.deleteForward(n);break;case"deleteContentBackward":Bf.deleteBackward(n);break;case"deleteEntireSoftLine":Bf.deleteBackward(n,{unit:"line"}),Bf.deleteForward(n,{unit:"line"});break;case"deleteHardLineBackward":Bf.deleteBackward(n,{unit:"block"});break;case"deleteSoftLineBackward":Bf.deleteBackward(n,{unit:"line"});break;case"deleteHardLineForward":Bf.deleteForward(n,{unit:"block"});break;case"deleteSoftLineForward":Bf.deleteForward(n,{unit:"line"});break;case"deleteWordBackward":Bf.deleteBackward(n,{unit:"word"});break;case"deleteWordForward":Bf.deleteForward(n,{unit:"word"});break;case"insertLineBreak":case"insertParagraph":Bf.insertBreak(n);break;case"insertFromDrop":case"insertFromPaste":case"insertFromYank":case"insertReplacementText":case"insertText":if("insertFromPaste"===a&&!BO.get(n))break;u instanceof DataTransfer?n.insertData(u):"string"==typeof u&&Bf.insertText(n,u)}}}},blur:function(e,t,n){var r=e,o=t.isUpdatingSelection,i=t.latestElement;if(!n.getConfig().readOnly&&!o&&JT(n,r.target)){var a=QO.findDocumentOrShadowRoot(n);if(i!==a.activeElement){var u=r.relatedTarget;if(!(u===QO.toDOMNode(n,n)||IO(u)&&u.hasAttribute("data-slate-spacer"))){if(null!=u&&LO(u)&&QO.hasDOMNode(n,u)){var s=QO.toSlateNode(n,u);if(Sf.isElement(s)&&!n.isVoid(s))return}if(KO){var l=a.getSelection();null==l||l.removeAllRanges()}AO.delete(n)}}}},focus:function(e,t,n){var r=QO.toDOMNode(n,n),o=QO.findDocumentOrShadowRoot(n);t.latestElement=o.activeElement,qO&&e.target!==r?r.focus():AO.set(n,!0)},click:function(e,t,n){if(!n.getConfig().readOnly&&e_(n,e.target)&&LO(e.target)){var r=QO.toSlateNode(n,e.target),o=QO.findPath(n,r);if(Bf.hasPath(n,o)&&Nf.get(n,o)===r){var i=Bf.start(n,o),a=Bf.end(n,o),u=Bf.void(n,{at:i}),s=Bf.void(n,{at:a});if(u&&s&&Mf.equals(u[1],s[1])){var l=Bf.range(n,i);md.select(n,l)}}}},compositionstart:function(e,t,n){if(JT(n,e.target)){var r=n.selection;if(r&&qf.isExpanded(r)&&(Bf.deleteFragment(n),Promise.resolve().then((function(){t_(t,n,!0)}))),r&&qf.isCollapsed(r)){var o=QO.toDOMRange(n,r).startContainer,i=o.textContent||"";n_.set(n,i),r_.set(n,o)}t.isComposing=!0,function(e,t){var n;t.getConfig().placeholder&&t.isEmpty()&&e.showPlaceholder&&(null===(n=e.$placeholder)||void 0===n||n.hide(),e.showPlaceholder=!1)}(t,n)}},compositionend:function(e,t,n){var r=e;if(JT(n,r.target)){t.isComposing=!1;var o=n.selection;if(null!=o){(ZO||qO)&&QO.cleanExposedTexNodeInSelectionBlock(n);for(var i=qf.isBackward(o)?o.focus:o.anchor,a=aA(Bf.node(n,[i.path[0]]),1)[0],u=0;u<i.path.length;u++){var s=aA(Bf.node(n,i.path.slice(0,u+1)),1)[0];if(Sf.isElement(s)&&((KO||qO)&&"link"===s.type||"code"===s.type)){QO.setNewKey(a);break}}var l=r.data;if(l){if(n.getConfig().maxLength){var c=QO.getLeftLengthOfMaxLength(n);c<l.length?(QO.toDOMRange(n,o).startContainer.textContent=n_.get(n)||"",c>0&&Bf.insertText(n,l.slice(0,c)),t.changeViewState()):Bf.insertText(n,l)}else Bf.insertText(n,l);KO||setTimeout((function(){var e=n.selection;if(null!=e){var t=r_.get(n);null!=t&&QO.toDOMRange(n,e).startContainer!==t&&(t.textContent=n_.get(n)||"")}}))}}}},compositionupdate:function(e,t,n){JT(n,e.target)&&(t.isComposing=!0)},keydown:function(e,t,n){var r=e,o=n.selection;if(!n.getConfig().readOnly&&!t.isComposing&&JT(n,r.target)){if(function(e,t){var n=sO.get(e),r=n&&n.getMenus(),o=cO.get(e),i=o&&o.getMenus(),a=oA(oA({},r),i);for(var u in a){var s=a[u],l=s.hotkey;if(l&&jv(l,t)&&!s.isDisabled(e)){var c=s.getValue(e);s.exec(e,c)}}}(n,r),s_.isTab(r))return l_(r),void n.handleTab();if(s_.isRedo(r))return l_(r),void("function"==typeof n.redo&&n.redo());if(s_.isUndo(r))return l_(r),void("function"==typeof n.undo&&n.undo());if(s_.isMoveLineBackward(r))return l_(r),void md.move(n,{unit:"line",reverse:!0});if(s_.isMoveLineForward(r))return l_(r),void md.move(n,{unit:"line"});if(s_.isExtendLineBackward(r))return l_(r),void md.move(n,{unit:"line",edge:"focus",reverse:!0});if(s_.isExtendLineForward(r))return l_(r),void md.move(n,{unit:"line",edge:"focus"});if(s_.isMoveBackward(r))return l_(r),void(o&&qf.isCollapsed(o)?md.move(n,{reverse:!0}):md.collapse(n,{edge:"start"}));if(s_.isMoveForward(r))return l_(r),void(o&&qf.isCollapsed(o)?md.move(n):md.collapse(n,{edge:"end"}));if(s_.isMoveWordBackward(r))return l_(r),o&&qf.isExpanded(o)&&md.collapse(n,{edge:"focus"}),void md.move(n,{unit:"word",reverse:!0});if(s_.isMoveWordForward(r))return l_(r),o&&qf.isExpanded(o)&&md.collapse(n,{edge:"focus"}),void md.move(n,{unit:"word"});if(s_.isSelectAll(r))return l_(r),void n.selectAll();if(JO){if((ZO||KO)&&o&&(s_.isDeleteBackward(r)||s_.isDeleteForward(r))&&qf.isCollapsed(o)){var i=Nf.parent(n,o.anchor.path);if(Sf.isElement(i)&&Bf.isVoid(n,i)&&Bf.isInline(n,i))return r.preventDefault(),void md.delete(n,{unit:"block"})}}else{if(s_.isBold(r)||s_.isItalic(r)||s_.isTransposeCharacter(r))return void l_(r);if(s_.isSplitBlock(r))return l_(r),void Bf.insertBreak(n);if(s_.isDeleteBackward(r))return l_(r),void(o&&qf.isExpanded(o)?Bf.deleteFragment(n,{direction:"backward"}):Bf.deleteBackward(n));if(s_.isDeleteForward(r))return l_(r),void(o&&qf.isExpanded(o)?Bf.deleteFragment(n,{direction:"forward"}):Bf.deleteForward(n));if(s_.isDeleteLineBackward(r))return l_(r),void(o&&qf.isExpanded(o)?Bf.deleteFragment(n,{direction:"backward"}):Bf.deleteBackward(n,{unit:"line"}));if(s_.isDeleteLineForward(r))return l_(r),void(o&&qf.isExpanded(o)?Bf.deleteFragment(n,{direction:"forward"}):Bf.deleteForward(n,{unit:"line"}));if(s_.isDeleteWordBackward(r))return l_(r),void(o&&qf.isExpanded(o)?Bf.deleteFragment(n,{direction:"backward"}):Bf.deleteBackward(n,{unit:"word"}));if(s_.isDeleteWordForward(r))return l_(r),void(o&&qf.isExpanded(o)?Bf.deleteFragment(n,{direction:"forward"}):Bf.deleteForward(n,{unit:"word"}))}}},keypress:function(e,t,n){if(!JO&&!n.getConfig().readOnly&&JT(n,e.target)){e.preventDefault();var r=e.key;Bf.insertText(n,r)}},copy:function(e,t,n){var r=e;if(JT(n,r.target)){r.preventDefault();var o=r.clipboardData;null!=o&&n.setFragmentData(o)}},cut:function(e,t,n){var r=e,o=n.selection;if(!n.getConfig().readOnly&&JT(n,r.target)){r.preventDefault();var i=r.clipboardData;if(null!=i&&(n.setFragmentData(i),o))if(qf.isExpanded(o))Bf.deleteFragment(n);else{var a=Nf.parent(n,o.anchor.path);Bf.isVoid(n,a)&&md.delete(n)}}},paste:function(e,t,n){BO.set(n,!0);var r=e;if(!n.getConfig().readOnly&&JT(n,r.target)){var o=n.getConfig().customPaste;if(o&&!1===o(n,r))return void BO.set(n,!1);if(!JO||function(e){return e.clipboardData&&""!==e.clipboardData.getData("text/plain")&&1===e.clipboardData.types.length}(r)){r.preventDefault();var i=r.clipboardData;null!=i&&n.insertData(i)}}},dragover:function(e,t,n){if(e_(n,e.target)){var r=QO.toSlateNode(n,e.target);Bf.isVoid(n,r)&&e.preventDefault()}},dragstart:function(e,t,n){var r=e;if(e_(n,r.target)&&!n.getConfig().readOnly){var o=QO.toSlateNode(n,r.target),i=QO.findPath(n,o);if(Bf.isVoid(n,o)||Bf.void(n,{at:i,voids:!0})){var a=Bf.range(n,i);md.select(n,a)}var u=r.dataTransfer;null!=u&&(t.isDraggingInternally=!0,n.setFragmentData(u))}},dragend:function(e,t,n){var r=e;n.getConfig().readOnly||t.isDraggingInternally&&e_(n,r.target)&&(t.isDraggingInternally=!1)},drop:function(e,t,n){var r=e,o=r.dataTransfer;if(!n.getConfig().readOnly&&e_(n,r.target)&&null!=o&&!(JO&&KO&&o.files.length>0)){r.preventDefault();var i=n.selection,a=QO.findEventRange(n,r);md.select(n,a),t.isDraggingInternally&&(i&&md.delete(n,{at:i}),t.isDraggingInternally=!1),n.insertData(o),n.isFocused()||n.focus()}}},f_=1,d_=function(){function e(e){var t=this;this.id=f_++,this.$textArea=null,this.$progressBar=Mp('<div class="w-e-progress-bar"></div>'),this.$maxLengthInfo=Mp('<div class="w-e-max-length-info"></div>'),this.isComposing=!1,this.isUpdatingSelection=!1,this.isDraggingInternally=!1,this.latestElement=null,this.showPlaceholder=!1,this.$placeholder=null,this.latestEditorSelection=null,this.onDOMSelectionChange=eg((function(){var e=t.editorInstance;!function(e,t){var n=e.isComposing,r=e.isUpdatingSelection,o=e.isDraggingInternally;if(!(t.getConfig().readOnly||n||r||o)){var i=QO.findDocumentOrShadowRoot(t),a=i.activeElement,u=QO.toDOMNode(t,t),s=i.getSelection();if(a===u?(e.latestElement=a,AO.set(t,!0)):AO.delete(t),!s)return md.deselect(t);var l=s.anchorNode,c=s.focusNode,f=JT(t,l)||QT(t,l),d=JT(t,c)||QT(t,c);if(f&&d){var p=QO.toSlateRange(t,s,{exactMatch:!1,suppressThrow:!1});md.select(t,p)}else md.deselect(t)}}(t,e)}),100);var n=Mp(e);if(0===n.length)throw new Error("Cannot find textarea DOM by selector '"+e+"'");this.$box=n;var r=Mp('<div class="w-e-text-container"></div>');r.append(this.$progressBar),r.append(this.$maxLengthInfo),n.append(r);var o=Mp('<div class="w-e-scroll"></div>');r.append(o),this.$scroll=o,this.$textAreaContainer=r,ZB((function(){var e=t.editorInstance,n=QO.getWindow(e);n.document.addEventListener("selectionchange",t.onDOMSelectionChange),e.on("destroyed",(function(){n.document.removeEventListener("selectionchange",t.onDOMSelectionChange)})),r.on("click",(function(){return e.hidePanelOrModal()})),e.on("change",t.changeViewState.bind(t));var o=e.getConfig().onChange;o&&e.on("change",(function(){return o(e)})),t.onFocusAndOnBlur(),e.on("change",t.changeMaxLengthInfo.bind(t)),t.bindEvent()}))}return Object.defineProperty(e.prototype,"editorInstance",{get:function(){var e=aO.get(this);if(null==e)throw new Error("Can not get editor instance");return e},enumerable:!1,configurable:!0}),e.prototype.bindEvent=function(){var e=this,t=this.$textArea,n=this.$scroll,r=this.editorInstance;null!=t&&(Lh(c_,(function(n,o){t.on(o,(function(t){n(t,e,r)}))})),r.getConfig().scroll&&(n.css("overflow-y","auto"),n.on("scroll",eg((function(){r.emit("scroll")}),100))))},e.prototype.onFocusAndOnBlur=function(){var e=this,t=this.editorInstance,n=t.getConfig(),r=n.onBlur,o=n.onFocus;this.latestEditorSelection=t.selection,t.on("change",(function(){null==e.latestEditorSelection&&null!=t.selection?setTimeout((function(){return o&&o(t)})):null!=e.latestEditorSelection&&null==t.selection&&setTimeout((function(){return r&&r(t)})),e.latestEditorSelection=t.selection}))},e.prototype.changeMaxLengthInfo=function(){var e=this.editorInstance,t=e.getConfig().maxLength;if(t){var n=t-QO.getLeftLengthOfMaxLength(e);this.$maxLengthInfo[0].innerHTML=n+"/"+t}},e.prototype.changeProgress=function(e){var t=this.$progressBar;t.css("width",e+"%"),e>=100&&setTimeout((function(){t.hide(),t.css("width","0"),t.show()}),1e3)},e.prototype.changeViewState=function(){var e=this,t=this.editorInstance;WT(this,t),function(e,t){var n,r=t.getConfig().placeholder;if(r){var o=t.isEmpty();if(o&&!e.showPlaceholder&&!e.isComposing){if(null==e.$placeholder){var i=Mp('<div class="w-e-text-placeholder">'+r+"</div>");e.$textAreaContainer.append(i),e.$placeholder=i}return e.$placeholder.show(),void(e.showPlaceholder=!0)}!o&&e.showPlaceholder&&(null===(n=e.$placeholder)||void 0===n||n.hide(),e.showPlaceholder=!1)}}(this,t),ZB((function(){t_(e,t)}))},e.prototype.destroy=function(){this.$textAreaContainer.remove()},e}();function p_(e){e.removeAttr("width"),e.removeAttr("height"),e.removeAttr("fill"),e.removeAttr("class"),e.removeAttr("t"),e.removeAttr("p-id");var t=e.children();t.length&&p_(t)}function h_(){return Mp('<svg viewBox="0 0 1024 1024"><path d="M498.7 655.8l-197.6-268c-8.1-10.9-0.3-26.4 13.3-26.4h395.2c13.6 0 21.4 15.4 13.3 26.4l-197.6 268c-6.6 9-20 9-26.6 0z"></path></svg>')}function g_(){return Mp('<div class="w-e-bar-divider"></div>')}function v_(e,t,n,r,o){if(void 0===o&&(o=!1),t){if(r){var i=GO?"cmd":"ctrl";r=r.replace("mod",i)}if(o)r&&(e.attr("data-tooltip",r),e.addClass("w-e-menu-tooltip-v5"),e.addClass("tooltip-right"));else{var a=r?n+"\n"+r:n;e.attr("data-tooltip",a),e.addClass("w-e-menu-tooltip-v5")}}}NC("match",(function(e,t,n){return[function(t){var n=ww(this),r=null==t?void 0:dE(t,e);return r?oE(r,t,n):new RegExp(t)[e](bS(n))},function(e){var r=nE(this),o=bS(e),i=n(t,r,o);if(i.done)return i.value;if(!r.global)return GC(r,o);var a=r.unicode;r.lastIndex=0;for(var u,s=[],l=0;null!==(u=GC(r,o));){var c=bS(u[0]);s[l]=c,""===c&&(r.lastIndex=LC(o,dD(r.lastIndex),a)),l++}return 0===l?null:s}]}));var y_=function(){function e(e,t,n){var r=this;void 0===n&&(n=!1),this.$elem=Mp('<div class="w-e-bar-item"></div>'),this.$button=Mp('<button type="button"></button>'),this.disabled=!1,this.menu=t;var o=t.tag,i=t.width;if("button"!==o)throw new Error("Invalid tag '"+o+"', expected 'button'");var a=t.title,u=t.hotkey,s=void 0===u?"":u,l=t.iconSvg,c=void 0===l?"":l,f=this.$button;if(c){var d=Mp(c);p_(d),f.append(d)}else f.text(a);v_(f,c,a,s,n),n&&c&&f.append(Mp('<span class="title">'+a+"</span>")),i&&f.css("width",i+"px"),f.attr("data-menu-key",e),this.$elem.append(f),ZB((function(){return r.init()}))}return e.prototype.init=function(){var e=this;this.setActive(),this.setDisabled(),this.$button.on("click",(function(t){t.preventDefault(),T_(e).hidePanelOrModal(),e.disabled||(e.exec(),e.onButtonClick())}))},e.prototype.exec=function(){var e=T_(this),t=this.menu,n=t.getValue(e);t.exec(e,n)},e.prototype.setActive=function(){var e=T_(this),t=this.$button,n="active";this.menu.isActive(e)?t.addClass(n):t.removeClass(n)},e.prototype.setDisabled=function(){var e=T_(this),t=this.$button,n=this.menu.isDisabled(e);(null==e.selection||e.isDisabled())&&(n=!0),this.menu.alwaysEnable&&(n=!1);var r="disabled";n?t.addClass(r):t.removeClass(r),this.disabled=n},e.prototype.changeMenuState=function(){this.setActive(),this.setDisabled()},e}(),m_=function(e){function t(t,n,r){return void 0===r&&(r=!1),e.call(this,t,n,r)||this}return rA(t,e),t.prototype.onButtonClick=function(){},t}(y_),b_=function(){function e(e){this.isShow=!1,this.showTime=0,this.record(e)}return e.prototype.record=function(e){var t=dO.get(e);null==t&&(t=new Set,dO.set(e,t)),t.add(this),pO.set(this,e)},e.prototype.renderContent=function(e){var t=this.$elem;t.empty(),t.append(e);var n=this.genSelfElem();n&&t.append(n)},e.prototype.appendTo=function(e){var t=this.$elem;e.append(t)},e.prototype.show=function(){if(!this.isShow){this.showTime=Date.now(),this.$elem.show(),this.isShow=!0;var e=pO.get(this);e&&e.emit("modalOrPanelShow",this)}},e.prototype.hide=function(){if(this.isShow&&!(Date.now()-this.showTime<200)){this.$elem.hide(),this.isShow=!1;var e=pO.get(this);e&&e.emit("modalOrPanelHide")}},e}(),w_=function(e){function t(t){var n=e.call(this,t)||this;return n.type="dropPanel",n.$elem=Mp('<div class="w-e-drop-panel"></div>'),n}return rA(t,e),t.prototype.genSelfElem=function(){return null},t}(b_),E_=function(e){function t(t,n,r){void 0===r&&(r=!1);var o=e.call(this,t,n,r)||this;if(o.dropPanel=null,o.menu=n,n.showDropPanel){var i=h_();o.$button.append(i)}return o}return rA(t,e),t.prototype.onButtonClick=function(){this.menu.showDropPanel&&this.handleDropPanel()},t.prototype.handleDropPanel=function(){var e=this.menu;if(null!=e.getPanelContentElem){var t=T_(this);if(null==this.dropPanel){var n=new w_(t),r=e.getPanelContentElem(t);n.renderContent(r),n.appendTo(this.$elem),n.show(),this.dropPanel=n}else{var o=this.dropPanel;o.isShow?o.hide():(r=e.getPanelContentElem(t),o.renderContent(r),o.show())}var i=this.dropPanel;if(i.isShow){var a=this.$elem,u=a.offset().left,s=a.parents(".w-e-bar");u-s.offset().left>=s.width()/2?i.$elem.css({left:"none",right:"0"}):i.$elem.css({left:"0",right:"none"})}}},t}(y_),D_=function(e){function t(t,n){void 0===n&&(n=0);var r=e.call(this,t)||this;r.type="modal",r.$elem=Mp('<div class="w-e-modal"></div>'),r.width=0,n&&(r.width=n);var o=r.$elem;return o.on("click",(function(e){return e.stopPropagation()})),o.on("keyup",(function(e){"Escape"===e.code&&(r.hide(),t.restoreSelection())})),r}return rA(t,e),t.prototype.genSelfElem=function(){var e=this,t=Mp('<span class="btn-close"><svg viewBox="0 0 1024 1024"><path d="M1024 896.1024l-128 128L512 640 128 1024 0 896 384 512 0 128 128 0 512 384 896.1024 0l128 128L640 512z"></path></svg></span>'),n=pO.get(this);return t.on("click",(function(){e.hide(),null==n||n.restoreSelection()})),t},t.prototype.setStyle=function(e){var t=this.width,n=this.$elem;n.attr("style",""),t&&n.css("width",t+"px"),n.css(e)},t}(b_);function S_(e,t,n){var r=Mp('<label class="babel-container"></label>');r.append("<span>"+e+"</span>");var o=Mp('<input type="text" id="'+t+'" placeholder="'+(n||"")+'">');return r.append(o),[r[0],o[0]]}function x_(e,t,n){var r=Mp('<label class="babel-container"></label>');r.append("<span>"+e+"</span>");var o=Mp('<textarea type="text" id="'+t+'" placeholder="'+(n||"")+'"></textarea>');return r.append(o),[r[0],o[0]]}function C_(e,t){var n=Mp('<div class="button-container"></div>'),r=Mp('<button type="button" id="'+e+'">'+t+"</button>");return n.append(r),[n[0],r[0]]}var A_=function(e){function t(t,n,r){void 0===r&&(r=!1);var o=e.call(this,t,n,r)||this;return o.$body=Mp("body"),o.modal=null,o.menu=n,o}return rA(t,e),t.prototype.onButtonClick=function(){this.menu.showModal&&this.handleModal()},t.prototype.getPosition=function(){var e=T_(this),t=this.menu.getModalPositionNode(e);return Sf.isElement(t)?ET(e,t,"modal"):wT(e)},t.prototype.handleModal=function(){var e=T_(this),t=this.menu;if(null==this.modal){var n=new D_(e,t.modalWidth);this.renderAndShowModal(n,!0),this.modal=n}else(n=this.modal).isShow?n.hide():this.renderAndShowModal(n,!1)},t.prototype.renderAndShowModal=function(e,t){void 0===t&&(t=!1);var n=T_(this),r=this.menu;if(null!=r.getModalContentElem){var o=QO.getTextarea(n),i=QO.getToolbar(n),a=((null==i?void 0:i.getConfig())||{}).modalAppendToBody,u=r.getModalContentElem(n);if(e.renderContent(u),a)e.setStyle({left:"0",right:"0"});else{var s=this.getPosition();e.setStyle(s)}t&&(a?e.appendTo(this.$body):e.appendTo(o.$textAreaContainer)),e.show(),a||DT(n,e.$elem),setTimeout((function(){n.blur()}))}},t}(y_),O_=function(e){function t(t,n){var r=e.call(this,t)||this;return r.type="selectList",r.$elem=Mp('<div class="w-e-select-list"></div>'),n&&r.$elem.css("width",n+"px"),r.$elem.on("click",(function(e){e.stopPropagation()})),r}return rA(t,e),t.prototype.renderList=function(e){var t=this.$elem;t.empty();var n=Mp("<ul></ul>");e.forEach((function(e){var t=e.value,r=e.text,o=e.selected,i=e.styleForRenderMenuList,a=Mp('<li data-value="'+t+'"></li>');if(i&&a.css(i),o){var u=Mp('<svg viewBox="0 0 1446 1024"><path d="M574.116299 786.736392 1238.811249 48.517862C1272.390222 11.224635 1329.414799 7.827718 1366.75664 41.450462 1403.840015 74.840484 1406.731043 132.084741 1373.10189 169.433699L655.118888 966.834607C653.072421 969.716875 650.835807 972.514337 648.407938 975.210759 615.017957 1012.29409 558.292155 1015.652019 521.195664 982.250188L72.778218 578.493306C35.910826 545.297758 32.859041 488.584019 66.481825 451.242134 99.871807 414.158803 156.597563 410.800834 193.694055 444.202665L574.116299 786.736392Z"></path></svg>');a.append(u),a.addClass("selected")}a.append(Mp('<span data-value="'+t+'">'+r+"</span>")),a.attr("title",r),n.append(a)})),t.append(n)},t.prototype.genSelfElem=function(){return null},t}(b_),k_=function(){function e(e,t,n){var r=this;void 0===n&&(n=!1),this.$elem=Mp('<div class="w-e-bar-item"></div>'),this.$button=Mp('<button type="button" class="select-button"></button>'),this.disabled=!1,this.selectList=null;var o=t.tag,i=t.title,a=t.width,u=t.iconSvg,s=void 0===u?"":u,l=t.hotkey,c=void 0===l?"":l;if("select"!==o)throw new Error("Invalid tag '"+o+"', expected 'select'");var f=this.$button;a&&f.css("width",a+"px"),f.attr("data-menu-key",e),v_(f,s,i,c,n),this.$elem.append(f),this.menu=t,ZB((function(){return r.init()}))}return e.prototype.init=function(){var e=this;this.setSelectedValue(),this.$button.on("click",(function(t){t.preventDefault(),T_(e).hidePanelOrModal(),e.trigger()}))},e.prototype.trigger=function(){var e=this,t=T_(this);if(!t.isDisabled()&&!this.disabled){var n=this.menu;if(null==this.selectList){this.selectList=new O_(t,n.selectPanelWidth);var r=this.selectList,o=n.getOptions(t);r.renderList(o),r.appendTo(this.$elem),r.show(),r.$elem.on("click","li",(function(t){var n=t.target;if(null!=n){t.preventDefault();var r=Mp(n).attr("data-value");e.onChange(r)}}))}else(r=this.selectList).isShow?r.hide():(o=n.getOptions(t),r.renderList(o),r.show())}},e.prototype.onChange=function(e){var t=T_(this),n=this.menu;n.exec&&n.exec(t,e)},e.prototype.setSelectedValue=function(){var e=T_(this),t=this.menu,n=t.getValue(e),r=function(e,t){for(var n=e.length,r="",o=0;o<n;o++){var i=e[o];if(i.value===t){r=i.text;break}}return r}(t.getOptions(e),n.toString()),o=this.$button,i=h_();o.empty(),o.text(r),o.append(i)},e.prototype.setDisabled=function(){var e=T_(this),t=this.menu.isDisabled(e),n=this.$button;(null==e.selection||e.isDisabled())&&(t=!0);var r="disabled";t?n.addClass(r):n.removeClass(r),this.disabled=t},e.prototype.changeMenuState=function(){this.setSelectedValue(),this.setDisabled()},e}(),B_=function(){function e(e){this.$elem=Mp('<div class="w-e-bar-item w-e-bar-item-group"></div>'),this.$container=Mp('<div class="w-e-bar-item-menus-container"></div>'),this.$button=Mp('<button type="button"></button>');var t=e.key,n=e.iconSvg,r=e.title,o=this.$elem,i=this.$button;if(n){var a=Mp(n);p_(a),i.append(a)}else i.text(r);i.attr("data-menu-key",t);var u=h_();i.append(u),o.append(i);var s=this.$container;o.append(s);var l=this.createObserver();this.observe(l)}return e.prototype.appendBarItem=function(e){var t=e.$elem;this.$container.append(t)},e.prototype.observe=function(e){var t=this.$container;e.observe(t[0],{childList:!0,subtree:!0,attributes:!0})},e.prototype.createObserver=function(){var e=this,t=this.$container,n=this.$button,r=new MutationObserver((function(){var o=t.find("button"),i=o.length;if(0!==i){var a=0;o.each((function(e){Mp(e).hasClass("disabled")&&a++})),r.disconnect(),a===i?n.addClass("disabled"):n.removeClass("disabled"),e.observe(r)}}));return r},e}(),F_=new WeakMap;function T_(e){var t=fO.get(e);if(null==t)throw new Error("Can not get editor instance");return t}function __(e,t,n){void 0===n&&(n=!1);var r=F_.get(t);if(r)return r;var o=t.tag;if("button"===o){var i=t.showDropPanel,a=t.showModal;r=i?new E_(e,t,n):a?new A_(e,t,n):new m_(e,t,n)}if("select"===o&&(r=new k_(e,t,n)),null==r)throw new Error("Invalid tag in menu "+JSON.stringify(t));return F_.set(t,r),r}function P_(e,t){var n=e.selection;return null!=n&&!qf.isCollapsed(n)&&!QO.getSelectedElems(e).some((function(t){if(e.isVoid(t))return!0;var n=t.type;return!!["pre","code","table"].includes(n)||void 0}))&&!!ed.isText(t)}var j_=function(){function e(){var e=this;this.$elem=Mp('<div class="w-e-bar w-e-bar-hidden w-e-hover-bar"></div>'),this.menus={},this.hoverbarItems=[],this.prevSelectedNode=null,this.isShow=!1,this.changeHoverbarState=Zv((function(){var t=e.isShow,n=e.getSelectedNodeAndMenuKeys()||{},r=n.node,o=void 0===r?null:r,i=n.menuKeys,a=void 0===i?[]:i;null!=o&&e.changeItemsState(),o&&Sf.isElement(o)&&t&&e.isSamePath(o,e.prevSelectedNode)||(e.hideAndClean(),null!=o&&(e.registerItems(a),e.setPosition(o),e.show()),e.prevSelectedNode=o)}),200),ZB((function(){var t=e.getEditorInstance(),n=e.$elem;n.on("mousedown",(function(e){return e.preventDefault()}),{passive:!1}),QO.getTextarea(t).$textAreaContainer.append(n),t.on("change",e.changeHoverbarState);var r=e.hideAndClean.bind(e);t.on("scroll",r),t.on("fullScreen",r),t.on("unFullScreen",r)}))}return e.prototype.getMenus=function(){return this.menus},e.prototype.hideAndClean=function(){var e=this.$elem;e.removeClass("w-e-bar-show").addClass("w-e-bar-hidden"),this.hoverbarItems=[],e.empty(),this.isShow=!1},e.prototype.checkPositionBottom=function(){var e=this.$elem,t=!1,n=window.innerHeight;n&&n>=360&&n-e[0].getBoundingClientRect().bottom<360&&(t=!0),t?e.addClass("w-e-bar-bottom"):e.removeClass("w-e-bar-bottom")},e.prototype.show=function(){this.$elem.removeClass("w-e-bar-hidden").addClass("w-e-bar-show"),this.isShow=!0,this.checkPositionBottom()},e.prototype.changeItemsState=function(){var e=this;ZB((function(){e.hoverbarItems.forEach((function(e){e.changeMenuState()}))}))},e.prototype.registerItems=function(e){var t=this,n=this.$elem;e.forEach((function(e){if("|"!==e)t.registerSingleItem(e);else{var r=g_();n.append(r)}}))},e.prototype.registerSingleItem=function(e){var t=this.getEditorInstance(),n=this.menus,r=n[e];if(null==r){var o=nk[e];if(null==o)throw new Error("Not found menu item factory by key '"+e+"'");if("function"!=typeof o)throw new Error("Menu item factory (key='"+e+"') is not a function");r=o(),n[e]=r}var i=__(e,r);this.hoverbarItems.push(i),fO.set(i,t),this.$elem.append(i.$elem)},e.prototype.setPosition=function(e){var t=this.getEditorInstance(),n=this.$elem;if(n.attr("style",""),Sf.isElement(e)){var r=ET(t,e,"bar");return n.css(r),void DT(t,n)}if(ed.isText(e))return r=wT(t),n.css(r),void DT(t,n);throw new Error("hoverbar.setPosition error, current selected node is not elem nor text")},e.prototype.getSelectedNodeAndMenuKeys=function(){var e=this.getEditorInstance();if(null==e.selection)return null;var t=this.getHoverbarKeysConf(),n=null,r=[],o=function(o){var i=t[o],a=i.match,u=i.menuKeys,s=void 0===u?[]:u,l=a||function(e,t){return QO.checkNodeType(t,o)},c=aA(Bf.nodes(e,{match:function(t){return l(e,t)},universal:!0}),1),f=c[0];if(null!=f)return n=f[0],r=s,"break"};for(var i in t)if("break"===o(i))break;return null==n||0===r.length?null:{node:n,menuKeys:r}},e.prototype.getEditorInstance=function(){var e=lO.get(this);if(null==e)throw new Error("Can not get editor instance");return e},e.prototype.getHoverbarKeysConf=function(){var e=this.getEditorInstance().getConfig().hoverbarKeys,t=void 0===e?{}:e,n=t.text;return n&&null==n.match&&(n.match=P_),t},e.prototype.isSamePath=function(e,t){if(null==e||null==t)return!1;var n=QO.findPath(null,e),r=QO.findPath(null,t);return Mf.equals(n,r)},e.prototype.destroy=function(){this.changeHoverbarState.cancel(),this.$elem.remove(),this.menus={},this.hoverbarItems=[],this.prevSelectedNode=null},e}();function N_(e,t,n,r){if(mO.set(e,t),bO.set(e,n),Sf.isElement(e)){var o=e.children;if((void 0===o?[]:o).forEach((function(t,n){return N_(t,n,e,r)})),Bf.isVoid(r,e)){var i=aA(Nf.texts(e),1),a=aA(i[0],1)[0];mO.set(a,0),bO.set(a,e)}}}function I_(e){var t=e.selector,n=void 0===t?"":t,r=e.config,o=void 0===r?{}:r,i=e.content,a=e.html,u=e.plugins,s=void 0===u?[]:u,l=(e=>{var t=e,{apply:n}=t;return t.history={undos:[],redos:[]},t.redo=()=>{var{history:e}=t,{redos:n}=e;if(n.length>0){var r=n[n.length-1];yS.withoutSaving(t,(()=>{Bf.withoutNormalizing(t,(()=>{for(var e of r)t.apply(e)}))})),e.redos.pop(),e.undos.push(r)}},t.undo=()=>{var{history:e}=t,{undos:n}=e;if(n.length>0){var r=n[n.length-1];yS.withoutSaving(t,(()=>{Bf.withoutNormalizing(t,(()=>{var e=r.map(Rf.inverse).reverse();for(var n of e)t.apply(n)}))})),e.redos.push(r),e.undos.pop()}},t.apply=e=>{var{operations:r,history:o}=t,{undos:i}=o,a=i[i.length-1],u=a&&a[a.length-1],s=((e,t)=>!(!t||"set_selection"!==e.type||"set_selection"!==t.type))(e,u),l=yS.isSaving(t),c=yS.isMerging(t);if(null==l&&(l=((e,t)=>"set_selection"!==e.type||null!=e.properties&&null!=e.newProperties)(e)),l){if(null==c&&(c=null!=a&&(0!==r.length||((e,t)=>"set_selection"===e.type||!(!t||"insert_text"!==e.type||"insert_text"!==t.type||e.offset!==t.offset+t.text.length||!Mf.equals(e.path,t.path))||!(!t||"remove_text"!==e.type||"remove_text"!==t.type||e.offset+e.text.length!==t.offset||!Mf.equals(e.path,t.path)))(e,u)||s)),a&&c)s&&a.pop(),a.push(e);else{var f=[e];i.push(f)}for(;i.length>100;)i.shift();(e=>"set_selection"!==e.type)(e)&&(o.redos=[])}n(e)},t})(function(e){var t=e,n=t.insertText,r=t.insertNode,o=t.insertFragment,i=t.dangerouslyInsertHtml;return t.insertText=function(e){if(t.getConfig().maxLength){var r=QO.getLeftLengthOfMaxLength(t);r<=0||(r<e.length?n(e.slice(0,r)):n(e))}else n(e)},t.insertNode=function(e){if(t.getConfig().maxLength){var n=QO.getLeftLengthOfMaxLength(t);n<=0||n<Nf.string(e).length||r(e)}else r(e)},t.insertFragment=function(e){if(t.getConfig().maxLength)if(1!==e.length)e.forEach((function(e){t.insertNode(e)}));else{var n=e[0];if(QO.getLeftLengthOfMaxLength(t)<Nf.string(n).length)return;o(e)}else o(e)},t.dangerouslyInsertHtml=function(e,n){if(void 0===e&&(e=""),void 0===n&&(n=!1),e)if(t.getConfig().maxLength){var r=QO.getLeftLengthOfMaxLength(t);if(!(r<=0)){var o=document.createElement("div");o.innerHTML=e;var a=Array.from(o.childNodes).reduce((function(e,t){var n=t.nodeType,r=t.nodeName;return t?n===PO.TEXT_NODE?e+(t.textContent||""):n===PO.ELEMENT_NODE?UF.has(r.toLowerCase())?e:e+(t.textContent||""):e:e}),"");r<a.length||i(e,n)}}else i(e,n)},t}(function(e){var t=e;return t.on=function(e,n){var r=hT(t);if(r.on(e,n),"destroyed"===e&&vT(t,n),"destroyed"!==e){var o=function(){return r.off(e,n)};r.on("destroyed",o),vT(t,o)}},t.once=function(e,n){hT(t).once(e,n)},t.off=function(e,n){hT(t).off(e,n)},t.emit=function(e){for(var n=[],r=1;r<arguments.length;r++)n[r-1]=arguments[r];var o=hT(t);o.emit.apply(o,uA([e],aA(n))),"destroyed"===e&&(yT(t).forEach((function(e){return o.off("destroyed",e)})),mT(t))},t}(function(e){var t=e;return t.select=function(e){md.select(t,e)},t.deselect=function(){var n=t.selection,r=QO.findDocumentOrShadowRoot(t).getSelection();r&&r.rangeCount>0&&r.removeAllRanges(),n&&md.deselect(e)},t.move=function(t,n){void 0===n&&(n=!1),t&&(t<0||md.move(e,{distance:t,unit:"character",reverse:n}))},t.moveReverse=function(e){t.move(e,!0)},t.restoreSelection=function(){var e=OO.get(t);null!=e&&(t.focus(),md.select(t,e))},t.getSelectionPosition=function(){return wT(t)},t.getNodePosition=function(e){return ET(t,e)},t.isSelectedAll=function(){var e=t.selection;if(null==e)return!1;var n=aA(qf.edges(e),2),r=n[0],o=n[1],i=aA(Bf.edges(t,[]),2),a=i[0],u=i[1];return!(!Vf.equals(r,a)||!Vf.equals(o,u))},t.selectAll=function(){var e=Bf.start(t,[]),n=Bf.end(t,[]);md.select(t,{anchor:e,focus:n})},t}(function(e){var t=e,n=t.onChange,r=t.insertText,o=t.apply,i=t.deleteBackward;return t.insertText=function(e){t.getConfig().readOnly||r(e)},t.apply=function(e){var n,r,i,a,u,s,l,c,f=[];switch(e.type){case"insert_text":case"remove_text":case"set_node":try{for(var d=iA(Bf.levels(t,{at:e.path})),p=d.next();!p.done;p=d.next()){var h=aA(p.value,2),g=h[0],v=h[1],y=QO.findKey(t,g);f.push([v,y])}}catch(e){n={error:e}}finally{try{p&&!p.done&&(r=d.return)&&r.call(d)}finally{if(n)throw n.error}}break;case"insert_node":case"remove_node":case"merge_node":case"split_node":try{for(var m=iA(Bf.levels(t,{at:Mf.parent(e.path)})),b=m.next();!b.done;b=m.next()){var w=aA(b.value,2);g=w[0],v=w[1],y=QO.findKey(t,g),f.push([v,y])}}catch(e){i={error:e}}finally{try{b&&!b.done&&(a=m.return)&&a.call(m)}finally{if(i)throw i.error}}break;case"move_node":try{for(var E=iA(Bf.levels(t,{at:Mf.common(Mf.parent(e.path),Mf.parent(e.newPath))})),D=E.next();!D.done;D=E.next()){var S=aA(D.value,2);g=S[0],v=S[1],y=QO.findKey(t,g),f.push([v,y])}}catch(e){u={error:e}}finally{try{D&&!D.done&&(s=E.return)&&s.call(E)}finally{if(u)throw u.error}}}o(e);try{for(var x=iA(f),C=x.next();!C.done;C=x.next()){var A=aA(C.value,2);v=A[0],y=A[1],g=aA(Bf.node(t,v),1)[0],xO.set(g,y)}}catch(e){l={error:e}}finally{try{C&&!C.done&&(c=x.return)&&c.call(x)}finally{if(l)throw l.error}}},t.deleteBackward=function(n){if("line"!==n)return i(n);if(e.selection&&qf.isCollapsed(e.selection)){var r=Bf.above(e,{match:function(t){return Bf.isBlock(e,t)},at:e.selection});if(r){var o=aA(r,2)[1],a=Bf.range(e,o,e.selection.anchor),u=function(e,t){var n=Bf.range(e,qf.end(t)),r=Array.from(Bf.positions(e,{at:t})),o=0,i=r.length,a=Math.floor(i/2);if(tF(e,Bf.range(e,r[o]),n))return Bf.range(e,r[o],n);if(r.length<2)return Bf.range(e,r[r.length-1],n);for(;a!==r.length&&a!==o;)tF(e,Bf.range(e,r[a]),n)?i=a:o=a,a=Math.floor((o+i)/2);return Bf.range(e,r[i],n)}(t,a);qf.isCollapsed(u)||md.delete(e,{at:u})}}},t.onChange=function(){var e=t.selection;null!=e&&OO.set(t,e),t.emit("change"),n()},t.handleTab=function(){t.insertText("    ")},t.getHtml=function(){var e=t.children;return(void 0===e?[]:e).map((function(e){return JB(e,t)})).join("")},t.getText=function(){var e=t.children;return(void 0===e?[]:e).map((function(e){return Nf.string(e)})).join("\n")},t.getSelectionText=function(){var n=t.selection;return null==n?"":Bf.string(e,n)},t.getElemsByType=function(e,n){var r,o;void 0===n&&(n=!1);var i=[],a=Bf.nodes(t,{at:[],universal:!0});try{for(var u=iA(a),s=u.next();!s.done;s=u.next()){var l=aA(s.value,1)[0];if(Sf.isElement(l)&&(n?l.type.indexOf(e)>=0:l.type===e)){var c=QB(QO.findKey(t,l).id);i.push(oA(oA({},l),{id:c}))}}}catch(e){r={error:e}}finally{try{s&&!s.done&&(o=u.return)&&o.call(u)}finally{if(r)throw r.error}}return i},t.getElemsByTypePrefix=function(e){return t.getElemsByType(e,!0)},t.isEmpty=function(){var e=t.children,n=void 0===e?[]:e;if(n.length>1)return!1;var r=n[0];if(null==r)return!0;if(Sf.isElement(r)&&"paragraph"===r.type){var o=r.children,i=void 0===o?[]:o;if(i.length>1)return!1;var a=i[0];if(null==a)return!0;if(ed.isText(a)&&""===a.text)return!0}return!1},t.clear=function(){md.delete(t,{at:{anchor:Bf.start(t,[]),focus:Bf.end(t,[])}}),0===t.children.length&&md.insertNodes(t,[{type:"paragraph",children:[{text:""}]}])},t.getParentNode=function(e){return QO.getParentNode(t,e)},t.dangerouslyInsertHtml=function(e,n){if(void 0===e&&(e=""),void 0===n&&(n=!1),e){var r=document.createElement("div");r.innerHTML=e;var o=Array.from(r.childNodes);if(o=o.filter((function(e){var t=e.nodeType,n=e.nodeName;return t===PO.TEXT_NODE||t===PO.ELEMENT_NODE&&!UF.has(n.toLowerCase())})),0!==o.length){var i=t.selection;if(null!=i){var a=null;QO.isSelectedEmptyParagraph(t)&&!n&&(a=[i.focus.path[0]]),r.setAttribute("hidden","true"),document.body.appendChild(r);var u=0;o.forEach((function(e){var n=e.nodeType,r=e.nodeName,o=e.textContent,i=void 0===o?"":o;if(n!==PO.TEXT_NODE)if("BR"!==r){var a=e,s=!1;if(nF.includes(r.toLowerCase()))s=!0;else for(var l in iF)if(a.matches(l)){s=!0;break}if(s){var c=IF(Mp(a),t);return Array.isArray(c)?(c.forEach((function(e){return WF(t,e)})),u++):(WF(t,c),u++),void(QO.isSelectedVoidNode(t)&&t.move(1))}var f=window.getComputedStyle(a).display;QO.isSelectedEmptyParagraph(t)||f.indexOf("inline")<0&&t.insertBreak(),t.dangerouslyInsertHtml(a.innerHTML,!0)}else t.insertText("\n");else{if(!i||!i.trim())return;t.insertNode({text:i})}})),u&&a&&QO.isEmptyPath(t,a)&&md.removeNodes(t,{at:a}),r.remove()}}}},t.setHtml=function(e){void 0===e&&(e="");var n=t.isDisabled(),r=t.isFocused(),o=JSON.stringify(t.selection);t.enable(),t.focus(),t.clear();var i=RF(t,e);if(md.insertFragment(t,i),r||(t.deselect(),t.blur()),n&&(t.deselect(),t.disable()),t.isFocused())try{t.select(JSON.parse(o))}catch(e){t.select(Bf.start(t,[]))}},t}(function(e){var t=e;return t.getAllMenuKeys=function(){var e=[];for(var t in nk)e.push(t);return e},t.getConfig=function(){var e=hO.get(t);if(null==e)throw new Error("Can not get editor config");return e},t.getMenuConfig=function(e){var n=t.getConfig().MENU_CONF;return(void 0===n?{}:n)[e]||{}},t.alert=function(e,n){void 0===n&&(n="info");var r=t.getConfig().customAlert;r&&r(e,n)},t}(function(e){var t=GF(Wc());return t.id="wangEditor-"+ek++,t.isDestroyed=!1,t.isFullScreen=!1,t.focus=function(e){if(QO.toDOMNode(t,t).focus({preventScroll:!0}),AO.set(t,!0),e){var n=Bf.end(t,[]);md.select(t,n)}else{var r=OO.get(t);r?md.select(t,r):md.select(t,Bf.start(t,[]))}},t.isFocused=function(){return!!AO.get(t)},t.blur=function(){QO.toDOMNode(t,t).blur(),md.deselect(t),AO.set(t,!1)},t.updateView=function(){QO.getTextarea(t).changeViewState();var e=QO.getToolbar(t);e&&e.changeToolbarState();var n=QO.getHoverbar(t);n&&n.changeHoverbarState()},t.destroy=function(){if(!t.isDestroyed){var e=QO.getTextarea(t);e.destroy(),iO.delete(t),aO.delete(e);var n=QO.getToolbar(t);n&&(n.destroy(),sO.delete(t),uO.delete(n));var r=QO.getHoverbar(t);r&&(r.destroy(),cO.delete(t),lO.delete(r)),t.isDestroyed=!0,t.emit("destroyed")}},t.scrollToElem=function(e){if(!t.getConfig().scroll){var n="ç¼è¾å¨ç¦ç¨äº scroll ï¼ç¼è¾å¨åå®¹æ æ³æ»å¨ï¼è¯·èªè¡å®ç°è¯¥åè½";return n+="\nYou has disabled editor scroll, please do this yourself",void console.warn(n)}var r=Mp("#"+e);if(0!==r.length){var o=r[0];if(!QO.hasDOMNode(t,o))return n="Element (found by id is '"+e+"') is not in editor DOM",n+="\n éè¿ id '"+e+"' æ¾å°ç element ä¸å¨ editor DOM ä¹å",void console.error(n,o);var i=QO.getTextarea(t),a=i.$textAreaContainer,u=i.$scroll,s=r.offset().top,l=a.offset().top;u[0].scrollBy({top:s-l,behavior:"smooth"})}},t.showProgressBar=function(e){e<1||QO.getTextarea(t).changeProgress(e)},t.hidePanelOrModal=function(){var e=dO.get(t);null!=e&&e.forEach((function(e){return e.hide()}))},t.enable=function(){t.getConfig().readOnly=!1,t.updateView()},t.disable=function(){t.getConfig().readOnly=!0,t.updateView()},t.isDisabled=function(){return t.getConfig().readOnly},t.toDOMNode=function(e){return QO.toDOMNode(t,e)},t.fullScreen=function(){if(!t.isFullScreen){var e=null,n=QO.getToolbar(t);n&&(e=n.$box);var r=QO.getTextarea(t).$box.parent();if(e&&e.parent()[0]!==r[0])throw new Error("Can not set full screen, cause toolbar DOM parent is not equal to textarea DOM parent\nä¸è½è®¾ç½®å¨å±ï¼å ä¸º toolbar DOM ç¶èç¹å textarea DOM ç¶èç¹ä¸ä¸è´");r.addClass("w-e-full-screen-container");var o=r.css("z-index");r.attr("data-z-index",o.toString()),t.isFullScreen=!0,t.emit("fullScreen")}},t.unFullScreen=function(){if(t.isFullScreen){var e=QO.getTextarea(t).$box.parent();setTimeout((function(){e.removeClass("w-e-full-screen-container"),t.isFullScreen=!1,t.emit("unFullScreen")}),200)}},t.getEditableContainer=function(){return QO.getTextarea(t).$textAreaContainer[0]},t}()))))));if(n&&function(e,t){return LF(e,"data-w-e-textarea",t)}(l,n))throw new Error("Repeated create editor by selector '"+n+"'");var c=function(e){void 0===e&&(e={});var t=Jv(tk),n={},r=e.MENU_CONF,o=void 0===r?{}:r;return Lh(t,(function(e,t){n[t]=oA(oA({},e),o[t]||{})})),delete e.MENU_CONF,oA({scroll:!0,readOnly:!1,autoFocus:!0,decorate:function(){return[]},maxLength:0,MENU_CONF:n,hoverbarKeys:{},customAlert:function(e,t){window.alert(t+":\n"+e)}},e)}(o);hO.set(l,c);var f=c.hoverbarKeys,d=void 0===f?{}:f;if(s.forEach((function(e){l=e(l)})),null!=a&&(l.children=RF(l,a)),i&&i.length&&(l.children=i),0===l.children.length&&(l.children=[{type:"paragraph",children:[{text:""}]}]),QO.normalizeContent(l),n){var p=new d_(n);iO.set(l,p),aO.set(p,l),p.changeViewState(),ZB((function(){var e=p.$scroll;null!=e&&e.height()<300&&console.warn("ç¼è¾åºåé«åº¦ < 300px è¿å¯è½ä¼å¯¼è´ modal hoverbar å®ä½å¼å¸¸\nTextarea height < 300px . This may be cause modal and hoverbar position error",e)}));var h=void 0;Object.keys(d).length>0&&(h=new j_,lO.set(h,l),cO.set(l,h)),l.on("change",(function(){l.hidePanelOrModal()})),l.on("scroll",(function(){l.hidePanelOrModal()}))}else l.children.forEach((function(e,t){return N_(e,t,l,l)}));var g=c.onCreated,v=c.onDestroyed;return g&&l.on("created",(function(){return g(l)})),v&&l.on("destroyed",(function(){return v(l)})),ZB((function(){return l.emit("created")})),l}var L_=iC("splice"),R_=lw.TypeError,M_=Math.max,z_=Math.min;cS({target:"Array",proto:!0,forced:!L_},{splice:function(e,t){var n,r,o,i,a,u,s=Dw(this),l=pD(s),c=VD(e,l),f=arguments.length;if(0===f?n=r=0:1===f?(n=0,r=l-c):(n=f-2,r=z_(M_(cD(t),0),l-c)),l+n-r>9007199254740991)throw R_("Maximum allowed length exceeded");for(o=CD(s,r),i=0;i<r;i++)(a=c+i)in s&&tx(o,i,s[a]);if(o.length=r,n<r){for(i=c;i<l-r;i++)u=i+n,(a=i+r)in s?s[u]=s[a]:delete s[u];for(i=l;i>l-r+n;i--)delete s[i-1]}else if(n>r)for(i=l-r;i>c;i--)u=i+n-1,(a=i+r-1)in s?s[u]=s[a]:delete s[u];for(i=0;i<n;i++)s[i+c]=arguments[i+2];return s.length=l-r+n,o}});var $_=function(){function e(e,t){var n=this;this.$toolbar=Mp('<div class="w-e-bar w-e-bar-show w-e-toolbar"></div>'),this.menus={},this.toolbarItems=[],this.config={},this.changeToolbarState=Zv((function(){n.toolbarItems.forEach((function(e){e.changeMenuState()}))}),200),this.config=t;var r=Mp(e);if(0===r.length)throw new Error("Cannot find toolbar DOM by selector '"+e+"'");this.$box=r;var o=this.$toolbar;o.on("mousedown",(function(e){return e.preventDefault()}),{passive:!1}),r.append(o),ZB((function(){n.registerItems(),n.changeToolbarState(),n.getEditorInstance().on("change",n.changeToolbarState)}))}return e.prototype.getMenus=function(){return this.menus},e.prototype.getConfig=function(){return this.config},e.prototype.registerItems=function(){var e=this,t="",n=this.$toolbar,r=this.config,o=r.toolbarKeys,i=void 0===o?[]:o,a=r.insertKeys,u=void 0===a?{index:0,keys:[]}:a,s=r.excludeKeys,l=void 0===s?[]:s,c=Jv(i);u.keys.length>0&&("string"==typeof u.keys&&(u.keys=[u.keys]),u.keys.forEach((function(e,t){c.splice(u.index+t,0,e)})));var f=c.filter((function(e){if("string"==typeof e){if(l.includes(e))return!1}else if(l.includes(e.key))return!1;return!0})),d=f.length;f.forEach((function(r,o){if("|"===r){if(0===o)return;if(o+1===d)return;if("|"===t)return;var i=g_();return n.append(i),void(t=r)}if("string"==typeof r)return e.registerSingleItem(r,e),void(t=r);e.registerGroup(r),t="group"}))},e.prototype.registerGroup=function(e){var t=this,n=this.$toolbar,r=function(e){return new B_(e)}(e),o=e.menuKeys,i=void 0===o?[]:o,a=this.config.excludeKeys,u=void 0===a?[]:a;i.forEach((function(e){u.includes(e)||t.registerSingleItem(e,r)})),n.append(r.$elem)},e.prototype.registerSingleItem=function(e,t){var n=this.getEditorInstance(),r=t instanceof B_,o=this.menus,i=o[e];if(null==i){var a=nk[e];if(null==a)throw new Error("Not found menu item factory by key '"+e+"'");if("function"!=typeof a)throw new Error("Menu item factory (key='"+e+"') is not a function");i=a(),o[e]=i}else console.warn("Duplicated toolbar menu key '"+e+"'\néå¤æ³¨åäºèåæ  menu '"+e+"'");var u=__(e,i,r);this.toolbarItems.push(u),fO.set(u,n),r?t.appendBarItem(u):t.$toolbar.append(u.$elem)},e.prototype.getEditorInstance=function(){var e=uO.get(this);if(null==e)throw new Error("Can not get editor instance");return e},e.prototype.destroy=function(){this.$toolbar.remove(),this.menus={},this.toolbarItems=[]},e}();var H_=VE.EXISTS,V_=bE.f,U_=Function.prototype,W_=mw(U_.toString),G_=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,q_=mw(G_.exec);function K_(e){var t=e.server,n=void 0===t?"":t,r=e.fieldName,o=void 0===r?"":r,i=e.maxFileSize,a=void 0===i?10485760:i,u=e.maxNumberOfFiles,s=void 0===u?100:u,l=e.meta,c=void 0===l?{}:l,f=e.metaWithUrl,d=void 0!==f&&f,p=e.headers,h=void 0===p?{}:p,g=e.withCredentials,v=void 0!==g&&g,y=e.timeout,m=void 0===y?1e4:y,b=e.onBeforeUpload,w=void 0===b?function(e){return e}:b,E=e.onSuccess,D=void 0===E?function(e,t){}:E,S=e.onError,x=void 0===S?function(e,t,n){console.error(e.name+" upload error",t,n)}:S,C=e.onProgress,A=void 0===C?function(e){}:C;if(!n)throw new Error("Cannot get upload server address\næ²¡æéç½®ä¸ä¼ å°å");if(!o)throw new Error("Cannot get fieldName\næ²¡æéç½® fieldName");var O=n;d&&(O=function(e,t){var n=aA(e.split("#"),2),r=n[0],o=n[1],i=[];Lh(t,(function(e,t){i.push(t+"="+e)}));var a=i.join("&");return r=r.indexOf("?")>0?r+"&"+a:r+"?"+a,o?r+"#"+o:r}(O,c));var k=new _m({onBeforeUpload:w,restrictions:{maxFileSize:a,maxNumberOfFiles:s},meta:c}).use(rw,{endpoint:O,headers:h,formData:!0,fieldName:o,bundle:!0,withCredentials:v,timeout:m});return k.on("upload-success",(function(e,t){var n=t.body,r=void 0===n?{}:n;try{D(e,r)}catch(e){console.error("wangEditor upload file - onSuccess error",e)}k.removeFile(e.id)})),k.on("progress",(function(e){e<1||A(e)})),k.on("upload-error",(function(e,t,n){try{x(e,t,n)}catch(e){console.error("wangEditor upload file - onError error",e)}k.removeFile(e.id)})),k.on("restriction-failed",(function(e,t){try{x(e,t)}catch(e){console.error("wangEditor upload file - onError error",e)}k.removeFile(e.id)})),k}function Y_(e){return Y_="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Y_(e)}function X_(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Z_(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?Object(arguments[t]):{},r=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&r.push.apply(r,Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.forEach((function(t){X_(e,t,n[t])}))}return e}function J_(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function Q_(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function eP(e,t,n){return t&&Q_(e.prototype,t),n&&Q_(e,n),e}function tP(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function nP(e,t){if(t&&("object"===Y_(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return tP(e)}function rP(e){return rP=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},rP(e)}function oP(e,t){return oP=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},oP(e,t)}function iP(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&oP(e,t)}Kw&&!H_&&V_(U_,"name",{configurable:!0,get:function(){try{return q_(G_,W_(this))[1]}catch(e){return""}}});var aP={type:"logger",log:function(e){this.output("log",e)},warn:function(e){this.output("warn",e)},error:function(e){this.output("error",e)},output:function(e,t){console&&console[e]&&console[e].apply(console,t)}},uP=new(function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};J_(this,e),this.init(t,n)}return eP(e,[{key:"init",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=t.prefix||"i18next:",this.logger=e||aP,this.options=t,this.debug=t.debug}},{key:"setDebug",value:function(e){this.debug=e}},{key:"log",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"log","",!0)}},{key:"warn",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","",!0)}},{key:"error",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"error","")}},{key:"deprecate",value:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.forward(t,"warn","WARNING DEPRECATED: ",!0)}},{key:"forward",value:function(e,t,n,r){return r&&!this.debug?null:("string"==typeof e[0]&&(e[0]="".concat(n).concat(this.prefix," ").concat(e[0])),this.logger[t](e))}},{key:"create",value:function(t){return new e(this.logger,Z_({},{prefix:"".concat(this.prefix,":").concat(t,":")},this.options))}}]),e}()),sP=function(){function e(){J_(this,e),this.observers={}}return eP(e,[{key:"on",value:function(e,t){var n=this;return e.split(" ").forEach((function(e){n.observers[e]=n.observers[e]||[],n.observers[e].push(t)})),this}},{key:"off",value:function(e,t){this.observers[e]&&(t?this.observers[e]=this.observers[e].filter((function(e){return e!==t})):delete this.observers[e])}},{key:"emit",value:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];if(this.observers[e]){var o=[].concat(this.observers[e]);o.forEach((function(e){e.apply(void 0,n)}))}if(this.observers["*"]){var i=[].concat(this.observers["*"]);i.forEach((function(t){t.apply(t,[e].concat(n))}))}}}]),e}();function lP(){var e,t,n=new Promise((function(n,r){e=n,t=r}));return n.resolve=e,n.reject=t,n}function cP(e){return null==e?"":""+e}function fP(e,t,n){e.forEach((function(e){t[e]&&(n[e]=t[e])}))}function dP(e,t,n){function r(e){return e&&e.indexOf("###")>-1?e.replace(/###/g,"."):e}function o(){return!e||"string"==typeof e}for(var i="string"!=typeof t?[].concat(t):t.split(".");i.length>1;){if(o())return{};var a=r(i.shift());!e[a]&&n&&(e[a]=new n),e=Object.prototype.hasOwnProperty.call(e,a)?e[a]:{}}return o()?{}:{obj:e,k:r(i.shift())}}function pP(e,t,n){var r=dP(e,t,Object);r.obj[r.k]=n}function hP(e,t){var n=dP(e,t),r=n.obj,o=n.k;if(r)return r[o]}function gP(e,t,n){var r=hP(e,n);return void 0!==r?r:hP(t,n)}function vP(e,t,n){for(var r in t)"__proto__"!==r&&"constructor"!==r&&(r in e?"string"==typeof e[r]||e[r]instanceof String||"string"==typeof t[r]||t[r]instanceof String?n&&(e[r]=t[r]):vP(e[r],t[r],n):e[r]=t[r]);return e}function yP(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}var mP={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};function bP(e){return"string"==typeof e?e.replace(/[&<>"'\/]/g,(function(e){return mP[e]})):e}var wP="undefined"!=typeof window&&window.navigator&&window.navigator.userAgent&&window.navigator.userAgent.indexOf("MSIE")>-1;function EP(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";if(e){if(e[t])return e[t];for(var r=t.split(n),o=e,i=0;i<r.length;++i){if(!o)return;if("string"==typeof o[r[i]]&&i+1<r.length)return;if(void 0===o[r[i]]){for(var a=2,u=r.slice(i,i+a).join(n),s=o[u];void 0===s&&r.length>i+a;)a++,s=o[u=r.slice(i,i+a).join(n)];if(void 0===s)return;if("string"==typeof s)return s;if(u&&"string"==typeof s[u])return s[u];var l=r.slice(i+a).join(n);return l?EP(s,l,n):void 0}o=o[r[i]]}return o}}var DP=function(e){function t(e){var n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};return J_(this,t),n=nP(this,rP(t).call(this)),wP&&sP.call(tP(n)),n.data=e||{},n.options=r,void 0===n.options.keySeparator&&(n.options.keySeparator="."),void 0===n.options.ignoreJSONStructure&&(n.options.ignoreJSONStructure=!0),n}return iP(t,sP),eP(t,[{key:"addNamespaces",value:function(e){this.options.ns.indexOf(e)<0&&this.options.ns.push(e)}},{key:"removeNamespaces",value:function(e){var t=this.options.ns.indexOf(e);t>-1&&this.options.ns.splice(t,1)}},{key:"getResource",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=void 0!==r.keySeparator?r.keySeparator:this.options.keySeparator,i=void 0!==r.ignoreJSONStructure?r.ignoreJSONStructure:this.options.ignoreJSONStructure,a=[e,t];n&&"string"!=typeof n&&(a=a.concat(n)),n&&"string"==typeof n&&(a=a.concat(o?n.split(o):n)),e.indexOf(".")>-1&&(a=e.split("."));var u=hP(this.data,a);return u||!i||"string"!=typeof n?u:EP(this.data&&this.data[e]&&this.data[e][t],n,o)}},{key:"addResource",value:function(e,t,n,r){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1},i=this.options.keySeparator;void 0===i&&(i=".");var a=[e,t];n&&(a=a.concat(i?n.split(i):n)),e.indexOf(".")>-1&&(r=t,t=(a=e.split("."))[1]),this.addNamespaces(t),pP(this.data,a,r),o.silent||this.emit("added",e,t,n,r)}},{key:"addResources",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{silent:!1};for(var o in n)"string"!=typeof n[o]&&"[object Array]"!==Object.prototype.toString.apply(n[o])||this.addResource(e,t,o,n[o],{silent:!0});r.silent||this.emit("added",e,t,n)}},{key:"addResourceBundle",value:function(e,t,n,r,o){var i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{silent:!1},a=[e,t];e.indexOf(".")>-1&&(r=n,n=t,t=(a=e.split("."))[1]),this.addNamespaces(t);var u=hP(this.data,a)||{};r?vP(u,n,o):u=Z_({},u,n),pP(this.data,a,u),i.silent||this.emit("added",e,t,n)}},{key:"removeResourceBundle",value:function(e,t){this.hasResourceBundle(e,t)&&delete this.data[e][t],this.removeNamespaces(t),this.emit("removed",e,t)}},{key:"hasResourceBundle",value:function(e,t){return void 0!==this.getResource(e,t)}},{key:"getResourceBundle",value:function(e,t){return t||(t=this.options.defaultNS),"v1"===this.options.compatibilityAPI?Z_({},{},this.getResource(e,t)):this.getResource(e,t)}},{key:"getDataByLanguage",value:function(e){return this.data[e]}},{key:"toJSON",value:function(){return this.data}}]),t}(),SP={processors:{},addPostProcessor:function(e){this.processors[e.name]=e},handle:function(e,t,n,r,o){var i=this;return e.forEach((function(e){i.processors[e]&&(t=i.processors[e].process(t,n,r,o))})),t}},xP={},CP=function(e){function t(e){var n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return J_(this,t),n=nP(this,rP(t).call(this)),wP&&sP.call(tP(n)),fP(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],e,tP(n)),n.options=r,void 0===n.options.keySeparator&&(n.options.keySeparator="."),n.logger=uP.create("translator"),n}return iP(t,sP),eP(t,[{key:"changeLanguage",value:function(e){e&&(this.language=e)}},{key:"exists",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}};if(null==e)return!1;var n=this.resolve(e,t);return n&&void 0!==n.res}},{key:"extractFromKey",value:function(e,t){var n=void 0!==t.nsSeparator?t.nsSeparator:this.options.nsSeparator;void 0===n&&(n=":");var r=void 0!==t.keySeparator?t.keySeparator:this.options.keySeparator,o=t.ns||this.options.defaultNS;if(n&&e.indexOf(n)>-1){var i=e.match(this.interpolator.nestingRegexp);if(i&&i.length>0)return{key:e,namespaces:o};var a=e.split(n);(n!==r||n===r&&this.options.ns.indexOf(a[0])>-1)&&(o=a.shift()),e=a.join(r)}return"string"==typeof o&&(o=[o]),{key:e,namespaces:o}}},{key:"translate",value:function(e,n,r){var o=this;if("object"!==Y_(n)&&this.options.overloadTranslationOptionHandler&&(n=this.options.overloadTranslationOptionHandler(arguments)),n||(n={}),null==e)return"";Array.isArray(e)||(e=[String(e)]);var i=void 0!==n.keySeparator?n.keySeparator:this.options.keySeparator,a=this.extractFromKey(e[e.length-1],n),u=a.key,s=a.namespaces,l=s[s.length-1],c=n.lng||this.language,f=n.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(c&&"cimode"===c.toLowerCase()){if(f){var d=n.nsSeparator||this.options.nsSeparator;return l+d+u}return u}var p=this.resolve(e,n),h=p&&p.res,g=p&&p.usedKey||u,v=p&&p.exactUsedKey||u,y=Object.prototype.toString.apply(h),m=["[object Number]","[object Function]","[object RegExp]"],b=void 0!==n.joinArrays?n.joinArrays:this.options.joinArrays,w=!this.i18nFormat||this.i18nFormat.handleAsObject,E="string"!=typeof h&&"boolean"!=typeof h&&"number"!=typeof h;if(w&&h&&E&&m.indexOf(y)<0&&("string"!=typeof b||"[object Array]"!==y)){if(!n.returnObjects&&!this.options.returnObjects)return this.options.returnedObjectHandler||this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(g,h,Z_({},n,{ns:s})):"key '".concat(u," (").concat(this.language,")' returned an object instead of string.");if(i){var D="[object Array]"===y,S=D?[]:{},x=D?v:g;for(var C in h)if(Object.prototype.hasOwnProperty.call(h,C)){var A="".concat(x).concat(i).concat(C);S[C]=this.translate(A,Z_({},n,{joinArrays:!1,ns:s})),S[C]===A&&(S[C]=h[C])}h=S}}else if(w&&"string"==typeof b&&"[object Array]"===y)(h=h.join(b))&&(h=this.extendTranslation(h,e,n,r));else{var O=!1,k=!1,B=void 0!==n.count&&"string"!=typeof n.count,F=t.hasDefaultValue(n),T=B?this.pluralResolver.getSuffix(c,n.count):"",_=n["defaultValue".concat(T)]||n.defaultValue;!this.isValidLookup(h)&&F&&(O=!0,h=_),this.isValidLookup(h)||(k=!0,h=u);var P=n.missingKeyNoValueFallbackToKey||this.options.missingKeyNoValueFallbackToKey,j=P&&k?void 0:h,N=F&&_!==h&&this.options.updateMissing;if(k||O||N){if(this.logger.log(N?"updateKey":"missingKey",c,l,u,N?_:h),i){var I=this.resolve(u,Z_({},n,{keySeparator:!1}));I&&I.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}var L=[],R=this.languageUtils.getFallbackCodes(this.options.fallbackLng,n.lng||this.language);if("fallback"===this.options.saveMissingTo&&R&&R[0])for(var M=0;M<R.length;M++)L.push(R[M]);else"all"===this.options.saveMissingTo?L=this.languageUtils.toResolveHierarchy(n.lng||this.language):L.push(n.lng||this.language);var z=function(e,t,r){o.options.missingKeyHandler?o.options.missingKeyHandler(e,l,t,N?r:j,N,n):o.backendConnector&&o.backendConnector.saveMissing&&o.backendConnector.saveMissing(e,l,t,N?r:j,N,n),o.emit("missingKey",e,l,t,h)};this.options.saveMissing&&(this.options.saveMissingPlurals&&B?L.forEach((function(e){o.pluralResolver.getSuffixes(e).forEach((function(t){z([e],u+t,n["defaultValue".concat(t)]||_)}))})):z(L,u,_))}h=this.extendTranslation(h,e,n,p,r),k&&h===u&&this.options.appendNamespaceToMissingKey&&(h="".concat(l,":").concat(u)),(k||O)&&this.options.parseMissingKeyHandler&&(h=this.options.parseMissingKeyHandler(h))}return h}},{key:"extendTranslation",value:function(e,t,n,r,o){var i=this;if(this.i18nFormat&&this.i18nFormat.parse)e=this.i18nFormat.parse(e,n,r.usedLng,r.usedNS,r.usedKey,{resolved:r});else if(!n.skipInterpolation){n.interpolation&&this.interpolator.init(Z_({},n,{interpolation:Z_({},this.options.interpolation,n.interpolation)}));var a,u=n.interpolation&&n.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;if(u){var s=e.match(this.interpolator.nestingRegexp);a=s&&s.length}var l=n.replace&&"string"!=typeof n.replace?n.replace:n;if(this.options.interpolation.defaultVariables&&(l=Z_({},this.options.interpolation.defaultVariables,l)),e=this.interpolator.interpolate(e,l,n.lng||this.language,n),u){var c=e.match(this.interpolator.nestingRegexp);a<(c&&c.length)&&(n.nest=!1)}!1!==n.nest&&(e=this.interpolator.nest(e,(function(){for(var e=arguments.length,r=new Array(e),a=0;a<e;a++)r[a]=arguments[a];return o&&o[0]===r[0]&&!n.context?(i.logger.warn("It seems you are nesting recursively key: ".concat(r[0]," in key: ").concat(t[0])),null):i.translate.apply(i,r.concat([t]))}),n)),n.interpolation&&this.interpolator.reset()}var f=n.postProcess||this.options.postProcess,d="string"==typeof f?[f]:f;return null!=e&&d&&d.length&&!1!==n.applyPostProcessor&&(e=SP.handle(d,e,t,this.options&&this.options.postProcessPassResolved?Z_({i18nResolved:r},n):n,this)),e}},{key:"resolve",value:function(e){var t,n,r,o,i,a=this,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"string"==typeof e&&(e=[e]),e.forEach((function(e){if(!a.isValidLookup(t)){var s=a.extractFromKey(e,u),l=s.key;n=l;var c=s.namespaces;a.options.fallbackNS&&(c=c.concat(a.options.fallbackNS));var f=void 0!==u.count&&"string"!=typeof u.count,d=void 0!==u.context&&("string"==typeof u.context||"number"==typeof u.context)&&""!==u.context,p=u.lngs?u.lngs:a.languageUtils.toResolveHierarchy(u.lng||a.language,u.fallbackLng);c.forEach((function(e){a.isValidLookup(t)||(i=e,!xP["".concat(p[0],"-").concat(e)]&&a.utils&&a.utils.hasLoadedNamespace&&!a.utils.hasLoadedNamespace(i)&&(xP["".concat(p[0],"-").concat(e)]=!0,a.logger.warn('key "'.concat(n,'" for languages "').concat(p.join(", "),'" won\'t get resolved as namespace "').concat(i,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),p.forEach((function(n){if(!a.isValidLookup(t)){o=n;var i,s,c=l,p=[c];for(a.i18nFormat&&a.i18nFormat.addLookupKeys?a.i18nFormat.addLookupKeys(p,l,n,e,u):(f&&(i=a.pluralResolver.getSuffix(n,u.count)),f&&d&&p.push(c+i),d&&p.push(c+="".concat(a.options.contextSeparator).concat(u.context)),f&&p.push(c+=i));s=p.pop();)a.isValidLookup(t)||(r=s,t=a.getResource(n,e,s,u))}})))}))}})),{res:t,usedKey:n,exactUsedKey:r,usedLng:o,usedNS:i}}},{key:"isValidLookup",value:function(e){return!(void 0===e||!this.options.returnNull&&null===e||!this.options.returnEmptyString&&""===e)}},{key:"getResource",value:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(e,t,n,r):this.resourceStore.getResource(e,t,n,r)}}],[{key:"hasDefaultValue",value:function(e){var t="defaultValue";for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)&&t===n.substring(0,t.length)&&void 0!==e[n])return!0;return!1}}]),t}();function AP(e){return e.charAt(0).toUpperCase()+e.slice(1)}var OP=function(){function e(t){J_(this,e),this.options=t,this.whitelist=this.options.supportedLngs||!1,this.supportedLngs=this.options.supportedLngs||!1,this.logger=uP.create("languageUtils")}return eP(e,[{key:"getScriptPartFromCode",value:function(e){if(!e||e.indexOf("-")<0)return null;var t=e.split("-");return 2===t.length?null:(t.pop(),"x"===t[t.length-1].toLowerCase()?null:this.formatLanguageCode(t.join("-")))}},{key:"getLanguagePartFromCode",value:function(e){if(!e||e.indexOf("-")<0)return e;var t=e.split("-");return this.formatLanguageCode(t[0])}},{key:"formatLanguageCode",value:function(e){if("string"==typeof e&&e.indexOf("-")>-1){var t=["hans","hant","latn","cyrl","cans","mong","arab"],n=e.split("-");return this.options.lowerCaseLng?n=n.map((function(e){return e.toLowerCase()})):2===n.length?(n[0]=n[0].toLowerCase(),n[1]=n[1].toUpperCase(),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=AP(n[1].toLowerCase()))):3===n.length&&(n[0]=n[0].toLowerCase(),2===n[1].length&&(n[1]=n[1].toUpperCase()),"sgn"!==n[0]&&2===n[2].length&&(n[2]=n[2].toUpperCase()),t.indexOf(n[1].toLowerCase())>-1&&(n[1]=AP(n[1].toLowerCase())),t.indexOf(n[2].toLowerCase())>-1&&(n[2]=AP(n[2].toLowerCase()))),n.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?e.toLowerCase():e}},{key:"isWhitelisted",value:function(e){return this.logger.deprecate("languageUtils.isWhitelisted",'function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it\'s usage asap.'),this.isSupportedCode(e)}},{key:"isSupportedCode",value:function(e){return("languageOnly"===this.options.load||this.options.nonExplicitSupportedLngs)&&(e=this.getLanguagePartFromCode(e)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(e)>-1}},{key:"getBestMatchFromCodes",value:function(e){var t,n=this;return e?(e.forEach((function(e){if(!t){var r=n.formatLanguageCode(e);n.options.supportedLngs&&!n.isSupportedCode(r)||(t=r)}})),!t&&this.options.supportedLngs&&e.forEach((function(e){if(!t){var r=n.getLanguagePartFromCode(e);if(n.isSupportedCode(r))return t=r;t=n.options.supportedLngs.find((function(e){if(0===e.indexOf(r))return e}))}})),t||(t=this.getFallbackCodes(this.options.fallbackLng)[0]),t):null}},{key:"getFallbackCodes",value:function(e,t){if(!e)return[];if("function"==typeof e&&(e=e(t)),"string"==typeof e&&(e=[e]),"[object Array]"===Object.prototype.toString.apply(e))return e;if(!t)return e.default||[];var n=e[t];return n||(n=e[this.getScriptPartFromCode(t)]),n||(n=e[this.formatLanguageCode(t)]),n||(n=e[this.getLanguagePartFromCode(t)]),n||(n=e.default),n||[]}},{key:"toResolveHierarchy",value:function(e,t){var n=this,r=this.getFallbackCodes(t||this.options.fallbackLng||[],e),o=[],i=function(e){e&&(n.isSupportedCode(e)?o.push(e):n.logger.warn("rejecting language code not found in supportedLngs: ".concat(e)))};return"string"==typeof e&&e.indexOf("-")>-1?("languageOnly"!==this.options.load&&i(this.formatLanguageCode(e)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&i(this.getScriptPartFromCode(e)),"currentOnly"!==this.options.load&&i(this.getLanguagePartFromCode(e))):"string"==typeof e&&i(this.formatLanguageCode(e)),r.forEach((function(e){o.indexOf(e)<0&&i(n.formatLanguageCode(e))})),o}}]),e}(),kP=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kk","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],BP={1:function(e){return Number(e>1)},2:function(e){return Number(1!=e)},3:function(e){return 0},4:function(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},5:function(e){return Number(0==e?0:1==e?1:2==e?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5)},6:function(e){return Number(1==e?0:e>=2&&e<=4?1:2)},7:function(e){return Number(1==e?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},8:function(e){return Number(1==e?0:2==e?1:8!=e&&11!=e?2:3)},9:function(e){return Number(e>=2)},10:function(e){return Number(1==e?0:2==e?1:e<7?2:e<11?3:4)},11:function(e){return Number(1==e||11==e?0:2==e||12==e?1:e>2&&e<20?2:3)},12:function(e){return Number(e%10!=1||e%100==11)},13:function(e){return Number(0!==e)},14:function(e){return Number(1==e?0:2==e?1:3==e?2:3)},15:function(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2)},16:function(e){return Number(e%10==1&&e%100!=11?0:0!==e?1:2)},17:function(e){return Number(1==e||e%10==1&&e%100!=11?0:1)},18:function(e){return Number(0==e?0:1==e?1:2)},19:function(e){return Number(1==e?0:0==e||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3)},20:function(e){return Number(1==e?0:0==e||e%100>0&&e%100<20?1:2)},21:function(e){return Number(e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0)},22:function(e){return Number(1==e?0:2==e?1:(e<0||e>10)&&e%10==0?2:3)}};function FP(){var e={};return kP.forEach((function(t){t.lngs.forEach((function(n){e[n]={numbers:t.nr,plurals:BP[t.fc]}}))})),e}var TP=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};J_(this,e),this.languageUtils=t,this.options=n,this.logger=uP.create("pluralResolver"),this.rules=FP()}return eP(e,[{key:"addRule",value:function(e,t){this.rules[e]=t}},{key:"getRule",value:function(e){return this.rules[e]||this.rules[this.languageUtils.getLanguagePartFromCode(e)]}},{key:"needsPlural",value:function(e){var t=this.getRule(e);return t&&t.numbers.length>1}},{key:"getPluralFormsOfKey",value:function(e,t){return this.getSuffixes(e).map((function(e){return t+e}))}},{key:"getSuffixes",value:function(e){var t=this,n=this.getRule(e);return n?n.numbers.map((function(n){return t.getSuffix(e,n)})):[]}},{key:"getSuffix",value:function(e,t){var n=this,r=this.getRule(e);if(r){var o=r.noAbs?r.plurals(t):r.plurals(Math.abs(t)),i=r.numbers[o];this.options.simplifyPluralSuffix&&2===r.numbers.length&&1===r.numbers[0]&&(2===i?i="plural":1===i&&(i=""));var a=function(){return n.options.prepend&&i.toString()?n.options.prepend+i.toString():i.toString()};return"v1"===this.options.compatibilityJSON?1===i?"":"number"==typeof i?"_plural_".concat(i.toString()):a():"v2"===this.options.compatibilityJSON||this.options.simplifyPluralSuffix&&2===r.numbers.length&&1===r.numbers[0]?a():this.options.prepend&&o.toString()?this.options.prepend+o.toString():o.toString()}return this.logger.warn("no plural rule found for: ".concat(e)),""}}]),e}(),_P=function(){function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};J_(this,e),this.logger=uP.create("interpolator"),this.options=t,this.format=t.interpolation&&t.interpolation.format||function(e){return e},this.init(t)}return eP(e,[{key:"init",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.interpolation||(e.interpolation={escapeValue:!0});var t=e.interpolation;this.escape=void 0!==t.escape?t.escape:bP,this.escapeValue=void 0===t.escapeValue||t.escapeValue,this.useRawValueToEscape=void 0!==t.useRawValueToEscape&&t.useRawValueToEscape,this.prefix=t.prefix?yP(t.prefix):t.prefixEscaped||"{{",this.suffix=t.suffix?yP(t.suffix):t.suffixEscaped||"}}",this.formatSeparator=t.formatSeparator?t.formatSeparator:t.formatSeparator||",",this.unescapePrefix=t.unescapeSuffix?"":t.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":t.unescapeSuffix||"",this.nestingPrefix=t.nestingPrefix?yP(t.nestingPrefix):t.nestingPrefixEscaped||yP("$t("),this.nestingSuffix=t.nestingSuffix?yP(t.nestingSuffix):t.nestingSuffixEscaped||yP(")"),this.nestingOptionsSeparator=t.nestingOptionsSeparator?t.nestingOptionsSeparator:t.nestingOptionsSeparator||",",this.maxReplaces=t.maxReplaces?t.maxReplaces:1e3,this.alwaysFormat=void 0!==t.alwaysFormat&&t.alwaysFormat,this.resetRegExp()}},{key:"reset",value:function(){this.options&&this.init(this.options)}},{key:"resetRegExp",value:function(){var e="".concat(this.prefix,"(.+?)").concat(this.suffix);this.regexp=new RegExp(e,"g");var t="".concat(this.prefix).concat(this.unescapePrefix,"(.+?)").concat(this.unescapeSuffix).concat(this.suffix);this.regexpUnescape=new RegExp(t,"g");var n="".concat(this.nestingPrefix,"(.+?)").concat(this.nestingSuffix);this.nestingRegexp=new RegExp(n,"g")}},{key:"interpolate",value:function(e,t,n,r){var o,i,a,u=this,s=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{};function l(e){return e.replace(/\$/g,"$$$$")}var c=function(e){if(e.indexOf(u.formatSeparator)<0){var o=gP(t,s,e);return u.alwaysFormat?u.format(o,void 0,n,Z_({},r,t,{interpolationkey:e})):o}var i=e.split(u.formatSeparator),a=i.shift().trim(),l=i.join(u.formatSeparator).trim();return u.format(gP(t,s,a),l,n,Z_({},r,t,{interpolationkey:a}))};this.resetRegExp();var f=r&&r.missingInterpolationHandler||this.options.missingInterpolationHandler,d=r&&r.interpolation&&r.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables,p=[{regex:this.regexpUnescape,safeValue:function(e){return l(e)}},{regex:this.regexp,safeValue:function(e){return u.escapeValue?l(u.escape(e)):l(e)}}];return p.forEach((function(t){for(a=0;o=t.regex.exec(e);){if(void 0===(i=c(o[1].trim())))if("function"==typeof f){var n=f(e,o,r);i="string"==typeof n?n:""}else{if(d){i=o[0];continue}u.logger.warn("missed to pass in variable ".concat(o[1]," for interpolating ").concat(e)),i=""}else"string"==typeof i||u.useRawValueToEscape||(i=cP(i));var s=t.safeValue(i);if(e=e.replace(o[0],s),d?(t.regex.lastIndex+=s.length,t.regex.lastIndex-=o[0].length):t.regex.lastIndex=0,++a>=u.maxReplaces)break}})),e}},{key:"nest",value:function(e,t){var n,r,o=this,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=Z_({},i);function u(e,t){var n=this.nestingOptionsSeparator;if(e.indexOf(n)<0)return e;var r=e.split(new RegExp("".concat(n,"[ ]*{"))),o="{".concat(r[1]);e=r[0],o=(o=this.interpolate(o,a)).replace(/'/g,'"');try{a=JSON.parse(o),t&&(a=Z_({},t,a))}catch(t){return this.logger.warn("failed parsing options string in nesting for key ".concat(e),t),"".concat(e).concat(n).concat(o)}return delete a.defaultValue,e}for(a.applyPostProcessor=!1,delete a.defaultValue;n=this.nestingRegexp.exec(e);){var s=[],l=!1;if(-1!==n[0].indexOf(this.formatSeparator)&&!/{.*}/.test(n[1])){var c=n[1].split(this.formatSeparator).map((function(e){return e.trim()}));n[1]=c.shift(),s=c,l=!0}if((r=t(u.call(this,n[1].trim(),a),a))&&n[0]===e&&"string"!=typeof r)return r;"string"!=typeof r&&(r=cP(r)),r||(this.logger.warn("missed to resolve ".concat(n[1]," for nesting ").concat(e)),r=""),l&&(r=s.reduce((function(e,t){return o.format(e,t,i.lng,Z_({},i,{interpolationkey:n[1].trim()}))}),r.trim())),e=e.replace(n[0],r),this.regexp.lastIndex=0}return e}}]),e}(),PP=function(e){function t(e,n,r){var o,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return J_(this,t),o=nP(this,rP(t).call(this)),wP&&sP.call(tP(o)),o.backend=e,o.store=n,o.services=r,o.languageUtils=r.languageUtils,o.options=i,o.logger=uP.create("backendConnector"),o.state={},o.queue=[],o.backend&&o.backend.init&&o.backend.init(r,i.backend,i),o}return iP(t,sP),eP(t,[{key:"queueLoad",value:function(e,t,n,r){var o=this,i=[],a=[],u=[],s=[];return e.forEach((function(e){var r=!0;t.forEach((function(t){var u="".concat(e,"|").concat(t);!n.reload&&o.store.hasResourceBundle(e,t)?o.state[u]=2:o.state[u]<0||(1===o.state[u]?a.indexOf(u)<0&&a.push(u):(o.state[u]=1,r=!1,a.indexOf(u)<0&&a.push(u),i.indexOf(u)<0&&i.push(u),s.indexOf(t)<0&&s.push(t)))})),r||u.push(e)})),(i.length||a.length)&&this.queue.push({pending:a,loaded:{},errors:[],callback:r}),{toLoad:i,pending:a,toLoadLanguages:u,toLoadNamespaces:s}}},{key:"loaded",value:function(e,t,n){var r=e.split("|"),o=r[0],i=r[1];t&&this.emit("failedLoading",o,i,t),n&&this.store.addResourceBundle(o,i,n),this.state[e]=t?-1:2;var a={};this.queue.forEach((function(n){!function(e,t,n,r){var o=dP(e,t,Object),i=o.obj,a=o.k;i[a]=i[a]||[],i[a].push(n)}(n.loaded,[o],i),function(e,t){for(var n=e.indexOf(t);-1!==n;)e.splice(n,1),n=e.indexOf(t)}(n.pending,e),t&&n.errors.push(t),0!==n.pending.length||n.done||(Object.keys(n.loaded).forEach((function(e){a[e]||(a[e]=[]),n.loaded[e].length&&n.loaded[e].forEach((function(t){a[e].indexOf(t)<0&&a[e].push(t)}))})),n.done=!0,n.errors.length?n.callback(n.errors):n.callback())})),this.emit("loaded",a),this.queue=this.queue.filter((function(e){return!e.done}))}},{key:"read",value:function(e,t,n){var r=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:350,a=arguments.length>5?arguments[5]:void 0;return e.length?this.backend[n](e,t,(function(u,s){u&&s&&o<5?setTimeout((function(){r.read.call(r,e,t,n,o+1,2*i,a)}),i):a(u,s)})):a(null,{})}},{key:"prepareLoading",value:function(e,t){var n=this,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),o&&o();"string"==typeof e&&(e=this.languageUtils.toResolveHierarchy(e)),"string"==typeof t&&(t=[t]);var i=this.queueLoad(e,t,r,o);if(!i.toLoad.length)return i.pending.length||o(),null;i.toLoad.forEach((function(e){n.loadOne(e)}))}},{key:"load",value:function(e,t,n){this.prepareLoading(e,t,{},n)}},{key:"reload",value:function(e,t,n){this.prepareLoading(e,t,{reload:!0},n)}},{key:"loadOne",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=e.split("|"),o=r[0],i=r[1];this.read(o,i,"read",void 0,void 0,(function(r,a){r&&t.logger.warn("".concat(n,"loading namespace ").concat(i," for language ").concat(o," failed"),r),!r&&a&&t.logger.log("".concat(n,"loaded namespace ").concat(i," for language ").concat(o),a),t.loaded(e,r,a)}))}},{key:"saveMissing",value:function(e,t,n,r,o){var i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(t)?this.logger.warn('did not save key "'.concat(n,'" as the namespace "').concat(t,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"):null!=n&&""!==n&&(this.backend&&this.backend.create&&this.backend.create(e,t,n,r,null,Z_({},i,{isUpdate:o})),e&&e[0]&&this.store.addResource(e[0],t,n,r))}}]),t}();function jP(){return{debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,whitelist:!1,nonExplicitWhitelist:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!0,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:function(e){var t={};if("object"===Y_(e[1])&&(t=e[1]),"string"==typeof e[1]&&(t.defaultValue=e[1]),"string"==typeof e[2]&&(t.tDescription=e[2]),"object"===Y_(e[2])||"object"===Y_(e[3])){var n=e[3]||e[2];Object.keys(n).forEach((function(e){t[e]=n[e]}))}return t},interpolation:{escapeValue:!0,format:function(e,t,n,r){return e},prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!1}}}function NP(e){return"string"==typeof e.ns&&(e.ns=[e.ns]),"string"==typeof e.fallbackLng&&(e.fallbackLng=[e.fallbackLng]),"string"==typeof e.fallbackNS&&(e.fallbackNS=[e.fallbackNS]),e.whitelist&&(e.whitelist&&e.whitelist.indexOf("cimode")<0&&(e.whitelist=e.whitelist.concat(["cimode"])),e.supportedLngs=e.whitelist),e.nonExplicitWhitelist&&(e.nonExplicitSupportedLngs=e.nonExplicitWhitelist),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e}function IP(){}var LP=function(e){function t(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0;if(J_(this,t),e=nP(this,rP(t).call(this)),wP&&sP.call(tP(e)),e.options=NP(n),e.services={},e.logger=uP,e.modules={external:[]},r&&!e.isInitialized&&!n.isClone){if(!e.options.initImmediate)return e.init(n,r),nP(e,tP(e));setTimeout((function(){e.init(n,r)}),0)}return e}return iP(t,sP),eP(t,[{key:"init",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;function r(e){return e?"function"==typeof e?new e:e:null}if("function"==typeof t&&(n=t,t={}),t.whitelist&&!t.supportedLngs&&this.logger.deprecate("whitelist",'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.'),t.nonExplicitWhitelist&&!t.nonExplicitSupportedLngs&&this.logger.deprecate("whitelist",'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.'),this.options=Z_({},jP(),this.options,NP(t)),this.format=this.options.interpolation.format,n||(n=IP),!this.options.isClone){this.modules.logger?uP.init(r(this.modules.logger),this.options):uP.init(null,this.options);var o=new OP(this.options);this.store=new DP(this.options.resources,this.options);var i=this.services;i.logger=uP,i.resourceStore=this.store,i.languageUtils=o,i.pluralResolver=new TP(o,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),i.interpolator=new _P(this.options),i.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},i.backendConnector=new PP(r(this.modules.backend),i.resourceStore,i,this.options),i.backendConnector.on("*",(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.emit.apply(e,[t].concat(r))})),this.modules.languageDetector&&(i.languageDetector=r(this.modules.languageDetector),i.languageDetector.init(i,this.options.detection,this.options)),this.modules.i18nFormat&&(i.i18nFormat=r(this.modules.i18nFormat),i.i18nFormat.init&&i.i18nFormat.init(this)),this.translator=new CP(this.services,this.options),this.translator.on("*",(function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.emit.apply(e,[t].concat(r))})),this.modules.external.forEach((function(t){t.init&&t.init(e)}))}if(this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){var a=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);a.length>0&&"dev"!==a[0]&&(this.options.lng=a[0])}this.services.languageDetector||this.options.lng||this.logger.warn("init: no languageDetector is used and no lng is defined");var u=["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"];u.forEach((function(t){e[t]=function(){var n;return(n=e.store)[t].apply(n,arguments)}}));var s=["addResource","addResources","addResourceBundle","removeResourceBundle"];s.forEach((function(t){e[t]=function(){var n;return(n=e.store)[t].apply(n,arguments),e}}));var l=lP(),c=function(){var t=function(t,r){e.isInitialized&&!e.initializedStoreOnce&&e.logger.warn("init: i18next is already initialized. You should call init just once!"),e.isInitialized=!0,e.options.isClone||e.logger.log("initialized",e.options),e.emit("initialized",e.options),l.resolve(r),n(t,r)};if(e.languages&&"v1"!==e.options.compatibilityAPI&&!e.isInitialized)return t(null,e.t.bind(e));e.changeLanguage(e.options.lng,t)};return this.options.resources||!this.options.initImmediate?c():setTimeout(c,0),l}},{key:"loadResources",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:IP,r=n,o="string"==typeof e?e:this.language;if("function"==typeof e&&(r=e),!this.options.resources||this.options.partialBundledLanguages){if(o&&"cimode"===o.toLowerCase())return r();var i=[],a=function(e){e&&t.services.languageUtils.toResolveHierarchy(e).forEach((function(e){i.indexOf(e)<0&&i.push(e)}))};if(o)a(o);else{var u=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);u.forEach((function(e){return a(e)}))}this.options.preload&&this.options.preload.forEach((function(e){return a(e)})),this.services.backendConnector.load(i,this.options.ns,r)}else r(null)}},{key:"reloadResources",value:function(e,t,n){var r=lP();return e||(e=this.languages),t||(t=this.options.ns),n||(n=IP),this.services.backendConnector.reload(e,t,(function(e){r.resolve(),n(e)})),r}},{key:"use",value:function(e){if(!e)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!e.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return"backend"===e.type&&(this.modules.backend=e),("logger"===e.type||e.log&&e.warn&&e.error)&&(this.modules.logger=e),"languageDetector"===e.type&&(this.modules.languageDetector=e),"i18nFormat"===e.type&&(this.modules.i18nFormat=e),"postProcessor"===e.type&&SP.addPostProcessor(e),"3rdParty"===e.type&&this.modules.external.push(e),this}},{key:"changeLanguage",value:function(e,t){var n=this;this.isLanguageChangingTo=e;var r=lP();this.emit("languageChanging",e);var o=function(o){e||o||!n.services.languageDetector||(o=[]);var i="string"==typeof o?o:n.services.languageUtils.getBestMatchFromCodes(o);i&&(n.language||(n.language=i,n.languages=n.services.languageUtils.toResolveHierarchy(i)),n.translator.language||n.translator.changeLanguage(i),n.services.languageDetector&&n.services.languageDetector.cacheUserLanguage(i)),n.loadResources(i,(function(e){!function(e,o){o?(n.language=o,n.languages=n.services.languageUtils.toResolveHierarchy(o),n.translator.changeLanguage(o),n.isLanguageChangingTo=void 0,n.emit("languageChanged",o),n.logger.log("languageChanged",o)):n.isLanguageChangingTo=void 0,r.resolve((function(){return n.t.apply(n,arguments)})),t&&t(e,(function(){return n.t.apply(n,arguments)}))}(e,i)}))};return e||!this.services.languageDetector||this.services.languageDetector.async?!e&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect(o):o(e):o(this.services.languageDetector.detect()),r}},{key:"getFixedT",value:function(e,t,n){var r=this,o=function e(t,o){var i;if("object"!==Y_(o)){for(var a=arguments.length,u=new Array(a>2?a-2:0),s=2;s<a;s++)u[s-2]=arguments[s];i=r.options.overloadTranslationOptionHandler([t,o].concat(u))}else i=Z_({},o);i.lng=i.lng||e.lng,i.lngs=i.lngs||e.lngs,i.ns=i.ns||e.ns;var l=r.options.keySeparator||".",c=n?"".concat(n).concat(l).concat(t):t;return r.t(c,i)};return"string"==typeof e?o.lng=e:o.lngs=e,o.ns=t,o.keyPrefix=n,o}},{key:"t",value:function(){var e;return this.translator&&(e=this.translator).translate.apply(e,arguments)}},{key:"exists",value:function(){var e;return this.translator&&(e=this.translator).exists.apply(e,arguments)}},{key:"setDefaultNamespace",value:function(e){this.options.defaultNS=e}},{key:"hasLoadedNamespace",value:function(e){var t=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;var r=this.languages[0],o=!!this.options&&this.options.fallbackLng,i=this.languages[this.languages.length-1];if("cimode"===r.toLowerCase())return!0;var a=function(e,n){var r=t.services.backendConnector.state["".concat(e,"|").concat(n)];return-1===r||2===r};if(n.precheck){var u=n.precheck(this,a);if(void 0!==u)return u}return!!this.hasResourceBundle(r,e)||!this.services.backendConnector.backend||!(!a(r,e)||o&&!a(i,e))}},{key:"loadNamespaces",value:function(e,t){var n=this,r=lP();return this.options.ns?("string"==typeof e&&(e=[e]),e.forEach((function(e){n.options.ns.indexOf(e)<0&&n.options.ns.push(e)})),this.loadResources((function(e){r.resolve(),t&&t(e)})),r):(t&&t(),Promise.resolve())}},{key:"loadLanguages",value:function(e,t){var n=lP();"string"==typeof e&&(e=[e]);var r=this.options.preload||[],o=e.filter((function(e){return r.indexOf(e)<0}));return o.length?(this.options.preload=r.concat(o),this.loadResources((function(e){n.resolve(),t&&t(e)})),n):(t&&t(),Promise.resolve())}},{key:"dir",value:function(e){return e||(e=this.languages&&this.languages.length>0?this.languages[0]:this.language),e?["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e))>=0?"rtl":"ltr":"rtl"}},{key:"createInstance",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;return new t(e,n)}},{key:"cloneInstance",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:IP,o=Z_({},this.options,n,{isClone:!0}),i=new t(o),a=["store","services","language"];return a.forEach((function(t){i[t]=e[t]})),i.services=Z_({},this.services),i.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},i.translator=new CP(i.services,i.options),i.translator.on("*",(function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];i.emit.apply(i,[e].concat(n))})),i.init(o,r),i.translator.options=i.options,i.translator.backendConnector.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},i}},{key:"toJSON",value:function(){return{options:this.options,store:this.store,language:this.language,languages:this.languages}}}]),t}(),RP=new LP;function MP(e,t){RP.addResourceBundle(e,"translation",t,!0,!0)}function zP(e){RP.changeLanguage(e)}function $P(e){return RP.getResourceBundle(e,"translation")}RP.init({lng:"zh-CN",resources:{}});var HP=RP.t.bind(RP);MP("en",{editor:{more:"More",justify:"Justify",indent:"Indent",image:"Image",video:"Video"}}),MP("zh-CN",{editor:{more:"æ´å¤",justify:"å¯¹é½",indent:"ç¼©è¿",image:"å¾ç",video:"è§é¢"}});var VP=ea?{}.toString:function(){return"[object "+oa(this)+"]"};ea||Ei(Object.prototype,"toString",VP,{unsafe:!0});var UP=Array.isArray||function(e){return"Array"==Hr(e)},WP=function(){},GP=[],qP=Jr("Reflect","construct"),KP=/^\s*(?:class|function)\b/,YP=Mr(KP.exec),XP=!KP.exec(WP),ZP=function(e){if(!Yr(e))return!1;try{return qP(WP,GP,e),!0}catch(e){return!1}},JP=!qP||Ar((function(){var e;return ZP(ZP.call)||!ZP(Object)||!ZP((function(){e=!0}))||e}))?function(e){if(!Yr(e))return!1;switch(oa(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return XP||!!YP(KP,ri(e))}:ZP,QP=Po("species"),ej=Cr.Array,tj=function(e,t){return new(function(e){var t;return UP(e)&&(t=e.constructor,(JP(t)&&(t===ej||UP(t.prototype))||Xr(t)&&null===(t=t[QP]))&&(t=void 0)),void 0===t?ej:t}(e))(0===t?0:t)},nj=Mr([].push),rj=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=Do(s),g=Wr(h),v=yu(l,c),y=Fi(g),m=0,b=f||tj,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:nj(w,d)}else switch(e){case 4:return!1;case 7:nj(w,d)}return i?-1:r||o?o:w}},oj={forEach:rj(0),map:rj(1),filter:rj(2),some:rj(3),every:rj(4),find:rj(5),findIndex:rj(6),filterReject:rj(7)}.forEach,ij=function(e,t){var n=[][e];return!!n&&Ar((function(){n.call(null,t||function(){throw 1},1)}))}("forEach"),aj=ij?[].forEach:function(e){return oj(this,e,arguments.length>1?arguments[1]:void 0)},uj=function(e){if(e&&e.forEach!==aj)try{Jo(e,"forEach",aj)}catch(t){e.forEach=aj}};for(var sj in fs)fs[sj]&&uj(Cr[sj]&&Cr[sj].prototype);uj(hs),MP("en",{common:{ok:"OK",delete:"Delete",enter:"Enter"},blockQuote:{title:"Quote"},codeBlock:{title:"Code block"},color:{color:"Font color",bgColor:"Back color",default:"Default color",clear:"Clear back color"},divider:{title:"Divider"},emotion:{title:"Emotion"},fontSize:{title:"Font size",default:"Default"},fontFamily:{title:"Font family",default:"Default"},fullScreen:{title:"Full screen"},header:{title:"Header",text:"Text"},image:{netImage:"Net image",delete:"Delete image",edit:"Edit image",viewLink:"View link",src:"Image src",desc:"Description",link:"Image link"},indent:{decrease:"Decrease",increase:"Increase"},justify:{left:"Left",right:"Right",center:"Center",justify:"Justify"},lineHeight:{title:"Line height",default:"Default"},link:{insert:"Insert link",text:"Link text",url:"Link source",unLink:"Unlink",edit:"Edit link",view:"View link"},textStyle:{bold:"Bold",clear:"Clear styles",code:"Inline code",italic:"Italic",sub:"Sub",sup:"Sup",through:"Through",underline:"Underline"},undo:{undo:"undo",redo:"Redo"},todo:{todo:"Todo"}}),MP("zh-CN",{common:{ok:"ç¡®å®",delete:"å é¤",enter:"åè½¦"},blockQuote:{title:"å¼ç¨"},codeBlock:{title:"ä»£ç å"},color:{color:"æå­é¢è²",bgColor:"èæ¯è²",default:"é»è®¤é¢è²",clear:"æ¸é¤èæ¯è²"},divider:{title:"åå²çº¿"},emotion:{title:"è¡¨æ"},fontSize:{title:"å­å·",default:"é»è®¤å­å·"},fontFamily:{title:"å­ä½",default:"é»è®¤å­ä½"},fullScreen:{title:"å¨å±"},header:{title:"æ é¢",text:"æ­£æ"},image:{netImage:"ç½ç»å¾ç",delete:"å é¤å¾ç",edit:"ç¼è¾å¾ç",viewLink:"æ¥çé¾æ¥",src:"å¾çå°å",desc:"å¾çæè¿°",link:"å¾çé¾æ¥"},indent:{decrease:"åå°ç¼©è¿",increase:"å¢å ç¼©è¿"},justify:{left:"å·¦å¯¹é½",right:"å³å¯¹é½",center:"å±ä¸­å¯¹é½",justify:"ä¸¤ç«¯å¯¹é½"},lineHeight:{title:"è¡é«",default:"é»è®¤è¡é«"},link:{insert:"æå¥é¾æ¥",text:"é¾æ¥ææ¬",url:"é¾æ¥å°å",unLink:"åæ¶é¾æ¥",edit:"ä¿®æ¹é¾æ¥",view:"æ¥çé¾æ¥"},textStyle:{bold:"ç²ä½",clear:"æ¸é¤æ ¼å¼",code:"è¡åä»£ç ",italic:"æä½",sub:"ä¸æ ",sup:"ä¸æ ",through:"å é¤çº¿",underline:"ä¸åçº¿"},undo:{undo:"æ¤é",redo:"éå"},todo:{todo:"å¾å"}});var lj={type:"paragraph",renderElem:function(e,t,n){return Pg("p",null,t)}},cj="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function fj(e){var t={exports:{}};return e(t,t.exports),t.exports}var dj,pj,hj=function(e){return e&&e.Math==Math&&e},gj=hj("object"==typeof globalThis&&globalThis)||hj("object"==typeof window&&window)||hj("object"==typeof self&&self)||hj("object"==typeof cj&&cj)||function(){return this}()||Function("return this")(),vj=function(e){try{return!!e()}catch(e){return!0}},yj=!vj((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),mj=Function.prototype.call,bj=mj.bind?mj.bind(mj):function(){return mj.apply(mj,arguments)},wj={}.propertyIsEnumerable,Ej=Object.getOwnPropertyDescriptor,Dj=Ej&&!wj.call({1:2},1)?function(e){var t=Ej(this,e);return!!t&&t.enumerable}:wj,Sj={f:Dj},xj=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},Cj=Function.prototype,Aj=Cj.bind,Oj=Cj.call,kj=Aj&&Aj.bind(Oj),Bj=Aj?function(e){return e&&kj(Oj,e)}:function(e){return e&&function(){return Oj.apply(e,arguments)}},Fj=Bj({}.toString),Tj=Bj("".slice),_j=function(e){return Tj(Fj(e),8,-1)},Pj=gj.Object,jj=Bj("".split),Nj=vj((function(){return!Pj("z").propertyIsEnumerable(0)}))?function(e){return"String"==_j(e)?jj(e,""):Pj(e)}:Pj,Ij=gj.TypeError,Lj=function(e){if(null==e)throw Ij("Can't call method on "+e);return e},Rj=function(e){return Nj(Lj(e))},Mj=function(e){return"function"==typeof e},zj=function(e){return"object"==typeof e?null!==e:Mj(e)},$j=function(e){return Mj(e)?e:void 0},Hj=function(e,t){return arguments.length<2?$j(gj[e]):gj[e]&&gj[e][t]},Vj=Bj({}.isPrototypeOf),Uj=Hj("navigator","userAgent")||"",Wj=gj.process,Gj=gj.Deno,qj=Wj&&Wj.versions||Gj&&Gj.version,Kj=qj&&qj.v8;Kj&&(pj=(dj=Kj.split("."))[0]>0&&dj[0]<4?1:+(dj[0]+dj[1])),!pj&&Uj&&(!(dj=Uj.match(/Edge\/(\d+)/))||dj[1]>=74)&&(dj=Uj.match(/Chrome\/(\d+)/))&&(pj=+dj[1]);var Yj=pj,Xj=!!Object.getOwnPropertySymbols&&!vj((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&Yj&&Yj<41})),Zj=Xj&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,Jj=gj.Object,Qj=Zj?function(e){return"symbol"==typeof e}:function(e){var t=Hj("Symbol");return Mj(t)&&Vj(t.prototype,Jj(e))},eN=gj.String,tN=function(e){try{return eN(e)}catch(e){return"Object"}},nN=gj.TypeError,rN=function(e){if(Mj(e))return e;throw nN(tN(e)+" is not a function")},oN=function(e,t){var n=e[t];return null==n?void 0:rN(n)},iN=gj.TypeError,aN=Object.defineProperty,uN=function(e,t){try{aN(gj,e,{value:t,configurable:!0,writable:!0})}catch(n){gj[e]=t}return t},sN=gj["__core-js_shared__"]||uN("__core-js_shared__",{}),lN=fj((function(e){(e.exports=function(e,t){return sN[e]||(sN[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),cN=gj.Object,fN=function(e){return cN(Lj(e))},dN=Bj({}.hasOwnProperty),pN=Object.hasOwn||function(e,t){return dN(fN(e),t)},hN=0,gN=Math.random(),vN=Bj(1..toString),yN=function(e){return"Symbol("+(void 0===e?"":e)+")_"+vN(++hN+gN,36)},mN=lN("wks"),bN=gj.Symbol,wN=bN&&bN.for,EN=Zj?bN:bN&&bN.withoutSetter||yN,DN=function(e){if(!pN(mN,e)||!Xj&&"string"!=typeof mN[e]){var t="Symbol."+e;Xj&&pN(bN,e)?mN[e]=bN[e]:mN[e]=Zj&&wN?wN(t):EN(t)}return mN[e]},SN=gj.TypeError,xN=DN("toPrimitive"),CN=function(e){var t=function(e,t){if(!zj(e)||Qj(e))return e;var n,r=oN(e,xN);if(r){if(void 0===t&&(t="default"),n=bj(r,e,t),!zj(n)||Qj(n))return n;throw SN("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&Mj(n=e.toString)&&!zj(r=bj(n,e)))return r;if(Mj(n=e.valueOf)&&!zj(r=bj(n,e)))return r;if("string"!==t&&Mj(n=e.toString)&&!zj(r=bj(n,e)))return r;throw iN("Can't convert object to primitive value")}(e,t)}(e,"string");return Qj(t)?t:t+""},AN=gj.document,ON=zj(AN)&&zj(AN.createElement),kN=function(e){return ON?AN.createElement(e):{}},BN=!yj&&!vj((function(){return 7!=Object.defineProperty(kN("div"),"a",{get:function(){return 7}}).a})),FN=Object.getOwnPropertyDescriptor,TN={f:yj?FN:function(e,t){if(e=Rj(e),t=CN(t),BN)try{return FN(e,t)}catch(e){}if(pN(e,t))return xj(!bj(Sj.f,e,t),e[t])}},_N=gj.String,PN=gj.TypeError,jN=function(e){if(zj(e))return e;throw PN(_N(e)+" is not an object")},NN=gj.TypeError,IN=Object.defineProperty,LN={f:yj?IN:function(e,t,n){if(jN(e),t=CN(t),jN(n),BN)try{return IN(e,t,n)}catch(e){}if("get"in n||"set"in n)throw NN("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},RN=yj?function(e,t,n){return LN.f(e,t,xj(1,n))}:function(e,t,n){return e[t]=n,e},MN=Bj(Function.toString);Mj(sN.inspectSource)||(sN.inspectSource=function(e){return MN(e)});var zN,$N,HN,VN=sN.inspectSource,UN=gj.WeakMap,WN=Mj(UN)&&/native code/.test(VN(UN)),GN=lN("keys"),qN=function(e){return GN[e]||(GN[e]=yN(e))},KN={},YN=gj.TypeError,XN=gj.WeakMap;if(WN||sN.state){var ZN=sN.state||(sN.state=new XN),JN=Bj(ZN.get),QN=Bj(ZN.has),eI=Bj(ZN.set);zN=function(e,t){if(QN(ZN,e))throw new YN("Object already initialized");return t.facade=e,eI(ZN,e,t),t},$N=function(e){return JN(ZN,e)||{}},HN=function(e){return QN(ZN,e)}}else{var tI=qN("state");KN[tI]=!0,zN=function(e,t){if(pN(e,tI))throw new YN("Object already initialized");return t.facade=e,RN(e,tI,t),t},$N=function(e){return pN(e,tI)?e[tI]:{}},HN=function(e){return pN(e,tI)}}var nI={set:zN,get:$N,has:HN,enforce:function(e){return HN(e)?$N(e):zN(e,{})},getterFor:function(e){return function(t){var n;if(!zj(t)||(n=$N(t)).type!==e)throw YN("Incompatible receiver, "+e+" required");return n}}},rI=Function.prototype,oI=yj&&Object.getOwnPropertyDescriptor,iI=pN(rI,"name"),aI={EXISTS:iI,PROPER:iI&&"something"===function(){}.name,CONFIGURABLE:iI&&(!yj||yj&&oI(rI,"name").configurable)},uI=fj((function(e){var t=aI.CONFIGURABLE,n=nI.get,r=nI.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;Mj(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!pN(i,"name")||t&&i.name!==f)&&RN(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==gj?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:RN(e,n,i)):l?e[n]=i:uN(n,i)})(Function.prototype,"toString",(function(){return Mj(this)&&n(this).source||VN(this)}))})),sI=Math.ceil,lI=Math.floor,cI=function(e){var t=+e;return t!=t||0===t?0:(t>0?lI:sI)(t)},fI=Math.max,dI=Math.min,pI=function(e,t){var n=cI(e);return n<0?fI(n+t,0):dI(n,t)},hI=Math.min,gI=function(e){return e>0?hI(cI(e),9007199254740991):0},vI=function(e){return gI(e.length)},yI=function(e){return function(t,n,r){var o,i=Rj(t),a=vI(i),u=pI(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},mI={includes:yI(!0),indexOf:yI(!1)},bI=mI.indexOf,wI=Bj([].push),EI=function(e,t){var n,r=Rj(e),o=0,i=[];for(n in r)!pN(KN,n)&&pN(r,n)&&wI(i,n);for(;t.length>o;)pN(r,n=t[o++])&&(~bI(i,n)||wI(i,n));return i},DI=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],SI=DI.concat("length","prototype"),xI={f:Object.getOwnPropertyNames||function(e){return EI(e,SI)}},CI={f:Object.getOwnPropertySymbols},AI=Bj([].concat),OI=Hj("Reflect","ownKeys")||function(e){var t=xI.f(jN(e)),n=CI.f;return n?AI(t,n(e)):t},kI=function(e,t){for(var n=OI(t),r=LN.f,o=TN.f,i=0;i<n.length;i++){var a=n[i];pN(e,a)||r(e,a,o(t,a))}},BI=/#|\.prototype\./,FI=function(e,t){var n=_I[TI(e)];return n==jI||n!=PI&&(Mj(t)?vj(t):!!t)},TI=FI.normalize=function(e){return String(e).replace(BI,".").toLowerCase()},_I=FI.data={},PI=FI.NATIVE="N",jI=FI.POLYFILL="P",NI=FI,II=TN.f,LI=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?gj:l?gj[u]||uN(u,{}):(gj[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=II(n,r))&&a.value:n[r],!NI(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;kI(i,o)}(e.sham||o&&o.sham)&&RN(i,"sham",!0),uI(n,r,i,e)}},RI=Bj(Bj.bind),MI=Array.isArray||function(e){return"Array"==_j(e)},zI={};zI[DN("toStringTag")]="z";var $I="[object z]"===String(zI),HI=DN("toStringTag"),VI=gj.Object,UI="Arguments"==_j(function(){return arguments}()),WI=$I?_j:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=VI(e),HI))?n:UI?_j(t):"Object"==(r=_j(t))&&Mj(t.callee)?"Arguments":r},GI=function(){},qI=[],KI=Hj("Reflect","construct"),YI=/^\s*(?:class|function)\b/,XI=Bj(YI.exec),ZI=!YI.exec(GI),JI=function(e){if(!Mj(e))return!1;try{return KI(GI,qI,e),!0}catch(e){return!1}},QI=!KI||vj((function(){var e;return JI(JI.call)||!JI(Object)||!JI((function(){e=!0}))||e}))?function(e){if(!Mj(e))return!1;switch(WI(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return ZI||!!XI(YI,VN(e))}:JI,eL=DN("species"),tL=gj.Array,nL=function(e,t){return new(function(e){var t;return MI(e)&&(t=e.constructor,(QI(t)&&(t===tL||MI(t.prototype))||zj(t)&&null===(t=t[eL]))&&(t=void 0)),void 0===t?tL:t}(e))(0===t?0:t)},rL=Bj([].push),oL=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=fN(s),g=Nj(h),v=function(e,t){return rN(e),void 0===t?e:RI?RI(e,t):function(){return e.apply(t,arguments)}}(l,c),y=vI(g),m=0,b=f||nL,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:rL(w,d)}else switch(e){case 4:return!1;case 7:rL(w,d)}return i?-1:r||o?o:w}},iL={forEach:oL(0),map:oL(1),filter:oL(2),some:oL(3),every:oL(4),find:oL(5),findIndex:oL(6),filterReject:oL(7)},aL=DN("species"),uL=function(e){return Yj>=51||!vj((function(){var t=[];return(t.constructor={})[aL]=function(){return{foo:1}},1!==t[e](Boolean).foo}))},sL=iL.filter;LI({target:"Array",proto:!0,forced:!uL("filter")},{filter:function(e){return sL(this,e,arguments.length>1?arguments[1]:void 0)}});var lL=$I?{}.toString:function(){return"[object "+WI(this)+"]"};$I||uI(Object.prototype,"toString",lL,{unsafe:!0});var cL,fL=gj.String,dL=function(e){if("Symbol"===WI(e))throw TypeError("Cannot convert a Symbol value to a string");return fL(e)},pL=function(){var e=jN(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},hL=gj.RegExp,gL=vj((function(){var e=hL("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),vL=gL||vj((function(){return!hL("a","y").sticky})),yL={BROKEN_CARET:gL||vj((function(){var e=hL("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:vL,UNSUPPORTED_Y:gL},mL=Object.keys||function(e){return EI(e,DI)},bL=yj?Object.defineProperties:function(e,t){jN(e);for(var n,r=Rj(t),o=mL(t),i=o.length,a=0;i>a;)LN.f(e,n=o[a++],r[n]);return e},wL=Hj("document","documentElement"),EL=qN("IE_PROTO"),DL=function(){},SL=function(e){return"<script>"+e+"<\/script>"},xL=function(e){e.write(SL("")),e.close();var t=e.parentWindow.Object;return e=null,t},CL=function(){try{cL=new ActiveXObject("htmlfile")}catch(e){}var e,t;CL="undefined"!=typeof document?document.domain&&cL?xL(cL):((t=kN("iframe")).style.display="none",wL.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(SL("document.F=Object")),e.close(),e.F):xL(cL);for(var n=DI.length;n--;)delete CL.prototype[DI[n]];return CL()};KN[EL]=!0;var AL,OL,kL=Object.create||function(e,t){var n;return null!==e?(DL.prototype=jN(e),n=new DL,DL.prototype=null,n[EL]=e):n=CL(),void 0===t?n:bL(n,t)},BL=gj.RegExp,FL=vj((function(){var e=BL(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),TL=gj.RegExp,_L=vj((function(){var e=TL("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),PL=nI.get,jL=lN("native-string-replace",String.prototype.replace),NL=RegExp.prototype.exec,IL=NL,LL=Bj("".charAt),RL=Bj("".indexOf),ML=Bj("".replace),zL=Bj("".slice),$L=(OL=/b*/g,bj(NL,AL=/a/,"a"),bj(NL,OL,"a"),0!==AL.lastIndex||0!==OL.lastIndex),HL=yL.BROKEN_CARET,VL=void 0!==/()??/.exec("")[1];($L||VL||HL||FL||_L)&&(IL=function(e){var t,n,r,o,i,a,u,s=this,l=PL(s),c=dL(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=bj(IL,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=HL&&s.sticky,h=bj(pL,s),g=s.source,v=0,y=c;if(p&&(h=ML(h,"y",""),-1===RL(h,"g")&&(h+="g"),y=zL(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==LL(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),VL&&(n=new RegExp("^"+g+"$(?!\\s)",h)),$L&&(r=s.lastIndex),o=bj(NL,p?n:s,y),p?o?(o.input=zL(o.input,v),o[0]=zL(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:$L&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),VL&&o&&o.length>1&&bj(jL,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=kL(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var UL=IL;LI({target:"RegExp",proto:!0,forced:/./.exec!==UL},{exec:UL});var WL=Function.prototype,GL=WL.apply,qL=WL.bind,KL=WL.call,YL="object"==typeof Reflect&&Reflect.apply||(qL?KL.bind(GL):function(){return KL.apply(GL,arguments)}),XL=DN("species"),ZL=RegExp.prototype,JL=function(e,t,n,r){var o=DN(e),i=!vj((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!vj((function(){var t=!1,n=/a/;return"split"===e&&((n={}).constructor={},n.constructor[XL]=function(){return n},n.flags="",n[o]=/./[o]),n.exec=function(){return t=!0,null},n[o](""),!t}));if(!i||!a||n){var u=Bj(/./[o]),s=t(o,""[e],(function(e,t,n,r,o){var a=Bj(e),s=t.exec;return s===UL||s===ZL.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));uI(String.prototype,e,s[0]),uI(ZL,o,s[1])}r&&RN(ZL[o],"sham",!0)},QL=Bj("".charAt),eR=Bj("".charCodeAt),tR=Bj("".slice),nR=function(e){return function(t,n){var r,o,i=dL(Lj(t)),a=cI(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=eR(i,a))<55296||r>56319||a+1===u||(o=eR(i,a+1))<56320||o>57343?e?QL(i,a):r:e?tR(i,a,a+2):o-56320+(r-55296<<10)+65536}},rR=(nR(!1),nR(!0)),oR=function(e,t,n){return t+(n?rR(e,t).length:1)},iR=Math.floor,aR=Bj("".charAt),uR=Bj("".replace),sR=Bj("".slice),lR=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,cR=/\$([$&'`]|\d{1,2})/g,fR=function(e,t,n,r,o,i){var a=n+e.length,u=r.length,s=cR;return void 0!==o&&(o=fN(o),s=lR),uR(i,s,(function(i,s){var l;switch(aR(s,0)){case"$":return"$";case"&":return e;case"`":return sR(t,0,n);case"'":return sR(t,a);case"<":l=o[sR(s,1,-1)];break;default:var c=+s;if(0===c)return i;if(c>u){var f=iR(c/10);return 0===f?i:f<=u?void 0===r[f-1]?aR(s,1):r[f-1]+aR(s,1):i}l=r[c-1]}return void 0===l?"":l}))},dR=gj.TypeError,pR=function(e,t){var n=e.exec;if(Mj(n)){var r=bj(n,e,t);return null!==r&&jN(r),r}if("RegExp"===_j(e))return bj(UL,e,t);throw dR("RegExp#exec called on incompatible receiver")},hR=DN("replace"),gR=Math.max,vR=Math.min,yR=Bj([].concat),mR=Bj([].push),bR=Bj("".indexOf),wR=Bj("".slice),ER="$0"==="a".replace(/./,"$0"),DR=!!/./[hR]&&""===/./[hR]("a","$0");JL("replace",(function(e,t,n){var r=DR?"$":"$0";return[function(e,n){var r=Lj(this),o=null==e?void 0:oN(e,hR);return o?bj(o,e,r,n):bj(t,dL(r),e,n)},function(e,o){var i=jN(this),a=dL(e);if("string"==typeof o&&-1===bR(o,r)&&-1===bR(o,"$<")){var u=n(t,i,a,o);if(u.done)return u.value}var s=Mj(o);s||(o=dL(o));var l=i.global;if(l){var c=i.unicode;i.lastIndex=0}for(var f=[];;){var d=pR(i,a);if(null===d)break;if(mR(f,d),!l)break;""===dL(d[0])&&(i.lastIndex=oR(a,gI(i.lastIndex),c))}for(var p,h="",g=0,v=0;v<f.length;v++){for(var y=dL((d=f[v])[0]),m=gR(vR(cI(d.index),a.length),0),b=[],w=1;w<d.length;w++)mR(b,void 0===(p=d[w])?p:String(p));var E=d.groups;if(s){var D=yR([y],b,m,a);void 0!==E&&mR(D,E);var S=dL(YL(o,void 0,D))}else S=fR(y,a,m,b,E,o);m>=g&&(h+=wR(a,g,m)+S,g=m+y.length)}return h+wR(a,g)}]}),!!vj((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!ER||DR);var SR=DN("unscopables"),xR=Array.prototype;null==xR[SR]&&LN.f(xR,SR,{configurable:!0,value:kL(null)});var CR=function(e){xR[SR][e]=!0},AR=iL.find,OR=!0;"find"in[]&&Array(1).find((function(){OR=!1})),LI({target:"Array",proto:!0,forced:OR},{find:function(e){return AR(this,e,arguments.length>1?arguments[1]:void 0)}}),CR("find");var kR=DN("match"),BR=function(e){var t;return zj(e)&&(void 0!==(t=e[kR])?!!t:"RegExp"==_j(e))},FR=gj.TypeError,TR=DN("species"),_R=function(e,t,n){var r=CN(t);r in e?LN.f(e,r,xj(0,n)):e[r]=n},PR=gj.Array,jR=Math.max,NR=function(e,t,n){for(var r=vI(e),o=pI(t,r),i=pI(void 0===n?r:n,r),a=PR(jR(i-o,0)),u=0;o<i;o++,u++)_R(a,u,e[o]);return a.length=u,a},IR=yL.UNSUPPORTED_Y,LR=Math.min,RR=[].push,MR=Bj(/./.exec),zR=Bj(RR),$R=Bj("".slice);JL("split",(function(e,t,n){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(e,n){var r=dL(Lj(this)),o=void 0===n?4294967295:n>>>0;if(0===o)return[];if(void 0===e)return[r];if(!BR(e))return bj(t,r,e,o);for(var i,a,u,s=[],l=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),c=0,f=new RegExp(e.source,l+"g");(i=bj(UL,f,r))&&!((a=f.lastIndex)>c&&(zR(s,$R(r,c,i.index)),i.length>1&&i.index<r.length&&YL(RR,s,NR(i,1)),u=i[0].length,c=a,s.length>=o));)f.lastIndex===i.index&&f.lastIndex++;return c===r.length?!u&&MR(f,"")||zR(s,""):zR(s,$R(r,c)),s.length>o?NR(s,0,o):s}:"0".split(void 0,0).length?function(e,n){return void 0===e&&0===n?[]:bj(t,this,e,n)}:t,[function(t,n){var o=Lj(this),i=null==t?void 0:oN(t,e);return i?bj(i,t,o,n):bj(r,dL(o),t,n)},function(e,o){var i=jN(this),a=dL(e),u=n(r,i,a,o,r!==t);if(u.done)return u.value;var s=function(e,t){var n,r=jN(e).constructor;return void 0===r||null==(n=jN(r)[TR])?t:function(e){if(QI(e))return e;throw FR(tN(e)+" is not a constructor")}(n)}(i,RegExp),l=i.unicode,c=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(IR?"g":"y"),f=new s(IR?"^(?:"+i.source+")":i,c),d=void 0===o?4294967295:o>>>0;if(0===d)return[];if(0===a.length)return null===pR(f,a)?[a]:[];for(var p=0,h=0,g=[];h<a.length;){f.lastIndex=IR?0:h;var v,y=pR(f,IR?$R(a,h):a);if(null===y||(v=LR(gI(f.lastIndex+(IR?h:0)),a.length))===p)h=oR(a,h,l);else{if(zR(g,$R(a,p,h)),g.length===d)return g;for(var m=1;m<=y.length-1;m++)if(zR(g,y[m]),g.length===d)return g;h=p=v}}return zR(g,$R(a,p)),g}]}),!!vj((function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var n="ab".split(e);return 2!==n.length||"a"!==n[0]||"b"!==n[1]})),IR);var HR="\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff",VR=Bj("".replace),UR="["+HR+"]",WR=RegExp("^"+UR+UR+"*"),GR=RegExp(UR+UR+"*$"),qR=function(e){return function(t){var n=dL(Lj(t));return 1&e&&(n=VR(n,WR,"")),2&e&&(n=VR(n,GR,"")),n}},KR={start:qR(1),end:qR(2),trim:qR(3)},YR=aI.PROPER,XR=KR.trim;function ZR(e){return 0===Mp("<div>"+e+"</div>").children().filter((function(e){return"BR"!==e.tagName})).length}function JR(e){return 0===e.length?"":e[0].outerHTML}function QR(e){return e.length?e[0].tagName.toLowerCase():""}function eM(e,t){for(var n="",r=(e.attr("style")||"").split(";"),o=r.length,i=0;i<o;i++){var a=r[i];if(a){var u=a.split(":");u[0].trim()===t&&(n=u[1].trim())}}return n}LI({target:"String",proto:!0,forced:("trim",vj((function(){return!!HR.trim()||"âÂá "!=="âÂá ".trim()||YR&&"trim"!==HR.trim.name})))},{trim:function(){return XR(this)}}),LI({global:!0},{globalThis:gj}),eh&&(Mp.fn.css=eh),ah&&(Mp.fn.append=ah),uh&&(Mp.fn.prepend=uh),zp&&(Mp.fn.addClass=zp),$p&&(Mp.fn.removeClass=$p),Hp&&(Mp.fn.hasClass=Hp),qp&&(Mp.fn.on=qp),Kp&&(Mp.fn.off=Kp),yh&&(Mp.fn.focus=yh),Vp&&(Mp.fn.attr=Vp),Up&&(Mp.fn.removeAttr=Up),Jp&&(Mp.fn.hide=Jp),Qp&&(Mp.fn.show=Qp),lh&&(Mp.fn.parents=lh),Wp&&(Mp.fn.dataset=Wp),Gp&&(Mp.fn.val=Gp),oh&&(Mp.fn.text=oh),rh&&(Mp.fn.html=rh),fh&&(Mp.fn.children=fh),dh&&(Mp.fn.remove=dh),ch&&(Mp.fn.find=ch),Yp&&(Mp.fn.width=Yp),Xp&&(Mp.fn.height=Xp),nh&&(Mp.fn.filter=nh),ph&&(Mp.fn.empty=ph);var tM={selector:"p:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e);return 0===(t=t.filter((function(e){return!!ed.isText(e)||!!n.isInline(e)}))).length&&(t=[{text:r.text().replace(/\s+/gm," ")}]),{type:"paragraph",children:t}}},nM=function(e,t){return nM=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},nM(e,t)
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */};function rM(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}nM(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var oM=function(){return oM=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e},oM.apply(this,arguments)};function iM(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{s(r.next(e))}catch(e){i(e)}}function u(e){try{s(r.throw(e))}catch(e){i(e)}}function s(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,u)}s((r=r.apply(e,t||[])).next())}))}function aM(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function u(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=t.call(e,a)}catch(e){i=[6,e],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}}function uM(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function sM(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return a}function lM(e){var t=sM(Bf.nodes(e,{match:function(t){return e.children[0]===t},mode:"highest"}),1)[0];if(null==t)return!1;var n=t[0];if(!Sf.isElement(n))return!1;if("paragraph"===n.type)return!1;if(""!==Nf.string(n))return!1;var r=n.children,o=void 0===r?[]:r;return!!ed.isText(o[0])&&(md.setNodes(e,{type:"paragraph"}),!0)}var cM={renderElems:[lj],elemsToHtml:[{type:"paragraph",elemToHtml:function(e,t){return""===t?"<p><br></p>":"<p>"+t+"</p>"}}],parseElemsHtml:[tM],editorPlugin:function(e){var t=e.deleteBackward,n=e.deleteForward;e.insertText,e.insertBreak;var r=e;return r.deleteBackward=function(e){lM(r)||t(e)},r.deleteForward=function(e){lM(r)||n(e)},r}},fM=/"/g,dM=Bj("".replace),pM=function(e,t,n,r){var o=dL(Lj(e)),i="<"+t;return""!==n&&(i+=" "+n+'="'+dM(dL(r),fM,"&quot;")+'"'),i+">"+o+"</"+t+">"},hM=function(e){return vj((function(){var t=""[e]('"');return t!==t.toLowerCase()||t.split('"').length>3}))};function gM(e,t){var n=t,r=e,o=r.bold,i=r.italic,a=r.underline;return o&&(n="<strong>"+n+"</strong>"),r.code&&(n="<code>"+n+"</code>"),i&&(n="<em>"+n+"</em>"),a&&(n="<u>"+n+"</u>"),r.through&&(n="<s>"+n+"</s>"),r.sub&&(n="<sub>"+n+"</sub>"),r.sup&&(n="<sup>"+n+"</sup>"),n}function vM(e,t){return 0!==e.length&&(!!e[0].matches(t)||e.find(t).length>0)}LI({target:"String",proto:!0,forced:hM("bold")},{bold:function(){return pM(this,"b","","")}}),LI({target:"String",proto:!0,forced:hM("italics")},{italics:function(){return pM(this,"i","","")}}),LI({target:"String",proto:!0,forced:hM("sub")},{sub:function(){return pM(this,"sub","","")}}),LI({target:"String",proto:!0,forced:hM("sup")},{sup:function(){return pM(this,"sup","","")}});var yM={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},mM=kN("span").classList,bM=mM&&mM.constructor&&mM.constructor.prototype,wM=bM===Object.prototype?void 0:bM,EM=function(e,t){var n=[][e];return!!n&&vj((function(){n.call(null,t||function(){throw 1},1)}))},DM=iL.forEach,SM=EM("forEach")?[].forEach:function(e){return DM(this,e,arguments.length>1?arguments[1]:void 0)},xM=function(e){if(e&&e.forEach!==SM)try{RN(e,"forEach",SM)}catch(t){e.forEach=SM}};for(var CM in yM)yM[CM]&&xM(gj[CM]&&gj[CM].prototype);function AM(e,t){return null==e.selection||!!sM(Bf.nodes(e,{match:function(t){return"pre"===QO.getNodeType(t)||!!Bf.isVoid(e,t)},universal:!0}),1)[0]}function OM(e,t){Object.keys(t).forEach((function(t){"text"!==t&&Bf.removeMark(e,t)}))}xM(wM),LI({target:"Object",stat:!0,forced:vj((function(){mL(1)}))},{keys:function(e){return mL(fN(e))}});var kM=function(){function e(){this.marksNeedToRemove=[],this.tag="button"}return e.prototype.getValue=function(e){var t=this.mark,n=Bf.marks(e);return n?n[t]:!!sM(Bf.nodes(e,{match:function(e){return!0===e[t]}}),1)[0]},e.prototype.isActive=function(e){return!!this.getValue(e)},e.prototype.isDisabled=function(e){return AM(e,this.mark)},e.prototype.exec=function(e,t){var n=this.mark,r=this.marksNeedToRemove;t?e.removeMark(n):(e.addMark(n,!0),r&&r.forEach((function(t){return e.removeMark(t)})))},e}(),BM='<svg viewBox="0 0 1024 1024"><path d="M707.872 484.64A254.88 254.88 0 0 0 768 320c0-141.152-114.848-256-256-256H192v896h384c141.152 0 256-114.848 256-256a256.096 256.096 0 0 0-124.128-219.36zM384 192h101.504c55.968 0 101.504 57.408 101.504 128s-45.536 128-101.504 128H384V192z m159.008 640H384v-256h159.008c58.464 0 106.016 57.408 106.016 128s-47.552 128-106.016 128z"></path></svg>',FM='<svg viewBox="0 0 1024 1024"><path d="M704 64l128 0 0 416c0 159.072-143.264 288-320 288s-320-128.928-320-288l0-416 128 0 0 416c0 40.16 18.24 78.688 51.36 108.512 36.896 33.216 86.848 51.488 140.64 51.488s103.744-18.304 140.64-51.488c33.12-29.792 51.36-68.352 51.36-108.512l0-416zM192 832l640 0 0 128-640 0z"></path></svg>',TM='<svg viewBox="0 0 1024 1024"><path d="M896 64v64h-128L448 896h128v64H128v-64h128L576 128h-128V64z"></path></svg>',_M='<svg viewBox="0 0 1024 1024"><path d="M1024 512v64h-234.496c27.52 38.496 42.496 82.688 42.496 128 0 70.88-36.672 139.04-100.576 186.976C672.064 935.488 594.144 960 512 960s-160.064-24.512-219.424-69.024C228.64 843.04 192 774.88 192 704h128c0 69.376 87.936 128 192 128s192-58.624 192-128-87.936-128-192-128H0v-64h299.52a385.984 385.984 0 0 1-6.944-5.024C228.64 459.04 192 390.88 192 320s36.672-139.04 100.576-186.976C351.936 88.512 429.856 64 512 64s160.064 24.512 219.424 69.024C795.328 180.96 832 249.12 832 320h-128c0-69.376-87.936-128-192-128s-192 58.624-192 128 87.936 128 192 128c78.976 0 154.048 22.688 212.48 64H1024z"></path></svg>',PM='<svg viewBox="0 0 1024 1024"><path d="M576 736l96 96 320-320L672 192l-96 96 224 224zM448 288l-96-96L32 512l320 320 96-96-224-224z"></path></svg>',jM='<svg viewBox="0 0 1024 1024"><path d="M864 0a160 160 0 0 1 128 256l-64 64-224-224 64-64c26.752-20.096 59.968-32 96-32zM64 736l-64 288 288-64 592-592-224-224L64 736z m651.584-372.416l-448 448-55.168-55.168 448-448 55.168 55.168z"></path></svg>',NM='<svg viewBox="0 0 1024 1024"><path d="M924.402464 1023.068211H0.679665V99.345412h461.861399v98.909208H99.596867v725.896389h725.896389V561.206811h98.909208z" p-id="10909"></path><path d="M930.805104 22.977336l69.965436 69.965436-453.492405 453.492404-69.965435-69.901489z" p-id="10910"></path><path d="M1022.464381 304.030081h-98.917201V99.345412H709.230573V0.428211h313.233808z"></path></svg>',IM='<svg viewBox="0 0 1024 1024"><path d="M64 864h896v96H64zM360.58 576h302.85l81.53 224h102.16L579.24 64H444.77L176.89 800h102.16l81.53-224zM512 159.96L628.49 480H395.52L512 159.96z"></path></svg>',LM='<svg viewBox="0 0 1024 1024"><path d="M510.030769 315.076923l84.676923 196.923077h-177.230769l76.8-196.923077h15.753846zM945.230769 157.538462v708.923076c0 43.323077-35.446154 78.769231-78.769231 78.769231H157.538462c-43.323077 0-78.769231-35.446154-78.769231-78.769231V157.538462c0-43.323077 35.446154-78.769231 78.769231-78.769231h708.923076c43.323077 0 78.769231 35.446154 78.769231 78.769231z m-108.307692 643.938461L600.615385 216.615385c-5.907692-11.815385-15.753846-19.692308-29.538462-19.692308h-139.815385c-11.815385 0-23.630769 7.876923-27.56923 19.692308l-216.615385 584.861538c-3.938462 11.815385 3.938462 25.6 17.723077 25.6h80.738462c11.815385 0 23.630769-9.846154 27.56923-21.661538l63.015385-175.261539h263.876923l68.923077 175.261539c3.938462 11.815385 15.753846 21.661538 27.569231 21.661538h80.738461c13.784615 0 23.630769-13.784615 19.692308-25.6z"></path></svg>',RM='<svg viewBox="0 0 1024 1024"><path d="M64 512h384v128h-128V1024h-128V640h-128z m896-256H708.2496v768h-136.4992V256H320V128h640z"></path></svg>',MM='<svg viewBox="0 0 1024 1024"><path d="M956.788364 152.110545h-24.110546l23.924364 9.029819 0.186182 121.018181h-65.070546l-86.574545-130.048H566.551273v650.14691l130.048 64.977454v65.163636h-390.050909v-65.163636l129.954909-64.977454V152.110545H198.283636L111.429818 282.065455H46.545455V69.259636C46.545455 33.792 82.664727 22.062545 98.955636 22.062545h812.683637c23.738182 0 45.056 15.173818 45.056 41.053091V169.425455v-17.221819z"></path></svg>',zM='<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m256-512v384l-256-192z"></path></svg>',$M='<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>',HM='<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',VM='<svg viewBox="0 0 1024 1024"><path d="M972.8 793.6v102.4H256v-102.4h716.8z m0-230.4v102.4H51.2v-102.4h921.6z m0-230.4v102.4H256v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',UM='<svg viewBox="0 0 1024 1024"><path d="M870.4 793.6v102.4H153.6v-102.4h716.8z m102.4-230.4v102.4H51.2v-102.4h921.6z m-102.4-230.4v102.4H153.6v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',WM='<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z m0 192h1024v128H0z"></path></svg>',GM='<svg viewBox="0 0 1024 1024"><path d="M768 206.016v50.016h128v64h-192V174.016l128-60V64h-128V0h192v146.016zM676 256h-136L352 444 164 256H28l256 256-256 256h136L352 580 540 768h136l-256-256z"></path></svg>',qM='<svg viewBox="0 0 1024 1024"><path d="M768 910.016v50.016h128v64h-192v-146.016l128-60V768h-128v-64h192v146.016zM676 256h-136L352 444 164 256H28l256 256-256 256h136L352 580 540 768h136l-256-256z"></path></svg>',KM=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.mark="bold",t.title=HP("textStyle.bold"),t.iconSvg=BM,t.hotkey="mod+b",t}return rM(t,e),t}(kM),YM=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.mark="code",t.title=HP("textStyle.code"),t.iconSvg=PM,t.hotkey="mod+e",t}return rM(t,e),t}(kM),XM=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.mark="italic",t.title=HP("textStyle.italic"),t.iconSvg=TM,t.hotkey="mod+i",t}return rM(t,e),t}(kM),ZM=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.mark="through",t.title=HP("textStyle.through"),t.iconSvg=_M,t.hotkey="mod+shift+x",t}return rM(t,e),t}(kM),JM=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.mark="underline",t.title=HP("textStyle.underline"),t.iconSvg=FM,t.hotkey="mod+u",t}return rM(t,e),t}(kM),QM=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.mark="sub",t.marksNeedToRemove=["sup"],t.title=HP("textStyle.sub"),t.iconSvg=qM,t.hotkey="",t}return rM(t,e),t}(kM),ez=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.mark="sup",t.marksNeedToRemove=["sub"],t.title=HP("textStyle.sup"),t.iconSvg=GM,t.hotkey="",t}return rM(t,e),t}(kM),tz=function(){function e(){this.title=HP("textStyle.clear"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M969.382408 288.738615l-319.401123-270.852152a67.074236 67.074236 0 0 0-96.459139 5.74922l-505.931379 574.922021a68.35184 68.35184 0 0 0-17.886463 47.910169 74.101061 74.101061 0 0 0 24.274486 47.910168l156.50655 132.232065h373.060512L975.131628 383.281347a67.074236 67.074236 0 0 0-5.74922-96.459139z m-440.134747 433.746725H264.144729l-90.071117-78.572676c-5.74922-5.74922-12.137243-12.137243-12.137243-17.886463a36.411728 36.411728 0 0 1 5.749221-24.274485l210.804741-240.828447 265.102932 228.691204z m-439.495945 180.781036h843.218964a60.047411 60.047411 0 1 1 0 120.733624H89.751716a60.047411 60.047411 0 1 1 0-120.733624z m0 0"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return AM(e)},e.prototype.exec=function(e,t){var n,r,o=Bf.nodes(e,{match:function(e){return ed.isText(e)},universal:!0});try{for(var i=uM(o),a=i.next();!a.done;a=i.next())OM(e,a.value[0])}catch(e){n={error:e}}finally{try{a&&!a.done&&(r=i.return)&&r.call(i)}finally{if(n)throw n.error}}},e}(),nz={renderStyle:function(e,t){var n=e,r=n.bold,o=n.italic,i=n.underline,a=n.code,u=n.through,s=n.sub,l=n.sup,c=t;return r&&(c=Pg("strong",null,c)),a&&(c=Pg("code",null,c)),o&&(c=Pg("em",null,c)),i&&(c=Pg("u",null,c)),u&&(c=Pg("s",null,c)),s&&(c=Pg("sub",null,c)),l&&(c=Pg("sup",null,c)),c},menus:[{key:"bold",factory:function(){return new KM}},{key:"underline",factory:function(){return new JM}},{key:"italic",factory:function(){return new XM}},{key:"through",factory:function(){return new ZM}},{key:"code",factory:function(){return new YM}},{key:"sub",factory:function(){return new QM}},{key:"sup",factory:function(){return new ez}},{key:"clearStyle",factory:function(){return new tz}}],styleToHtml:function(e,t){if(!ed.isText(e))return t;if(ZR(t))return gM(e,t);var n=Mp(t);if("br"===QR(n))return gM(e,"<br>");var r=n.html();return r=gM(e,r),n.html(r),JR(n)},parseStyleHtml:function(e,t,n){var r=Mp(e);if(!ed.isText(t))return t;var o=t;return vM(r,"b,strong")&&(o.bold=!0),vM(r,"i,em")&&(o.italic=!0),vM(r,"u")&&(o.underline=!0),vM(r,"s,strike")&&(o.through=!0),vM(r,"sub")&&(o.sub=!0),vM(r,"sup")&&(o.sup=!0),vM(r,"code")&&(o.code=!0),o}};function rz(e){return function(t,n,r){return Pg("h"+e,null,n)}}var oz={type:"header1",renderElem:rz(1)},iz={type:"header2",renderElem:rz(2)},az={type:"header3",renderElem:rz(3)},uz={type:"header4",renderElem:rz(4)},sz={type:"header5",renderElem:rz(5)},lz=aI.PROPER,cz=RegExp.prototype,fz=cz.toString,dz=Bj(pL),pz=vj((function(){return"/a/b"!=fz.call({source:"a",flags:"b"})})),hz=lz&&"toString"!=fz.name;(pz||hz)&&uI(RegExp.prototype,"toString",(function(){var e=jN(this),t=dL(e.source),n=e.flags;return"/"+t+"/"+dL(void 0===n&&Vj(cz,e)&&!("flags"in cz)?dz(e):n)}),{unsafe:!0});var gz,vz=gj.TypeError,yz=function(e){if(BR(e))throw vz("The method doesn't accept regular expressions");return e},mz=DN("match"),bz=function(e){var t=/./;try{"/./"[e](t)}catch(n){try{return t[mz]=!1,"/./"[e](t)}catch(e){}}return!1},wz=TN.f,Ez=Bj("".startsWith),Dz=Bj("".slice),Sz=Math.min,xz=bz("startsWith");function Cz(e){var t=sM(Bf.nodes(e,{match:function(e){return QO.getNodeType(e).startsWith("header")},universal:!0}),1),n=t[0];if(null==n)return"paragraph";var r=sM(n,1)[0];return QO.getNodeType(r)}function Az(e){return null==e.selection||!sM(Bf.nodes(e,{match:function(e){var t=QO.getNodeType(e);return"paragraph"===t||!!t.startsWith("header")},universal:!0,mode:"highest"}),1)[0]}function Oz(e,t){t&&md.setNodes(e,{type:t})}LI({target:"String",proto:!0,forced:!(!xz&&(gz=wz(String.prototype,"startsWith"),gz&&!gz.writable)||xz)},{startsWith:function(e){var t=dL(Lj(this));yz(e);var n=gI(Sz(arguments.length>1?arguments[1]:void 0,t.length)),r=dL(e);return Ez?Ez(t,r,n):Dz(t,n,n+r.length)===r}});var kz=function(){function e(){this.title=HP("header.title"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M960 960c-51.2 0-102.4-3.2-153.6-3.2-51.2 0-99.2 3.2-150.4 3.2-19.2 0-28.8-22.4-28.8-38.4 0-51.2 57.6-28.8 86.4-48 19.2-12.8 19.2-60.8 19.2-80v-224-19.2c-9.6-3.2-19.2-3.2-28.8-3.2H320c-9.6 0-19.2 0-28.8 3.2V780.8c0 22.4 0 80 22.4 92.8 28.8 19.2 96-6.4 96 44.8 0 16-9.6 41.6-28.8 41.6-54.4 0-105.6-3.2-160-3.2-48 0-96 3.2-147.2 3.2-19.2 0-28.8-22.4-28.8-38.4 0-51.2 51.2-28.8 80-48 19.2-12.8 19.2-60.8 19.2-83.2V294.4c0-28.8 3.2-115.2-22.4-131.2-25.6-16-86.4 9.6-86.4-41.6 0-16 6.4-41.6 28.8-41.6 51.2 0 105.6 3.2 156.8 3.2 48 0 96-3.2 144-3.2 19.2 0 28.8 22.4 28.8 41.6 0 48-57.6 25.6-83.2 41.6-19.2 12.8-19.2 73.6-19.2 92.8v201.6c6.4 3.2 16 3.2 22.4 3.2h400c6.4 0 12.8 0 22.4-3.2V256c0-22.4 0-80-19.2-92.8-28.8-16-86.4 6.4-86.4-41.6 0-16 9.6-41.6 28.8-41.6 51.2 0 99.2 3.2 150.4 3.2 48 0 99.2-3.2 147.2-3.2 19.2 0 28.8 22.4 28.8 41.6 0 51.2-57.6 25.6-86.4 41.6-19.2 12.8-19.2 70.4-19.2 92.8v537.6c0 19.2 0 67.2 19.2 80 28.8 19.2 89.6-6.4 89.6 44.8 0 19.2-6.4 41.6-28.8 41.6z"></path></svg>',this.tag="select",this.width=60}return e.prototype.getOptions=function(e){var t=[{value:"header1",text:"H1",styleForRenderMenuList:{"font-size":"32px","font-weight":"bold"}},{value:"header2",text:"H2",styleForRenderMenuList:{"font-size":"24px","font-weight":"bold"}},{value:"header3",text:"H3",styleForRenderMenuList:{"font-size":"18px","font-weight":"bold"}},{value:"header4",text:"H4",styleForRenderMenuList:{"font-size":"16px","font-weight":"bold"}},{value:"header5",text:"H5",styleForRenderMenuList:{"font-size":"13px","font-weight":"bold"}},{value:"paragraph",text:HP("header.text")}],n=this.getValue(e).toString();return t.forEach((function(e){e.value===n?e.selected=!0:delete e.selected})),t},e.prototype.isActive=function(e){return!1},e.prototype.getValue=function(e){return Cz(e)},e.prototype.isDisabled=function(e){return Az(e)},e.prototype.exec=function(e,t){Oz(e,t.toString())},e}(),Bz=function(){function e(){this.tag="button"}return e.prototype.getValue=function(e){return Cz(e)},e.prototype.isActive=function(e){return this.getValue(e)===this.type},e.prototype.isDisabled=function(e){return Az(e)},e.prototype.exec=function(e,t){var n=this.type;Oz(e,t===n?"paragraph":n)},e}(),Fz=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="H1",t.type="header1",t}return rM(t,e),t}(Bz),Tz=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="H2",t.type="header2",t}return rM(t,e),t}(Bz),_z=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="H3",t.type="header3",t}return rM(t,e),t}(Bz),Pz=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="H4",t.type="header4",t}return rM(t,e),t}(Bz),jz=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="H5",t.type="header5",t}return rM(t,e),t}(Bz),Nz={key:"headerSelect",factory:function(){return new kz}},Iz={key:"header1",factory:function(){return new Fz}},Lz={key:"header2",factory:function(){return new Tz}},Rz={key:"header3",factory:function(){return new _z}},Mz={key:"header4",factory:function(){return new Pz}},zz={key:"header5",factory:function(){return new jz}};function $z(e){return function(t,n){return"<h"+e+">"+n+"</h"+e+">"}}function Hz(e){return function(t,n,r){var o=Mp(t);return 0===(n=n.filter((function(e){return!!ed.isText(e)||!!r.isInline(e)}))).length&&(n=[{text:o.text().replace(/\s+/gm," ")}]),{type:"header"+e,children:n}}}var Vz={renderElems:[oz,iz,az,uz,sz],elemsToHtml:[{type:"header1",elemToHtml:$z(1)},{type:"header2",elemToHtml:$z(2)},{type:"header3",elemToHtml:$z(3)},{type:"header4",elemToHtml:$z(4)},{type:"header5",elemToHtml:$z(5)}],parseElemsHtml:[{selector:"h1:not([data-w-e-type])",parseElemHtml:Hz(1)},{selector:"h2:not([data-w-e-type])",parseElemHtml:Hz(2)},{selector:"h3:not([data-w-e-type])",parseElemHtml:Hz(3)},{selector:"h4:not([data-w-e-type])",parseElemHtml:Hz(4)},{selector:"h5:not([data-w-e-type])",parseElemHtml:Hz(5)}],menus:[Nz,Iz,Lz,Rz,Mz,zz],editorPlugin:function(e){var t=e.insertBreak;e.insertNode;var n=e;return n.insertBreak=function(){var r=sM(Bf.nodes(n,{match:function(e){return QO.getNodeType(e).startsWith("header")},universal:!0}),1)[0];r&&QO.isSelectionAtLineEnd(e,r[1])?md.insertNodes(n,{type:"paragraph",children:[{text:""}]},{mode:"highest"}):t()},n}},Uz=Object.assign,Wz=Object.defineProperty,Gz=Bj([].concat),qz=!Uz||vj((function(){if(yj&&1!==Uz({b:1},Uz(Wz({},"a",{enumerable:!0,get:function(){Wz(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var e={},t={},n=Symbol(),r="abcdefghijklmnopqrst";return e[n]=7,r.split("").forEach((function(e){t[e]=e})),7!=Uz({},e)[n]||mL(Uz({},t)).join("")!=r}))?function(e,t){for(var n=fN(e),r=arguments.length,o=1,i=CI.f,a=Sj.f;r>o;)for(var u,s=Nj(arguments[o++]),l=i?Gz(mL(s),i(s)):mL(s),c=l.length,f=0;c>f;)u=l[f++],yj&&!bj(a,s,u)||(n[u]=s[u]);return n}:Uz;function Kz(e,t){null==e.data&&(e.data={});var n=e.data;null==n.style&&(n.style={}),Object.assign(n.style,t)}LI({target:"Object",stat:!0,forced:Object.assign!==qz},{assign:qz});var Yz={selector:"font",preParseHtml:function(e){var t=Mp(e);if("font"!==QR(t))return e;var n=t.attr("color")||"";return n&&(t.removeAttr("color"),t.css("color",n)),t[0]}},Xz=function(){function e(){this.tag="button",this.showDropPanel=!0,this.$content=null}return e.prototype.exec=function(e,t){},e.prototype.getValue=function(e){var t=this.mark,n=Bf.marks(e);return n&&n[t]?n[t]:""},e.prototype.isActive=function(e){return!!this.getValue(e)},e.prototype.isDisabled=function(e){return null==e.selection||!!sM(Bf.nodes(e,{match:function(t){return"pre"===QO.getNodeType(t)||!!Bf.isVoid(e,t)},universal:!0}),1)[0]},e.prototype.getPanelContentElem=function(e){var t=this.mark;if(null==this.$content){var n=Mp('<ul class="w-e-panel-content-color"></ul>');n.on("click","li",(function(n){var r=n.target;if(null!=r&&(n.preventDefault(),null!=e.selection)){var o=Mp(r).attr("data-value");"0"===o?Bf.removeMark(e,t):Bf.addMark(e,t,o)}})),this.$content=n}var r=this.$content;if(null==r)return document.createElement("ul");r.empty();var o=this.getValue(e),i=e.getMenuConfig(t).colors;(void 0===i?[]:i).forEach((function(e){var t=Mp('<div class="color-block" data-value="'+e+'"></div>');t.css("background-color",e);var n=Mp('<li data-value="'+e+'"></li>');o===e&&n.addClass("active"),n.append(t),r.append(n)}));var a="";"color"===t&&(a=HP("color.default")),"bgColor"===t&&(a=HP("color.clear"));var u=Mp('\n      <li data-value="0" class="clear">\n        <svg viewBox="0 0 1024 1024"><path d="M236.8 128L896 787.2V128H236.8z m614.4 704L192 172.8V832h659.2zM192 64h704c38.4 0 64 25.6 64 64v704c0 38.4-25.6 64-64 64H192c-38.4 0-64-25.6-64-64V128c0-38.4 25.6-64 64-64z"></path></svg>\n        '+a+"\n      </li>\n    ");return r.prepend(u),r[0]},e}(),Zz=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("color.color"),t.iconSvg=IM,t.mark="color",t}return rM(t,e),t}(Xz),Jz=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("color.bgColor"),t.iconSvg=LM,t.mark="bgColor",t}return rM(t,e),t}(Xz),Qz=["rgb(0, 0, 0)","rgb(38, 38, 38)","rgb(89, 89, 89)","rgb(140, 140, 140)","rgb(191, 191, 191)","rgb(217, 217, 217)","rgb(233, 233, 233)","rgb(245, 245, 245)","rgb(250, 250, 250)","rgb(255, 255, 255)","rgb(225, 60, 57)","rgb(231, 95, 51)","rgb(235, 144, 58)","rgb(245, 219, 77)","rgb(114, 192, 64)","rgb(89, 191, 192)","rgb(66, 144, 247)","rgb(54, 88, 226)","rgb(106, 57, 201)","rgb(216, 68, 147)","rgb(251, 233, 230)","rgb(252, 237, 225)","rgb(252, 239, 212)","rgb(252, 251, 207)","rgb(231, 246, 213)","rgb(218, 244, 240)","rgb(217, 237, 250)","rgb(224, 232, 250)","rgb(237, 225, 248)","rgb(246, 226, 234)","rgb(255, 163, 158)","rgb(255, 187, 150)","rgb(255, 213, 145)","rgb(255, 251, 143)","rgb(183, 235, 143)","rgb(135, 232, 222)","rgb(145, 213, 255)","rgb(173, 198, 255)","rgb(211, 173, 247)","rgb(255, 173, 210)","rgb(255, 77, 79)","rgb(255, 122, 69)","rgb(255, 169, 64)","rgb(255, 236, 61)","rgb(115, 209, 61)","rgb(54, 207, 201)","rgb(64, 169, 255)","rgb(89, 126, 247)","rgb(146, 84, 222)","rgb(247, 89, 171)","rgb(207, 19, 34)","rgb(212, 56, 13)","rgb(212, 107, 8)","rgb(212, 177, 6)","rgb(56, 158, 13)","rgb(8, 151, 156)","rgb(9, 109, 217)","rgb(29, 57, 196)","rgb(83, 29, 171)","rgb(196, 29, 127)","rgb(130, 0, 20)","rgb(135, 20, 0)","rgb(135, 56, 0)","rgb(97, 71, 0)","rgb(19, 82, 0)","rgb(0, 71, 79)","rgb(0, 58, 140)","rgb(6, 17, 120)","rgb(34, 7, 94)","rgb(120, 6, 80)"],e$={renderStyle:function(e,t){var n=e,r=n.color,o=n.bgColor,i=t;return r&&Kz(i,{color:r}),o&&Kz(i,{backgroundColor:o}),i},styleToHtml:function(e,t){if(!ed.isText(e))return t;var n,r=e,o=r.color,i=r.bgColor;return o||i?((ZR(t)||"span"!==QR(n=Mp(t)))&&(n=Mp("<span>"+t+"</span>")),o&&n.css("color",o),i&&n.css("background-color",i),JR(n)):t},preParseHtml:[Yz],parseStyleHtml:function(e,t,n){var r=Mp(e);if(!ed.isText(t))return t;var o=t,i=eM(r,"color");i&&(o.color=i);var a=eM(r,"background-color");return a||(a=eM(r,"background")),a&&(o.bgColor=a),o},menus:[{key:"color",factory:function(){return new Zz},config:{colors:Qz}},{key:"bgColor",factory:function(){return new Jz},config:{colors:Qz}}]},t$=/^(?:\w+:)?\/\/(\S+)$/,n$=/^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/,r$=/^[^\s\.]+\.\S{2,}$/,o$=mI.includes;function i$(e){return void 0===e&&(e="r"),e+"-"+Rh()}function a$(e){return e.replace(/</g,"&lt;").replace(/>/g,"&gt;")}function u$(e,t,n,r){return iM(this,void 0,void 0,(function(){var o,i;return aM(this,(function(a){switch(a.label){case 0:return(o=t.getMenuConfig(e).checkLink)?[4,o(n,r)]:[3,2];case 1:if("string"==typeof(i=a.sent()))return t.alert(i,"error"),[2,!1];if(null==i)return[2,!1];a.label=2;case 2:return[2,!0]}}))}))}function s$(e,t,n){return iM(this,void 0,void 0,(function(){var r;return aM(this,(function(o){switch(o.label){case 0:return(r=t.getMenuConfig(e).parseLinkUrl)?[4,r(n)]:[3,2];case 1:return[2,o.sent()];case 2:return[2,n]}}))}))}function l$(e){return null==e.selection||!!QO.getSelectedElems(e).some((function(t){var n=t.type;return!!e.isVoid(t)||!!["pre","code","link"].includes(n)||void 0}))}function c$(e,t){return{type:"link",url:a$(e),children:t?[{text:t}]:[]}}function f$(e,t,n){return iM(this,void 0,void 0,(function(){var r,o,i;return aM(this,(function(a){switch(a.label){case 0:return n?(t||(t=n),e.restoreSelection(),l$(e)?[2]:[4,u$("insertLink",e,t,n)]):[2];case 1:return a.sent()?[4,s$("insertLink",e,n)]:[2];case 2:return r=a.sent(),null==(o=e.selection)||(qf.isCollapsed(o)?(e.insertText(" "),i=c$(r,t),md.insertNodes(e,i),e.insertFragment([{text:" "}])):Bf.string(e,o)!==t?(e.deleteFragment(),i=c$(r,t),md.insertNodes(e,i)):(i=c$(r),md.wrapNodes(e,i,{split:!0}),md.collapse(e,{edge:"end"}))),[2]}}))}))}LI({target:"Array",proto:!0},{includes:function(e){return o$(this,e,arguments.length>1?arguments[1]:void 0)}}),CR("includes");var d$={type:"link",renderElem:function(e,t,n){var r=e,o=r.url,i=r.target;return Pg("a",{href:o,target:void 0===i?"_blank":i},t)}},p$={selector:"a:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e);return 0===(t=t.filter((function(e){return!!ed.isText(e)||!!n.isInline(e)}))).length&&(t=[{text:r.text().replace(/\s+/gm," ")}]),{type:"link",url:r.attr("href")||"",target:r.attr("target")||"",children:t}}};function h$(){return i$("w-e-insert-link")}var g$=function(){function e(){this.title=HP("link.insert"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M440.224 635.776a51.84 51.84 0 0 1-36.768-15.232c-95.136-95.136-95.136-249.92 0-345.056l192-192C641.536 37.408 702.816 12.032 768 12.032s126.432 25.376 172.544 71.456c95.136 95.136 95.136 249.92 0 345.056l-87.776 87.776a51.968 51.968 0 1 1-73.536-73.536l87.776-87.776a140.16 140.16 0 0 0 0-197.984c-26.432-26.432-61.6-40.992-99.008-40.992s-72.544 14.56-99.008 40.992l-192 192a140.16 140.16 0 0 0 0 197.984 51.968 51.968 0 0 1-36.768 88.768z"></path><path d="M256 1012a242.4 242.4 0 0 1-172.544-71.456c-95.136-95.136-95.136-249.92 0-345.056l87.776-87.776a51.968 51.968 0 1 1 73.536 73.536l-87.776 87.776a140.16 140.16 0 0 0 0 197.984c26.432 26.432 61.6 40.992 99.008 40.992s72.544-14.56 99.008-40.992l192-192a140.16 140.16 0 0 0 0-197.984 51.968 51.968 0 1 1 73.536-73.536c95.136 95.136 95.136 249.92 0 345.056l-192 192A242.4 242.4 0 0 1 256 1012z"></path></svg>',this.tag="button",this.showModal=!0,this.modalWidth=300,this.$content=null,this.textInputId=h$(),this.urlInputId=h$(),this.buttonId=h$()}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){},e.prototype.isDisabled=function(e){return l$(e)},e.prototype.getModalPositionNode=function(e){return null},e.prototype.getModalContentElem=function(e){var t=e.selection,n=this,r=n.textInputId,o=n.urlInputId,i=n.buttonId,a=sM(S_(HP("link.text"),r),2),u=a[0],s=Mp(a[1]),l=sM(S_(HP("link.url"),o),2),c=l[0],f=Mp(l[1]),d=sM(C_(i,HP("common.ok")),1)[0];if(null==this.$content){var p=Mp("<div></div>");p.on("click","#"+i,(function(t){t.preventDefault();var n=p.find("#"+r).val(),i=p.find("#"+o).val();f$(e,n,i),e.hidePanelOrModal()})),this.$content=p}var h=this.$content;if(h.empty(),h.append(u),h.append(c),h.append(d),null==t||qf.isCollapsed(t))s.val("");else{var g=Bf.string(e,t);s.val(g)}return f.val(""),setTimeout((function(){s.focus()})),h[0]},e}();function v$(){return i$("w-e-update-link")}var y$=function(){function e(){this.title=HP("link.edit"),this.iconSvg=jM,this.tag="button",this.showModal=!0,this.modalWidth=300,this.$content=null,this.urlInputId=v$(),this.buttonId=v$()}return e.prototype.getSelectedLinkElem=function(e){var t=QO.getSelectedNodeByType(e,"link");return null==t?null:t},e.prototype.getValue=function(e){var t=this.getSelectedLinkElem(e);return t&&t.url||""},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){},e.prototype.isDisabled=function(e){return null==e.selection||null==this.getSelectedLinkElem(e)},e.prototype.getModalPositionNode=function(e){return QO.getSelectedNodeByType(e,"link")},e.prototype.getModalContentElem=function(e){var t=this.urlInputId,n=this.buttonId,r=sM(S_(HP("link.url"),t),2),o=r[0],i=Mp(r[1]),a=sM(C_(n,HP("common.ok")),1)[0];if(null==this.$content){var u=Mp("<div></div>");u.on("click","button",(function(n){n.preventDefault(),e.restoreSelection();var r=QO.getSelectedNodeByType(e,"link"),o=r?Nf.string(r):"",i=u.find("#"+t).val();!function(e,t,n){iM(this,void 0,void 0,(function(){var r,o;return aM(this,(function(i){switch(i.label){case 0:return n?[4,u$("editLink",e,t,n)]:[2];case 1:return i.sent()?[4,s$("editLink",e,n)]:[2];case 2:return r=i.sent(),o={url:a$(r)},md.setNodes(e,o,{match:function(e){return QO.checkNodeType(e,"link")}}),[2]}}))}))}(e,o,i),e.hidePanelOrModal()})),this.$content=u}var s=this.$content;s.empty(),s.append(o),s.append(a);var l=this.getValue(e);return i.val(l),setTimeout((function(){i.focus()})),s[0]},e}(),m$=function(){function e(){this.title=HP("link.unLink"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M608.16328 811.815036c9.371954 9.371954 9.371954 24.56788 0 33.941834l-89.347563 89.347564c-118.525421 118.523421-311.38448 118.531421-429.919901 0-118.527421-118.529421-118.527421-311.39048 0-429.917901l89.349564-89.349563c9.371954-9.371954 24.56788-9.371954 33.941834 0l79.195613 79.195613c9.371954 9.371954 9.371954 24.56788 0 33.941834l-89.349563 89.347564c-56.143726 56.145726-56.143726 147.49928 0 203.645005 56.143726 56.143726 147.49928 56.145726 203.647005 0l89.347564-89.347563c9.371954-9.371954 24.56788-9.371954 33.941834 0l79.193613 79.195613z m-113.135447-520.429459c9.371954 9.371954 24.56788 9.371954 33.941834 0l89.347564-89.347564c56.143726-56.149726 147.49928-56.145726 203.647006 0 56.143726 56.145726 56.143726 147.49928 0 203.645006l-89.349564 89.347564c-9.371954 9.371954-9.371954 24.56788 0 33.941834l79.195613 79.195613c9.371954 9.371954 24.56788 9.371954 33.941834 0l89.349564-89.349563c118.529421-118.529421 118.529421-311.38848 0-429.917901-118.531421-118.527421-311.38848-118.527421-429.919901 0l-89.347563 89.347564c-9.371954 9.371954-9.371954 24.56788 0 33.941834l79.193613 79.195613z m469.653707 718.556492l45.253779-45.253779c18.745908-18.745908 18.745908-49.13776 0-67.881669L127.195629 14.062931c-18.745908-18.745908-49.13776-18.745908-67.881669 0L14.058181 59.31871c-18.745908 18.745908-18.745908 49.13776 0 67.881669l882.74169 882.74169c18.745908 18.743908 49.13776 18.743908 67.881669 0z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection||null==QO.getSelectedNodeByType(e,"link")},e.prototype.exec=function(e,t){this.isDisabled(e)||md.unwrapNodes(e,{match:function(e){return QO.checkNodeType(e,"link")}})},e}(),b$=function(){function e(){this.title=HP("link.view"),this.iconSvg=NM,this.tag="button"}return e.prototype.getSelectedLinkElem=function(e){var t=QO.getSelectedNodeByType(e,"link");return null==t?null:t},e.prototype.getValue=function(e){var t=this.getSelectedLinkElem(e);return t&&t.url||""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection||null==this.getSelectedLinkElem(e)},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){if(!t||"string"!=typeof t)throw new Error("View link failed, link url is '"+t+"'");window.open(t,"_blank")}},e}(),w$={checkLink:function(e,t){return!0},parseLinkUrl:function(e){return e}},E$={renderElems:[d$],elemsToHtml:[{type:"link",elemToHtml:function(e,t){var n=e,r=n.url,o=n.target;return'<a href="'+r+'" target="'+(void 0===o?"_blank":o)+'">'+t+"</a>"}}],parseElemsHtml:[p$],menus:[{key:"insertLink",factory:function(){return new g$},config:w$},{key:"editLink",factory:function(){return new y$},config:w$},{key:"unLink",factory:function(){return new m$}},{key:"viewLink",factory:function(){return new b$}}],editorPlugin:function(e){var t=e.isInline,n=e.insertData,r=e.normalizeNode;e.insertNode,e.insertText;var o=e;return o.isInline=function(e){return"link"===e.type||t(e)},o.insertData=function(e){var t=e.getData("text/plain");if(function(e){if("string"!=typeof e)return!1;var t=e.match(t$);if(!t)return!1;var n=t[1];return!(!n||!n$.test(n)&&!r$.test(n))}(t)){if(!l$(o)){var r=o.selection;if(null!=r){var i=Bf.string(o,r);f$(o,i,t)}}}else n(e)},o.normalizeNode=function(e){var t=sM(e,2),n=t[0],i=t[1];return"link"!==QO.getNodeType(n)?r([n,i]):""===Nf.string(n)?md.removeNodes(o,{at:i}):r([n,i])},o}},D$=Bj(1..valueOf),S$=gj.RangeError,x$=gj.RangeError,C$=gj.String,A$=Math.floor,O$=Bj((function(e){var t=dL(Lj(this)),n="",r=cI(e);if(r<0||r==1/0)throw S$("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(t+=t))1&r&&(n+=t);return n})),k$=Bj("".slice),B$=Bj(1..toFixed),F$=function(e,t,n){return 0===t?n:t%2==1?F$(e,t-1,n*e):F$(e*e,t/2,n)},T$=function(e,t,n){for(var r=-1,o=n;++r<6;)o+=t*e[r],e[r]=o%1e7,o=A$(o/1e7)},_$=function(e,t){for(var n=6,r=0;--n>=0;)r+=e[n],e[n]=A$(r/t),r=r%t*1e7},P$=function(e){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==e[t]){var r=C$(e[t]);n=""===n?r:n+O$("0",7-r.length)+r}return n};function j$(e,t){return"w-e-image-container-"+QO.findKey(e,t).id}LI({target:"Number",proto:!0,forced:vj((function(){return"0.000"!==B$(8e-5,3)||"1"!==B$(.9,0)||"1.25"!==B$(1.255,2)||"1000000000000000128"!==B$(0xde0b6b3a7640080,0)}))||!vj((function(){B$({})}))},{toFixed:function(e){var t,n,r,o,i=D$(this),a=cI(e),u=[0,0,0,0,0,0],s="",l="0";if(a<0||a>20)throw x$("Incorrect fraction digits");if(i!=i)return"NaN";if(i<=-1e21||i>=1e21)return C$(i);if(i<0&&(s="-",i=-i),i>1e-21)if(n=(t=function(e){for(var t=0,n=e;n>=4096;)t+=12,n/=4096;for(;n>=2;)t+=1,n/=2;return t}(i*F$(2,69,1))-69)<0?i*F$(2,-t,1):i/F$(2,t,1),n*=4503599627370496,(t=52-t)>0){for(T$(u,0,n),r=a;r>=7;)T$(u,1e7,0),r-=7;for(T$(u,F$(10,r,1),0),r=t-1;r>=23;)_$(u,1<<23),r-=23;_$(u,1<<r),T$(u,1,1),_$(u,2),l=P$(u)}else T$(u,0,n),T$(u,1<<-t,0),l=P$(u)+O$("0",a);return a>0?s+((o=l.length)<=a?"0."+O$("0",a-o)+l:k$(l,0,o-a)+"."+k$(l,o-a)):s+l}});var N$={type:"image",renderElem:function(e,t,n){var r=e,o=r.src,i=r.alt,a=void 0===i?"":i,u=r.href,s=void 0===u?"":u,l=r.style,c=void 0===l?{}:l,f=c.width,d=void 0===f?"":f,p=c.height,h=void 0===p?"":p,g=QO.isNodeSelected(n,e),v={};d&&(v.width="100%"),h&&(v.height="100%");var y=Pg("img",{style:v,src:o,alt:a,"data-href":s}),m=n.isDisabled();return g&&!m?function(e,t,n,r){var o=Mp("body"),i=j$(e,t),a=r.width,u=r.height,s=0,l=0,c=0,f=!1,d=null;function p(t){d=function(){var e=Mp("#"+i);if(0===e.length)throw new Error("Cannot find image container elem");return e}(),s=t;var n=d.find("img");if(0===n.length)throw new Error("Cannot find image elem");l=n.width(),c=n.height(),o.on("mousemove",h),o.on("mouseup",g);var r=QO.getHoverbar(e);r&&r.hideAndClean()}var h=eg((function(e){e.preventDefault();var t=e.clientX,n=l+(f?s-t:t-s),r=c*(n/l);null!=d&&(n<=15||r<=15||(d.css("width",n+"px"),d.css("height",r+"px")))}),100);function g(n){if(o.off("mousemove",h),null!=d){var r=d.width().toFixed(2),i=d.height().toFixed(2),a={style:oM(oM({},t.style),{width:r+"px",height:i+"px"})};md.setNodes(e,a,{at:QO.findPath(e,t)}),o.off("mouseup",g)}}var v={};return a&&(v.width=a),u&&(v.height=u),Pg("div",{id:i,style:v,className:"w-e-image-container w-e-selected-image-container",on:{mousedown:function(e){var t=Mp(e.target);t.hasClass("w-e-image-dragger")&&(e.preventDefault(),(t.hasClass("left-top")||t.hasClass("left-bottom"))&&(f=!0),p(e.clientX))}}},n,Pg("div",{className:"w-e-image-dragger left-top"}),Pg("div",{className:"w-e-image-dragger right-top"}),Pg("div",{className:"w-e-image-dragger left-bottom"}),Pg("div",{className:"w-e-image-dragger right-bottom"}))}(n,e,y,{width:d,height:h}):function(e,t,n,r){var o=r.width,i=r.height,a={};return o&&(a.width=o),i&&(a.height=i),Pg("div",{id:j$(e,t),style:a,className:"w-e-image-container"},n)}(n,e,y,{width:d,height:h})}},I$={selector:"img:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e),o=r.attr("data-href")||"";return o=decodeURIComponent(o),{type:"image",src:r.attr("src")||"",alt:r.attr("alt")||"",href:o,style:{width:eM(r,"width"),height:eM(r,"height")},children:[{text:""}]}}};function L$(e,t,n,r,o){return void 0===r&&(r=""),void 0===o&&(o=""),iM(this,void 0,void 0,(function(){var i,a;return aM(this,(function(u){switch(u.label){case 0:return(i=t.getMenuConfig(e).checkImage)?[4,i(n,r,o)]:[3,2];case 1:if("string"==typeof(a=u.sent()))return t.alert(a,"error"),[2,!1];if(null==a)return[2,!1];u.label=2;case 2:return[2,!0]}}))}))}function R$(e,t,n){return iM(this,void 0,void 0,(function(){var r;return aM(this,(function(o){switch(o.label){case 0:return(r=t.getMenuConfig(e).parseImageSrc)?[4,r(n)]:[3,2];case 1:return[2,o.sent()];case 2:return[2,n]}}))}))}function M$(e,t,n,r){return void 0===n&&(n=""),void 0===r&&(r=""),iM(this,void 0,void 0,(function(){var o,i,a;return aM(this,(function(u){switch(u.label){case 0:return[4,L$("insertImage",e,t,n,r)];case 1:return u.sent()?[4,R$("insertImage",e,t)]:[2];case 2:return o=u.sent(),i={type:"image",src:a$(o),href:r,alt:n,style:{},children:[{text:""}]},null===e.selection&&e.restoreSelection(),QO.getSelectedNodeByType(e,"image")&&e.move(1),z$(e)||(md.insertNodes(e,i),(a=e.getMenuConfig("insertImage").onInsertedImage)&&a(i)),[2]}}))}))}function z$(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||!!sM(Bf.nodes(e,{match:function(t){var n=QO.getNodeType(t);return"code"===n||"pre"===n||"link"===n||"list-item"===n||!!n.startsWith("header")||"blockquote"===n||!!Bf.isVoid(e,t)},universal:!0}),1)[0]}function $$(){return i$("w-e-insert-image")}var H$=function(){function e(){this.title=HP("image.netImage"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>',this.tag="button",this.showModal=!0,this.modalWidth=300,this.$content=null,this.srcInputId=$$(),this.altInputId=$$(),this.hrefInputId=$$(),this.buttonId=$$()}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){},e.prototype.isDisabled=function(e){return z$(e)},e.prototype.getModalPositionNode=function(e){return null},e.prototype.getModalContentElem=function(e){var t=this,n=this,r=n.srcInputId,o=n.altInputId,i=n.hrefInputId,a=n.buttonId,u=sM(S_(HP("image.src"),r),2),s=u[0],l=Mp(u[1]),c=sM(S_(HP("image.desc"),o),2),f=c[0],d=Mp(c[1]),p=sM(S_(HP("image.link"),i),2),h=p[0],g=Mp(p[1]),v=sM(C_(a,HP("common.ok")),1)[0];if(null==this.$content){var y=Mp("<div></div>");y.on("click","#"+a,(function(n){n.preventDefault();var a=y.find("#"+r).val().trim(),u=y.find("#"+o).val().trim(),s=y.find("#"+i).val().trim();t.insertImage(e,a,u,s),e.hidePanelOrModal()})),this.$content=y}var m=this.$content;return m.empty(),m.append(s),m.append(f),m.append(h),m.append(v),l.val(""),d.val(""),g.val(""),setTimeout((function(){l.focus()})),m[0]},e.prototype.insertImage=function(e,t,n,r){void 0===n&&(n=""),void 0===r&&(r=""),t&&(e.restoreSelection(),this.isDisabled(e)||M$(e,t,n,r))},e}(),V$=function(){function e(){this.title=HP("image.delete"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M826.8032 356.5312c-19.328 0-36.3776 15.6928-36.3776 35.0464v524.2624c0 19.328-16 34.56-35.328 34.56H264.9344c-19.328 0-35.5072-15.3088-35.5072-34.56V390.0416c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.6928-33.5104 35.0464V915.712c0 57.9328 44.6208 108.288 102.528 108.288H755.2c57.9328 0 108.0832-50.4576 108.0832-108.288V391.4752c-0.1024-19.2512-17.1264-34.944-36.48-34.944z" p-id="9577"></path><path d="M437.1712 775.7568V390.6048c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.616-33.5104 35.0464v385.152c0 19.328 14.1568 35.0464 33.5104 35.0464s33.5104-15.7184 33.5104-35.0464zM649.7024 775.7568V390.6048c0-19.328-17.0496-35.0464-36.3776-35.0464s-36.3776 15.616-36.3776 35.0464v385.152c0 19.328 17.0496 35.0464 36.3776 35.0464s36.3776-15.7184 36.3776-35.0464zM965.0432 217.0368h-174.6176V145.5104c0-57.9328-47.2064-101.76-104.6528-101.76h-350.976c-57.8304 0-105.3952 43.8528-105.3952 101.76v71.5264H54.784c-19.4304 0-35.0464 14.1568-35.0464 33.5104 0 19.328 15.616 33.5104 35.0464 33.5104h910.3616c19.328 0 35.0464-14.1568 35.0464-33.5104 0-19.3536-15.6928-33.5104-35.1488-33.5104z m-247.3728 0H297.3952V145.5104c0-19.328 18.2016-34.7648 37.4272-34.7648h350.976c19.1488 0 31.872 15.1296 31.872 34.7648v71.5264z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection||null==QO.getSelectedNodeByType(e,"image")},e.prototype.exec=function(e,t){this.isDisabled(e)||md.removeNodes(e,{match:function(e){return QO.checkNodeType(e,"image")}})},e}();function U$(){return i$("w-e-edit-image")}var W$=function(){function e(){this.title=HP("image.edit"),this.iconSvg=jM,this.tag="button",this.showModal=!0,this.modalWidth=300,this.$content=null,this.srcInputId=U$(),this.altInputId=U$(),this.hrefInputId=U$(),this.buttonId=U$()}return e.prototype.getValue=function(e){return""},e.prototype.getImageNode=function(e){return QO.getSelectedNodeByType(e,"image")},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||null==QO.getSelectedNodeByType(e,"image")},e.prototype.getModalPositionNode=function(e){return this.getImageNode(e)},e.prototype.getModalContentElem=function(e){var t=this,n=this,r=n.srcInputId,o=n.altInputId,i=n.hrefInputId,a=n.buttonId,u=this.getImageNode(e);if(null==u)throw new Error("Not found selected image node");var s=sM(S_(HP("image.src"),r),2),l=s[0],c=Mp(s[1]),f=sM(S_(HP("image.desc"),o),2),d=f[0],p=Mp(f[1]),h=sM(S_(HP("image.link"),i),2),g=h[0],v=Mp(h[1]),y=sM(C_(a,HP("common.ok")),1)[0];if(null==this.$content){var m=Mp("<div></div>");m.on("click","#"+a,(function(n){n.preventDefault();var a=m.find("#"+r).val(),u=m.find("#"+o).val(),s=m.find("#"+i).val();t.updateImage(e,a,u,s),e.hidePanelOrModal()})),this.$content=m}var b=this.$content;b.empty(),b.append(l),b.append(d),b.append(g),b.append(y);var w=u,E=w.src,D=w.alt,S=void 0===D?"":D,x=w.href,C=void 0===x?"":x;return c.val(E),p.val(S),v.val(C),setTimeout((function(){c.focus()})),b[0]},e.prototype.updateImage=function(e,t,n,r,o){void 0===n&&(n=""),void 0===r&&(r=""),void 0===o&&(o={}),t&&(e.restoreSelection(),this.isDisabled(e)||function(e,t,n,r,o){void 0===n&&(n=""),void 0===r&&(r=""),void 0===o&&(o={}),iM(this,void 0,void 0,(function(){var i,a,u,s,l,c;return aM(this,(function(f){switch(f.label){case 0:return[4,L$("editImage",e,t,n,r)];case 1:return f.sent()?[4,R$("editImage",e,t)]:[2];case 2:return i=f.sent(),null==(a=QO.getSelectedNodeByType(e,"image"))||(u=a.style,s={src:i,alt:n,href:r,style:oM(oM({},void 0===u?{}:u),o)},md.setNodes(e,s,{match:function(e){return QO.checkNodeType(e,"image")}}),l=QO.getSelectedNodeByType(e,"image"),(c=e.getMenuConfig("editImage").onUpdatedImage)&&c(l)),[2]}}))}))}(e,t,n,r,o))},e}(),G$=function(){function e(){this.title=HP("image.viewLink"),this.iconSvg=NM,this.tag="button"}return e.prototype.getValue=function(e){var t=QO.getSelectedNodeByType(e,"image");return t&&t.href||""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection||!this.getValue(e)},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){if(!t||"string"!=typeof t)throw new Error("View image link failed, image.href is '"+t+"'");window.open(t,"_blank")}},e}(),q$=function(){function e(){this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.getSelectedNode=function(e){return QO.getSelectedNodeByType(e,"image")},e.prototype.isDisabled=function(e){return null==e.selection||null==this.getSelectedNode(e)},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n=this.getSelectedNode(e);if(null!=n){var r=QO.getHoverbar(e);r&&r.hideAndClean();var o=n.style,i={style:oM(oM({},void 0===o?{}:o),{width:this.value,height:""})};md.setNodes(e,i,{match:function(e){return QO.checkNodeType(e,"image")}})}}},e}(),K$=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="30%",t.value="30%",t}return rM(t,e),t}(q$),Y$=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="50%",t.value="50%",t}return rM(t,e),t}(q$),X$=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title="100%",t.value="100%",t}return rM(t,e),t}(q$),Z$={onInsertedImage:function(e){},onUpdatedImage:function(e){},checkImage:function(e,t,n){return!0},parseImageSrc:function(e){return e}},J$={renderElems:[N$],elemsToHtml:[{type:"image",elemToHtml:function(e,t){var n=e,r=n.src,o=n.alt,i=void 0===o?"":o,a=n.href,u=void 0===a?"":a,s=n.style,l=void 0===s?{}:s,c=l.width,f=void 0===c?"":c,d=l.height,p=void 0===d?"":d,h="";return f&&(h+="width: "+f+";"),p&&(h+="height: "+p+";"),'<img src="'+r+'" alt="'+i+'" data-href="'+u+'" style="'+h+'"/>'}}],parseElemsHtml:[I$],menus:[{key:"insertImage",factory:function(){return new H$},config:Z$},{key:"deleteImage",factory:function(){return new V$}},{key:"editImage",factory:function(){return new W$},config:Z$},{key:"viewImageLink",factory:function(){return new G$}},{key:"imageWidth30",factory:function(){return new K$}},{key:"imageWidth50",factory:function(){return new Y$}},{key:"imageWidth100",factory:function(){return new X$}}],editorPlugin:function(e){var t=e.isInline,n=e.isVoid;e.insertNode;var r=e;return r.isInline=function(e){return"image"===e.type||t(e)},r.isVoid=function(e){return"image"===e.type||n(e)},r}},Q$={type:"todo",renderElem:function(e,t,n){var r=!1;n.isDisabled()&&(r=!0);var o=Pg("div",{style:{margin:"5px 0"}},Pg("span",{contentEditable:!1,style:{marginRight:"0.5em"}},Pg("input",{type:"checkbox",checked:e.checked,disabled:r,on:{change:function(t){var r=QO.findPath(n,e),o={checked:t.target.checked};md.setNodes(n,o,{at:r})}}})),Pg("span",null,t));return o}},eH=function(){function e(){this.title=HP("todo.todo"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M278.755556 403.911111l-79.644445 79.644445L455.111111 739.555556l568.888889-568.888889-79.644444-79.644445L455.111111 580.266667l-176.355555-176.355556zM910.222222 910.222222H113.777778V113.777778h568.888889V0H113.777778C51.2 0 0 51.2 0 113.777778v796.444444c0 62.577778 51.2 113.777778 113.777778 113.777778h796.444444c62.577778 0 113.777778-51.2 113.777778-113.777778V455.111111h-113.777778v455.111111z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!!QO.getSelectedNodeByType(e,"todo")},e.prototype.isDisabled=function(e){return null==e.selection||!!QO.getSelectedElems(e).some((function(t){if(Bf.isVoid(e,t)&&Bf.isBlock(e,t))return!0;var n=t.type;return!!["pre","table","list-item"].includes(n)||void 0}))},e.prototype.exec=function(e,t){var n=this.isActive(e);md.setNodes(e,{type:n?"paragraph":"todo"})},e}(),tH={selector:'div[data-w-e-type="todo"]',parseElemHtml:function(e,t,n){var r=Mp(e);0===(t=t.filter((function(e){return!!ed.isText(e)||!!n.isInline(e)}))).length&&(t=[{text:r.text().replace(/\s+/gm," ")}]);var o=!1;return null!=r.find('input[type="checkbox"]').attr("checked")&&(o=!0),{type:"todo",checked:o,children:t}}},nH={renderElems:[Q$],elemsToHtml:[{type:"todo",elemToHtml:function(e,t){return'<div data-w-e-type="todo"><input type="checkbox" disabled '+(e.checked?"checked":"")+">"+t+"</div>"}}],preParseHtml:[{selector:"ul.w-e-todo",preParseHtml:function(e){var t=Mp(e).find("li"),n=Mp('<div data-w-e-type="todo"></div>'),r=t.find("input[type]");return n.append(r),t.children()[0].remove(),n[0].innerHTML=n[0].innerHTML+t[0].innerHTML,n[0]}}],parseElemsHtml:[tH],menus:[{key:"todo",factory:function(){return new eH}}],editorPlugin:function(e){var t=e.deleteBackward,n=e;return n.deleteBackward=function(n){var r=e.selection;if(r&&qf.isCollapsed(r)){var o=QO.getSelectedNodeByType(e,"todo");if(o&&0===Nf.string(o).length)return void md.setNodes(e,{type:"paragraph"},{mode:"highest"})}t(n)},n}},rH={type:"blockquote",renderElem:function(e,t,n){return Pg("blockquote",null,t)}},oH={selector:"blockquote:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e);return 0===(t=t.filter((function(e){return!!ed.isText(e)||!!n.isInline(e)}))).length&&(t=[{text:r.text().replace(/\s+/gm," ")}]),{type:"blockquote",children:t}}},iH=function(){function e(){this.title=HP("blockQuote.title"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M894.6 907.1H605.4c-32.6 0-59-26.4-59-59V608.2l-4-14.9c0-315.9 125.5-485.1 376.5-507.5v59.8C752.7 180.4 711.3 315.8 711.3 442.4v41.2l31.5 12.3h151.8c32.6 0 59 26.4 59 59v293.2c0 32.5-26.4 59-59 59z m-472 0H133.4c-32.6 0-59-26.4-59-59V608.2l-4-14.9c0-315.9 125.5-485.1 376.5-507.5v59.8C280.7 180.4 239.3 315.8 239.3 442.4v41.2l31.5 12.3h151.8c32.6 0 59 26.4 59 59v293.2c0 32.5-26.4 59-59 59z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!!QO.getSelectedNodeByType(e,"blockquote")},e.prototype.isDisabled=function(e){return null==e.selection||!sM(Bf.nodes(e,{match:function(e){var t=QO.getNodeType(e);return"paragraph"===t||"blockquote"===t},universal:!0,mode:"highest"}),1)[0]},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n=this.isActive(e)?"paragraph":"blockquote";md.setNodes(e,{type:n},{mode:"highest"})}},e}(),aH={key:"blockquote",factory:function(){return new iH}},uH=Bj([].slice),sH=uL("slice"),lH=DN("species"),cH=gj.Array,fH=Math.max;LI({target:"Array",proto:!0,forced:!sH},{slice:function(e,t){var n,r,o,i=Rj(this),a=vI(i),u=pI(e,a),s=pI(void 0===t?a:t,a);if(MI(i)&&(n=i.constructor,(QI(n)&&(n===cH||MI(n.prototype))||zj(n)&&null===(n=n[lH]))&&(n=void 0),n===cH||void 0===n))return uH(i,u,s);for(r=new(void 0===n?cH:n)(fH(s-u,0)),o=0;u<s;u++,o++)u in i&&_R(r,o,i[u]);return r.length=o,r}});var dH={renderElems:[rH],elemsToHtml:[{type:"blockquote",elemToHtml:function(e,t){return"<blockquote>"+t+"</blockquote>"}}],parseElemsHtml:[oH],menus:[aH],editorPlugin:function(e){var t=e.insertBreak,n=e.insertText,r=e;return r.insertBreak=function(){var o=r.selection;if(null==o)return t();var i=sM(Bf.nodes(e,{match:function(e){return QO.checkNodeType(e,"blockquote")},universal:!0}),1)[0];if(!i)return t();var a=i[0],u=QO.findPath(e,a),s=Bf.end(e,u);if(Vf.equals(s,o.focus)){var l=Nf.string(a);if(l&&"\n"===l.slice(-1))return e.deleteBackward("character"),void md.insertNodes(r,{type:"paragraph",children:[{text:""}]},{mode:"highest"})}n("\n")},r}},pH=function(){function e(){this.title=HP("emotion.title"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M512 1024C230.4 1024 0 793.6 0 512S230.4 0 512 0s512 230.4 512 512-230.4 512-512 512z m0-102.4c226.742857 0 409.6-182.857143 409.6-409.6S738.742857 102.4 512 102.4 102.4 285.257143 102.4 512s182.857143 409.6 409.6 409.6z m-204.8-358.4h409.6c0 113.371429-91.428571 204.8-204.8 204.8s-204.8-91.428571-204.8-204.8z m0-102.4c-43.885714 0-76.8-32.914286-76.8-76.8s32.914286-76.8 76.8-76.8 76.8 32.914286 76.8 76.8-32.914286 76.8-76.8 76.8z m409.6 0c-43.885714 0-76.8-32.914286-76.8-76.8s32.914286-76.8 76.8-76.8c43.885714 0 76.8 32.914286 76.8 76.8s-32.914286 76.8-76.8 76.8z"></path></svg>',this.tag="button",this.showDropPanel=!0,this.$content=null}return e.prototype.exec=function(e,t){},e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection||!!sM(Bf.nodes(e,{match:function(t){return"pre"===QO.getNodeType(t)||!!Bf.isVoid(e,t)},universal:!0}),1)[0]},e.prototype.getPanelContentElem=function(e){if(null==this.$content){var t=Mp('<ul class="w-e-panel-content-emotion"></ul>');t.on("click","li",(function(t){var n=t.target;if(null!=n){t.preventDefault();var r=Mp(n).text();e.insertText(r)}})),this.$content=t}var n=this.$content;if(null==n)return document.createElement("ul");n.empty();var r=e.getMenuConfig("emotion").emotions;return(void 0===r?[]:r).forEach((function(e){var t=Mp("<li>"+e+"</li>");n.append(t)})),n[0]},e}(),hH={menus:[{key:"emotion",factory:function(){return new pH},config:{emotions:"ð ð ð ð ð ð ð ð¤£ ð ð ð ð ð ð ð ð ð ð ð ð ð ð ð ð¤ ð ð ð ð ð ð ð ð ð£ ð ð« ð© ð¢ ð­ ð¤ ð  ð¡ ð³ ð± ð¨ ð¤ ð¤ ð¶ ð ð¬ ð ð¯ ð´ ð· ð¤ ð ð¤¡ ð© ð» ð ð ð£ ð ð ð ð¤ ð ð ð â ð¤ ð¤ ð¤ âï¸ ð¤ ð ð ð ð ð âï¸ â ð¤ ð ð ð ð¤ ðª ð âï¸ ð".split(" ")}}]},gH={1:"12px",2:"14px",3:"16px",4:"19px",5:"24px",6:"32px",7:"48px"},vH={selector:"font",preParseHtml:function(e){var t=Mp(e);if("font"!==QR(t))return e;var n=t.attr("size")||"";n&&(t.removeAttr("size"),t.css("font-size",gH[n]));var r=t.attr("face")||"";return r&&(t.removeAttr("face"),t.css("font-family",r)),t[0]}},yH=Bj("".indexOf);LI({target:"String",proto:!0,forced:!bz("includes")},{includes:function(e){return!!~yH(dL(Lj(this)),dL(yz(e)),arguments.length>1?arguments[1]:void 0)}});var mH,bH,wH=function(e){return e&&e.Math==Math&&e},EH=wH("object"==typeof globalThis&&globalThis)||wH("object"==typeof window&&window)||wH("object"==typeof self&&self)||wH("object"==typeof cj&&cj)||function(){return this}()||Function("return this")(),DH=Function.prototype,SH=DH.apply,xH=DH.bind,CH=DH.call,AH="object"==typeof Reflect&&Reflect.apply||(xH?CH.bind(SH):function(){return CH.apply(SH,arguments)}),OH=Function.prototype,kH=OH.bind,BH=OH.call,FH=kH&&kH.bind(BH),TH=kH?function(e){return e&&FH(BH,e)}:function(e){return e&&function(){return BH.apply(e,arguments)}},_H=function(e){return"function"==typeof e},PH=function(e){try{return!!e()}catch(e){return!0}},jH=!PH((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),NH=Function.prototype.call,IH=NH.bind?NH.bind(NH):function(){return NH.apply(NH,arguments)},LH={}.propertyIsEnumerable,RH=Object.getOwnPropertyDescriptor,MH=RH&&!LH.call({1:2},1)?function(e){var t=RH(this,e);return!!t&&t.enumerable}:LH,zH={f:MH},$H=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},HH=TH({}.toString),VH=TH("".slice),UH=function(e){return VH(HH(e),8,-1)},WH=EH.Object,GH=TH("".split),qH=PH((function(){return!WH("z").propertyIsEnumerable(0)}))?function(e){return"String"==UH(e)?GH(e,""):WH(e)}:WH,KH=EH.TypeError,YH=function(e){if(null==e)throw KH("Can't call method on "+e);return e},XH=function(e){return qH(YH(e))},ZH=function(e){return"object"==typeof e?null!==e:_H(e)},JH={},QH=function(e){return _H(e)?e:void 0},eV=function(e,t){return arguments.length<2?QH(JH[e])||QH(EH[e]):JH[e]&&JH[e][t]||EH[e]&&EH[e][t]},tV=TH({}.isPrototypeOf),nV=eV("navigator","userAgent")||"",rV=EH.process,oV=EH.Deno,iV=rV&&rV.versions||oV&&oV.version,aV=iV&&iV.v8;aV&&(bH=(mH=aV.split("."))[0]>0&&mH[0]<4?1:+(mH[0]+mH[1])),!bH&&nV&&(!(mH=nV.match(/Edge\/(\d+)/))||mH[1]>=74)&&(mH=nV.match(/Chrome\/(\d+)/))&&(bH=+mH[1]);var uV=bH,sV=!!Object.getOwnPropertySymbols&&!PH((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&uV&&uV<41})),lV=sV&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,cV=EH.Object,fV=lV?function(e){return"symbol"==typeof e}:function(e){var t=eV("Symbol");return _H(t)&&tV(t.prototype,cV(e))},dV=EH.String,pV=EH.TypeError,hV=function(e){if(_H(e))return e;throw pV(function(e){try{return dV(e)}catch(e){return"Object"}}(e)+" is not a function")},gV=EH.TypeError,vV=Object.defineProperty,yV=EH["__core-js_shared__"]||function(e,t){try{vV(EH,e,{value:t,configurable:!0,writable:!0})}catch(n){EH[e]=t}return t}("__core-js_shared__",{}),mV=fj((function(e){(e.exports=function(e,t){return yV[e]||(yV[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"pure",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),bV=EH.Object,wV=function(e){return bV(YH(e))},EV=TH({}.hasOwnProperty),DV=Object.hasOwn||function(e,t){return EV(wV(e),t)},SV=0,xV=Math.random(),CV=TH(1..toString),AV=function(e){return"Symbol("+(void 0===e?"":e)+")_"+CV(++SV+xV,36)},OV=mV("wks"),kV=EH.Symbol,BV=kV&&kV.for,FV=lV?kV:kV&&kV.withoutSetter||AV,TV=function(e){if(!DV(OV,e)||!sV&&"string"!=typeof OV[e]){var t="Symbol."+e;sV&&DV(kV,e)?OV[e]=kV[e]:OV[e]=lV&&BV?BV(t):FV(t)}return OV[e]},_V=EH.TypeError,PV=TV("toPrimitive"),jV=function(e){var t=function(e,t){if(!ZH(e)||fV(e))return e;var n,r,o=null==(n=e[PV])?void 0:hV(n);if(o){if(void 0===t&&(t="default"),r=IH(o,e,t),!ZH(r)||fV(r))return r;throw _V("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&_H(n=e.toString)&&!ZH(r=IH(n,e)))return r;if(_H(n=e.valueOf)&&!ZH(r=IH(n,e)))return r;if("string"!==t&&_H(n=e.toString)&&!ZH(r=IH(n,e)))return r;throw gV("Can't convert object to primitive value")}(e,t)}(e,"string");return fV(t)?t:t+""},NV=EH.document,IV=ZH(NV)&&ZH(NV.createElement),LV=function(e){return IV?NV.createElement(e):{}},RV=!jH&&!PH((function(){return 7!=Object.defineProperty(LV("div"),"a",{get:function(){return 7}}).a})),MV=Object.getOwnPropertyDescriptor,zV={f:jH?MV:function(e,t){if(e=XH(e),t=jV(t),RV)try{return MV(e,t)}catch(e){}if(DV(e,t))return $H(!IH(zH.f,e,t),e[t])}},$V=/#|\.prototype\./,HV=function(e,t){var n=UV[VV(e)];return n==GV||n!=WV&&(_H(t)?PH(t):!!t)},VV=HV.normalize=function(e){return String(e).replace($V,".").toLowerCase()},UV=HV.data={},WV=HV.NATIVE="N",GV=HV.POLYFILL="P",qV=HV,KV=TH(TH.bind),YV=function(e,t){return hV(e),void 0===t?e:KV?KV(e,t):function(){return e.apply(t,arguments)}},XV=EH.String,ZV=EH.TypeError,JV=function(e){if(ZH(e))return e;throw ZV(XV(e)+" is not an object")},QV=EH.TypeError,eU=Object.defineProperty,tU={f:jH?eU:function(e,t,n){if(JV(e),t=jV(t),JV(n),RV)try{return eU(e,t,n)}catch(e){}if("get"in n||"set"in n)throw QV("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},nU=jH?function(e,t,n){return tU.f(e,t,$H(1,n))}:function(e,t,n){return e[t]=n,e},rU=zV.f,oU=function(e){var t=function(n,r,o){if(this instanceof t){switch(arguments.length){case 0:return new e;case 1:return new e(n);case 2:return new e(n,r)}return new e(n,r,o)}return AH(e,this,arguments)};return t.prototype=e.prototype,t},iU=function(e,t){var n,r,o,i,a,u,s,l,c=e.target,f=e.global,d=e.stat,p=e.proto,h=f?EH:d?EH[c]:(EH[c]||{}).prototype,g=f?JH:JH[c]||nU(JH,c,{})[c],v=g.prototype;for(o in t)n=!qV(f?o:c+(d?".":"#")+o,e.forced)&&h&&DV(h,o),a=g[o],n&&(u=e.noTargetGet?(l=rU(h,o))&&l.value:h[o]),i=n&&u?u:t[o],n&&typeof a==typeof i||(s=e.bind&&n?YV(i,EH):e.wrap&&n?oU(i):p&&_H(i)?TH(i):i,(e.sham||i&&i.sham||a&&a.sham)&&nU(s,"sham",!0),nU(g,o,s),p&&(DV(JH,r=c+"Prototype")||nU(JH,r,{}),nU(JH[r],o,i),e.real&&v&&!v[o]&&nU(v,o,i)))},aU=Array.isArray||function(e){return"Array"==UH(e)},uU=Math.ceil,sU=Math.floor,lU=function(e){var t=+e;return t!=t||0===t?0:(t>0?sU:uU)(t)},cU=Math.min,fU=function(e){return(t=e.length)>0?cU(lU(t),9007199254740991):0;// removed by dead control flow
{ var t; }},dU=function(e,t,n){var r=jV(t);r in e?tU.f(e,r,$H(0,n)):e[r]=n},pU={};pU[TV("toStringTag")]="z";var hU="[object z]"===String(pU),gU=TV("toStringTag"),vU=EH.Object,yU="Arguments"==UH(function(){return arguments}()),mU=hU?UH:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=vU(e),gU))?n:yU?UH(t):"Object"==(r=UH(t))&&_H(t.callee)?"Arguments":r},bU=TH(Function.toString);_H(yV.inspectSource)||(yV.inspectSource=function(e){return bU(e)});var wU=yV.inspectSource,EU=function(){},DU=[],SU=eV("Reflect","construct"),xU=/^\s*(?:class|function)\b/,CU=TH(xU.exec),AU=!xU.exec(EU),OU=function(e){if(!_H(e))return!1;try{return SU(EU,DU,e),!0}catch(e){return!1}},kU=!SU||PH((function(){var e;return OU(OU.call)||!OU(Object)||!OU((function(){e=!0}))||e}))?function(e){if(!_H(e))return!1;switch(mU(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return AU||!!CU(xU,wU(e))}:OU,BU=TV("species"),FU=EH.Array,TU=function(e,t){return new(function(e){var t;return aU(e)&&(t=e.constructor,(kU(t)&&(t===FU||aU(t.prototype))||ZH(t)&&null===(t=t[BU]))&&(t=void 0)),void 0===t?FU:t}(e))(0===t?0:t)},_U=TV("species"),PU=TV("isConcatSpreadable"),jU=EH.TypeError,NU=uV>=51||!PH((function(){var e=[];return e[PU]=!1,e.concat()[0]!==e})),IU=uV>=51||!PH((function(){var e=[];return(e.constructor={})[_U]=function(){return{foo:1}},1!==e.concat(Boolean).foo})),LU=function(e){if(!ZH(e))return!1;var t=e[PU];return void 0!==t?!!t:aU(e)};iU({target:"Array",proto:!0,forced:!NU||!IU},{concat:function(e){var t,n,r,o,i,a=wV(this),u=TU(a,0),s=0;for(t=-1,r=arguments.length;t<r;t++)if(LU(i=-1===t?a:arguments[t])){if(s+(o=fU(i))>9007199254740991)throw jU("Maximum allowed index exceeded");for(n=0;n<o;n++,s++)n in i&&dU(u,s,i[n])}else{if(s>=9007199254740991)throw jU("Maximum allowed index exceeded");dU(u,s++,i)}return u.length=s,u}});var RU,MU=EH.String,zU=function(e){if("Symbol"===mU(e))throw TypeError("Cannot convert a Symbol value to a string");return MU(e)},$U=Math.max,HU=Math.min,VU=function(e,t){var n=lU(e);return n<0?$U(n+t,0):HU(n,t)},UU=function(e){return function(t,n,r){var o,i=XH(t),a=fU(i),u=VU(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},WU={includes:UU(!0),indexOf:UU(!1)},GU={},qU=WU.indexOf,KU=TH([].push),YU=function(e,t){var n,r=XH(e),o=0,i=[];for(n in r)!DV(GU,n)&&DV(r,n)&&KU(i,n);for(;t.length>o;)DV(r,n=t[o++])&&(~qU(i,n)||KU(i,n));return i},XU=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],ZU=Object.keys||function(e){return YU(e,XU)},JU=jH?Object.defineProperties:function(e,t){JV(e);for(var n,r=XH(t),o=ZU(t),i=o.length,a=0;i>a;)tU.f(e,n=o[a++],r[n]);return e},QU=eV("document","documentElement"),eW=mV("keys"),tW=function(e){return eW[e]||(eW[e]=AV(e))},nW=tW("IE_PROTO"),rW=function(){},oW=function(e){return"<script>"+e+"<\/script>"},iW=function(e){e.write(oW("")),e.close();var t=e.parentWindow.Object;return e=null,t},aW=function(){try{RU=new ActiveXObject("htmlfile")}catch(e){}var e,t;aW="undefined"!=typeof document?document.domain&&RU?iW(RU):((t=LV("iframe")).style.display="none",QU.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(oW("document.F=Object")),e.close(),e.F):iW(RU);for(var n=XU.length;n--;)delete aW.prototype[XU[n]];return aW()};GU[nW]=!0;var uW,sW,lW,cW=Object.create||function(e,t){var n;return null!==e?(rW.prototype=JV(e),n=new rW,rW.prototype=null,n[nW]=e):n=aW(),void 0===t?n:JU(n,t)},fW=XU.concat("length","prototype"),dW={f:Object.getOwnPropertyNames||function(e){return YU(e,fW)}},pW=EH.Array,hW=Math.max,gW=dW.f,vW="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],yW={f:function(e){return vW&&"Window"==UH(e)?function(e){try{return gW(e)}catch(e){return function(e,t,n){for(var r=fU(e),o=VU(void 0,r),i=VU(r,r),a=pW(hW(i-o,0)),u=0;o<i;o++,u++)dU(a,u,e[o]);return a.length=u,a}(vW)}}(e):gW(XH(e))}},mW={f:Object.getOwnPropertySymbols},bW=TH([].slice),wW=function(e,t,n,r){r&&r.enumerable?e[t]=n:nU(e,t,n)},EW={f:TV},DW=tU.f,SW=function(e){var t=JH.Symbol||(JH.Symbol={});DV(t,e)||DW(t,e,{value:EW.f(e)})},xW=hU?{}.toString:function(){return"[object "+mU(this)+"]"},CW=tU.f,AW=TV("toStringTag"),OW=function(e,t,n,r){if(e){var o=n?e:e.prototype;DV(o,AW)||CW(o,AW,{configurable:!0,value:t}),r&&!hU&&nU(o,"toString",xW)}},kW=EH.WeakMap,BW=_H(kW)&&/native code/.test(wU(kW)),FW=EH.TypeError,TW=EH.WeakMap;if(BW||yV.state){var _W=yV.state||(yV.state=new TW),PW=TH(_W.get),jW=TH(_W.has),NW=TH(_W.set);uW=function(e,t){if(jW(_W,e))throw new FW("Object already initialized");return t.facade=e,NW(_W,e,t),t},sW=function(e){return PW(_W,e)||{}},lW=function(e){return jW(_W,e)}}else{var IW=tW("state");GU[IW]=!0,uW=function(e,t){if(DV(e,IW))throw new FW("Object already initialized");return t.facade=e,nU(e,IW,t),t},sW=function(e){return DV(e,IW)?e[IW]:{}},lW=function(e){return DV(e,IW)}}var LW={set:uW,get:sW,has:lW,enforce:function(e){return lW(e)?sW(e):uW(e,{})},getterFor:function(e){return function(t){var n;if(!ZH(t)||(n=sW(t)).type!==e)throw FW("Incompatible receiver, "+e+" required");return n}}},RW=TH([].push),MW=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=wV(s),g=qH(h),v=YV(l,c),y=fU(g),m=0,b=f||TU,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:RW(w,d)}else switch(e){case 4:return!1;case 7:RW(w,d)}return i?-1:r||o?o:w}},zW=[MW(0),MW(1),MW(2),MW(3),MW(4),MW(5),MW(6),MW(7)][0],$W=tW("hidden"),HW=TV("toPrimitive"),VW=LW.set,UW=LW.getterFor("Symbol"),WW=Object.prototype,GW=EH.Symbol,qW=GW&&GW.prototype,KW=EH.TypeError,YW=EH.QObject,XW=eV("JSON","stringify"),ZW=zV.f,JW=tU.f,QW=yW.f,eG=zH.f,tG=TH([].push),nG=mV("symbols"),rG=mV("op-symbols"),oG=mV("string-to-symbol-registry"),iG=mV("symbol-to-string-registry"),aG=mV("wks"),uG=!YW||!YW.prototype||!YW.prototype.findChild,sG=jH&&PH((function(){return 7!=cW(JW({},"a",{get:function(){return JW(this,"a",{value:7}).a}})).a}))?function(e,t,n){var r=ZW(WW,t);r&&delete WW[t],JW(e,t,n),r&&e!==WW&&JW(WW,t,r)}:JW,lG=function(e,t){var n=nG[e]=cW(qW);return VW(n,{type:"Symbol",tag:e,description:t}),jH||(n.description=t),n},cG=function(e,t,n){e===WW&&cG(rG,t,n),JV(e);var r=jV(t);return JV(n),DV(nG,r)?(n.enumerable?(DV(e,$W)&&e[$W][r]&&(e[$W][r]=!1),n=cW(n,{enumerable:$H(0,!1)})):(DV(e,$W)||JW(e,$W,$H(1,{})),e[$W][r]=!0),sG(e,r,n)):JW(e,r,n)},fG=function(e,t){JV(e);var n=XH(t),r=ZU(n).concat(gG(n));return zW(r,(function(t){jH&&!IH(dG,n,t)||cG(e,t,n[t])})),e},dG=function(e){var t=jV(e),n=IH(eG,this,t);return!(this===WW&&DV(nG,t)&&!DV(rG,t))&&(!(n||!DV(this,t)||!DV(nG,t)||DV(this,$W)&&this[$W][t])||n)},pG=function(e,t){var n=XH(e),r=jV(t);if(n!==WW||!DV(nG,r)||DV(rG,r)){var o=ZW(n,r);return!o||!DV(nG,r)||DV(n,$W)&&n[$W][r]||(o.enumerable=!0),o}},hG=function(e){var t=QW(XH(e)),n=[];return zW(t,(function(e){DV(nG,e)||DV(GU,e)||tG(n,e)})),n},gG=function(e){var t=e===WW,n=QW(t?rG:XH(e)),r=[];return zW(n,(function(e){!DV(nG,e)||t&&!DV(WW,e)||tG(r,nG[e])})),r};if(sV||(qW=(GW=function(){if(tV(qW,this))throw KW("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?zU(arguments[0]):void 0,t=AV(e),n=function(e){this===WW&&IH(n,rG,e),DV(this,$W)&&DV(this[$W],t)&&(this[$W][t]=!1),sG(this,t,$H(1,e))};return jH&&uG&&sG(WW,t,{configurable:!0,set:n}),lG(t,e)}).prototype,wW(qW,"toString",(function(){return UW(this).tag})),wW(GW,"withoutSetter",(function(e){return lG(AV(e),e)})),zH.f=dG,tU.f=cG,zV.f=pG,dW.f=yW.f=hG,mW.f=gG,EW.f=function(e){return lG(TV(e),e)},jH&&JW(qW,"description",{configurable:!0,get:function(){return UW(this).description}})),iU({global:!0,wrap:!0,forced:!sV,sham:!sV},{Symbol:GW}),zW(ZU(aG),(function(e){SW(e)})),iU({target:"Symbol",stat:!0,forced:!sV},{for:function(e){var t=zU(e);if(DV(oG,t))return oG[t];var n=GW(t);return oG[t]=n,iG[n]=t,n},keyFor:function(e){if(!fV(e))throw KW(e+" is not a symbol");if(DV(iG,e))return iG[e]},useSetter:function(){uG=!0},useSimple:function(){uG=!1}}),iU({target:"Object",stat:!0,forced:!sV,sham:!jH},{create:function(e,t){return void 0===t?cW(e):fG(cW(e),t)},defineProperty:cG,defineProperties:fG,getOwnPropertyDescriptor:pG}),iU({target:"Object",stat:!0,forced:!sV},{getOwnPropertyNames:hG,getOwnPropertySymbols:gG}),iU({target:"Object",stat:!0,forced:PH((function(){mW.f(1)}))},{getOwnPropertySymbols:function(e){return mW.f(wV(e))}}),XW){var vG=!sV||PH((function(){var e=GW();return"[null]"!=XW([e])||"{}"!=XW({a:e})||"{}"!=XW(Object(e))}));iU({target:"JSON",stat:!0,forced:vG},{stringify:function(e,t,n){var r=bW(arguments),o=t;if((ZH(t)||void 0!==e)&&!fV(e))return aU(t)||(t=function(e,t){if(_H(o)&&(t=IH(o,this,e,t)),!fV(t))return t}),r[1]=t,AH(XW,null,r)}})}if(!qW[HW]){var yG=qW.valueOf;wW(qW,HW,(function(e){return IH(yG,this)}))}OW(GW,"Symbol"),GU[$W]=!0,SW("asyncIterator"),SW("hasInstance"),SW("isConcatSpreadable"),SW("iterator"),SW("match"),SW("matchAll"),SW("replace"),SW("search"),SW("species"),SW("split"),SW("toPrimitive"),SW("toStringTag"),SW("unscopables"),OW(EH.JSON,"JSON",!0);var mG,bG,wG,EG=JH.Symbol,DG={},SG=Function.prototype,xG=jH&&Object.getOwnPropertyDescriptor,CG=DV(SG,"name"),AG={EXISTS:CG,PROPER:CG&&"something"===function(){}.name,CONFIGURABLE:CG&&(!jH||jH&&xG(SG,"name").configurable)},OG=!PH((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),kG=tW("IE_PROTO"),BG=EH.Object,FG=BG.prototype,TG=OG?BG.getPrototypeOf:function(e){var t=wV(e);if(DV(t,kG))return t[kG];var n=t.constructor;return _H(n)&&t instanceof n?n.prototype:t instanceof BG?FG:null},_G=TV("iterator"),PG=!1;[].keys&&("next"in(wG=[].keys())?(bG=TG(TG(wG)))!==Object.prototype&&(mG=bG):PG=!0);var jG=null==mG||PH((function(){var e={};return mG[_G].call(e)!==e}));mG=jG?{}:cW(mG),_H(mG[_G])||wW(mG,_G,(function(){return this}));var NG={IteratorPrototype:mG,BUGGY_SAFARI_ITERATORS:PG},IG=NG.IteratorPrototype,LG=function(){return this};EH.String,EH.TypeError,Object.setPrototypeOf||"__proto__"in{}&&function(){var e={};try{TH(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set)(e,[]),e instanceof Array}catch(e){}}();var RG=AG.PROPER,MG=NG.BUGGY_SAFARI_ITERATORS,zG=TV("iterator"),$G=function(){return this},HG=function(e,t,n,r,o,i,a){!function(e,t,n,r){var o=t+" Iterator";e.prototype=cW(IG,{next:$H(1,n)}),OW(e,o,!1,!0),DG[o]=LG}(n,t,r);var u,s,l,c=function(e){if(e===o&&g)return g;if(!MG&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[zG]||p["@@iterator"]||o&&p[o],g=!MG&&h||c(o),v="Array"==t&&p.entries||h;if(v&&(u=TG(v.call(new e)))!==Object.prototype&&u.next&&(OW(u,f,!0,!0),DG[f]=$G),RG&&"values"==o&&h&&"values"!==h.name&&(d=!0,g=function(){return IH(h,this)}),o)if(s={values:c("values"),keys:i?g:c("keys"),entries:c("entries")},a)for(l in s)(MG||d||!(l in p))&&wW(p,l,s[l]);else iU({target:t,proto:!0,forced:MG||d},s);return a&&p[zG]!==g&&wW(p,zG,g,{name:o}),DG[t]=g,s},VG=LW.set,UG=LW.getterFor("Array Iterator");HG(Array,"Array",(function(e,t){VG(this,{type:"Array Iterator",target:XH(e),index:0,kind:t})}),(function(){var e=UG(this),t=e.target,n=e.kind,r=e.index++;return!t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values"),DG.Arguments=DG.Array;var WG=TV("toStringTag");for(var GG in{CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}){var qG=EH[GG],KG=qG&&qG.prototype;KG&&mU(KG)!==WG&&nU(KG,WG,GG),DG[GG]=DG.Array}var YG=EG;SW("asyncDispose"),SW("dispose"),SW("matcher"),SW("metadata"),SW("observable"),SW("patternMatch"),SW("replaceAll");var XG=YG,ZG=TH("".charAt),JG=TH("".charCodeAt),QG=TH("".slice),eq=function(e){return function(t,n){var r,o,i=zU(YH(t)),a=lU(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=JG(i,a))<55296||r>56319||a+1===u||(o=JG(i,a+1))<56320||o>57343?e?ZG(i,a):r:e?QG(i,a,a+2):o-56320+(r-55296<<10)+65536}},tq=(eq(!1),eq(!0)),nq=LW.set,rq=LW.getterFor("String Iterator");HG(String,"String",(function(e){nq(this,{type:"String Iterator",string:zU(e),index:0})}),(function(){var e,t=rq(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=tq(n,r),t.index+=e.length,{value:e,done:!1})}));var oq=EW.f("iterator"),iq=fj((function(e){function t(n){return"function"==typeof XG&&"symbol"==typeof oq?(e.exports=t=function(e){return typeof e},e.exports.default=e.exports,e.exports.__esModule=!0):(e.exports=t=function(e){return e&&"function"==typeof XG&&e.constructor===XG&&e!==XG.prototype?"symbol":typeof e},e.exports.default=e.exports,e.exports.__esModule=!0),t(n)}e.exports=t,e.exports.default=e.exports,e.exports.__esModule=!0})),aq=function(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}(iq),uq=aI.EXISTS,sq=LN.f,lq=Function.prototype,cq=Bj(lq.toString),fq=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,dq=Bj(fq.exec);yj&&!uq&&sq(lq,"name",{configurable:!0,get:function(){try{return dq(fq,cq(this))[1]}catch(e){return""}}});var pq=function(){function e(){this.tag="select",this.width=80}return e.prototype.isActive=function(e){return!1},e.prototype.getValue=function(e){var t=this.mark,n=Bf.marks(e);return n&&n[t]?n[t]:""},e.prototype.isDisabled=function(e){return null==e.selection||(this.mark,!!sM(Bf.nodes(e,{match:function(t){return"pre"===QO.getNodeType(t)||!!Bf.isVoid(e,t)},universal:!0}),1)[0])},e.prototype.exec=function(e,t){var n=this.mark;t?e.addMark(n,t):e.removeMark(n)},e}(),hq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("fontSize.title"),t.iconSvg=RM,t.mark="fontSize",t}return rM(t,e),t.prototype.getOptions=function(e){var t=[],n=e.getMenuConfig(this.mark).fontSizeList,r=void 0===n?[]:n;t.push({text:HP("fontSize.default"),value:""}),r.forEach((function(e){if("string"==typeof e)t.push({text:e,value:e});else if("object"===aq(e)){var n=e.name,r=e.value;t.push({text:n,value:r})}}));var o=this.getValue(e);return t.forEach((function(e){e.value===o?e.selected=!0:delete e.selected})),t},t}(pq),gq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("fontFamily.title"),t.iconSvg=MM,t.mark="fontFamily",t.selectPanelWidth=150,t}return rM(t,e),t.prototype.getOptions=function(e){var t=[],n=e.getMenuConfig(this.mark).fontFamilyList,r=void 0===n?[]:n;t.push({text:HP("fontFamily.default"),value:""}),r.forEach((function(e){if("string"==typeof e)t.push({text:e,value:e,styleForRenderMenuList:{"font-family":e}});else if("object"===aq(e)){var n=e.name,r=e.value;t.push({text:n,value:r,styleForRenderMenuList:{"font-family":r}})}}));var o=this.getValue(e);return t.forEach((function(e){e.value===o?e.selected=!0:delete e.selected})),t},t}(pq),vq={renderStyle:function(e,t){var n=e,r=n.fontSize,o=n.fontFamily,i=t;return r&&Kz(i,{fontSize:r}),o&&Kz(i,{fontFamily:o}),i},styleToHtml:function(e,t){if(!ed.isText(e))return t;var n,r=e,o=r.fontSize,i=r.fontFamily;return o||i?((ZR(t)||"span"!==QR(n=Mp(t)))&&(n=Mp("<span>"+t+"</span>")),o&&n.css("font-size",o),i&&n.css("font-family",i),JR(n)):t},preParseHtml:[vH],parseStyleHtml:function(e,t,n){var r=Mp(e);if(!ed.isText(t))return t;var o=t,i=n.getMenuConfig("fontSize").fontSizeList,a=void 0===i?[]:i,u=eM(r,"font-size"),s=a.find((function(e){return e.value&&e.value===u}))||a.includes(u);u&&s&&(o.fontSize=u);var l=n.getMenuConfig("fontFamily").fontFamilyList,c=void 0===l?[]:l,f=eM(r,"font-family").replace(/"/g,""),d=c.find((function(e){return e.value&&e.value===f}))||c.includes(f);return f&&d&&(o.fontFamily=f),o},menus:[{key:"fontSize",factory:function(){return new hq},config:{fontSizeList:["12px",{name:"13px",value:"13px"},"14px","15px","16px","19px",{name:"22px",value:"22px"},"24px","29px","32px","40px","48px"]}},{key:"fontFamily",factory:function(){return new gq},config:{fontFamilyList:["é»ä½",{name:"ä»¿å®",value:"ä»¿å®"},"æ¥·ä½","æ æ¥·ä½","åæä»¿å®","åææ¥·ä½",{name:"å®ä½",value:"å®ä½"},"å¾®è½¯éé»","Arial","Tahoma","Verdana","Times New Roman","Courier New"]}}]},yq={selector:"p,h1,h2,h3,h4,h5",preParseHtml:function(e){var t=Mp(e),n=eM(t,"padding-left");return/\dem/.test(n)&&t.css("text-indent","2em"),/\dpx/.test(n)&&parseInt(n,10)%32==0&&t.css("text-indent","2em"),t[0]}},mq=function(){function e(){this.tag="button"}return e.prototype.getValue=function(e){var t=sM(Bf.nodes(e,{match:function(e){return!!e.indent},universal:!0}),1),n=t[0];return null==n?"":sM(n,1)[0].indent||""},e.prototype.isActive=function(e){return!1},e.prototype.getMatchNode=function(e){var t=sM(Bf.nodes(e,{match:function(e){var t=QO.getNodeType(e);return"paragraph"===t||!!t.startsWith("header")},universal:!0,mode:"highest"}),1)[0];return null==t?null:t[0]},e}(),bq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("indent.decrease"),t.iconSvg=zM,t}return rM(t,e),t.prototype.isDisabled=function(e){var t=this.getMatchNode(e);return null==t||!t.indent},t.prototype.exec=function(e,t){md.setNodes(e,{indent:null},{match:function(e){return Sf.isElement(e)}})},t}(mq),wq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("indent.increase"),t.iconSvg=$M,t}return rM(t,e),t.prototype.isDisabled=function(e){var t=this.getMatchNode(e);return null==t||!!t.indent},t.prototype.exec=function(e,t){md.setNodes(e,{indent:"2em"},{match:function(e){return Sf.isElement(e)},mode:"highest"})},t}(mq),Eq={renderStyle:function(e,t){if(!Sf.isElement(e))return t;var n=e.indent,r=t;return n&&Kz(r,{textIndent:n}),r},styleToHtml:function(e,t){if(!Sf.isElement(e))return t;var n=e.indent;if(!n)return t;var r=Mp(t);return r.css("text-indent",n),JR(r)},preParseHtml:[yq],parseStyleHtml:function(e,t,n){var r=Mp(e);if(!Sf.isElement(t))return t;var o=t,i=eM(r,"text-indent"),a=parseInt(i,10);return i&&a>0&&(o.indent=i),o},menus:[{key:"indent",factory:function(){return new wq}},{key:"delIndent",factory:function(){return new bq}}]},Dq=function(){function e(){this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.getMatchNode=function(e){var t=sM(Bf.nodes(e,{match:function(e){var t=QO.getNodeType(e);return"paragraph"===t||"blockquote"===t||!!t.startsWith("header")},universal:!0,mode:"highest"}),1)[0];return null==t?null:t[0]},e.prototype.isDisabled=function(e){return null==e.selection||!!QO.getSelectedElems(e).some((function(t){if(Bf.isVoid(e,t)&&Bf.isBlock(e,t))return!0;var n=t.type;return!!["pre","code"].includes(n)||void 0}))},e}(),Sq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("justify.left"),t.iconSvg=HM,t}return rM(t,e),t.prototype.exec=function(e,t){md.setNodes(e,{textAlign:"left"},{match:function(t){return Sf.isElement(t)&&!e.isInline(t)}})},t}(Dq),xq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("justify.right"),t.iconSvg=VM,t}return rM(t,e),t.prototype.exec=function(e,t){md.setNodes(e,{textAlign:"right"},{match:function(t){return Sf.isElement(t)&&!e.isInline(t)}})},t}(Dq),Cq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("justify.center"),t.iconSvg=UM,t}return rM(t,e),t.prototype.exec=function(e,t){md.setNodes(e,{textAlign:"center"},{match:function(t){return Sf.isElement(t)&&!e.isInline(t)}})},t}(Dq),Aq=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.title=HP("justify.justify"),t.iconSvg=WM,t}return rM(t,e),t.prototype.exec=function(e,t){md.setNodes(e,{textAlign:"justify"},{match:function(t){return Sf.isElement(t)&&!e.isInline(t)}})},t}(Dq),Oq={renderStyle:function(e,t){if(!Sf.isElement(e))return t;var n=e.textAlign,r=t;return n&&Kz(r,{textAlign:n}),r},styleToHtml:function(e,t){if(!Sf.isElement(e))return t;var n=e.textAlign;if(!n)return t;var r=Mp(t);return r.css("text-align",n),JR(r)},parseStyleHtml:function(e,t,n){var r=Mp(e);if(!Sf.isElement(t))return t;var o=t,i=eM(r,"text-align");return i&&(o.textAlign=i),o},menus:[{key:"justifyLeft",factory:function(){return new Sq}},{key:"justifyRight",factory:function(){return new xq}},{key:"justifyCenter",factory:function(){return new Cq}},{key:"justifyJustify",factory:function(){return new Aq}}]},kq=function(){function e(){this.title=HP("lineHeight.title"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M964 788a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526zM198.93 144.306c6.668-5.798 16.774-5.094 22.573 1.574l122.26 140.582a16 16 0 0 1 3.927 10.5c0 8.836-7.164 16-16 16h-61.8a8 8 0 0 0-8 8v390.077h69.819a16 16 0 0 1 10.502 3.928c6.666 5.8 7.37 15.906 1.57 22.573L221.476 878.123a16 16 0 0 1-1.57 1.57c-6.668 5.8-16.774 5.097-22.574-1.57L75.051 737.538a16 16 0 0 1-3.928-10.5c0-8.837 7.163-16 16-16h69.822V312.96H87.127a16 16 0 0 1-10.502-3.928c-6.666-5.8-7.37-15.906-1.57-22.573l122.303-140.582a16 16 0 0 1 1.572-1.572zM964 465a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526z m0-323a8 8 0 0 1 8 8v98a8 8 0 0 1-8 8H438a8 8 0 0 1-8-8v-98a8 8 0 0 1 8-8h526z"></path></svg>',this.tag="select",this.width=80}return e.prototype.getOptions=function(e){var t=[],n=e.getMenuConfig("lineHeight").lineHeightList,r=void 0===n?[]:n;t.push({text:HP("lineHeight.default"),value:""}),r.forEach((function(e){t.push({text:e,value:e})}));var o=this.getValue(e);return t.forEach((function(e){e.value===o?e.selected=!0:delete e.selected})),t},e.prototype.getMatchNode=function(e){var t=sM(Bf.nodes(e,{match:function(e){var t=QO.getNodeType(e);return!!t.startsWith("header")||!!["paragraph","blockquote","list-item"].includes(t)},universal:!0,mode:"highest"}),1)[0];return null==t?null:t[0]},e.prototype.isActive=function(e){return!1},e.prototype.getValue=function(e){var t=this.getMatchNode(e);return null==t?"":Sf.isElement(t)&&t.lineHeight||""},e.prototype.isDisabled=function(e){return null==e.selection||null==this.getMatchNode(e)},e.prototype.exec=function(e,t){md.setNodes(e,{lineHeight:t.toString()},{mode:"highest"})},e}(),Bq={renderStyle:function(e,t){if(!Sf.isElement(e))return t;var n=e.lineHeight,r=t;return n&&Kz(r,{lineHeight:n}),r},styleToHtml:function(e,t){if(!Sf.isElement(e))return t;var n=e.lineHeight;if(!n)return t;var r=Mp(t);return r.css("line-height",n),JR(r)},parseStyleHtml:function(e,t,n){var r=Mp(e);if(!Sf.isElement(t))return t;var o=t,i=n.getMenuConfig("lineHeight").lineHeightList,a=void 0===i?[]:i,u=eM(r,"line-height");return u&&a.includes(u)&&(o.lineHeight=u),o},menus:[{key:"lineHeight",factory:function(){return new kq},config:{lineHeightList:["1","1.15","1.5","2","2.5","3"]}}]},Fq=function(){function e(){this.title=HP("undo.redo"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M0.00032 576a510.72 510.72 0 0 0 173.344 384l84.672-96A383.136 383.136 0 0 1 128.00032 576C128.00032 363.936 299.93632 192 512.00032 192c106.048 0 202.048 42.976 271.52 112.48L640.00032 448h384V64l-149.984 149.984A510.272 510.272 0 0 0 512.00032 64C229.21632 64 0.00032 293.216 0.00032 576z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection},e.prototype.exec=function(e,t){"function"==typeof e.redo&&e.redo()},e}(),Tq=function(){function e(){this.title=HP("undo.undo"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M512 64A510.272 510.272 0 0 0 149.984 213.984L0.032 64v384h384L240.512 304.48A382.784 382.784 0 0 1 512.032 192c212.064 0 384 171.936 384 384 0 114.688-50.304 217.632-130.016 288l84.672 96a510.72 510.72 0 0 0 173.344-384c0-282.784-229.216-512-512-512z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection},e.prototype.exec=function(e,t){"function"==typeof e.undo&&e.undo()},e}(),_q={menus:[{key:"redo",factory:function(){return new Fq}},{key:"undo",factory:function(){return new Tq}}]},Pq={type:"divider",renderElem:function(e,t,n){return pg("div",{props:{contentEditable:!1,className:"w-e-textarea-divider"},dataset:{selected:QO.isNodeSelected(n,e)?"true":""},style:{},on:{mousedown:function(e){return e.preventDefault()}}},[pg("hr")])}},jq=function(){function e(){this.title=HP("divider.title"),this.iconSvg='<svg viewBox="0 0 1092 1024"><path d="M0 51.2m51.2 0l989.866667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-989.866667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M0 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M819.2 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M409.6 460.8m51.2 0l170.666667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-170.666667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path><path d="M0 870.4m51.2 0l989.866667 0q51.2 0 51.2 51.2l0 0q0 51.2-51.2 51.2l-989.866667 0q-51.2 0-51.2-51.2l0 0q0-51.2 51.2-51.2Z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection||!!QO.getSelectedElems(e).some((function(t){if(e.isVoid(t))return!0;var n=QO.getNodeType(t);return"table"===n||"pre"===n||void 0}))},e.prototype.exec=function(e,t){md.insertNodes(e,{type:"divider",children:[{text:""}]},{mode:"highest"})},e}(),Nq={renderElems:[Pq],elemsToHtml:[{type:"divider",elemToHtml:function(e,t){return"<hr/>"}}],parseElemsHtml:[{selector:"hr:not([data-w-e-type])",parseElemHtml:function(e,t,n){return{type:"divider",children:[{text:""}]}}}],menus:[{key:"divider",factory:function(){return new jq}}],editorPlugin:function(e){var t=e.isVoid,n=e.normalizeNode,r=e;return r.isVoid=function(e){return"divider"===e.type||t(e)},r.normalizeNode=function(e){var t=sM(e,2),o=t[0],i=t[1];if("divider"!==QO.getNodeType(o))return n([o,i]);QO.isLastNode(r,o)&&md.insertNodes(r,QO.genEmptyParagraph(),{at:[i[0]+1]})},r}},Iq=iL.map;LI({target:"Array",proto:!0,forced:!uL("map")},{map:function(e){return Iq(this,e,arguments.length>1?arguments[1]:void 0)}});var Lq=Bj([].join),Rq=Nj!=Object,Mq=EM("join",",");LI({target:"Array",proto:!0,forced:Rq||!Mq},{join:function(e){return Lq(Rj(this),void 0===e?",":e)}});var zq=function(){function e(){this.title=HP("codeBlock.title"),this.iconSvg='<svg viewBox="0 0 1280 1024"><path d="M832 736l96 96 320-320L928 192l-96 96 224 224zM448 288l-96-96L32 512l320 320 96-96-224-224zM701.312 150.528l69.472 18.944-192 704.032-69.472-18.944 192-704.032z"></path></svg>',this.tag="button"}return e.prototype.getSelectCodeElem=function(e){var t=QO.getSelectedNodeByType(e,"code");if(null==t)return null;var n=QO.getParentNode(e,t);return null==n||"pre"!==QO.getNodeType(n)?null:t},e.prototype.getValue=function(e){var t=this.getSelectCodeElem(e);return null==t?"":t.language||""},e.prototype.isActive=function(e){return!!this.getSelectCodeElem(e)},e.prototype.isDisabled=function(e){if(null==e.selection)return!0;var t=QO.getSelectedElems(e);return!!t.some((function(t){return e.isVoid(t)}))||!t.some((function(e){var t=QO.getNodeType(e);if("pre"===t||"paragraph"===t)return!0}))},e.prototype.exec=function(e,t){this.isActive(e)?this.changeToPlainText(e):this.changeToCodeBlock(e,t.toString())},e.prototype.changeToPlainText=function(e){var t=this.getSelectCodeElem(e);if(null!=t){var n=Nf.string(t);md.removeNodes(e,{mode:"highest"});var r=n.split("\n").map((function(e){return{type:"paragraph",children:[{text:e}]}}));md.insertNodes(e,r,{mode:"highest"})}},e.prototype.changeToCodeBlock=function(e,t){var n,r,o=[],i=Bf.nodes(e,{match:function(t){return e.children.includes(t)},universal:!0});try{for(var a=uM(i),u=a.next();!u.done;u=a.next()){var s=sM(u.value,1)[0];s&&o.push(Nf.string(s))}}catch(e){n={error:e}}finally{try{u&&!u.done&&(r=a.return)&&r.call(a)}finally{if(n)throw n.error}}md.removeNodes(e,{mode:"highest"});var l={type:"pre",children:[{type:"code",language:t,children:[{text:o.join("\n")}]}]};md.insertNodes(e,l,{mode:"highest"})},e}(),$q={key:"codeBlock",factory:function(){return new zq}};LI({target:"String",proto:!0,forced:hM("anchor")},{anchor:function(e){return pM(this,"a","name",e)}}),JL("match",(function(e,t,n){return[function(t){var n=Lj(this),r=null==t?void 0:oN(t,e);return r?bj(r,t,n):new RegExp(t)[e](dL(n))},function(e){var r=jN(this),o=dL(e),i=n(t,r,o);if(i.done)return i.value;if(!r.global)return pR(r,o);var a=r.unicode;r.lastIndex=0;for(var u,s=[],l=0;null!==(u=pR(r,o));){var c=dL(u[0]);s[l]=c,""===c&&(r.lastIndex=oR(o,gI(r.lastIndex),a)),l++}return 0===l?null:s}]}));var Hq={type:"pre",renderElem:function(e,t,n){return Pg("pre",null,t)}},Vq={type:"code",renderElem:function(e,t,n){return Pg("code",null,t)}},Uq={selector:"pre:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e);return 0===(t=t.filter((function(e){return"code"===QO.getNodeType(e)}))).length&&(t=[{type:"code",language:"",children:[{text:r[0].textContent||""}]}]),{type:"pre",children:t.filter((function(e){return"code"===QO.getNodeType(e)}))}}},Wq={menus:[$q],editorPlugin:function(e){var t=e.insertBreak,n=e.normalizeNode,r=e.insertData;e.insertNode;var o=e;return o.insertBreak=function(){var e=QO.getSelectedNodeByType(o,"code");if(null!=e){var n=function(e,t){var n=t.selection;if(null==n)return"";var r=Nf.string(e),o=n.anchor.offset,i=r.slice(0,o).split("\n"),a=i.length;return 0===a?"":i[a-1]}(e,o);if(n){var r=n.match(/^\s+/);if(null!=r&&null!=r[0]){var i=r[0];return void o.insertText("\n"+i)}}o.insertText("\n")}else t()},o.normalizeNode=function(e){var t=sM(e,2),r=t[0],i=t[1],a=QO.getNodeType(r);return"code"===a&&i.length<=1&&md.setNodes(o,{type:"paragraph"},{at:i}),"pre"===a&&(QO.isLastNode(o,r)&&md.insertNodes(o,QO.genEmptyParagraph(),{at:[i[0]+1]}),"code"!==QO.getNodeType(r.children[0])&&(md.unwrapNodes(o),md.setNodes(o,{type:"paragraph"},{mode:"highest"}))),n([r,i])},o.insertData=function(e){if(null!=QO.getSelectedNodeByType(o,"code")){var t=e.getData("text/plain");Bf.insertText(o,t)}else r(e)},o},renderElems:[Hq,Vq],elemsToHtml:[{type:"code",elemToHtml:function(e,t){return"<code>"+t+"</code>"}},{type:"pre",elemToHtml:function(e,t){return"<pre>"+t+"</pre>"}}],preParseHtml:[{selector:"pre>code",preParseHtml:function(e){var t=Mp(e);if("code"!==QR(t))return e;var n=t.find("xmp");if(0===n.length)return e;var r=n.text();return n.remove(),t.text(r),t[0]}}],parseElemsHtml:[{selector:"pre:not([data-w-e-type])>code",parseElemHtml:function(e,t,n){return{type:"code",language:"",children:[{text:Mp(e)[0].textContent||""}]}}},Uq]},Gq=function(){function e(){this.title=HP("fullScreen.title"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M133.705143 335.433143V133.851429h201.581714a29.622857 29.622857 0 0 0 29.622857-29.549715V68.754286a29.622857 29.622857 0 0 0-29.622857-29.622857H61.732571A22.893714 22.893714 0 0 0 38.765714 62.025143V335.725714c0 16.310857 13.238857 29.622857 29.622857 29.622857h35.547429a29.842286 29.842286 0 0 0 29.696-29.842285zM690.980571 133.851429h201.581715v201.654857c0 16.310857 13.238857 29.549714 29.622857 29.549714h35.547428a29.622857 29.622857 0 0 0 29.549715-29.549714V61.952a22.893714 22.893714 0 0 0-22.820572-22.893714h-273.554285a29.622857 29.622857 0 0 0-29.549715 29.622857v35.547428c0 16.310857 13.238857 29.696 29.622857 29.696zM335.286857 892.781714H133.705143V691.2a29.622857 29.622857 0 0 0-29.622857-29.622857H68.534857a29.622857 29.622857 0 0 0-29.549714 29.622857v273.554286c0 12.653714 10.24 22.893714 22.820571 22.893714h273.554286a29.622857 29.622857 0 0 0 29.696-29.622857v-35.547429a29.769143 29.769143 0 0 0-29.769143-29.696z m557.348572-201.581714v201.581714H690.907429a29.622857 29.622857 0 0 0-29.622858 29.622857v35.547429c0 16.310857 13.238857 29.622857 29.622858 29.622857h273.554285c12.580571 0 22.893714-10.313143 22.893715-22.893714V691.2a29.622857 29.622857 0 0 0-29.622858-29.622857h-35.547428a29.622857 29.622857 0 0 0-29.696 29.622857z"></path></svg>',this.tag="button",this.alwaysEnable=!0}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return e.isFullScreen},e.prototype.isDisabled=function(e){return!1},e.prototype.exec=function(e,t){e.isFullScreen?e.unFullScreen():e.fullScreen()},e}(),qq={menus:[{key:"fullScreen",factory:function(){return new Gq}}]},Kq=function(){function e(){this.title=HP("common.enter"),this.iconSvg='<svg viewBox="0 0 1255 1024"><path d="M1095.111111 731.477333h-625.777778V1024L0 658.318222 469.333333 292.408889v292.636444h625.777778V0h156.444445v731.477333z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!!qf.isExpanded(t)},e.prototype.exec=function(e,t){var n=e.selection;if(null!=n){var r=[n.anchor.path[0]];md.insertNodes(e,{type:"paragraph",children:[{text:""}]},{at:r}),e.select(Bf.start(e,r))}},e}(),Yq=[nz,e$,vq,Eq,Oq,Bq,J$,Nq,hH,E$,Wq,dH,Vz,cM,nH,_q,qq,{menus:[{key:"enter",factory:function(){return new Kq}}]}];MP("en",{listModule:{unOrderedList:"Unordered list",orderedList:"Ordered list"}}),MP("zh-CN",{listModule:{unOrderedList:"æ åºåè¡¨",orderedList:"æåºåè¡¨"}});var Xq="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function Zq(e){var t={exports:{}};return e(t,t.exports),t.exports}var Jq,Qq,eK=function(e){return e&&e.Math==Math&&e},tK=eK("object"==typeof globalThis&&globalThis)||eK("object"==typeof window&&window)||eK("object"==typeof self&&self)||eK("object"==typeof Xq&&Xq)||function(){return this}()||Function("return this")(),nK=Function.prototype,rK=nK.bind,oK=nK.call,iK=rK&&rK.bind(oK),aK=rK?function(e){return e&&iK(oK,e)}:function(e){return e&&function(){return oK.apply(e,arguments)}},uK=function(e){try{return!!e()}catch(e){return!0}},sK=aK({}.toString),lK=aK("".slice),cK=function(e){return lK(sK(e),8,-1)},fK=tK.Object,dK=aK("".split),pK=uK((function(){return!fK("z").propertyIsEnumerable(0)}))?function(e){return"String"==cK(e)?dK(e,""):fK(e)}:fK,hK=tK.TypeError,gK=function(e){if(null==e)throw hK("Can't call method on "+e);return e},vK=function(e){return pK(gK(e))},yK=Object.defineProperty,mK=function(e,t){try{yK(tK,e,{value:t,configurable:!0,writable:!0})}catch(n){tK[e]=t}return t},bK=tK["__core-js_shared__"]||mK("__core-js_shared__",{}),wK=Zq((function(e){(e.exports=function(e,t){return bK[e]||(bK[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),EK=tK.Object,DK=function(e){return EK(gK(e))},SK=aK({}.hasOwnProperty),xK=Object.hasOwn||function(e,t){return SK(DK(e),t)},CK=0,AK=Math.random(),OK=aK(1..toString),kK=function(e){return"Symbol("+(void 0===e?"":e)+")_"+OK(++CK+AK,36)},BK=function(e){return"function"==typeof e},FK=function(e){return BK(e)?e:void 0},TK=function(e,t){return arguments.length<2?FK(tK[e]):tK[e]&&tK[e][t]},_K=TK("navigator","userAgent")||"",PK=tK.process,jK=tK.Deno,NK=PK&&PK.versions||jK&&jK.version,IK=NK&&NK.v8;IK&&(Qq=(Jq=IK.split("."))[0]>0&&Jq[0]<4?1:+(Jq[0]+Jq[1])),!Qq&&_K&&(!(Jq=_K.match(/Edge\/(\d+)/))||Jq[1]>=74)&&(Jq=_K.match(/Chrome\/(\d+)/))&&(Qq=+Jq[1]);var LK,RK=Qq,MK=!!Object.getOwnPropertySymbols&&!uK((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&RK&&RK<41})),zK=MK&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,$K=wK("wks"),HK=tK.Symbol,VK=HK&&HK.for,UK=zK?HK:HK&&HK.withoutSetter||kK,WK=function(e){if(!xK($K,e)||!MK&&"string"!=typeof $K[e]){var t="Symbol."+e;MK&&xK(HK,e)?$K[e]=HK[e]:$K[e]=zK&&VK?VK(t):UK(t)}return $K[e]},GK=function(e){return"object"==typeof e?null!==e:BK(e)},qK=tK.String,KK=tK.TypeError,YK=function(e){if(GK(e))return e;throw KK(qK(e)+" is not an object")},XK=!uK((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),ZK=tK.document,JK=GK(ZK)&&GK(ZK.createElement),QK=function(e){return JK?ZK.createElement(e):{}},eY=!XK&&!uK((function(){return 7!=Object.defineProperty(QK("div"),"a",{get:function(){return 7}}).a})),tY=Function.prototype.call,nY=tY.bind?tY.bind(tY):function(){return tY.apply(tY,arguments)},rY=aK({}.isPrototypeOf),oY=tK.Object,iY=zK?function(e){return"symbol"==typeof e}:function(e){var t=TK("Symbol");return BK(t)&&rY(t.prototype,oY(e))},aY=tK.String,uY=function(e){try{return aY(e)}catch(e){return"Object"}},sY=tK.TypeError,lY=function(e){if(BK(e))return e;throw sY(uY(e)+" is not a function")},cY=function(e,t){var n=e[t];return null==n?void 0:lY(n)},fY=tK.TypeError,dY=tK.TypeError,pY=WK("toPrimitive"),hY=function(e){var t=function(e,t){if(!GK(e)||iY(e))return e;var n,r=cY(e,pY);if(r){if(void 0===t&&(t="default"),n=nY(r,e,t),!GK(n)||iY(n))return n;throw dY("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&BK(n=e.toString)&&!GK(r=nY(n,e)))return r;if(BK(n=e.valueOf)&&!GK(r=nY(n,e)))return r;if("string"!==t&&BK(n=e.toString)&&!GK(r=nY(n,e)))return r;throw fY("Can't convert object to primitive value")}(e,t)}(e,"string");return iY(t)?t:t+""},gY=tK.TypeError,vY=Object.defineProperty,yY={f:XK?vY:function(e,t,n){if(YK(e),t=hY(t),YK(n),eY)try{return vY(e,t,n)}catch(e){}if("get"in n||"set"in n)throw gY("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},mY=Math.ceil,bY=Math.floor,wY=function(e){var t=+e;return t!=t||0===t?0:(t>0?bY:mY)(t)},EY=Math.max,DY=Math.min,SY=function(e,t){var n=wY(e);return n<0?EY(n+t,0):DY(n,t)},xY=Math.min,CY=function(e){return e>0?xY(wY(e),9007199254740991):0},AY=function(e){return CY(e.length)},OY=function(e){return function(t,n,r){var o,i=vK(t),a=AY(i),u=SY(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},kY={includes:OY(!0),indexOf:OY(!1)},BY={},FY=kY.indexOf,TY=aK([].push),_Y=function(e,t){var n,r=vK(e),o=0,i=[];for(n in r)!xK(BY,n)&&xK(r,n)&&TY(i,n);for(;t.length>o;)xK(r,n=t[o++])&&(~FY(i,n)||TY(i,n));return i},PY=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],jY=Object.keys||function(e){return _Y(e,PY)},NY=XK?Object.defineProperties:function(e,t){YK(e);for(var n,r=vK(t),o=jY(t),i=o.length,a=0;i>a;)yY.f(e,n=o[a++],r[n]);return e},IY=TK("document","documentElement"),LY=wK("keys"),RY=function(e){return LY[e]||(LY[e]=kK(e))},MY=RY("IE_PROTO"),zY=function(){},$Y=function(e){return"<script>"+e+"<\/script>"},HY=function(e){e.write($Y("")),e.close();var t=e.parentWindow.Object;return e=null,t},VY=function(){try{LK=new ActiveXObject("htmlfile")}catch(e){}var e,t;VY="undefined"!=typeof document?document.domain&&LK?HY(LK):((t=QK("iframe")).style.display="none",IY.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write($Y("document.F=Object")),e.close(),e.F):HY(LK);for(var n=PY.length;n--;)delete VY.prototype[PY[n]];return VY()};BY[MY]=!0;var UY=Object.create||function(e,t){var n;return null!==e?(zY.prototype=YK(e),n=new zY,zY.prototype=null,n[MY]=e):n=VY(),void 0===t?n:NY(n,t)},WY=WK("unscopables"),GY=Array.prototype;null==GY[WY]&&yY.f(GY,WY,{configurable:!0,value:UY(null)});var qY=function(e){GY[WY][e]=!0},KY={},YY=aK(Function.toString);BK(bK.inspectSource)||(bK.inspectSource=function(e){return YY(e)});var XY,ZY,JY,QY=bK.inspectSource,eX=tK.WeakMap,tX=BK(eX)&&/native code/.test(QY(eX)),nX=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},rX=XK?function(e,t,n){return yY.f(e,t,nX(1,n))}:function(e,t,n){return e[t]=n,e},oX=tK.TypeError,iX=tK.WeakMap;if(tX||bK.state){var aX=bK.state||(bK.state=new iX),uX=aK(aX.get),sX=aK(aX.has),lX=aK(aX.set);XY=function(e,t){if(sX(aX,e))throw new oX("Object already initialized");return t.facade=e,lX(aX,e,t),t},ZY=function(e){return uX(aX,e)||{}},JY=function(e){return sX(aX,e)}}else{var cX=RY("state");BY[cX]=!0,XY=function(e,t){if(xK(e,cX))throw new oX("Object already initialized");return t.facade=e,rX(e,cX,t),t},ZY=function(e){return xK(e,cX)?e[cX]:{}},JY=function(e){return xK(e,cX)}}var fX,dX,pX,hX={set:XY,get:ZY,has:JY,enforce:function(e){return JY(e)?ZY(e):XY(e,{})},getterFor:function(e){return function(t){var n;if(!GK(t)||(n=ZY(t)).type!==e)throw oX("Incompatible receiver, "+e+" required");return n}}},gX={}.propertyIsEnumerable,vX=Object.getOwnPropertyDescriptor,yX={f:vX&&!gX.call({1:2},1)?function(e){var t=vX(this,e);return!!t&&t.enumerable}:gX},mX=Object.getOwnPropertyDescriptor,bX={f:XK?mX:function(e,t){if(e=vK(e),t=hY(t),eY)try{return mX(e,t)}catch(e){}if(xK(e,t))return nX(!nY(yX.f,e,t),e[t])}},wX=Function.prototype,EX=XK&&Object.getOwnPropertyDescriptor,DX=xK(wX,"name"),SX={EXISTS:DX,PROPER:DX&&"something"===function(){}.name,CONFIGURABLE:DX&&(!XK||XK&&EX(wX,"name").configurable)},xX=Zq((function(e){var t=SX.CONFIGURABLE,n=hX.get,r=hX.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;BK(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!xK(i,"name")||t&&i.name!==f)&&rX(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==tK?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:rX(e,n,i)):l?e[n]=i:mK(n,i)})(Function.prototype,"toString",(function(){return BK(this)&&n(this).source||QY(this)}))})),CX=PY.concat("length","prototype"),AX={f:Object.getOwnPropertyNames||function(e){return _Y(e,CX)}},OX={f:Object.getOwnPropertySymbols},kX=aK([].concat),BX=TK("Reflect","ownKeys")||function(e){var t=AX.f(YK(e)),n=OX.f;return n?kX(t,n(e)):t},FX=function(e,t){for(var n=BX(t),r=yY.f,o=bX.f,i=0;i<n.length;i++){var a=n[i];xK(e,a)||r(e,a,o(t,a))}},TX=/#|\.prototype\./,_X=function(e,t){var n=jX[PX(e)];return n==IX||n!=NX&&(BK(t)?uK(t):!!t)},PX=_X.normalize=function(e){return String(e).replace(TX,".").toLowerCase()},jX=_X.data={},NX=_X.NATIVE="N",IX=_X.POLYFILL="P",LX=_X,RX=bX.f,MX=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?tK:l?tK[u]||mK(u,{}):(tK[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=RX(n,r))&&a.value:n[r],!LX(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;FX(i,o)}(e.sham||o&&o.sham)&&rX(i,"sham",!0),xX(n,r,i,e)}},zX=!uK((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),$X=RY("IE_PROTO"),HX=tK.Object,VX=HX.prototype,UX=zX?HX.getPrototypeOf:function(e){var t=DK(e);if(xK(t,$X))return t[$X];var n=t.constructor;return BK(n)&&t instanceof n?n.prototype:t instanceof HX?VX:null},WX=WK("iterator"),GX=!1;[].keys&&("next"in(pX=[].keys())?(dX=UX(UX(pX)))!==Object.prototype&&(fX=dX):GX=!0);var qX=null==fX||uK((function(){var e={};return fX[WX].call(e)!==e}));qX&&(fX={}),BK(fX[WX])||xX(fX,WX,(function(){return this}));var KX={IteratorPrototype:fX,BUGGY_SAFARI_ITERATORS:GX},YX=yY.f,XX=WK("toStringTag"),ZX=function(e,t,n){e&&!xK(e=n?e:e.prototype,XX)&&YX(e,XX,{configurable:!0,value:t})},JX=KX.IteratorPrototype,QX=function(){return this},eZ=tK.String,tZ=tK.TypeError,nZ=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=aK(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(n,[]),t=n instanceof Array}catch(e){}return function(n,r){return YK(n),function(e){if("object"==typeof e||BK(e))return e;throw tZ("Can't set "+eZ(e)+" as a prototype")}(r),t?e(n,r):n.__proto__=r,n}}():void 0),rZ=SX.PROPER,oZ=SX.CONFIGURABLE,iZ=KX.IteratorPrototype,aZ=KX.BUGGY_SAFARI_ITERATORS,uZ=WK("iterator"),sZ=function(){return this},lZ=function(e,t,n,r,o,i,a){!function(e,t,n,r){var o=t+" Iterator";e.prototype=UY(JX,{next:nX(1,n)}),ZX(e,o,!1),KY[o]=QX}(n,t,r);var u,s,l,c=function(e){if(e===o&&g)return g;if(!aZ&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[uZ]||p["@@iterator"]||o&&p[o],g=!aZ&&h||c(o),v="Array"==t&&p.entries||h;if(v&&(u=UX(v.call(new e)))!==Object.prototype&&u.next&&(UX(u)!==iZ&&(nZ?nZ(u,iZ):BK(u[uZ])||xX(u,uZ,sZ)),ZX(u,f,!0)),rZ&&"values"==o&&h&&"values"!==h.name&&(oZ?rX(p,"name","values"):(d=!0,g=function(){return nY(h,this)})),o)if(s={values:c("values"),keys:i?g:c("keys"),entries:c("entries")},a)for(l in s)(aZ||d||!(l in p))&&xX(p,l,s[l]);else MX({target:t,proto:!0,forced:aZ||d},s);return p[uZ]!==g&&xX(p,uZ,g,{name:o}),KY[t]=g,s},cZ=hX.set,fZ=hX.getterFor("Array Iterator"),dZ=lZ(Array,"Array",(function(e,t){cZ(this,{type:"Array Iterator",target:vK(e),index:0,kind:t})}),(function(){var e=fZ(this),t=e.target,n=e.kind,r=e.index++;return!t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");KY.Arguments=KY.Array,qY("keys"),qY("values"),qY("entries");var pZ={};pZ[WK("toStringTag")]="z";var hZ="[object z]"===String(pZ),gZ=WK("toStringTag"),vZ=tK.Object,yZ="Arguments"==cK(function(){return arguments}()),mZ=hZ?cK:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=vZ(e),gZ))?n:yZ?cK(t):"Object"==(r=cK(t))&&BK(t.callee)?"Arguments":r},bZ=hZ?{}.toString:function(){return"[object "+mZ(this)+"]"};hZ||xX(Object.prototype,"toString",bZ,{unsafe:!0});var wZ=tK.String,EZ=function(e){if("Symbol"===mZ(e))throw TypeError("Cannot convert a Symbol value to a string");return wZ(e)},DZ=aK("".charAt),SZ=aK("".charCodeAt),xZ=aK("".slice),CZ=function(e){return function(t,n){var r,o,i=EZ(gK(t)),a=wY(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=SZ(i,a))<55296||r>56319||a+1===u||(o=SZ(i,a+1))<56320||o>57343?e?DZ(i,a):r:e?xZ(i,a,a+2):o-56320+(r-55296<<10)+65536}},AZ={codeAt:CZ(!1),charAt:CZ(!0)},OZ=AZ.charAt,kZ=hX.set,BZ=hX.getterFor("String Iterator");lZ(String,"String",(function(e){kZ(this,{type:"String Iterator",string:EZ(e),index:0})}),(function(){var e,t=BZ(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=OZ(n,r),t.index+=e.length,{value:e,done:!1})}));var FZ=function(e,t,n){for(var r in t)xX(e,r,t[r],n);return e},TZ=tK.Array,_Z=Math.max,PZ=AX.f,jZ="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],NZ={f:function(e){return jZ&&"Window"==cK(e)?function(e){try{return PZ(e)}catch(e){return function(e,t,n){for(var r,o,i,a,u=AY(e),s=SY(void 0,u),l=SY(u,u),c=TZ(_Z(l-s,0)),f=0;s<l;s++,f++)r=c,o=f,i=e[s],(a=hY(o))in r?yY.f(r,a,nX(0,i)):r[a]=i;return c.length=f,c}(jZ)}}(e):PZ(vK(e))}},IZ=uK((function(){if("function"==typeof ArrayBuffer){var e=new ArrayBuffer(8);Object.isExtensible(e)&&Object.defineProperty(e,"a",{value:8})}})),LZ=Object.isExtensible,RZ=uK((function(){LZ(1)}))||IZ?function(e){return!!GK(e)&&(!IZ||"ArrayBuffer"!=cK(e))&&(!LZ||LZ(e))}:LZ,MZ=!uK((function(){return Object.isExtensible(Object.preventExtensions({}))})),zZ=Zq((function(e){var t=yY.f,n=!1,r=kK("meta"),o=0,i=function(e){t(e,r,{value:{objectID:"O"+o++,weakData:{}}})},a=e.exports={enable:function(){a.enable=function(){},n=!0;var e=AX.f,t=aK([].splice),o={};o[r]=1,e(o).length&&(AX.f=function(n){for(var o=e(n),i=0,a=o.length;i<a;i++)if(o[i]===r){t(o,i,1);break}return o},MX({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:NZ.f}))},fastKey:function(e,t){if(!GK(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!xK(e,r)){if(!RZ(e))return"F";if(!t)return"E";i(e)}return e[r].objectID},getWeakData:function(e,t){if(!xK(e,r)){if(!RZ(e))return!0;if(!t)return!1;i(e)}return e[r].weakData},onFreeze:function(e){return MZ&&n&&RZ(e)&&!xK(e,r)&&i(e),e}};BY[r]=!0})),$Z=aK(aK.bind),HZ=function(e,t){return lY(e),void 0===t?e:$Z?$Z(e,t):function(){return e.apply(t,arguments)}},VZ=WK("iterator"),UZ=Array.prototype,WZ=WK("iterator"),GZ=function(e){if(null!=e)return cY(e,WZ)||cY(e,"@@iterator")||KY[mZ(e)]},qZ=tK.TypeError,KZ=function(e,t,n){var r,o;YK(e);try{if(!(r=cY(e,"return"))){if("throw"===t)throw n;return n}r=nY(r,e)}catch(e){o=!0,r=e}if("throw"===t)throw n;if(o)throw r;return YK(r),n},YZ=tK.TypeError,XZ=function(e,t){this.stopped=e,this.result=t},ZZ=XZ.prototype,JZ=function(e,t,n){var r,o,i,a,u,s,l,c,f=n&&n.that,d=!(!n||!n.AS_ENTRIES),p=!(!n||!n.IS_ITERATOR),h=!(!n||!n.INTERRUPTED),g=HZ(t,f),v=function(e){return r&&KZ(r,"normal",e),new XZ(!0,e)},y=function(e){return d?(YK(e),h?g(e[0],e[1],v):g(e[0],e[1])):h?g(e,v):g(e)};if(p)r=e;else{if(!(o=GZ(e)))throw YZ(uY(e)+" is not iterable");if(void 0!==(c=o)&&(KY.Array===c||UZ[VZ]===c)){for(i=0,a=AY(e);a>i;i++)if((u=y(e[i]))&&rY(ZZ,u))return u;return new XZ(!1)}r=function(e,t){var n=arguments.length<2?GZ(e):t;if(lY(n))return YK(nY(n,e));throw qZ(uY(e)+" is not iterable")}(e,o)}for(s=r.next;!(l=nY(s,r)).done;){try{u=y(l.value)}catch(e){KZ(r,"throw",e)}if("object"==typeof u&&u&&rY(ZZ,u))return u}return new XZ(!1)},QZ=tK.TypeError,eJ=function(e,t){if(rY(t,e))return e;throw QZ("Incorrect invocation")},tJ=WK("iterator"),nJ=!1;try{var rJ=0,oJ={next:function(){return{done:!!rJ++}},return:function(){nJ=!0}};oJ[tJ]=function(){return this},Array.from(oJ,(function(){throw 2}))}catch(Ml){}var iJ=Array.isArray||function(e){return"Array"==cK(e)},aJ=function(){},uJ=[],sJ=TK("Reflect","construct"),lJ=/^\s*(?:class|function)\b/,cJ=aK(lJ.exec),fJ=!lJ.exec(aJ),dJ=function(e){if(!BK(e))return!1;try{return sJ(aJ,uJ,e),!0}catch(e){return!1}},pJ=!sJ||uK((function(){var e;return dJ(dJ.call)||!dJ(Object)||!dJ((function(){e=!0}))||e}))?function(e){if(!BK(e))return!1;switch(mZ(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return fJ||!!cJ(lJ,QY(e))}:dJ,hJ=WK("species"),gJ=tK.Array,vJ=function(e,t){return new(function(e){var t;return iJ(e)&&(t=e.constructor,(pJ(t)&&(t===gJ||iJ(t.prototype))||GK(t)&&null===(t=t[hJ]))&&(t=void 0)),void 0===t?gJ:t}(e))(0===t?0:t)},yJ=aK([].push),mJ=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=DK(s),g=pK(h),v=HZ(l,c),y=AY(g),m=0,b=f||vJ,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:yJ(w,d)}else switch(e){case 4:return!1;case 7:yJ(w,d)}return i?-1:r||o?o:w}},bJ={forEach:mJ(0),map:mJ(1),filter:mJ(2),some:mJ(3),every:mJ(4),find:mJ(5),findIndex:mJ(6),filterReject:mJ(7)},wJ=zZ.getWeakData,EJ=hX.set,DJ=hX.getterFor,SJ=bJ.find,xJ=bJ.findIndex,CJ=aK([].splice),AJ=0,OJ=function(e){return e.frozen||(e.frozen=new kJ)},kJ=function(){this.entries=[]},BJ=function(e,t){return SJ(e.entries,(function(e){return e[0]===t}))};kJ.prototype={get:function(e){var t=BJ(this,e);if(t)return t[1]},has:function(e){return!!BJ(this,e)},set:function(e,t){var n=BJ(this,e);n?n[1]=t:this.entries.push([e,t])},delete:function(e){var t=xJ(this.entries,(function(t){return t[0]===e}));return~t&&CJ(this.entries,t,1),!!~t}};var FJ,TJ={getConstructor:function(e,t,n,r){var o=e((function(e,o){eJ(e,i),EJ(e,{type:t,id:AJ++,frozen:void 0}),null!=o&&JZ(o,e[r],{that:e,AS_ENTRIES:n})})),i=o.prototype,a=DJ(t),u=function(e,t,n){var r=a(e),o=wJ(YK(t),!0);return!0===o?OJ(r).set(t,n):o[r.id]=n,e};return FZ(i,{delete:function(e){var t=a(this);if(!GK(e))return!1;var n=wJ(e);return!0===n?OJ(t).delete(e):n&&xK(n,t.id)&&delete n[t.id]},has:function(e){var t=a(this);if(!GK(e))return!1;var n=wJ(e);return!0===n?OJ(t).has(e):n&&xK(n,t.id)}}),FZ(i,n?{get:function(e){var t=a(this);if(GK(e)){var n=wJ(e);return!0===n?OJ(t).get(e):n?n[t.id]:void 0}},set:function(e,t){return u(this,e,t)}}:{add:function(e){return u(this,e,!0)}}),o}},_J=hX.enforce,PJ=!tK.ActiveXObject&&"ActiveXObject"in tK,jJ=function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},NJ=function(e,t,n){var r=-1!==e.indexOf("Map"),o=-1!==e.indexOf("Weak"),i=r?"set":"add",a=tK[e],u=a&&a.prototype,s=a,l={},c=function(e){var t=aK(u[e]);xX(u,e,"add"==e?function(e){return t(this,0===e?0:e),this}:"delete"==e?function(e){return!(o&&!GK(e))&&t(this,0===e?0:e)}:"get"==e?function(e){return o&&!GK(e)?void 0:t(this,0===e?0:e)}:"has"==e?function(e){return!(o&&!GK(e))&&t(this,0===e?0:e)}:function(e,n){return t(this,0===e?0:e,n),this})};if(LX(e,!BK(a)||!(o||u.forEach&&!uK((function(){(new a).entries().next()})))))s=n.getConstructor(t,e,r,i),zZ.enable();else if(LX(e,!0)){var f=new s,d=f[i](o?{}:-0,1)!=f,p=uK((function(){f.has(1)})),h=function(e,t){if(!nJ)return!1;var n=!1;try{var r={};r[tJ]=function(){return{next:function(){return{done:n=!0}}}},function(e){new a(e)}(r)}catch(e){}return n}(),g=!o&&uK((function(){for(var e=new a,t=5;t--;)e[i](t,t);return!e.has(-0)}));h||((s=t((function(e,t){eJ(e,u);var n=function(e,t,n){var r,o;return nZ&&BK(r=t.constructor)&&r!==n&&GK(o=r.prototype)&&o!==n.prototype&&nZ(e,o),e}(new a,e,s);return null!=t&&JZ(t,n[i],{that:n,AS_ENTRIES:r}),n}))).prototype=u,u.constructor=s),(p||g)&&(c("delete"),c("has"),r&&c("get")),(g||d)&&c(i),o&&u.clear&&delete u.clear}return l[e]=s,MX({global:!0,forced:s!=a},l),ZX(s,e),o||n.setStrong(s,e,r),s}("WeakMap",jJ,TJ);if(tX&&PJ){FJ=TJ.getConstructor(jJ,"WeakMap",!0),zZ.enable();var IJ=NJ.prototype,LJ=aK(IJ.delete),RJ=aK(IJ.has),MJ=aK(IJ.get),zJ=aK(IJ.set);FZ(IJ,{delete:function(e){if(GK(e)&&!RZ(e)){var t=_J(this);return t.frozen||(t.frozen=new FJ),LJ(this,e)||t.frozen.delete(e)}return LJ(this,e)},has:function(e){if(GK(e)&&!RZ(e)){var t=_J(this);return t.frozen||(t.frozen=new FJ),RJ(this,e)||t.frozen.has(e)}return RJ(this,e)},get:function(e){if(GK(e)&&!RZ(e)){var t=_J(this);return t.frozen||(t.frozen=new FJ),RJ(this,e)?MJ(this,e):t.frozen.get(e)}return MJ(this,e)},set:function(e,t){if(GK(e)&&!RZ(e)){var n=_J(this);n.frozen||(n.frozen=new FJ),RJ(this,e)?zJ(this,e,t):n.frozen.set(e,t)}else zJ(this,e,t);return this}})}var $J={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},HJ=QK("span").classList,VJ=HJ&&HJ.constructor&&HJ.constructor.prototype,UJ=VJ===Object.prototype?void 0:VJ,WJ=WK("iterator"),GJ=WK("toStringTag"),qJ=dZ.values,KJ=function(e,t){if(e){if(e[WJ]!==qJ)try{rX(e,WJ,qJ)}catch(t){e[WJ]=qJ}if(e[GJ]||rX(e,GJ,t),$J[t])for(var n in dZ)if(e[n]!==dZ[n])try{rX(e,n,dZ[n])}catch(t){e[n]=dZ[n]}}};for(var YJ in $J)KJ(tK[YJ]&&tK[YJ].prototype,YJ);KJ(UJ,"DOMTokenList");var XJ=new WeakMap,ZJ={type:"list-item",renderElem:function(e,t,n){XJ.set(e,n);var r=e,o=r.level,i=void 0===o?0:o,a=r.ordered,u={margin:"5px 0 5px "+20*i+"px"},s="";if(void 0!==a&&a){var l=function(e,t){var n=t,r=n.type,o=n.level,i=void 0===o?0:o,a=n.ordered,u=void 0!==a&&a;if(!u)return-1;var s=1,l=t,c=QO.findPath(e,l);if(0===c[0])return 1;for(;c[0]>0;){var f=Mf.previous(c),d=Bf.node(e,f);if(null==d)break;var p=d[0],h=p.level,g=void 0===h?0:h,v=p.type,y=p.ordered;if(v!==r)break;if(g<i)break;if(g===i){if(y!==u)break;s++}l=p,c=f}return s}(n,e);s=l+"."}else s=function(e){void 0===e&&(e=0);var t="";switch(e){case 0:t="â¢";break;case 1:t="â¦";break;default:t="âª"}return t}(i);var c=function(e){var t,n=e.children||[],r=n.length;if(0===r)return"";for(var o=0;o<r&&!t;o++){var i=n[o];ed.isText(i)&&(t=i)}return null==t?"":t.color||""}(e);return Pg("div",{style:u},Pg("span",{contentEditable:!1,style:{marginRight:"0.5em",color:c},"data-w-e-reserve":!0},s),Pg("span",null,t))}},JJ=function(e,t){return JJ=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},JJ(e,t)
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */};function QJ(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}JJ(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}function eQ(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function tQ(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return a}function nQ(e){return Bf.nodes(e,{at:e.selection||void 0,match:function(t){return 1===QO.findPath(e,t).length}})}var rQ=kY.includes;MX({target:"Array",proto:!0},{includes:function(e){return rQ(this,e,arguments.length>1?arguments[1]:void 0)}}),qY("includes");var oQ,iQ,aQ=function(){var e=YK(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},uQ=tK.RegExp,sQ=uK((function(){var e=uQ("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),lQ=sQ||uK((function(){return!uQ("a","y").sticky})),cQ={BROKEN_CARET:sQ||uK((function(){var e=uQ("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:lQ,UNSUPPORTED_Y:sQ},fQ=tK.RegExp,dQ=uK((function(){var e=fQ(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),pQ=tK.RegExp,hQ=uK((function(){var e=pQ("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),gQ=hX.get,vQ=wK("native-string-replace",String.prototype.replace),yQ=RegExp.prototype.exec,mQ=yQ,bQ=aK("".charAt),wQ=aK("".indexOf),EQ=aK("".replace),DQ=aK("".slice),SQ=(iQ=/b*/g,nY(yQ,oQ=/a/,"a"),nY(yQ,iQ,"a"),0!==oQ.lastIndex||0!==iQ.lastIndex),xQ=cQ.BROKEN_CARET,CQ=void 0!==/()??/.exec("")[1];(SQ||CQ||xQ||dQ||hQ)&&(mQ=function(e){var t,n,r,o,i,a,u,s=this,l=gQ(s),c=EZ(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=nY(mQ,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=xQ&&s.sticky,h=nY(aQ,s),g=s.source,v=0,y=c;if(p&&(h=EQ(h,"y",""),-1===wQ(h,"g")&&(h+="g"),y=DQ(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==bQ(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),CQ&&(n=new RegExp("^"+g+"$(?!\\s)",h)),SQ&&(r=s.lastIndex),o=nY(yQ,p?n:s,y),p?o?(o.input=DQ(o.input,v),o[0]=DQ(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:SQ&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),CQ&&o&&o.length>1&&nY(vQ,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=UY(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var AQ=mQ;MX({target:"RegExp",proto:!0,forced:/./.exec!==AQ},{exec:AQ});var OQ=function(){function e(){this.type="list-item",this.tag="button"}return e.prototype.getListNode=function(e){var t=this.type;return QO.getSelectedNodeByType(e,t)},e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){var t=this.getListNode(e);if(null==t)return!1;var n=t.ordered;return(void 0!==n&&n)===this.ordered},e.prototype.isDisabled=function(e){return null==e.selection||!!QO.getSelectedElems(e).some((function(t){if(Bf.isVoid(e,t)&&Bf.isBlock(e,t))return!0;var n=t.type;return!!["pre","code","table"].includes(n)||void 0}))},e.prototype.exec=function(e,t){this.isActive(e)?md.setNodes(e,{type:"paragraph",ordered:void 0,level:void 0}):md.setNodes(e,{type:"list-item",ordered:this.ordered,indent:void 0})},e}(),kQ='<svg viewBox="0 0 1024 1024"><path d="M384 64h640v128H384V64z m0 384h640v128H384v-128z m0 384h640v128H384v-128zM0 128a128 128 0 1 1 256 0 128 128 0 0 1-256 0z m0 384a128 128 0 1 1 256 0 128 128 0 0 1-256 0z m0 384a128 128 0 1 1 256 0 128 128 0 0 1-256 0z"></path></svg>',BQ='<svg viewBox="0 0 1024 1024"><path d="M384 832h640v128H384z m0-384h640v128H384z m0-384h640v128H384zM192 0v256H128V64H64V0zM128 526.016v50.016h128v64H64v-146.016l128-60V384H64v-64h192v146.016zM256 704v320H64v-64h128v-64H64v-64h128v-64H64v-64z"></path></svg>',FQ=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.ordered=!1,t.title=HP("listModule.unOrderedList"),t.iconSvg=kQ,t}return QJ(t,e),t}(OQ),TQ=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.ordered=!0,t.title=HP("listModule.orderedList"),t.iconSvg=BQ,t}return QJ(t,e),t}(OQ),_Q={key:"bulletedList",factory:function(){return new FQ}},PQ={key:"numberedList",factory:function(){return new TQ}},jQ=[],NQ={type:"list-item",elemToHtml:function(e,t){var n="",r="",o=e.ordered,i=void 0!==o&&o?"ol":"ul",a=function(e){var t=XJ.get(e);if(null==t)return 0;var n=e,r=n.type,o=n.ordered,i=void 0!==o&&o,a=n.level,u=void 0===a?0:a,s=QO.findPath(t,e);if(0===s[0])return u+1;var l=Mf.previous(s),c=Bf.node(t,l);if(!c)return 0;var f=tQ(c,1)[0];if(QO.getNodeType(f)!==r)return u+1;var d=f,p=d.ordered,h=void 0!==p&&p,g=d.level,v=void 0===g?0:g;return v<u?u-v:v>u?0:v===u?h===i?0:1:0}(e);if(a>0)for(var u=0;u<a;u++)n+="<"+i+">",jQ.push(i);var s=function(e){var t=XJ.get(e);if(null==t)return 0;var n=e,r=n.type,o=n.ordered,i=void 0!==o&&o,a=n.level,u=void 0===a?0:a,s=QO.findPath(t,e);if(s[0]===t.children.length-1)return u+1;var l=Mf.next(s),c=Bf.node(t,l);if(!c)return 0;var f=tQ(c,1)[0];if(QO.getNodeType(f)!==r)return u+1;var d=f,p=d.ordered,h=void 0!==p&&p,g=d.level,v=void 0===g?0:g;return v<u?u-v:v>u?0:v===u?h===i?0:1:0}(e);if(s>0)for(u=0;u<s;u++)r+="</"+jQ.pop()+">";return{html:"<li>"+t+"</li>",prefix:n,suffix:r}}},IQ=WK("species"),LQ=bJ.filter,RQ=("filter",RK>=51||!uK((function(){var e=[];return(e.constructor={})[IQ]=function(){return{foo:1}},1!==e.filter(Boolean).foo})));MX({target:"Array",proto:!0,forced:!RQ},{filter:function(e){return LQ(this,e,arguments.length>1?arguments[1]:void 0)}});var MQ=Function.prototype,zQ=MQ.apply,$Q=MQ.bind,HQ=MQ.call,VQ="object"==typeof Reflect&&Reflect.apply||($Q?HQ.bind(zQ):function(){return HQ.apply(zQ,arguments)}),UQ=(WK("species"),RegExp.prototype),WQ=AZ.charAt,GQ=function(e,t,n){return t+(n?WQ(e,t).length:1)},qQ=Math.floor,KQ=aK("".charAt),YQ=aK("".replace),XQ=aK("".slice),ZQ=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,JQ=/\$([$&'`]|\d{1,2})/g,QQ=function(e,t,n,r,o,i){var a=n+e.length,u=r.length,s=JQ;return void 0!==o&&(o=DK(o),s=ZQ),YQ(i,s,(function(i,s){var l;switch(KQ(s,0)){case"$":return"$";case"&":return e;case"`":return XQ(t,0,n);case"'":return XQ(t,a);case"<":l=o[XQ(s,1,-1)];break;default:var c=+s;if(0===c)return i;if(c>u){var f=qQ(c/10);return 0===f?i:f<=u?void 0===r[f-1]?KQ(s,1):r[f-1]+KQ(s,1):i}l=r[c-1]}return void 0===l?"":l}))},e0=tK.TypeError,t0=function(e,t){var n=e.exec;if(BK(n)){var r=nY(n,e,t);return null!==r&&YK(r),r}if("RegExp"===cK(e))return nY(AQ,e,t);throw e0("RegExp#exec called on incompatible receiver")},n0=WK("replace"),r0=Math.max,o0=Math.min,i0=aK([].concat),a0=aK([].push),u0=aK("".indexOf),s0=aK("".slice),l0="$0"==="a".replace(/./,"$0"),c0=!!/./[n0]&&""===/./[n0]("a","$0");!function(e,t,n,r){var o=WK(e),i=!uK((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!uK((function(){var e=!1,t=/a/;return t.exec=function(){return e=!0,null},t[o](""),!e}));if(!i||!a||n){var u=aK(/./[o]),s=function(e,t,n){var r=c0?"$":"$0";return[function(e,n){var r=gK(this),o=null==e?void 0:cY(e,n0);return o?nY(o,e,r,n):nY(t,EZ(r),e,n)},function(e,o){var i=YK(this),a=EZ(e);if("string"==typeof o&&-1===u0(o,r)&&-1===u0(o,"$<")){var u=n(t,i,a,o);if(u.done)return u.value}var s=BK(o);s||(o=EZ(o));var l=i.global;if(l){var c=i.unicode;i.lastIndex=0}for(var f=[];;){var d=t0(i,a);if(null===d)break;if(a0(f,d),!l)break;""===EZ(d[0])&&(i.lastIndex=GQ(a,CY(i.lastIndex),c))}for(var p,h="",g=0,v=0;v<f.length;v++){for(var y=EZ((d=f[v])[0]),m=r0(o0(wY(d.index),a.length),0),b=[],w=1;w<d.length;w++)a0(b,void 0===(p=d[w])?p:String(p));var E=d.groups;if(s){var D=i0([y],b,m,a);void 0!==E&&a0(D,E);var S=EZ(VQ(o,void 0,D))}else S=QQ(y,a,m,b,E,o);m>=g&&(h+=s0(a,g,m)+S,g=m+y.length)}return h+s0(a,g)}]}(0,""[e],(function(e,t,n,r,o){var a=aK(e),s=t.exec;return s===AQ||s===UQ.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));xX(String.prototype,e,s[0]),xX(UQ,o,s[1])}}("replace",0,!!uK((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!l0||c0);var f0=tK.TypeError,d0=function(e,t,n,r,o,i,a,u){for(var s,l,c=o,f=0,d=!!a&&HZ(a,u);f<r;){if(f in n){if(s=d?d(n[f],f,t):n[f],i>0&&iJ(s))l=AY(s),c=d0(e,t,s,l,c,i-1)-1;else{if(c>=9007199254740991)throw f0("Exceed the acceptable array length");e[c]=s}c++}f++}return c},p0=d0;function h0(e){return e.length?e[0].tagName.toLowerCase():""}MX({target:"Array",proto:!0},{flat:function(){var e=arguments.length?arguments[0]:void 0,t=DK(this),n=AY(t),r=vJ(t,0);return r.length=p0(r,t,t,n,0,void 0===e?1:wY(e)),r}}),qY("flat"),MX({global:!0},{globalThis:tK}),ah&&(Mp.fn.append=ah),Vp&&(Mp.fn.attr=Vp),sh&&(Mp.fn.parent=sh);var g0={renderElems:[ZJ],editorPlugin:function(e){var t=e.deleteBackward,n=e.handleTab,r=e.normalizeNode,o=e;return o.deleteBackward=function(e){var n=o.selection;if(null!=n)if(qf.isExpanded(n))t(e);else{var r=QO.getSelectedNodeByType(o,"list-item");if(null!=r)if(0!==n.focus.offset)t(e);else{var i=r.level,a=void 0===i?0:i;a>0?md.setNodes(o,{level:a-1}):md.setNodes(o,{type:"paragraph",ordered:void 0,level:void 0})}else t(e)}else t(e)},o.handleTab=function(){var e,t,r,i,a=o.selection;if(null!=a){if(qf.isCollapsed(a)){var u=QO.getSelectedNodeByType(o,"list-item");if(null==u)return void n();if(0===a.focus.offset){var s=u.level,l=void 0===s?0:s;return void md.setNodes(o,{level:l+1})}}if(qf.isExpanded(a)){var c=0,f=!1;try{for(var d=eQ(nQ(o)),p=d.next();!p.done;p=d.next()){var h=tQ(p.value,1)[0];"list-item"===QO.getNodeType(h)?c++:f=!0}}catch(t){e={error:t}}finally{try{p&&!p.done&&(t=d.return)&&t.call(d)}finally{if(e)throw e.error}}if(f||c<=1)return void n();try{for(var g=eQ(nQ(o)),v=g.next();!v.done;v=g.next()){var y=tQ(v.value,2),m=(h=y[0],y[1]),b=h.level;l=void 0===b?0:b,md.setNodes(o,{level:l+1},{at:m})}}catch(e){r={error:e}}finally{try{v&&!v.done&&(i=g.return)&&i.call(g)}finally{if(r)throw r.error}}}else n()}else n()},o.normalizeNode=function(e){var t=tQ(e,2),n=t[0],i=t[1],a=QO.getNodeType(n);return"bulleted-list"!==a&&"numbered-list"!==a||md.unwrapNodes(o,{at:i}),r([n,i])},o},menus:[_Q,PQ],elemsToHtml:[NQ],parseElemsHtml:[{selector:"ul:not([data-w-e-type]),ol:not([data-w-e-type])",parseElemHtml:function(e,t,n){return t.flat(1/0)}},{selector:"li:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e);0===(t=t.filter((function(e){return!!ed.isText(e)||!!n.isInline(e)}))).length&&(t=[{text:r.text().replace(/\s+/gm," ")}]);var o=function(e){return"ol"===h0(e.parent())}(r),i=function(e){for(var t=0,n=e.parent(),r=h0(n);"ul"===r||"ol"===r;)r=h0(n=n.parent()),t++;return t-1}(r);return{type:"list-item",ordered:o,level:i,children:t}}}]},v0=n((function(t,n){var r="__lodash_hash_undefined__",o=9007199254740991,i="[object Arguments]",a="[object Array]",u="[object Boolean]",s="[object Date]",l="[object Error]",c="[object Function]",f="[object Map]",d="[object Number]",p="[object Object]",h="[object Promise]",g="[object RegExp]",v="[object Set]",y="[object String]",m="[object Symbol]",b="[object WeakMap]",w="[object ArrayBuffer]",E="[object DataView]",D=/^\[object .+?Constructor\]$/,S=/^(?:0|[1-9]\d*)$/,x={};x["[object Float32Array]"]=x["[object Float64Array]"]=x["[object Int8Array]"]=x["[object Int16Array]"]=x["[object Int32Array]"]=x["[object Uint8Array]"]=x["[object Uint8ClampedArray]"]=x["[object Uint16Array]"]=x["[object Uint32Array]"]=!0,x[i]=x[a]=x[w]=x[u]=x[E]=x[s]=x[l]=x[c]=x[f]=x[d]=x[p]=x[g]=x[v]=x[y]=x[b]=!1;var C="object"==typeof e&&e&&e.Object===Object&&e,A="object"==typeof self&&self&&self.Object===Object&&self,O=C||A||Function("return this")(),k=n&&!n.nodeType&&n,B=k&&t&&!t.nodeType&&t,F=B&&B.exports===k,T=F&&C.process,_=function(){try{return T&&T.binding&&T.binding("util")}catch(e){}}(),P=_&&_.isTypedArray;function j(e,t){for(var n=-1,r=null==e?0:e.length;++n<r;)if(t(e[n],n,e))return!0;return!1}function N(e){var t=-1,n=Array(e.size);return e.forEach((function(e,r){n[++t]=[r,e]})),n}function I(e){var t=-1,n=Array(e.size);return e.forEach((function(e){n[++t]=e})),n}var L=Array.prototype,R=Function.prototype,M=Object.prototype,z=O["__core-js_shared__"],$=R.toString,H=M.hasOwnProperty,V=function(){var e=/[^.]+$/.exec(z&&z.keys&&z.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),U=M.toString,W=RegExp("^"+$.call(H).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),G=F?O.Buffer:void 0,q=O.Symbol,K=O.Uint8Array,Y=M.propertyIsEnumerable,X=L.splice,Z=q?q.toStringTag:void 0,J=Object.getOwnPropertySymbols,Q=G?G.isBuffer:void 0,ee=function(e,t){return function(n){return e(t(n))}}(Object.keys,Object),te=Be(O,"DataView"),ne=Be(O,"Map"),re=Be(O,"Promise"),oe=Be(O,"Set"),ie=Be(O,"WeakMap"),ae=Be(Object,"create"),ue=Pe(te),se=Pe(ne),le=Pe(re),ce=Pe(oe),fe=Pe(ie),de=q?q.prototype:void 0,pe=de?de.valueOf:void 0;function he(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}function ge(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}function ve(e){var t=-1,n=null==e?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}function ye(e){var t=-1,n=null==e?0:e.length;for(this.__data__=new ve;++t<n;)this.add(e[t])}function me(e){var t=this.__data__=new ge(e);this.size=t.size}function be(e,t){var n=Ie(e),r=!n&&Ne(e),o=!n&&!r&&Le(e),i=!n&&!r&&!o&&He(e),a=n||r||o||i,u=a?function(e,t){for(var n=-1,r=Array(e);++n<e;)r[n]=t(n);return r}(e.length,String):[],s=u.length;for(var l in e)!t&&!H.call(e,l)||a&&("length"==l||o&&("offset"==l||"parent"==l)||i&&("buffer"==l||"byteLength"==l||"byteOffset"==l)||_e(l,s))||u.push(l);return u}function we(e,t){for(var n=e.length;n--;)if(je(e[n][0],t))return n;return-1}function Ee(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":Z&&Z in Object(e)?function(e){var t=H.call(e,Z),n=e[Z];try{e[Z]=void 0;var r=!0}catch(e){}var o=U.call(e);r&&(t?e[Z]=n:delete e[Z]);return o}(e):function(e){return U.call(e)}(e)}function De(e){return $e(e)&&Ee(e)==i}function Se(e,t,n,r,o){return e===t||(null==e||null==t||!$e(e)&&!$e(t)?e!=e&&t!=t:function(e,t,n,r,o,c){var h=Ie(e),b=Ie(t),D=h?a:Te(e),S=b?a:Te(t),x=(D=D==i?p:D)==p,C=(S=S==i?p:S)==p,A=D==S;if(A&&Le(e)){if(!Le(t))return!1;h=!0,x=!1}if(A&&!x)return c||(c=new me),h||He(e)?Ae(e,t,n,r,o,c):function(e,t,n,r,o,i,a){switch(n){case E:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case w:return!(e.byteLength!=t.byteLength||!i(new K(e),new K(t)));case u:case s:case d:return je(+e,+t);case l:return e.name==t.name&&e.message==t.message;case g:case y:return e==t+"";case f:var c=N;case v:var p=1&r;if(c||(c=I),e.size!=t.size&&!p)return!1;var h=a.get(e);if(h)return h==t;r|=2,a.set(e,t);var b=Ae(c(e),c(t),r,o,i,a);return a.delete(e),b;case m:if(pe)return pe.call(e)==pe.call(t)}return!1}(e,t,D,n,r,o,c);if(!(1&n)){var O=x&&H.call(e,"__wrapped__"),k=C&&H.call(t,"__wrapped__");if(O||k){var B=O?e.value():e,F=k?t.value():t;return c||(c=new me),o(B,F,n,r,c)}}if(!A)return!1;return c||(c=new me),function(e,t,n,r,o,i){var a=1&n,u=Oe(e),s=u.length,l=Oe(t).length;if(s!=l&&!a)return!1;var c=s;for(;c--;){var f=u[c];if(!(a?f in t:H.call(t,f)))return!1}var d=i.get(e);if(d&&i.get(t))return d==t;var p=!0;i.set(e,t),i.set(t,e);var h=a;for(;++c<s;){var g=e[f=u[c]],v=t[f];if(r)var y=a?r(v,g,f,t,e,i):r(g,v,f,e,t,i);if(!(void 0===y?g===v||o(g,v,n,r,i):y)){p=!1;break}h||(h="constructor"==f)}if(p&&!h){var m=e.constructor,b=t.constructor;m==b||!("constructor"in e)||!("constructor"in t)||"function"==typeof m&&m instanceof m&&"function"==typeof b&&b instanceof b||(p=!1)}return i.delete(e),i.delete(t),p}(e,t,n,r,o,c)}(e,t,n,r,Se,o))}function xe(e){return!(!ze(e)||function(e){return!!V&&V in e}(e))&&(Re(e)?W:D).test(Pe(e))}function Ce(e){if(n=(t=e)&&t.constructor,r="function"==typeof n&&n.prototype||M,t!==r)return ee(e);var t,n,r,o=[];for(var i in Object(e))H.call(e,i)&&"constructor"!=i&&o.push(i);return o}function Ae(e,t,n,r,o,i){var a=1&n,u=e.length,s=t.length;if(u!=s&&!(a&&s>u))return!1;var l=i.get(e);if(l&&i.get(t))return l==t;var c=-1,f=!0,d=2&n?new ye:void 0;for(i.set(e,t),i.set(t,e);++c<u;){var p=e[c],h=t[c];if(r)var g=a?r(h,p,c,t,e,i):r(p,h,c,e,t,i);if(void 0!==g){if(g)continue;f=!1;break}if(d){if(!j(t,(function(e,t){if(a=t,!d.has(a)&&(p===e||o(p,e,n,r,i)))return d.push(t);var a}))){f=!1;break}}else if(p!==h&&!o(p,h,n,r,i)){f=!1;break}}return i.delete(e),i.delete(t),f}function Oe(e){return function(e,t,n){var r=t(e);return Ie(e)?r:function(e,t){for(var n=-1,r=t.length,o=e.length;++n<r;)e[o+n]=t[n];return e}(r,n(e))}(e,Ve,Fe)}function ke(e,t){var n,r,o=e.__data__;return("string"==(r=typeof(n=t))||"number"==r||"symbol"==r||"boolean"==r?"__proto__"!==n:null===n)?o["string"==typeof t?"string":"hash"]:o.map}function Be(e,t){var n=function(e,t){return null==e?void 0:e[t]}(e,t);return xe(n)?n:void 0}he.prototype.clear=function(){this.__data__=ae?ae(null):{},this.size=0},he.prototype.delete=function(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t},he.prototype.get=function(e){var t=this.__data__;if(ae){var n=t[e];return n===r?void 0:n}return H.call(t,e)?t[e]:void 0},he.prototype.has=function(e){var t=this.__data__;return ae?void 0!==t[e]:H.call(t,e)},he.prototype.set=function(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=ae&&void 0===t?r:t,this},ge.prototype.clear=function(){this.__data__=[],this.size=0},ge.prototype.delete=function(e){var t=this.__data__,n=we(t,e);return!(n<0)&&(n==t.length-1?t.pop():X.call(t,n,1),--this.size,!0)},ge.prototype.get=function(e){var t=this.__data__,n=we(t,e);return n<0?void 0:t[n][1]},ge.prototype.has=function(e){return we(this.__data__,e)>-1},ge.prototype.set=function(e,t){var n=this.__data__,r=we(n,e);return r<0?(++this.size,n.push([e,t])):n[r][1]=t,this},ve.prototype.clear=function(){this.size=0,this.__data__={hash:new he,map:new(ne||ge),string:new he}},ve.prototype.delete=function(e){var t=ke(this,e).delete(e);return this.size-=t?1:0,t},ve.prototype.get=function(e){return ke(this,e).get(e)},ve.prototype.has=function(e){return ke(this,e).has(e)},ve.prototype.set=function(e,t){var n=ke(this,e),r=n.size;return n.set(e,t),this.size+=n.size==r?0:1,this},ye.prototype.add=ye.prototype.push=function(e){return this.__data__.set(e,r),this},ye.prototype.has=function(e){return this.__data__.has(e)},me.prototype.clear=function(){this.__data__=new ge,this.size=0},me.prototype.delete=function(e){var t=this.__data__,n=t.delete(e);return this.size=t.size,n},me.prototype.get=function(e){return this.__data__.get(e)},me.prototype.has=function(e){return this.__data__.has(e)},me.prototype.set=function(e,t){var n=this.__data__;if(n instanceof ge){var r=n.__data__;if(!ne||r.length<199)return r.push([e,t]),this.size=++n.size,this;n=this.__data__=new ve(r)}return n.set(e,t),this.size=n.size,this};var Fe=J?function(e){return null==e?[]:(e=Object(e),function(e,t){for(var n=-1,r=null==e?0:e.length,o=0,i=[];++n<r;){var a=e[n];t(a,n,e)&&(i[o++]=a)}return i}(J(e),(function(t){return Y.call(e,t)})))}:function(){return[]},Te=Ee;function _e(e,t){return!!(t=null==t?o:t)&&("number"==typeof e||S.test(e))&&e>-1&&e%1==0&&e<t}function Pe(e){if(null!=e){try{return $.call(e)}catch(e){}try{return e+""}catch(e){}}return""}function je(e,t){return e===t||e!=e&&t!=t}(te&&Te(new te(new ArrayBuffer(1)))!=E||ne&&Te(new ne)!=f||re&&Te(re.resolve())!=h||oe&&Te(new oe)!=v||ie&&Te(new ie)!=b)&&(Te=function(e){var t=Ee(e),n=t==p?e.constructor:void 0,r=n?Pe(n):"";if(r)switch(r){case ue:return E;case se:return f;case le:return h;case ce:return v;case fe:return b}return t});var Ne=De(function(){return arguments}())?De:function(e){return $e(e)&&H.call(e,"callee")&&!Y.call(e,"callee")},Ie=Array.isArray;var Le=Q||function(){return!1};function Re(e){if(!ze(e))return!1;var t=Ee(e);return t==c||"[object GeneratorFunction]"==t||"[object AsyncFunction]"==t||"[object Proxy]"==t}function Me(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=o}function ze(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}function $e(e){return null!=e&&"object"==typeof e}var He=P?function(e){return function(t){return e(t)}}(P):function(e){return $e(e)&&Me(e.length)&&!!x[Ee(e)]};function Ve(e){return null!=(t=e)&&Me(t.length)&&!Re(t)?be(e):Ce(e);// removed by dead control flow
{ var t; }}t.exports=function(e,t){return Se(e,t)}}));MP("en",{tableModule:{deleteCol:"Delete column",deleteRow:"Delete row",deleteTable:"Delete table",widthAuto:"Width auto",insertCol:"Insert column",insertRow:"Insert row",insertTable:"Insert table",header:"Header"}}),MP("zh-CN",{tableModule:{deleteCol:"å é¤å",deleteRow:"å é¤è¡",deleteTable:"å é¤è¡¨æ ¼",widthAuto:"å®½åº¦èªéåº",insertCol:"æå¥å",insertRow:"æå¥è¡",insertTable:"æå¥è¡¨æ ¼",header:"è¡¨å¤´"}});var y0="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function m0(e){var t={exports:{}};return e(t,t.exports),t.exports}var b0,w0,E0=function(e){return e&&e.Math==Math&&e},D0=E0("object"==typeof globalThis&&globalThis)||E0("object"==typeof window&&window)||E0("object"==typeof self&&self)||E0("object"==typeof y0&&y0)||function(){return this}()||Function("return this")(),S0=function(e){try{return!!e()}catch(e){return!0}},x0=!S0((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),C0=Function.prototype.call,A0=C0.bind?C0.bind(C0):function(){return C0.apply(C0,arguments)},O0={}.propertyIsEnumerable,k0=Object.getOwnPropertyDescriptor,B0={f:k0&&!O0.call({1:2},1)?function(e){var t=k0(this,e);return!!t&&t.enumerable}:O0},F0=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},T0=Function.prototype,_0=T0.bind,P0=T0.call,j0=_0&&_0.bind(P0),N0=_0?function(e){return e&&j0(P0,e)}:function(e){return e&&function(){return P0.apply(e,arguments)}},I0=N0({}.toString),L0=N0("".slice),R0=function(e){return L0(I0(e),8,-1)},M0=D0.Object,z0=N0("".split),$0=S0((function(){return!M0("z").propertyIsEnumerable(0)}))?function(e){return"String"==R0(e)?z0(e,""):M0(e)}:M0,H0=D0.TypeError,V0=function(e){if(null==e)throw H0("Can't call method on "+e);return e},U0=function(e){return $0(V0(e))},W0=function(e){return"function"==typeof e},G0=function(e){return"object"==typeof e?null!==e:W0(e)},q0=function(e){return W0(e)?e:void 0},K0=function(e,t){return arguments.length<2?q0(D0[e]):D0[e]&&D0[e][t]},Y0=N0({}.isPrototypeOf),X0=K0("navigator","userAgent")||"",Z0=D0.process,J0=D0.Deno,Q0=Z0&&Z0.versions||J0&&J0.version,e1=Q0&&Q0.v8;e1&&(w0=(b0=e1.split("."))[0]>0&&b0[0]<4?1:+(b0[0]+b0[1])),!w0&&X0&&(!(b0=X0.match(/Edge\/(\d+)/))||b0[1]>=74)&&(b0=X0.match(/Chrome\/(\d+)/))&&(w0=+b0[1]);var t1=w0,n1=!!Object.getOwnPropertySymbols&&!S0((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&t1&&t1<41})),r1=n1&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,o1=D0.Object,i1=r1?function(e){return"symbol"==typeof e}:function(e){var t=K0("Symbol");return W0(t)&&Y0(t.prototype,o1(e))},a1=D0.String,u1=function(e){try{return a1(e)}catch(e){return"Object"}},s1=D0.TypeError,l1=function(e){if(W0(e))return e;throw s1(u1(e)+" is not a function")},c1=function(e,t){var n=e[t];return null==n?void 0:l1(n)},f1=D0.TypeError,d1=Object.defineProperty,p1=function(e,t){try{d1(D0,e,{value:t,configurable:!0,writable:!0})}catch(n){D0[e]=t}return t},h1=D0["__core-js_shared__"]||p1("__core-js_shared__",{}),g1=m0((function(e){(e.exports=function(e,t){return h1[e]||(h1[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),v1=D0.Object,y1=function(e){return v1(V0(e))},m1=N0({}.hasOwnProperty),b1=Object.hasOwn||function(e,t){return m1(y1(e),t)},w1=0,E1=Math.random(),D1=N0(1..toString),S1=function(e){return"Symbol("+(void 0===e?"":e)+")_"+D1(++w1+E1,36)},x1=g1("wks"),C1=D0.Symbol,A1=C1&&C1.for,O1=r1?C1:C1&&C1.withoutSetter||S1,k1=function(e){if(!b1(x1,e)||!n1&&"string"!=typeof x1[e]){var t="Symbol."+e;n1&&b1(C1,e)?x1[e]=C1[e]:x1[e]=r1&&A1?A1(t):O1(t)}return x1[e]},B1=D0.TypeError,F1=k1("toPrimitive"),T1=function(e){var t=function(e,t){if(!G0(e)||i1(e))return e;var n,r=c1(e,F1);if(r){if(void 0===t&&(t="default"),n=A0(r,e,t),!G0(n)||i1(n))return n;throw B1("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&W0(n=e.toString)&&!G0(r=A0(n,e)))return r;if(W0(n=e.valueOf)&&!G0(r=A0(n,e)))return r;if("string"!==t&&W0(n=e.toString)&&!G0(r=A0(n,e)))return r;throw f1("Can't convert object to primitive value")}(e,t)}(e,"string");return i1(t)?t:t+""},_1=D0.document,P1=G0(_1)&&G0(_1.createElement),j1=function(e){return P1?_1.createElement(e):{}},N1=!x0&&!S0((function(){return 7!=Object.defineProperty(j1("div"),"a",{get:function(){return 7}}).a})),I1=Object.getOwnPropertyDescriptor,L1={f:x0?I1:function(e,t){if(e=U0(e),t=T1(t),N1)try{return I1(e,t)}catch(e){}if(b1(e,t))return F0(!A0(B0.f,e,t),e[t])}},R1=D0.String,M1=D0.TypeError,z1=function(e){if(G0(e))return e;throw M1(R1(e)+" is not an object")},$1=D0.TypeError,H1=Object.defineProperty,V1={f:x0?H1:function(e,t,n){if(z1(e),t=T1(t),z1(n),N1)try{return H1(e,t,n)}catch(e){}if("get"in n||"set"in n)throw $1("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},U1=x0?function(e,t,n){return V1.f(e,t,F0(1,n))}:function(e,t,n){return e[t]=n,e},W1=N0(Function.toString);W0(h1.inspectSource)||(h1.inspectSource=function(e){return W1(e)});var G1,q1,K1,Y1=h1.inspectSource,X1=D0.WeakMap,Z1=W0(X1)&&/native code/.test(Y1(X1)),J1=g1("keys"),Q1=function(e){return J1[e]||(J1[e]=S1(e))},e2={},t2=D0.TypeError,n2=D0.WeakMap;if(Z1||h1.state){var r2=h1.state||(h1.state=new n2),o2=N0(r2.get),i2=N0(r2.has),a2=N0(r2.set);G1=function(e,t){if(i2(r2,e))throw new t2("Object already initialized");return t.facade=e,a2(r2,e,t),t},q1=function(e){return o2(r2,e)||{}},K1=function(e){return i2(r2,e)}}else{var u2=Q1("state");e2[u2]=!0,G1=function(e,t){if(b1(e,u2))throw new t2("Object already initialized");return t.facade=e,U1(e,u2,t),t},q1=function(e){return b1(e,u2)?e[u2]:{}},K1=function(e){return b1(e,u2)}}var s2={set:G1,get:q1,has:K1,enforce:function(e){return K1(e)?q1(e):G1(e,{})},getterFor:function(e){return function(t){var n;if(!G0(t)||(n=q1(t)).type!==e)throw t2("Incompatible receiver, "+e+" required");return n}}},l2=Function.prototype,c2=x0&&Object.getOwnPropertyDescriptor,f2=b1(l2,"name"),d2={EXISTS:f2,PROPER:f2&&"something"===function(){}.name,CONFIGURABLE:f2&&(!x0||x0&&c2(l2,"name").configurable)},p2=m0((function(e){var t=d2.CONFIGURABLE,n=s2.get,r=s2.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;W0(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!b1(i,"name")||t&&i.name!==f)&&U1(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==D0?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:U1(e,n,i)):l?e[n]=i:p1(n,i)})(Function.prototype,"toString",(function(){return W0(this)&&n(this).source||Y1(this)}))})),h2=Math.ceil,g2=Math.floor,v2=function(e){var t=+e;return t!=t||0===t?0:(t>0?g2:h2)(t)},y2=Math.max,m2=Math.min,b2=function(e,t){var n=v2(e);return n<0?y2(n+t,0):m2(n,t)},w2=Math.min,E2=function(e){return e>0?w2(v2(e),9007199254740991):0},D2=function(e){return E2(e.length)},S2=function(e){return function(t,n,r){var o,i=U0(t),a=D2(i),u=b2(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},x2=(S2(!0),S2(!1)),C2=N0([].push),A2=function(e,t){var n,r=U0(e),o=0,i=[];for(n in r)!b1(e2,n)&&b1(r,n)&&C2(i,n);for(;t.length>o;)b1(r,n=t[o++])&&(~x2(i,n)||C2(i,n));return i},O2=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],k2=O2.concat("length","prototype"),B2={f:Object.getOwnPropertyNames||function(e){return A2(e,k2)}},F2={f:Object.getOwnPropertySymbols},T2=N0([].concat),_2=K0("Reflect","ownKeys")||function(e){var t=B2.f(z1(e)),n=F2.f;return n?T2(t,n(e)):t},P2=function(e,t){for(var n=_2(t),r=V1.f,o=L1.f,i=0;i<n.length;i++){var a=n[i];b1(e,a)||r(e,a,o(t,a))}},j2=/#|\.prototype\./,N2=function(e,t){var n=L2[I2(e)];return n==M2||n!=R2&&(W0(t)?S0(t):!!t)},I2=N2.normalize=function(e){return String(e).replace(j2,".").toLowerCase()},L2=N2.data={},R2=N2.NATIVE="N",M2=N2.POLYFILL="P",z2=N2,$2=L1.f,H2=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?D0:l?D0[u]||p1(u,{}):(D0[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=$2(n,r))&&a.value:n[r],!z2(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;P2(i,o)}(e.sham||o&&o.sham)&&U1(i,"sham",!0),p2(n,r,i,e)}},V2={};V2[k1("toStringTag")]="z";var U2="[object z]"===String(V2),W2=k1("toStringTag"),G2=D0.Object,q2="Arguments"==R0(function(){return arguments}()),K2=U2?R0:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=G2(e),W2))?n:q2?R0(t):"Object"==(r=R0(t))&&W0(t.callee)?"Arguments":r},Y2=D0.String,X2=function(e){if("Symbol"===K2(e))throw TypeError("Cannot convert a Symbol value to a string");return Y2(e)},Z2=/"/g,J2=N0("".replace);H2({target:"String",proto:!0,forced:("anchor",S0((function(){var e="".anchor('"');return e!==e.toLowerCase()||e.split('"').length>3})))},{anchor:function(e){return"a","name",t=e,n=X2(V0(this)),r="<a",(r+=' name="'+J2(X2(t),Z2,"&quot;")+'"')+">"+n+"</a>";// removed by dead control flow
{ var t, n, r; }}});var Q2,e4=function(){var e=z1(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},t4=D0.RegExp,n4=S0((function(){var e=t4("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),r4=n4||S0((function(){return!t4("a","y").sticky})),o4={BROKEN_CARET:n4||S0((function(){var e=t4("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:r4,UNSUPPORTED_Y:n4},i4=Object.keys||function(e){return A2(e,O2)},a4=x0?Object.defineProperties:function(e,t){z1(e);for(var n,r=U0(t),o=i4(t),i=o.length,a=0;i>a;)V1.f(e,n=o[a++],r[n]);return e},u4=K0("document","documentElement"),s4=Q1("IE_PROTO"),l4=function(){},c4=function(e){return"<script>"+e+"<\/script>"},f4=function(e){e.write(c4("")),e.close();var t=e.parentWindow.Object;return e=null,t},d4=function(){try{Q2=new ActiveXObject("htmlfile")}catch(e){}var e,t;d4="undefined"!=typeof document?document.domain&&Q2?f4(Q2):((t=j1("iframe")).style.display="none",u4.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(c4("document.F=Object")),e.close(),e.F):f4(Q2);for(var n=O2.length;n--;)delete d4.prototype[O2[n]];return d4()};e2[s4]=!0;var p4,h4,g4=Object.create||function(e,t){var n;return null!==e?(l4.prototype=z1(e),n=new l4,l4.prototype=null,n[s4]=e):n=d4(),void 0===t?n:a4(n,t)},v4=D0.RegExp,y4=S0((function(){var e=v4(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),m4=D0.RegExp,b4=S0((function(){var e=m4("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),w4=s2.get,E4=g1("native-string-replace",String.prototype.replace),D4=RegExp.prototype.exec,S4=D4,x4=N0("".charAt),C4=N0("".indexOf),A4=N0("".replace),O4=N0("".slice),k4=(h4=/b*/g,A0(D4,p4=/a/,"a"),A0(D4,h4,"a"),0!==p4.lastIndex||0!==h4.lastIndex),B4=o4.BROKEN_CARET,F4=void 0!==/()??/.exec("")[1];(k4||F4||B4||y4||b4)&&(S4=function(e){var t,n,r,o,i,a,u,s=this,l=w4(s),c=X2(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=A0(S4,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=B4&&s.sticky,h=A0(e4,s),g=s.source,v=0,y=c;if(p&&(h=A4(h,"y",""),-1===C4(h,"g")&&(h+="g"),y=O4(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==x4(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),F4&&(n=new RegExp("^"+g+"$(?!\\s)",h)),k4&&(r=s.lastIndex),o=A0(D4,p?n:s,y),p?o?(o.input=O4(o.input,v),o[0]=O4(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:k4&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),F4&&o&&o.length>1&&A0(E4,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=g4(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var T4=S4;H2({target:"RegExp",proto:!0,forced:/./.exec!==T4},{exec:T4});var _4=Array.isArray||function(e){return"Array"==R0(e)},P4=function(){},j4=[],N4=K0("Reflect","construct"),I4=/^\s*(?:class|function)\b/,L4=N0(I4.exec),R4=!I4.exec(P4),M4=function(e){if(!W0(e))return!1;try{return N4(P4,j4,e),!0}catch(e){return!1}},z4=!N4||S0((function(){var e;return M4(M4.call)||!M4(Object)||!M4((function(){e=!0}))||e}))?function(e){if(!W0(e))return!1;switch(K2(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return R4||!!L4(I4,Y1(e))}:M4,$4=function(e,t,n){var r=T1(t);r in e?V1.f(e,r,F0(0,n)):e[r]=n},H4=k1("species"),V4=function(e){return t1>=51||!S0((function(){var t=[];return(t.constructor={})[H4]=function(){return{foo:1}},1!==t[e](Boolean).foo}))},U4=N0([].slice),W4=V4("slice"),G4=k1("species"),q4=D0.Array,K4=Math.max;function Y4(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return a}function X4(e){var t=e.selection;if(null==t)return!1;var n=Y4(Bf.nodes(e,{match:function(e){return QO.checkNodeType(e,"table-cell")}}),1)[0];if(n){var r=Y4(n,2)[1],o=Bf.start(e,r);if(Vf.equals(t.anchor,o))return!0}return!1}function Z4(e,t){var n,r,o=Bf.nodes(e,{at:t,match:function(e){return"table"===QO.getNodeType(e)}}),i=!1;try{for(var a=
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(o),u=a.next();!u.done;u=a.next())u.value,i=!0}catch(e){n={error:e}}finally{try{u&&!u.done&&(r=a.return)&&r.call(a)}finally{if(n)throw n.error}}return i}H2({target:"Array",proto:!0,forced:!W4},{slice:function(e,t){var n,r,o,i=U0(this),a=D2(i),u=b2(e,a),s=b2(void 0===t?a:t,a);if(_4(i)&&(n=i.constructor,(z4(n)&&(n===q4||_4(n.prototype))||G0(n)&&null===(n=n[G4]))&&(n=void 0),n===q4||void 0===n))return U4(i,u,s);for(r=new(void 0===n?q4:n)(K4(s-u,0)),o=0;u<s;u++,o++)u in i&&$4(r,o,i[u]);return r.length=o,r}});var J4=N0(N0.bind),Q4=k1("species"),e6=D0.Array,t6=function(e,t){return new(function(e){var t;return _4(e)&&(t=e.constructor,(z4(t)&&(t===e6||_4(t.prototype))||G0(t)&&null===(t=t[Q4]))&&(t=void 0)),void 0===t?e6:t}(e))(0===t?0:t)},n6=N0([].push),r6=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=y1(s),g=$0(h),v=function(e,t){return l1(e),void 0===t?e:J4?J4(e,t):function(){return e.apply(t,arguments)}}(l,c),y=D2(g),m=0,b=f||t6,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:n6(w,d)}else switch(e){case 4:return!1;case 7:n6(w,d)}return i?-1:r||o?o:w}},o6={forEach:r6(0),map:r6(1),filter:r6(2),some:r6(3),every:r6(4),find:r6(5),findIndex:r6(6),filterReject:r6(7)},i6=o6.map;H2({target:"Array",proto:!0,forced:!V4("map")},{map:function(e){return i6(this,e,arguments.length>1?arguments[1]:void 0)}});var a6=U2?{}.toString:function(){return"[object "+K2(this)+"]"};function u6(e){var t=e.children||[];return 0===t.length?[]:(t[0]||{}).children||[]}function s6(e){return u6(e).every((function(e){return!!e.isHeader}))}U2||p2(Object.prototype,"toString",a6,{unsafe:!0});var l6=d2.PROPER,c6=RegExp.prototype,f6=c6.toString,d6=N0(e4),p6=S0((function(){return"/a/b"!=f6.call({source:"a",flags:"b"})})),h6=l6&&"toString"!=f6.name;(p6||h6)&&p2(RegExp.prototype,"toString",(function(){var e=z1(this),t=X2(e.source),n=e.flags;return"/"+t+"/"+X2(void 0===n&&Y0(c6,e)&&!("flags"in c6)?d6(e):n)}),{unsafe:!0});var g6=k1("unscopables"),v6=Array.prototype;null==v6[g6]&&V1.f(v6,g6,{configurable:!0,value:g4(null)});var y6=o6.find,m6=!0;"find"in[]&&Array(1).find((function(){m6=!1})),H2({target:"Array",proto:!0,forced:m6},{find:function(e){return y6(this,e,arguments.length>1?arguments[1]:void 0)}}),v6[g6].find=!0;var b6=Function.prototype,w6=b6.apply,E6=b6.bind,D6=b6.call,S6="object"==typeof Reflect&&Reflect.apply||(E6?D6.bind(w6):function(){return D6.apply(w6,arguments)}),x6=k1("species"),C6=RegExp.prototype,A6=function(e,t,n,r){var o=k1(e),i=!S0((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!S0((function(){var t=!1,n=/a/;return"split"===e&&((n={}).constructor={},n.constructor[x6]=function(){return n},n.flags="",n[o]=/./[o]),n.exec=function(){return t=!0,null},n[o](""),!t}));if(!i||!a||n){var u=N0(/./[o]),s=t(o,""[e],(function(e,t,n,r,o){var a=N0(e),s=t.exec;return s===T4||s===C6.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));p2(String.prototype,e,s[0]),p2(C6,o,s[1])}r&&U1(C6[o],"sham",!0)},O6=k1("match"),k6=D0.TypeError,B6=k1("species"),F6=N0("".charAt),T6=N0("".charCodeAt),_6=N0("".slice),P6=function(e){return function(t,n){var r,o,i=X2(V0(t)),a=v2(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=T6(i,a))<55296||r>56319||a+1===u||(o=T6(i,a+1))<56320||o>57343?e?F6(i,a):r:e?_6(i,a,a+2):o-56320+(r-55296<<10)+65536}},j6=(P6(!1),P6(!0)),N6=function(e,t,n){return t+(n?j6(e,t).length:1)},I6=D0.Array,L6=Math.max,R6=function(e,t,n){for(var r=D2(e),o=b2(t,r),i=b2(void 0===n?r:n,r),a=I6(L6(i-o,0)),u=0;o<i;o++,u++)$4(a,u,e[o]);return a.length=u,a},M6=D0.TypeError,z6=function(e,t){var n=e.exec;if(W0(n)){var r=A0(n,e,t);return null!==r&&z1(r),r}if("RegExp"===R0(e))return A0(T4,e,t);throw M6("RegExp#exec called on incompatible receiver")},$6=o4.UNSUPPORTED_Y,H6=Math.min,V6=[].push,U6=N0(/./.exec),W6=N0(V6),G6=N0("".slice);A6("split",(function(e,t,n){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(e,n){var r,o,i=X2(V0(this)),a=void 0===n?4294967295:n>>>0;if(0===a)return[];if(void 0===e)return[i];if(!G0(r=e)||!(void 0!==(o=r[O6])?o:"RegExp"==R0(r)))return A0(t,i,e,a);for(var u,s,l,c=[],f=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),d=0,p=new RegExp(e.source,f+"g");(u=A0(T4,p,i))&&!((s=p.lastIndex)>d&&(W6(c,G6(i,d,u.index)),u.length>1&&u.index<i.length&&S6(V6,c,R6(u,1)),l=u[0].length,d=s,c.length>=a));)p.lastIndex===u.index&&p.lastIndex++;return d===i.length?!l&&U6(p,"")||W6(c,""):W6(c,G6(i,d)),c.length>a?R6(c,0,a):c}:"0".split(void 0,0).length?function(e,n){return void 0===e&&0===n?[]:A0(t,this,e,n)}:t,[function(t,n){var o=V0(this),i=null==t?void 0:c1(t,e);return i?A0(i,t,o,n):A0(r,X2(o),t,n)},function(e,o){var i=z1(this),a=X2(e),u=n(r,i,a,o,r!==t);if(u.done)return u.value;var s=function(e,t){var n,r=z1(e).constructor;return void 0===r||null==(n=z1(r)[B6])?t:function(e){if(z4(e))return e;throw k6(u1(e)+" is not a constructor")}(n)}(i,RegExp),l=i.unicode,c=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+($6?"g":"y"),f=new s($6?"^(?:"+i.source+")":i,c),d=void 0===o?4294967295:o>>>0;if(0===d)return[];if(0===a.length)return null===z6(f,a)?[a]:[];for(var p=0,h=0,g=[];h<a.length;){f.lastIndex=$6?0:h;var v,y=z6(f,$6?G6(a,h):a);if(null===y||(v=H6(E2(f.lastIndex+($6?h:0)),a.length))===p)h=N6(a,h,l);else{if(W6(g,G6(a,p,h)),g.length===d)return g;for(var m=1;m<=y.length-1;m++)if(W6(g,y[m]),g.length===d)return g;h=p=v}}return W6(g,G6(a,p)),g}]}),!!S0((function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var n="ab".split(e);return 2!==n.length||"a"!==n[0]||"b"!==n[1]})),$6);var q6="\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff",K6=N0("".replace),Y6="["+q6+"]",X6=RegExp("^"+Y6+Y6+"*"),Z6=RegExp(Y6+Y6+"*$"),J6=function(e){return function(t){var n=X2(V0(t));return 1&e&&(n=K6(n,X6,"")),2&e&&(n=K6(n,Z6,"")),n}},Q6={start:J6(1),end:J6(2),trim:J6(3)},e3=d2.PROPER,t3=Q6.trim;function n3(e){return e.length?e[0].tagName.toLowerCase():""}H2({target:"String",proto:!0,forced:function(e){return S0((function(){return!!q6[e]()||"âÂá "!=="âÂá "[e]()||e3&&q6[e].name!==e}))}("trim")},{trim:function(){return t3(this)}}),H2({global:!0},{globalThis:D0}),ah&&(Mp.fn.append=ah),qp&&(Mp.fn.on=qp),yh&&(Mp.fn.focus=yh),Vp&&(Mp.fn.attr=Vp),Gp&&(Mp.fn.val=Gp),rh&&(Mp.fn.html=rh),Wp&&(Mp.fn.dataset=Wp),zp&&(Mp.fn.addClass=zp),$p&&(Mp.fn.removeClass=$p),fh&&(Mp.fn.children=fh),th&&(Mp.fn.each=th),ch&&(Mp.fn.find=ch);var r3=!1,o3=0,i3=0,a3=null,u3=null,s3=Mp("body");function l3(e){r3=!1,u3=null,a3=null,s3.off("mousemove",c3),s3.off("mouseup",l3)}s3.on("mousedown",(function(e){var t=e.target;if(("TH"===t.tagName||"TD"===t.tagName)&&"col-resize"===t.style.cursor){t.style.cursor="auto",e.preventDefault(),r3=!0;var n=e.clientX;o3=n;var r=t.getBoundingClientRect().width;i3=r,s3.on("mousemove",c3),s3.on("mouseup",l3)}}));var c3=eg((function(e){if(r3&&null!=u3&&null!=a3){e.preventDefault();var t=e.clientX,n=i3+(t-o3);(n=Math.floor(100*n)/100)<30&&(n=30),md.setNodes(u3,{width:n.toString()},{at:a3})}}),100),f3={type:"table",renderElem:function(e,t,n){var r=function(e,t){if(e.isDisabled())return!1;var n=e.selection;if(null==n)return!0;if(qf.isCollapsed(n))return!0;var r=n.anchor,o=n.focus,i=QO.findPath(e,t),a=Bf.start(e,i),u=Bf.end(e,i),s=Vf.compare(r,u)<=0&&Vf.compare(r,a)>=0,l=Vf.compare(o,u)<=0&&Vf.compare(o,a)>=0;return!!(s&&l&&Mf.equals(r.path.slice(0,3),o.path.slice(0,3)))}(n,e),o=e.width,i=void 0===o?"auto":o,a=Pg("div",{className:"table-container","data-selected":QO.isNodeSelected(n,e),on:{mousedown:function(t){if("DIV"===t.target.tagName&&t.preventDefault(),!n.isDisabled()){var r=QO.findPath(n,e),o=Bf.start(n,r),i=n.selection;null!=i?i.anchor.path[0]!==r[0]&&n.select(o):n.select(o)}}}},Pg("table",{width:i,contentEditable:r},Pg("colgroup",null,u6(e).map((function(e){var t=e.width;return Pg("col",{width:void 0===t?"auto":t})}))),Pg("tbody",null,t)));return a}},d3={type:"table-row",renderElem:function(e,t,n){return Pg("tr",null,t)}},p3={type:"table-cell",renderElem:function(e,t,n){var r=function(e,t){var n=QO.getParentNode(e,t);if(null==n)return!1;var r=QO.getParentNode(e,n);return null!=r&&u6(r).some((function(e){return e===t}))}(n,e),o=e,i=o.colSpan,a=void 0===i?1:i,u=o.rowSpan,s=void 0===u?1:u,l=o.isHeader,c=void 0!==l&&l;if(!r)return Pg("td",{colSpan:a,rowSpan:s},t);var f=Pg(c?"th":"td",{colSpan:a,rowSpan:s,style:{borderRightWidth:"3px"},on:{mousemove:eg((function(t){var r=this.elm;if(null!=r){var o=r.getBoundingClientRect(),i=o.left,a=o.width,u=o.top,s=o.height,l=t.clientX,c=t.clientY;r3||(l>i+a-5&&l<i+a&&c>u&&c<u+s?(r.style.cursor="col-resize",u3=n,a3=QO.findPath(n,e)):r3||(r.style.cursor="auto",u3=null,a3=null))}}),100)}},t);return f}},h3={selector:"table",preParseHtml:function(e){var t=Mp(e);if("table"!==n3(t))return e;var n=t.find("tbody");if(0===n.length)return e;var r=t.find("tr");return t.append(r),n.remove(),t[0]}},g3=o6.filter;H2({target:"Array",proto:!0,forced:!V4("filter")},{filter:function(e){return g3(this,e,arguments.length>1?arguments[1]:void 0)}});var v3=Math.floor,y3=N0("".charAt),m3=N0("".replace),b3=N0("".slice),w3=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,E3=/\$([$&'`]|\d{1,2})/g,D3=function(e,t,n,r,o,i){var a=n+e.length,u=r.length,s=E3;return void 0!==o&&(o=y1(o),s=w3),m3(i,s,(function(i,s){var l;switch(y3(s,0)){case"$":return"$";case"&":return e;case"`":return b3(t,0,n);case"'":return b3(t,a);case"<":l=o[b3(s,1,-1)];break;default:var c=+s;if(0===c)return i;if(c>u){var f=v3(c/10);return 0===f?i:f<=u?void 0===r[f-1]?y3(s,1):r[f-1]+y3(s,1):i}l=r[c-1]}return void 0===l?"":l}))},S3=k1("replace"),x3=Math.max,C3=Math.min,A3=N0([].concat),O3=N0([].push),k3=N0("".indexOf),B3=N0("".slice),F3="$0"==="a".replace(/./,"$0"),T3=!!/./[S3]&&""===/./[S3]("a","$0");A6("replace",(function(e,t,n){var r=T3?"$":"$0";return[function(e,n){var r=V0(this),o=null==e?void 0:c1(e,S3);return o?A0(o,e,r,n):A0(t,X2(r),e,n)},function(e,o){var i=z1(this),a=X2(e);if("string"==typeof o&&-1===k3(o,r)&&-1===k3(o,"$<")){var u=n(t,i,a,o);if(u.done)return u.value}var s=W0(o);s||(o=X2(o));var l=i.global;if(l){var c=i.unicode;i.lastIndex=0}for(var f=[];;){var d=z6(i,a);if(null===d)break;if(O3(f,d),!l)break;""===X2(d[0])&&(i.lastIndex=N6(a,E2(i.lastIndex),c))}for(var p,h="",g=0,v=0;v<f.length;v++){for(var y=X2((d=f[v])[0]),m=x3(C3(v2(d.index),a.length),0),b=[],w=1;w<d.length;w++)O3(b,void 0===(p=d[w])?p:String(p));var E=d.groups;if(s){var D=A3([y],b,m,a);void 0!==E&&O3(D,E);var S=X2(S6(o,void 0,D))}else S=D3(y,a,m,b,E,o);m>=g&&(h+=B3(a,g,m)+S,g=m+y.length)}return h+B3(a,g)}]}),!!S0((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!F3||T3);var _3={selector:"td:not([data-w-e-type]),th:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e);0===(t=t.filter((function(e){return!!ed.isText(e)||!!n.isInline(e)}))).length&&(t=[{text:r.text().replace(/\s+/gm," ")}]);var o=parseInt(r.attr("colSpan")||"1"),i=parseInt(r.attr("rowSpan")||"1"),a=r.attr("width")||"auto";return{type:"table-cell",isHeader:"th"===n3(r),colSpan:o,rowSpan:i,width:a,children:t}}},P3={selector:"tr:not([data-w-e-type])",parseElemHtml:function(e,t,n){return{type:"table-row",children:t.filter((function(e){return"table-cell"===QO.getNodeType(e)}))}}},j3={selector:"table:not([data-w-e-type])",parseElemHtml:function(e,t,n){var r=Mp(e),o="auto";return"100%"===function(e,t){for(var n="",r=(e.attr("style")||"").split(";"),o=r.length,i=0;i<o;i++){var a=r[i];if(a){var u=a.split(":");"width"===u[0].trim()&&(n=u[1].trim())}}return n}(r)&&(o="100%"),"100%"===r.attr("width")&&(o="100%"),{type:"table",width:o,children:t.filter((function(e){return"table-row"===QO.getNodeType(e)}))}}},N3=function(){function e(){this.title=HP("tableModule.insertTable"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M0 64v896h1024V64H0z m384 576v-192h256v192h-256z m256 64v192h-256v-192h256z m0-512v192h-256V192h256zM320 192v192H64V192h256z m-256 256h256v192H64v-192z m640 0h256v192h-256v-192z m0-64V192h256v192h-256zM64 704h256v192H64v-192z m640 192v-192h256v192h-256z"></path></svg>',this.tag="button",this.showDropPanel=!0,this.$content=null}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||!!QO.getSelectedElems(e).some((function(t){var n=QO.getNodeType(t);return"pre"===n||"table"===n||"list-item"===n||!!e.isVoid(t)}))},e.prototype.getPanelContentElem=function(e){var t=this;if(this.$content)return this.$content[0];for(var n=Mp('<div class="w-e-panel-content-table"></div>'),r=Mp("<span>0 &times; 0</span>"),o=Mp("<table></table>"),i=0;i<10;i++){for(var a=Mp("<tr></tr>"),u=0;u<10;u++){var s=Mp("<td></td>");s.attr("data-x",u.toString()),s.attr("data-y",i.toString()),a.append(s),s.on("mouseenter",(function(e){var t=e.target;if(null!=t){var n=Mp(t).dataset(),i=n.x,a=n.y;r[0].innerHTML=i+1+" &times; "+(a+1),o.children().each((function(e){Mp(e).children().each((function(e){var t=Mp(e),n=t.dataset(),r=n.x,o=n.y;r<=i&&o<=a?t.addClass("active"):t.removeClass("active")}))}))}})),s.on("click",(function(n){n.preventDefault();var r=n.target;if(null!=r){var o=Mp(r).dataset(),i=o.x,a=o.y;t.insertTable(e,a+1,i+1)}}))}o.append(a)}return n.append(o),n.append(r),this.$content=n,n[0]},e.prototype.insertTable=function(e,t,n){var r=parseInt(t,10),o=parseInt(n,10);if(r&&o&&!(r<=0||o<=0)){QO.isSelectedEmptyParagraph(e)&&md.removeNodes(e,{mode:"highest"});var i=function(e,t){for(var n=[],r=0;r<e;r++){for(var o=[],i=0;i<t;i++){var a={type:"table-cell",children:[{text:""}]};0===r&&(a.isHeader=!0),o.push(a)}n.push({type:"table-row",children:o})}return{type:"table",width:"auto",children:n}}(r,o);md.insertNodes(e,i,{mode:"highest"})}},e}(),I3=function(){function e(){this.title=HP("tableModule.deleteTable"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M826.8032 356.5312c-19.328 0-36.3776 15.6928-36.3776 35.0464v524.2624c0 19.328-16 34.56-35.328 34.56H264.9344c-19.328 0-35.5072-15.3088-35.5072-34.56V390.0416c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.6928-33.5104 35.0464V915.712c0 57.9328 44.6208 108.288 102.528 108.288H755.2c57.9328 0 108.0832-50.4576 108.0832-108.288V391.4752c-0.1024-19.2512-17.1264-34.944-36.48-34.944z" p-id="9577"></path><path d="M437.1712 775.7568V390.6048c0-19.328-14.1568-35.0464-33.5104-35.0464s-33.5104 15.616-33.5104 35.0464v385.152c0 19.328 14.1568 35.0464 33.5104 35.0464s33.5104-15.7184 33.5104-35.0464zM649.7024 775.7568V390.6048c0-19.328-17.0496-35.0464-36.3776-35.0464s-36.3776 15.616-36.3776 35.0464v385.152c0 19.328 17.0496 35.0464 36.3776 35.0464s36.3776-15.7184 36.3776-35.0464zM965.0432 217.0368h-174.6176V145.5104c0-57.9328-47.2064-101.76-104.6528-101.76h-350.976c-57.8304 0-105.3952 43.8528-105.3952 101.76v71.5264H54.784c-19.4304 0-35.0464 14.1568-35.0464 33.5104 0 19.328 15.616 33.5104 35.0464 33.5104h910.3616c19.328 0 35.0464-14.1568 35.0464-33.5104 0-19.3536-15.6928-33.5104-35.1488-33.5104z m-247.3728 0H297.3952V145.5104c0-19.328 18.2016-34.7648 37.4272-34.7648h350.976c19.1488 0 31.872 15.1296 31.872 34.7648v71.5264z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return null==e.selection||null==QO.getSelectedNodeByType(e,"table")},e.prototype.exec=function(e,t){this.isDisabled(e)||md.removeNodes(e,{mode:"highest"})},e}(),L3=function(){function e(){this.title=HP("tableModule.insertRow"),this.iconSvg='<svg viewBox="0 0 1048 1024"><path d="M707.7888 521.0112h-147.456v-147.456H488.2432v147.456h-147.456v68.8128h147.456v147.456h72.0896v-147.456h147.456zM0 917.504V0h1048.576v917.504H0zM327.68 65.536H65.536v196.608H327.68V65.536z m327.68 0H393.216v196.608h262.144V65.536z m327.68 0h-262.144v196.608h262.144V65.536z m0 258.8672H65.536v462.0288H983.04V324.4032z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||null==QO.getSelectedNodeByType(e,"table")},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n=Y4(Bf.nodes(e,{match:function(e){return QO.checkNodeType(e,"table-cell")},universal:!0}),1),r=Y4(n[0],2),o=r[0],i=r[1],a=QO.getParentNode(e,o),u=(null==a?void 0:a.children.length)||0;if(0!==u){for(var s={type:"table-row",children:[]},l=0;l<u;l++)s.children.push({type:"table-cell",children:[{text:""}]});var c=Mf.parent(i),f=Mf.next(c);md.insertNodes(e,s,{at:f})}}},e}(),R3=function(){function e(){this.title=HP("tableModule.deleteRow"),this.iconSvg='<svg viewBox="0 0 1048 1024"><path d="M907.6736 586.5472L747.1104 425.984l163.84-163.84-78.6432-78.6432-163.84 163.84L507.904 186.7776 429.2608 262.144l163.84 163.84-167.1168 167.1168 78.6432 78.6432 167.1168-167.1168 160.5632 160.5632 75.3664-78.6432zM0 917.504V0h1048.576v917.504H0z m983.04-327.68h-22.9376l-65.536-65.536H983.04V327.68h-91.7504l65.536-65.536h26.2144V65.536H65.536v196.608h317.8496l65.536 65.536H65.536v196.608h380.1088l-65.536 65.536H65.536v196.608H983.04v-196.608z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||null==QO.getSelectedNodeByType(e,"table-row")},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n=Y4(Bf.nodes(e,{match:function(e){return QO.checkNodeType(e,"table-row")},universal:!0}),1),r=Y4(n[0],2),o=r[0],i=r[1],a=QO.getParentNode(e,o);((null==a?void 0:a.children.length)||0)<=1?md.removeNodes(e,{mode:"highest"}):md.removeNodes(e,{at:i})}},e}(),M3={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},z3=j1("span").classList,$3=z3&&z3.constructor&&z3.constructor.prototype,H3=$3===Object.prototype?void 0:$3,V3=o6.forEach,U3=function(e,t){var n=[].forEach;return!!n&&S0((function(){n.call(null,(function(){throw 1}),1)}))}(),W3=U3?[].forEach:function(e){return V3(this,e,arguments.length>1?arguments[1]:void 0)},G3=function(e){if(e&&e.forEach!==W3)try{U1(e,"forEach",W3)}catch(t){e.forEach=W3}};for(var q3 in M3)M3[q3]&&G3(D0[q3]&&D0[q3].prototype);G3(H3);var K3=function(){function e(){this.title=HP("tableModule.insertCol"),this.iconSvg='<svg viewBox="0 0 1048 1024"><path d="M327.68 193.3312v186.7776H140.9024v91.7504H327.68v186.7776h88.4736V471.8592h190.0544V380.1088H416.1536V193.3312zM0 917.504V0h1048.576v917.504H0zM655.36 65.536H65.536v720.896H655.36V65.536z m327.68 0h-262.144v196.608h262.144V65.536z m0 262.144h-262.144v196.608h262.144V327.68z m0 262.144h-262.144v196.608h262.144v-196.608z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||null==QO.getSelectedNodeByType(e,"table")},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n=Y4(Bf.nodes(e,{match:function(e){return QO.checkNodeType(e,"table-cell")},universal:!0}),1),r=Y4(n[0],2),o=r[0],i=r[1],a=QO.getParentNode(e,o);if(null!=a){var u=QO.getParentNode(e,a);null!=u&&(u.children||[]).forEach((function(t,n){Sf.isElement(t)&&(t.children||[]).forEach((function(t){var r=QO.findPath(e,t);if(r.length===i.length&&v0(r.slice(-1),i.slice(-1))){var o={type:"table-cell",children:[{text:""}]};0===n&&s6(u)&&(o.isHeader=!0),md.insertNodes(e,o,{at:r})}}))}))}}},e}(),Y3=function(){function e(){this.title=HP("tableModule.deleteCol"),this.iconSvg='<svg viewBox="0 0 1048 1024"><path d="M327.68 510.976L393.216 445.44v-13.1072L327.68 366.7968V510.976z m327.68-78.4384l65.536-65.536V507.904L655.36 442.368v-9.8304z m393.216 484.9664V0H0v917.504h1048.576z m-65.536-131.072h-262.144v-52.4288l-13.1072 13.1072-52.4288-52.4288v91.7504H393.216v-91.7504l-52.4288 52.4288-13.1072-13.1072v52.4288H65.536V65.536H327.68v121.2416l36.0448-36.0448 29.4912 29.4912V62.2592h262.144V180.224l49.152-49.152 16.384 16.384V62.2592h262.144V786.432z m-294.912-108.1344l-160.5632-160.5632-167.1168 167.1168-78.6432-78.6432 167.1168-167.1168L288.3584 278.528l78.6432-78.6432 160.5632 160.5632 163.84-163.84 78.6432 78.6432-163.84 163.84 160.5632 160.5632-78.6432 78.6432z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||null==QO.getSelectedNodeByType(e,"table-cell")},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n=Y4(Bf.nodes(e,{match:function(e){return QO.checkNodeType(e,"table-cell")},universal:!0}),1),r=Y4(n[0],2),o=r[0],i=r[1],a=QO.getParentNode(e,o),u=(null==a?void 0:a.children.length)||0;if(!a||u<=1)md.removeNodes(e,{mode:"highest"});else{var s=QO.getParentNode(e,a);null!=s&&(s.children||[]).forEach((function(t){Sf.isElement(t)&&(t.children||[]).forEach((function(t){var n=QO.findPath(e,t);n.length===i.length&&v0(n.slice(-1),i.slice(-1))&&md.removeNodes(e,{at:n})}))}))}}},e}(),X3=function(){function e(){this.title=HP("tableModule.header"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M704 128l-64 0L384 128 320 128 0 128l0 256 0 64 0 192 0 64 0 256 320 0 64 0 256 0 64 0 320 0 0-256 0-64L1024 448 1024 384 1024 128 704 128zM640 640 384 640 384 448l256 0L640 640zM64 448l256 0 0 192L64 640 64 448zM320 896 64 896l0-192 256 0L320 896zM640 896 384 896l0-192 256 0L640 896zM960 896l-256 0 0-192 256 0L960 896zM960 640l-256 0L704 448l256 0L960 640z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){var t=QO.getSelectedNodeByType(e,"table");return null!=t&&s6(t)},e.prototype.isActive=function(e){return!!this.getValue(e)},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||null==QO.getSelectedNodeByType(e,"table")},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n=!t,r=QO.getSelectedNodeByType(e,"table");null!=r&&u6(r).forEach((function(t){return md.setNodes(e,{isHeader:n},{at:QO.findPath(e,t)})}))}},e}(),Z3=function(){function e(){this.title=HP("tableModule.widthAuto"),this.iconSvg='<svg viewBox="0 0 1228 1024"><path d="M862.514337 563.200461H404.581995v121.753478a13.311987 13.311987 0 0 1-6.655993 11.468789 10.23999 10.23999 0 0 1-12.083188-1.433599l-204.799795-179.199821a13.721586 13.721586 0 0 1 0-20.479979l204.799795-179.302221a10.23999 10.23999 0 0 1 12.185588-1.535998 13.209587 13.209587 0 0 1 6.553593 11.673588v115.097485h457.932342V319.693504a11.571188 11.571188 0 0 1 18.841582-10.239989l204.799795 179.19982a13.721586 13.721586 0 0 1 0 20.47998l-204.799795 179.199821a10.23999 10.23999 0 0 1-12.185588 1.535998 13.311987 13.311987 0 0 1-6.655994-11.571188V563.200461zM136.499064 14.951409v993.893406a15.257585 15.257585 0 0 1-15.155185 15.052785H15.155185A15.155185 15.155185 0 0 1 0 1008.844815V14.951409a15.257585 15.257585 0 0 1 15.155185-15.052785h106.086294a15.155185 15.155185 0 0 1 15.257585 15.155185zM1228.798771 14.951409v993.893406a15.257585 15.257585 0 0 1-15.155185 15.052785h-106.188693a15.155185 15.155185 0 0 1-15.155185-15.052785V14.951409a15.257585 15.257585 0 0 1 15.155185-15.052785h106.086293A15.155185 15.155185 0 0 1 1228.798771 15.053809z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){var t=QO.getSelectedNodeByType(e,"table");return null!=t&&"100%"===t.width},e.prototype.isActive=function(e){return!!this.getValue(e)},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||null==QO.getSelectedNodeByType(e,"table")},e.prototype.exec=function(e,t){if(!this.isDisabled(e)){var n={width:t?"auto":"100%"};md.setNodes(e,n,{mode:"highest"})}},e}(),J3={renderElems:[f3,d3,p3],elemsToHtml:[{type:"table",elemToHtml:function(e,t){var n=e.width;return'<table style="width: '+(void 0===n?"auto":n)+';"><tbody>'+t+"</tbody></table>"}},{type:"table-row",elemToHtml:function(e,t){return"<tr>"+t+"</tr>"}},{type:"table-cell",elemToHtml:function(e,t){var n=e,r=n.colSpan,o=void 0===r?1:r,i=n.rowSpan,a=void 0===i?1:i,u=n.isHeader,s=void 0!==u&&u,l=n.width,c=s?"th":"td";return"<"+c+' colSpan="'+o+'" rowSpan="'+a+'" width="'+(void 0===l?"auto":l)+'">'+t+"</"+c+">"}}],preParseHtml:[h3],parseElemsHtml:[_3,P3,j3],menus:[{key:"insertTable",factory:function(){return new N3}},{key:"deleteTable",factory:function(){return new I3}},{key:"insertTableRow",factory:function(){return new L3}},{key:"deleteTableRow",factory:function(){return new R3}},{key:"insertTableCol",factory:function(){return new K3}},{key:"deleteTableCol",factory:function(){return new Y3}},{key:"tableHeader",factory:function(){return new X3}},{key:"tableFullWidth",factory:function(){return new Z3}}],editorPlugin:function(e){var t=e.insertBreak,n=e.deleteBackward,r=e.deleteForward,o=e.normalizeNode,i=e.insertData,a=e.handleTab,u=e.selectAll,s=e;return s.insertBreak=function(){null==QO.getSelectedNodeByType(s,"table")?t():s.insertText("\n")},s.deleteBackward=function(e){if(!X4(s)){var t=s.selection;if(t){var r=Bf.before(s,t);if(r){var o=Z4(s,r),i=Z4(s,t);if(o&&!i)return}}n(e)}},s.handleTab=function(){var t;if(QO.getSelectedNodeByType(s,"table")){var n=Bf.above(e);QO.checkNodeType(n[0],"table-cell")&&md.select(e,n[1]);var r=Bf.next(e);if(r)r[0]&&r[0].text&&(r=null!==(t=Bf.above(e,{at:r[1]}))&&void 0!==t?t:r),md.select(e,r[1]);else{var o=s.children||[],i=o.length;if(QO.checkNodeType(o[i-1],"table")){var u=QO.genEmptyParagraph();md.insertNodes(s,u,{at:[i]}),s.handleTab()}}}else a()},s.deleteForward=function(e){X4(s)||r(e)},s.normalizeNode=function(e){var t=Y4(e,2),n=t[0],r=t[1];if("table"!==QO.getNodeType(n))return o([n,r]);if(QO.isLastNode(s,n)){var i=QO.genEmptyParagraph();md.insertNodes(s,i,{at:[r[0]+1]})}},s.insertData=function(e){if(null!=QO.getSelectedNodeByType(s,"table")){var t=e.getData("text/plain");"\n"===t||/<img[^>]+>/.test(e.getData("text/html"))?i(e):Bf.insertText(s,t)}else i(e)},s.selectAll=function(){var e=s.selection;if(null!=e){var t=QO.getSelectedNodeByType(s,"table-cell");if(null!=t){var n=e.anchor,r=e.focus;if(Mf.equals(n.path.slice(0,3),r.path.slice(0,3)))if(0!==Nf.string(t).length){var o=QO.findPath(s,t),i={anchor:Bf.start(s,o),focus:Bf.end(s,o)};s.select(i)}else u();else u()}else u()}else u()},s}};MP("en",{videoModule:{delete:"Delete",uploadVideo:"Upload video",insertVideo:"Insert video",videoSrc:"Video source",videoSrcPlaceHolder:"Video file url, or third-party <iframe>",videoPoster:"Video poster",videoPosterPlaceHolder:"Poster image url",ok:"Ok",editSize:"Edit size",width:"Width",height:"Height"}}),MP("zh-CN",{videoModule:{delete:"å é¤è§é¢",uploadVideo:"ä¸ä¼ è§é¢",insertVideo:"æå¥è§é¢",videoSrc:"è§é¢å°å",videoSrcPlaceHolder:"è§é¢æä»¶ url æç¬¬ä¸æ¹ <iframe>",videoPoster:"è§é¢å°é¢",videoPosterPlaceHolder:"å°é¢å¾ç url",ok:"ç¡®å®",editSize:"ä¿®æ¹å°ºå¯¸",width:"å®½åº¦",height:"é«åº¦"}});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Q3=function(){return Q3=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e},Q3.apply(this,arguments)};function e5(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{s(r.next(e))}catch(e){i(e)}}function u(e){try{s(r.throw(e))}catch(e){i(e)}}function s(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,u)}s((r=r.apply(e,t||[])).next())}))}function t5(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function u(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=t.call(e,a)}catch(e){i=[6,e],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}}function n5(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return a}function r5(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,n=e[Symbol.asyncIterator];return n?n.call(e):(e=function(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(n){t[n]=e[n]&&function(t){return new Promise((function(r,o){!function(e,t,n,r){Promise.resolve(r).then((function(t){e({value:t,done:n})}),t)}(r,o,(t=e[n](t)).done,t.value)}))}}}var o5="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function i5(e){var t={exports:{}};return e(t,t.exports),t.exports}var a5,u5,s5=function(e){return e&&e.Math==Math&&e},l5=s5("object"==typeof globalThis&&globalThis)||s5("object"==typeof window&&window)||s5("object"==typeof self&&self)||s5("object"==typeof o5&&o5)||function(){return this}()||Function("return this")(),c5=function(e){try{return!!e()}catch(e){return!0}},f5=!c5((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),d5=Function.prototype.call,p5=d5.bind?d5.bind(d5):function(){return d5.apply(d5,arguments)},h5={}.propertyIsEnumerable,g5=Object.getOwnPropertyDescriptor,v5={f:g5&&!h5.call({1:2},1)?function(e){var t=g5(this,e);return!!t&&t.enumerable}:h5},y5=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},m5=Function.prototype,b5=m5.bind,w5=m5.call,E5=b5&&b5.bind(w5),D5=b5?function(e){return e&&E5(w5,e)}:function(e){return e&&function(){return w5.apply(e,arguments)}},S5=D5({}.toString),x5=D5("".slice),C5=function(e){return x5(S5(e),8,-1)},A5=l5.Object,O5=D5("".split),k5=c5((function(){return!A5("z").propertyIsEnumerable(0)}))?function(e){return"String"==C5(e)?O5(e,""):A5(e)}:A5,B5=l5.TypeError,F5=function(e){if(null==e)throw B5("Can't call method on "+e);return e},T5=function(e){return k5(F5(e))},_5=function(e){return"function"==typeof e},P5=function(e){return"object"==typeof e?null!==e:_5(e)},j5=function(e){return _5(e)?e:void 0},N5=function(e,t){return arguments.length<2?j5(l5[e]):l5[e]&&l5[e][t]},I5=D5({}.isPrototypeOf),L5=N5("navigator","userAgent")||"",R5=l5.process,M5=l5.Deno,z5=R5&&R5.versions||M5&&M5.version,$5=z5&&z5.v8;$5&&(u5=(a5=$5.split("."))[0]>0&&a5[0]<4?1:+(a5[0]+a5[1])),!u5&&L5&&(!(a5=L5.match(/Edge\/(\d+)/))||a5[1]>=74)&&(a5=L5.match(/Chrome\/(\d+)/))&&(u5=+a5[1]);var H5=u5,V5=!!Object.getOwnPropertySymbols&&!c5((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&H5&&H5<41})),U5=V5&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,W5=l5.Object,G5=U5?function(e){return"symbol"==typeof e}:function(e){var t=N5("Symbol");return _5(t)&&I5(t.prototype,W5(e))},q5=l5.String,K5=function(e){try{return q5(e)}catch(e){return"Object"}},Y5=l5.TypeError,X5=function(e){if(_5(e))return e;throw Y5(K5(e)+" is not a function")},Z5=function(e,t){var n=e[t];return null==n?void 0:X5(n)},J5=l5.TypeError,Q5=Object.defineProperty,e8=function(e,t){try{Q5(l5,e,{value:t,configurable:!0,writable:!0})}catch(n){l5[e]=t}return t},t8=l5["__core-js_shared__"]||e8("__core-js_shared__",{}),n8=i5((function(e){(e.exports=function(e,t){return t8[e]||(t8[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),r8=l5.Object,o8=function(e){return r8(F5(e))},i8=D5({}.hasOwnProperty),a8=Object.hasOwn||function(e,t){return i8(o8(e),t)},u8=0,s8=Math.random(),l8=D5(1..toString),c8=function(e){return"Symbol("+(void 0===e?"":e)+")_"+l8(++u8+s8,36)},f8=n8("wks"),d8=l5.Symbol,p8=d8&&d8.for,h8=U5?d8:d8&&d8.withoutSetter||c8,g8=function(e){if(!a8(f8,e)||!V5&&"string"!=typeof f8[e]){var t="Symbol."+e;V5&&a8(d8,e)?f8[e]=d8[e]:f8[e]=U5&&p8?p8(t):h8(t)}return f8[e]},v8=l5.TypeError,y8=g8("toPrimitive"),m8=function(e){var t=function(e,t){if(!P5(e)||G5(e))return e;var n,r=Z5(e,y8);if(r){if(void 0===t&&(t="default"),n=p5(r,e,t),!P5(n)||G5(n))return n;throw v8("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&_5(n=e.toString)&&!P5(r=p5(n,e)))return r;if(_5(n=e.valueOf)&&!P5(r=p5(n,e)))return r;if("string"!==t&&_5(n=e.toString)&&!P5(r=p5(n,e)))return r;throw J5("Can't convert object to primitive value")}(e,t)}(e,"string");return G5(t)?t:t+""},b8=l5.document,w8=P5(b8)&&P5(b8.createElement),E8=function(e){return w8?b8.createElement(e):{}},D8=!f5&&!c5((function(){return 7!=Object.defineProperty(E8("div"),"a",{get:function(){return 7}}).a})),S8=Object.getOwnPropertyDescriptor,x8={f:f5?S8:function(e,t){if(e=T5(e),t=m8(t),D8)try{return S8(e,t)}catch(e){}if(a8(e,t))return y5(!p5(v5.f,e,t),e[t])}},C8=l5.String,A8=l5.TypeError,O8=function(e){if(P5(e))return e;throw A8(C8(e)+" is not an object")},k8=l5.TypeError,B8=Object.defineProperty,F8={f:f5?B8:function(e,t,n){if(O8(e),t=m8(t),O8(n),D8)try{return B8(e,t,n)}catch(e){}if("get"in n||"set"in n)throw k8("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},T8=f5?function(e,t,n){return F8.f(e,t,y5(1,n))}:function(e,t,n){return e[t]=n,e},_8=D5(Function.toString);_5(t8.inspectSource)||(t8.inspectSource=function(e){return _8(e)});var P8,j8,N8,I8=t8.inspectSource,L8=l5.WeakMap,R8=_5(L8)&&/native code/.test(I8(L8)),M8=n8("keys"),z8=function(e){return M8[e]||(M8[e]=c8(e))},$8={},H8=l5.TypeError,V8=l5.WeakMap;if(R8||t8.state){var U8=t8.state||(t8.state=new V8),W8=D5(U8.get),G8=D5(U8.has),q8=D5(U8.set);P8=function(e,t){if(G8(U8,e))throw new H8("Object already initialized");return t.facade=e,q8(U8,e,t),t},j8=function(e){return W8(U8,e)||{}},N8=function(e){return G8(U8,e)}}else{var K8=z8("state");$8[K8]=!0,P8=function(e,t){if(a8(e,K8))throw new H8("Object already initialized");return t.facade=e,T8(e,K8,t),t},j8=function(e){return a8(e,K8)?e[K8]:{}},N8=function(e){return a8(e,K8)}}var Y8={set:P8,get:j8,has:N8,enforce:function(e){return N8(e)?j8(e):P8(e,{})},getterFor:function(e){return function(t){var n;if(!P5(t)||(n=j8(t)).type!==e)throw H8("Incompatible receiver, "+e+" required");return n}}},X8=Function.prototype,Z8=f5&&Object.getOwnPropertyDescriptor,J8=a8(X8,"name"),Q8={EXISTS:J8,PROPER:J8&&"something"===function(){}.name,CONFIGURABLE:J8&&(!f5||f5&&Z8(X8,"name").configurable)},e7=i5((function(e){var t=Q8.CONFIGURABLE,n=Y8.get,r=Y8.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;_5(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!a8(i,"name")||t&&i.name!==f)&&T8(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==l5?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:T8(e,n,i)):l?e[n]=i:e8(n,i)})(Function.prototype,"toString",(function(){return _5(this)&&n(this).source||I8(this)}))})),t7=Math.ceil,n7=Math.floor,r7=function(e){var t=+e;return t!=t||0===t?0:(t>0?n7:t7)(t)},o7=Math.max,i7=Math.min,a7=function(e,t){var n=r7(e);return n<0?o7(n+t,0):i7(n,t)},u7=Math.min,s7=function(e){return e>0?u7(r7(e),9007199254740991):0},l7=function(e){return s7(e.length)},c7=function(e){return function(t,n,r){var o,i=T5(t),a=l7(i),u=a7(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},f7={includes:c7(!0),indexOf:c7(!1)},d7=f7.indexOf,p7=D5([].push),h7=function(e,t){var n,r=T5(e),o=0,i=[];for(n in r)!a8($8,n)&&a8(r,n)&&p7(i,n);for(;t.length>o;)a8(r,n=t[o++])&&(~d7(i,n)||p7(i,n));return i},g7=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],v7=g7.concat("length","prototype"),y7={f:Object.getOwnPropertyNames||function(e){return h7(e,v7)}},m7={f:Object.getOwnPropertySymbols},b7=D5([].concat),w7=N5("Reflect","ownKeys")||function(e){var t=y7.f(O8(e)),n=m7.f;return n?b7(t,n(e)):t},E7=function(e,t){for(var n=w7(t),r=F8.f,o=x8.f,i=0;i<n.length;i++){var a=n[i];a8(e,a)||r(e,a,o(t,a))}},D7=/#|\.prototype\./,S7=function(e,t){var n=C7[x7(e)];return n==O7||n!=A7&&(_5(t)?c5(t):!!t)},x7=S7.normalize=function(e){return String(e).replace(D7,".").toLowerCase()},C7=S7.data={},A7=S7.NATIVE="N",O7=S7.POLYFILL="P",k7=S7,B7=x8.f,F7=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?l5:l?l5[u]||e8(u,{}):(l5[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=B7(n,r))&&a.value:n[r],!k7(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;E7(i,o)}(e.sham||o&&o.sham)&&T8(i,"sham",!0),e7(n,r,i,e)}},T7={};T7[g8("toStringTag")]="z";var _7="[object z]"===String(T7),P7=g8("toStringTag"),j7=l5.Object,N7="Arguments"==C5(function(){return arguments}()),I7=_7?C5:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=j7(e),P7))?n:N7?C5(t):"Object"==(r=C5(t))&&_5(t.callee)?"Arguments":r},L7=l5.String,R7=function(e){if("Symbol"===I7(e))throw TypeError("Cannot convert a Symbol value to a string");return L7(e)},M7="\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff",z7=D5("".replace),$7="["+M7+"]",H7=RegExp("^"+$7+$7+"*"),V7=RegExp($7+$7+"*$"),U7=function(e){return function(t){var n=R7(F5(t));return 1&e&&(n=z7(n,H7,"")),2&e&&(n=z7(n,V7,"")),n}},W7={start:U7(1),end:U7(2),trim:U7(3)},G7=Q8.PROPER,q7=W7.trim;function K7(e){return e.length?e[0].tagName.toLowerCase():""}function Y7(e,t,n){void 0===t&&(t="auto"),void 0===n&&(n="auto");var r=Mp(e);return r.attr("width",t),r.attr("height",n),r[0].outerHTML}F7({target:"String",proto:!0,forced:("trim",c5((function(){return!!M7.trim()||"âÂá "!=="âÂá ".trim()||G7&&"trim"!==M7.trim.name})))},{trim:function(){return q7(this)}}),F7({global:!0},{globalThis:l5}),ah&&(Mp.fn.append=ah),qp&&(Mp.fn.on=qp),yh&&(Mp.fn.focus=yh),Vp&&(Mp.fn.attr=Vp),Gp&&(Mp.fn.val=Gp),rh&&(Mp.fn.html=rh),sh&&(Mp.fn.parent=sh),Hp&&(Mp.fn.hasClass=Hp),ph&&(Mp.fn.empty=ph);var X7,Z7={type:"video",renderElem:function(e,t,n){var r,o=e,i=o.src,a=void 0===i?"":i,u=o.poster,s=void 0===u?"":u,l=o.width,c=void 0===l?"auto":l,f=o.height,d=void 0===f?"auto":f,p=QO.isNodeSelected(n,e);if(0===a.trim().indexOf("<iframe ")){r=Pg("div",{className:"w-e-textarea-video-container","data-selected":p?"true":"",innerHTML:Y7(a,c,d)})}else{var h=Pg("video",{poster:s,controls:!0},Pg("source",{src:a,type:"video/mp4"}),"Sorry, your browser doesn't support embedded videos.\n æ±æ­ï¼æµè§å¨ä¸æ¯æ video è§é¢");"auto"!==c&&(h.data.width=c),"auto"!==d&&(h.data.height=d),r=Pg("div",{className:"w-e-textarea-video-container","data-selected":p?"true":""},h)}return pg("div",{props:{contentEditable:!1},on:{mousedown:function(e){return e.preventDefault()}}},r)}},J7={type:"video",elemToHtml:function(e,t){var n=e,r=n.src,o=void 0===r?"":r,i=n.poster,a=void 0===i?"":i,u=n.width,s=void 0===u?"auto":u,l=n.height,c=void 0===l?"auto":l,f='<div data-w-e-type="video" data-w-e-is-void>\n';return 0===o.trim().indexOf("<iframe ")?f+=Y7(o,s,c):f+='<video poster="'+a+'" controls="true" width="'+s+'" height="'+c+'"><source src="'+o+'" type="video/mp4"/></video>',f+"\n</div>"}},Q7=Object.keys||function(e){return h7(e,g7)},e9=f5?Object.defineProperties:function(e,t){O8(e);for(var n,r=T5(t),o=Q7(t),i=o.length,a=0;i>a;)F8.f(e,n=o[a++],r[n]);return e},t9=N5("document","documentElement"),n9=z8("IE_PROTO"),r9=function(){},o9=function(e){return"<script>"+e+"<\/script>"},i9=function(e){e.write(o9("")),e.close();var t=e.parentWindow.Object;return e=null,t},a9=function(){try{X7=new ActiveXObject("htmlfile")}catch(e){}var e,t;a9="undefined"!=typeof document?document.domain&&X7?i9(X7):((t=E8("iframe")).style.display="none",t9.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(o9("document.F=Object")),e.close(),e.F):i9(X7);for(var n=g7.length;n--;)delete a9.prototype[g7[n]];return a9()};$8[n9]=!0;var u9=Object.create||function(e,t){var n;return null!==e?(r9.prototype=O8(e),n=new r9,r9.prototype=null,n[n9]=e):n=a9(),void 0===t?n:e9(n,t)},s9=g8("unscopables"),l9=Array.prototype;null==l9[s9]&&F8.f(l9,s9,{configurable:!0,value:u9(null)});var c9=function(e){l9[s9][e]=!0},f9=f7.includes;F7({target:"Array",proto:!0},{includes:function(e){return f9(this,e,arguments.length>1?arguments[1]:void 0)}}),c9("includes");var d9={selector:"iframe,video,p",preParseHtml:function(e){var t=Mp(e),n=t;if("p"===K7(t)){var r=t.children();if(1===r.length){var o=r[0],i=o.tagName.toLowerCase();["iframe","video"].includes(i)&&(n=Mp(o))}}var a=K7(n);if("iframe"!==a&&"video"!==a)return n[0];if("video"===n.parent().attr("data-w-e-type"))return n[0];var u=Mp('<div data-w-e-type="video" data-w-e-is-void></div>');return u.append(n),u[0]}},p9=D5(D5.bind),h9=function(e,t){return X5(e),void 0===t?e:p9?p9(e,t):function(){return e.apply(t,arguments)}},g9=Array.isArray||function(e){return"Array"==C5(e)},v9=function(){},y9=[],m9=N5("Reflect","construct"),b9=/^\s*(?:class|function)\b/,w9=D5(b9.exec),E9=!b9.exec(v9),D9=function(e){if(!_5(e))return!1;try{return m9(v9,y9,e),!0}catch(e){return!1}},S9=!m9||c5((function(){var e;return D9(D9.call)||!D9(Object)||!D9((function(){e=!0}))||e}))?function(e){if(!_5(e))return!1;switch(I7(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return E9||!!w9(b9,I8(e))}:D9,x9=g8("species"),C9=l5.Array,A9=function(e,t){return new(function(e){var t;return g9(e)&&(t=e.constructor,(S9(t)&&(t===C9||g9(t.prototype))||P5(t)&&null===(t=t[x9]))&&(t=void 0)),void 0===t?C9:t}(e))(0===t?0:t)},O9=D5([].push),k9=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=o8(s),g=k5(h),v=h9(l,c),y=l7(g),m=0,b=f||A9,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:O9(w,d)}else switch(e){case 4:return!1;case 7:O9(w,d)}return i?-1:r||o?o:w}},B9={forEach:k9(0),map:k9(1),filter:k9(2),some:k9(3),every:k9(4),find:k9(5),findIndex:k9(6),filterReject:k9(7)},F9=B9.find,T9=!0;"find"in[]&&Array(1).find((function(){T9=!1})),F7({target:"Array",proto:!0,forced:T9},{find:function(e){return F9(this,e,arguments.length>1?arguments[1]:void 0)}}),c9("find");var _9=_7?{}.toString:function(){return"[object "+I7(this)+"]"};function P9(e,t,n,r){return void 0===t&&(t=""),void 0===n&&(n="auto"),void 0===r&&(r="auto"),{type:"video",src:e,poster:t,width:n,height:r,children:[{text:""}]}}_7||e7(Object.prototype,"toString",_9,{unsafe:!0});var j9,N9,I9={selector:'div[data-w-e-type="video"]',parseElemHtml:function(e,t,n){var r=Mp(e),o="",i="",a="auto",u="auto",s=r.find("iframe");if(s.length>0)return a=s.attr("width")||"auto",u=s.attr("height")||"auto",P9(o=s[0].outerHTML,i,a,u);var l=r.find("video");return(o=l.attr("src")||"")||l.length>0&&(o=l.find("source").attr("src")||""),a=l.attr("width")||"auto",u=l.attr("height")||"auto",P9(o,i=l.attr("poster")||"",a,u)}},L9=function(){var e=O8(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},R9=l5.RegExp,M9=c5((function(){var e=R9("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),z9=M9||c5((function(){return!R9("a","y").sticky})),$9={BROKEN_CARET:M9||c5((function(){var e=R9("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:z9,UNSUPPORTED_Y:M9},H9=l5.RegExp,V9=c5((function(){var e=H9(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),U9=l5.RegExp,W9=c5((function(){var e=U9("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),G9=Y8.get,q9=n8("native-string-replace",String.prototype.replace),K9=RegExp.prototype.exec,Y9=K9,X9=D5("".charAt),Z9=D5("".indexOf),J9=D5("".replace),Q9=D5("".slice),eee=(N9=/b*/g,p5(K9,j9=/a/,"a"),p5(K9,N9,"a"),0!==j9.lastIndex||0!==N9.lastIndex),tee=$9.BROKEN_CARET,nee=void 0!==/()??/.exec("")[1];(eee||nee||tee||V9||W9)&&(Y9=function(e){var t,n,r,o,i,a,u,s=this,l=G9(s),c=R7(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=p5(Y9,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=tee&&s.sticky,h=p5(L9,s),g=s.source,v=0,y=c;if(p&&(h=J9(h,"y",""),-1===Z9(h,"g")&&(h+="g"),y=Q9(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==X9(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),nee&&(n=new RegExp("^"+g+"$(?!\\s)",h)),eee&&(r=s.lastIndex),o=p5(K9,p?n:s,y),p?o?(o.input=Q9(o.input,v),o[0]=Q9(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:eee&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),nee&&o&&o.length>1&&p5(q9,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=u9(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var ree=Y9;F7({target:"RegExp",proto:!0,forced:/./.exec!==ree},{exec:ree});var oee=Function.prototype,iee=oee.apply,aee=oee.bind,uee=oee.call,see="object"==typeof Reflect&&Reflect.apply||(aee?uee.bind(iee):function(){return uee.apply(iee,arguments)}),lee=(g8("species"),RegExp.prototype),cee=D5("".charAt),fee=D5("".charCodeAt),dee=D5("".slice),pee=function(e){return function(t,n){var r,o,i=R7(F5(t)),a=r7(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=fee(i,a))<55296||r>56319||a+1===u||(o=fee(i,a+1))<56320||o>57343?e?cee(i,a):r:e?dee(i,a,a+2):o-56320+(r-55296<<10)+65536}},hee={codeAt:pee(!1),charAt:pee(!0)},gee=hee.charAt,vee=function(e,t,n){return t+(n?gee(e,t).length:1)},yee=Math.floor,mee=D5("".charAt),bee=D5("".replace),wee=D5("".slice),Eee=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,Dee=/\$([$&'`]|\d{1,2})/g,See=function(e,t,n,r,o,i){var a=n+e.length,u=r.length,s=Dee;return void 0!==o&&(o=o8(o),s=Eee),bee(i,s,(function(i,s){var l;switch(mee(s,0)){case"$":return"$";case"&":return e;case"`":return wee(t,0,n);case"'":return wee(t,a);case"<":l=o[wee(s,1,-1)];break;default:var c=+s;if(0===c)return i;if(c>u){var f=yee(c/10);return 0===f?i:f<=u?void 0===r[f-1]?mee(s,1):r[f-1]+mee(s,1):i}l=r[c-1]}return void 0===l?"":l}))},xee=l5.TypeError,Cee=function(e,t){var n=e.exec;if(_5(n)){var r=p5(n,e,t);return null!==r&&O8(r),r}if("RegExp"===C5(e))return p5(ree,e,t);throw xee("RegExp#exec called on incompatible receiver")},Aee=g8("replace"),Oee=Math.max,kee=Math.min,Bee=D5([].concat),Fee=D5([].push),Tee=D5("".indexOf),_ee=D5("".slice),Pee="$0"==="a".replace(/./,"$0"),jee=!!/./[Aee]&&""===/./[Aee]("a","$0");function Nee(e){return void 0===e&&(e="r"),e+"-"+Rh()}!function(e,t,n,r){var o=g8(e),i=!c5((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!c5((function(){var e=!1,t=/a/;return t.exec=function(){return e=!0,null},t[o](""),!e}));if(!i||!a||n){var u=D5(/./[o]),s=function(e,t,n){var r=jee?"$":"$0";return[function(e,n){var r=F5(this),o=null==e?void 0:Z5(e,Aee);return o?p5(o,e,r,n):p5(t,R7(r),e,n)},function(e,o){var i=O8(this),a=R7(e);if("string"==typeof o&&-1===Tee(o,r)&&-1===Tee(o,"$<")){var u=n(t,i,a,o);if(u.done)return u.value}var s=_5(o);s||(o=R7(o));var l=i.global;if(l){var c=i.unicode;i.lastIndex=0}for(var f=[];;){var d=Cee(i,a);if(null===d)break;if(Fee(f,d),!l)break;""===R7(d[0])&&(i.lastIndex=vee(a,s7(i.lastIndex),c))}for(var p,h="",g=0,v=0;v<f.length;v++){for(var y=R7((d=f[v])[0]),m=Oee(kee(r7(d.index),a.length),0),b=[],w=1;w<d.length;w++)Fee(b,void 0===(p=d[w])?p:String(p));var E=d.groups;if(s){var D=Bee([y],b,m,a);void 0!==E&&Fee(D,E);var S=R7(see(o,void 0,D))}else S=See(y,a,m,b,E,o);m>=g&&(h+=_ee(a,g,m)+S,g=m+y.length)}return h+_ee(a,g)}]}(0,""[e],(function(e,t,n,r,o){var a=D5(e),s=t.exec;return s===ree||s===lee.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));e7(String.prototype,e,s[0]),e7(lee,o,s[1])}}("replace",0,!!c5((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!Pee||jee);var Iee=l5.Promise,Lee=function(e,t,n){for(var r in t)e7(e,r,t[r],n);return e},Ree=l5.String,Mee=l5.TypeError,zee=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=D5(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(n,[]),t=n instanceof Array}catch(e){}return function(n,r){return O8(n),function(e){if("object"==typeof e||_5(e))return e;throw Mee("Can't set "+Ree(e)+" as a prototype")}(r),t?e(n,r):n.__proto__=r,n}}():void 0),$ee=F8.f,Hee=g8("toStringTag"),Vee=function(e,t,n){e&&!a8(e=n?e:e.prototype,Hee)&&$ee(e,Hee,{configurable:!0,value:t})},Uee=g8("species"),Wee=l5.TypeError,Gee=function(e,t){if(I5(t,e))return e;throw Wee("Incorrect invocation")},qee={},Kee=g8("iterator"),Yee=Array.prototype,Xee=g8("iterator"),Zee=function(e){if(null!=e)return Z5(e,Xee)||Z5(e,"@@iterator")||qee[I7(e)]},Jee=l5.TypeError,Qee=function(e,t,n){var r,o;O8(e);try{if(!(r=Z5(e,"return"))){if("throw"===t)throw n;return n}r=p5(r,e)}catch(e){o=!0,r=e}if("throw"===t)throw n;if(o)throw r;return O8(r),n},ete=l5.TypeError,tte=function(e,t){this.stopped=e,this.result=t},nte=tte.prototype,rte=function(e,t,n){var r,o,i,a,u,s,l,c,f=n&&n.that,d=!(!n||!n.AS_ENTRIES),p=!(!n||!n.IS_ITERATOR),h=!(!n||!n.INTERRUPTED),g=h9(t,f),v=function(e){return r&&Qee(r,"normal",e),new tte(!0,e)},y=function(e){return d?(O8(e),h?g(e[0],e[1],v):g(e[0],e[1])):h?g(e,v):g(e)};if(p)r=e;else{if(!(o=Zee(e)))throw ete(K5(e)+" is not iterable");if(void 0!==(c=o)&&(qee.Array===c||Yee[Kee]===c)){for(i=0,a=l7(e);a>i;i++)if((u=y(e[i]))&&I5(nte,u))return u;return new tte(!1)}r=function(e,t){var n=arguments.length<2?Zee(e):t;if(X5(n))return O8(p5(n,e));throw Jee(K5(e)+" is not iterable")}(e,o)}for(s=r.next;!(l=p5(s,r)).done;){try{u=y(l.value)}catch(e){Qee(r,"throw",e)}if("object"==typeof u&&u&&I5(nte,u))return u}return new tte(!1)},ote=g8("iterator"),ite=!1;try{var ate=0,ute={next:function(){return{done:!!ate++}},return:function(){ite=!0}};ute[ote]=function(){return this},Array.from(ute,(function(){throw 2}))}catch(Ml){}var ste,lte,cte,fte,dte=function(e,t){if(!t&&!ite)return!1;var n=!1;try{var r={};r[ote]=function(){return{next:function(){return{done:n=!0}}}},e(r)}catch(e){}return n},pte=l5.TypeError,hte=g8("species"),gte=D5([].slice),vte=/(?:ipad|iphone|ipod).*applewebkit/i.test(L5),yte="process"==C5(l5.process),mte=l5.setImmediate,bte=l5.clearImmediate,wte=l5.process,Ete=l5.Dispatch,Dte=l5.Function,Ste=l5.MessageChannel,xte=l5.String,Cte=0,Ate={};try{ste=l5.location}catch(Ml){}var Ote=function(e){if(a8(Ate,e)){var t=Ate[e];delete Ate[e],t()}},kte=function(e){return function(){Ote(e)}},Bte=function(e){Ote(e.data)},Fte=function(e){l5.postMessage(xte(e),ste.protocol+"//"+ste.host)};mte&&bte||(mte=function(e){var t=gte(arguments,1);return Ate[++Cte]=function(){see(_5(e)?e:Dte(e),void 0,t)},lte(Cte),Cte},bte=function(e){delete Ate[e]},yte?lte=function(e){wte.nextTick(kte(e))}:Ete&&Ete.now?lte=function(e){Ete.now(kte(e))}:Ste&&!vte?(fte=(cte=new Ste).port2,cte.port1.onmessage=Bte,lte=h9(fte.postMessage,fte)):l5.addEventListener&&_5(l5.postMessage)&&!l5.importScripts&&ste&&"file:"!==ste.protocol&&!c5(Fte)?(lte=Fte,l5.addEventListener("message",Bte,!1)):lte="onreadystatechange"in E8("script")?function(e){t9.appendChild(E8("script")).onreadystatechange=function(){t9.removeChild(this),Ote(e)}}:function(e){setTimeout(kte(e),0)});var Tte,_te,Pte,jte,Nte,Ite,Lte,Rte,Mte={set:mte,clear:bte},zte=/ipad|iphone|ipod/i.test(L5)&&void 0!==l5.Pebble,$te=/web0s(?!.*chrome)/i.test(L5),Hte=x8.f,Vte=Mte.set,Ute=l5.MutationObserver||l5.WebKitMutationObserver,Wte=l5.document,Gte=l5.process,qte=l5.Promise,Kte=Hte(l5,"queueMicrotask"),Yte=Kte&&Kte.value;Yte||(Tte=function(){var e,t;for(yte&&(e=Gte.domain)&&e.exit();_te;){t=_te.fn,_te=_te.next;try{t()}catch(e){throw _te?jte():Pte=void 0,e}}Pte=void 0,e&&e.enter()},vte||yte||$te||!Ute||!Wte?!zte&&qte&&qte.resolve?((Lte=qte.resolve(void 0)).constructor=qte,Rte=h9(Lte.then,Lte),jte=function(){Rte(Tte)}):yte?jte=function(){Gte.nextTick(Tte)}:(Vte=h9(Vte,l5),jte=function(){Vte(Tte)}):(Nte=!0,Ite=Wte.createTextNode(""),new Ute(Tte).observe(Ite,{characterData:!0}),jte=function(){Ite.data=Nte=!Nte}));var Xte,Zte,Jte,Qte,ene=Yte||function(e){var t={fn:e,next:void 0};Pte&&(Pte.next=t),_te||(_te=t,jte()),Pte=t},tne=function(e){var t,n;this.promise=new e((function(e,r){if(void 0!==t||void 0!==n)throw TypeError("Bad Promise constructor");t=e,n=r})),this.resolve=X5(t),this.reject=X5(n)},nne={f:function(e){return new tne(e)}},rne=function(e){try{return{error:!1,value:e()}}catch(e){return{error:!0,value:e}}},one="object"==typeof window,ine=Mte.set,ane=g8("species"),une="Promise",sne=Y8.getterFor(une),lne=Y8.set,cne=Y8.getterFor(une),fne=Iee&&Iee.prototype,dne=Iee,pne=fne,hne=l5.TypeError,gne=l5.document,vne=l5.process,yne=nne.f,mne=yne,bne=!!(gne&&gne.createEvent&&l5.dispatchEvent),wne=_5(l5.PromiseRejectionEvent),Ene=!1,Dne=k7(une,(function(){var e=I8(dne),t=e!==String(dne);if(!t&&66===H5)return!0;if(H5>=51&&/native code/.test(e))return!1;var n=new dne((function(e){e(1)})),r=function(e){e((function(){}),(function(){}))};return(n.constructor={})[ane]=r,!(Ene=n.then((function(){}))instanceof r)||!t&&one&&!wne})),Sne=Dne||!dte((function(e){dne.all(e).catch((function(){}))})),xne=function(e){var t;return!(!P5(e)||!_5(t=e.then))&&t},Cne=function(e,t){if(!e.notified){e.notified=!0;var n=e.reactions;ene((function(){for(var r=e.value,o=1==e.state,i=0;n.length>i;){var a,u,s,l=n[i++],c=o?l.ok:l.fail,f=l.resolve,d=l.reject,p=l.domain;try{c?(o||(2===e.rejection&&Bne(e),e.rejection=1),!0===c?a=r:(p&&p.enter(),a=c(r),p&&(p.exit(),s=!0)),a===l.promise?d(hne("Promise-chain cycle")):(u=xne(a))?p5(u,a,f,d):f(a)):d(r)}catch(e){p&&!s&&p.exit(),d(e)}}e.reactions=[],e.notified=!1,t&&!e.rejection&&One(e)}))}},Ane=function(e,t,n){var r,o;bne?((r=gne.createEvent("Event")).promise=t,r.reason=n,r.initEvent(e,!1,!0),l5.dispatchEvent(r)):r={promise:t,reason:n},!wne&&(o=l5["on"+e])?o(r):"unhandledrejection"===e&&function(e,t){var n=l5.console;n&&n.error&&(1==arguments.length?n.error(e):n.error(e,t))}("Unhandled promise rejection",n)},One=function(e){p5(ine,l5,(function(){var t,n=e.facade,r=e.value;if(kne(e)&&(t=rne((function(){yte?vne.emit("unhandledRejection",r,n):Ane("unhandledrejection",n,r)})),e.rejection=yte||kne(e)?2:1,t.error))throw t.value}))},kne=function(e){return 1!==e.rejection&&!e.parent},Bne=function(e){p5(ine,l5,(function(){var t=e.facade;yte?vne.emit("rejectionHandled",t):Ane("rejectionhandled",t,e.value)}))},Fne=function(e,t,n){return function(r){e(t,r,n)}},Tne=function(e,t,n){e.done||(e.done=!0,n&&(e=n),e.value=t,e.state=2,Cne(e,!0))},_ne=function(e,t,n){if(!e.done){e.done=!0,n&&(e=n);try{if(e.facade===t)throw hne("Promise can't be resolved itself");var r=xne(t);r?ene((function(){var n={done:!1};try{p5(r,t,Fne(_ne,n,e),Fne(Tne,n,e))}catch(t){Tne(n,t,e)}})):(e.value=t,e.state=1,Cne(e,!1))}catch(t){Tne({done:!1},t,e)}}};if(Dne&&(pne=(dne=function(e){Gee(this,pne),X5(e),p5(Xte,this);var t=sne(this);try{e(Fne(_ne,t),Fne(Tne,t))}catch(e){Tne(t,e)}}).prototype,(Xte=function(e){lne(this,{type:une,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=Lee(pne,{then:function(e,t){var n=cne(this),r=n.reactions,o=yne(function(e,t){var n,r=O8(e).constructor;return void 0===r||null==(n=O8(r)[hte])?t:function(e){if(S9(e))return e;throw pte(K5(e)+" is not a constructor")}(n)}(this,dne));return o.ok=!_5(e)||e,o.fail=_5(t)&&t,o.domain=yte?vne.domain:void 0,n.parent=!0,r[r.length]=o,0!=n.state&&Cne(n,!1),o.promise},catch:function(e){return this.then(void 0,e)}}),Zte=function(){var e=new Xte,t=sne(e);this.promise=e,this.resolve=Fne(_ne,t),this.reject=Fne(Tne,t)},nne.f=yne=function(e){return e===dne||e===Jte?new Zte(e):mne(e)},_5(Iee)&&fne!==Object.prototype)){Qte=fne.then,Ene||(e7(fne,"then",(function(e,t){var n=this;return new dne((function(e,t){p5(Qte,n,e,t)})).then(e,t)}),{unsafe:!0}),e7(fne,"catch",pne.catch,{unsafe:!0}));try{delete fne.constructor}catch(Ml){}zee&&zee(fne,pne)}function Pne(e,t,n){return void 0===n&&(n=""),e5(this,void 0,void 0,(function(){var r,o,i,a,u,s,l;return t5(this,(function(c){switch(c.label){case 0:return t?(e.restoreSelection(),r=e.getMenuConfig("insertVideo"),o=r.onInsertedVideo,i=r.checkVideo,a=r.parseVideoSrc,[4,i(t,n)]):[2];case 1:return"string"==typeof(u=c.sent())?(e.alert(u,"error"),[2]):null==u?[2]:[4,a(t)];case 2:return 0!==(s=c.sent()).trim().indexOf("<iframe ")&&(s=s.replace(/</g,"&lt;").replace(/>/g,"&gt;")),l={type:"video",src:s,poster:n,children:[{text:""}]},Promise.resolve().then((function(){md.insertNodes(e,l)})),o(l),[2]}}))}))}function jne(){return Nee("w-e-insert-video")}F7({global:!0,wrap:!0,forced:Dne},{Promise:dne}),Vee(dne,une,!1),function(e){var t=N5("Promise"),n=F8.f;f5&&t&&!t[Uee]&&n(t,Uee,{configurable:!0,get:function(){return this}})}(),Jte=N5(une),F7({target:une,stat:!0,forced:Dne},{reject:function(e){var t=yne(this);return p5(t.reject,void 0,e),t.promise}}),F7({target:une,stat:!0,forced:Dne},{resolve:function(e){return function(e,t){if(O8(e),P5(t)&&t.constructor===e)return t;var n=nne.f(e);return(0,n.resolve)(t),n.promise}(this,e)}}),F7({target:une,stat:!0,forced:Sne},{all:function(e){var t=this,n=yne(t),r=n.resolve,o=n.reject,i=rne((function(){var n=X5(t.resolve),i=[],a=0,u=1;rte(e,(function(e){var s=a++,l=!1;u++,p5(n,t,e).then((function(e){l||(l=!0,i[s]=e,--u||r(i))}),o)})),--u||r(i)}));return i.error&&o(i.value),n.promise},race:function(e){var t=this,n=yne(t),r=n.reject,o=rne((function(){var o=X5(t.resolve);rte(e,(function(e){p5(o,t,e).then(n.resolve,r)}))}));return o.error&&r(o.value),n.promise}});var Nne=function(){function e(){this.title=HP("videoModule.insertVideo"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>',this.tag="button",this.showModal=!0,this.modalWidth=320,this.$content=null,this.srcInputId=jne(),this.posterInputId=jne(),this.buttonId=jne()}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||!!QO.getSelectedElems(e).some((function(t){var n=QO.getNodeType(t);return"pre"===n||"list-item"===n||!!e.isVoid(t)}))},e.prototype.getModalPositionNode=function(e){return null},e.prototype.getModalContentElem=function(e){var t=this,n=this,r=n.srcInputId,o=n.posterInputId,i=n.buttonId,a=n5(S_(HP("videoModule.videoSrc"),r,HP("videoModule.videoSrcPlaceHolder")),2),u=a[0],s=a[1],l=n5(S_(HP("videoModule.videoPoster"),o,HP("videoModule.videoPosterPlaceHolder")),2),c=l[0],f=l[1],d=Mp(s),p=Mp(f),h=n5(C_(i,HP("videoModule.ok")),1)[0];if(null==this.$content){var g=Mp("<div></div>");g.on("click","#"+i,(function(n){return e5(t,void 0,void 0,(function(){var t,i;return t5(this,(function(a){switch(a.label){case 0:return n.preventDefault(),t=g.find("#"+r).val().trim(),i=g.find("#"+o).val().trim(),[4,Pne(e,t,i)];case 1:return a.sent(),e.hidePanelOrModal(),[2]}}))}))})),this.$content=g}var v=this.$content;return v.empty(),v.append(u),v.append(c),v.append(h),d.val(""),p.val(""),setTimeout((function(){d.focus()})),v[0]},e}(),Ine=D5([].join),Lne=k5!=Object,Rne=function(e,t){var n=[].join;return!!n&&c5((function(){n.call(null,",",1)}))}();F7({target:"Array",proto:!0,forced:Lne||!Rne},{join:function(e){return Ine(T5(this),void 0===e?",":e)}});var Mne,zne,$ne,Hne=!c5((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),Vne=z8("IE_PROTO"),Une=l5.Object,Wne=Une.prototype,Gne=Hne?Une.getPrototypeOf:function(e){var t=o8(e);if(a8(t,Vne))return t[Vne];var n=t.constructor;return _5(n)&&t instanceof n?n.prototype:t instanceof Une?Wne:null},qne=g8("iterator"),Kne=!1;[].keys&&("next"in($ne=[].keys())?(zne=Gne(Gne($ne)))!==Object.prototype&&(Mne=zne):Kne=!0);var Yne=null==Mne||c5((function(){var e={};return Mne[qne].call(e)!==e}));Yne&&(Mne={}),_5(Mne[qne])||e7(Mne,qne,(function(){return this}));var Xne={IteratorPrototype:Mne,BUGGY_SAFARI_ITERATORS:Kne},Zne=Xne.IteratorPrototype,Jne=function(){return this},Qne=Q8.PROPER,ere=Q8.CONFIGURABLE,tre=Xne.IteratorPrototype,nre=Xne.BUGGY_SAFARI_ITERATORS,rre=g8("iterator"),ore=function(){return this},ire=function(e,t,n,r,o,i,a){!function(e,t,n,r){var o=t+" Iterator";e.prototype=u9(Zne,{next:y5(1,n)}),Vee(e,o,!1),qee[o]=Jne}(n,t,r);var u,s,l,c=function(e){if(e===o&&g)return g;if(!nre&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[rre]||p["@@iterator"]||o&&p[o],g=!nre&&h||c(o),v="Array"==t&&p.entries||h;if(v&&(u=Gne(v.call(new e)))!==Object.prototype&&u.next&&(Gne(u)!==tre&&(zee?zee(u,tre):_5(u[rre])||e7(u,rre,ore)),Vee(u,f,!0)),Qne&&"values"==o&&h&&"values"!==h.name&&(ere?T8(p,"name","values"):(d=!0,g=function(){return p5(h,this)})),o)if(s={values:c("values"),keys:i?g:c("keys"),entries:c("entries")},a)for(l in s)(nre||d||!(l in p))&&e7(p,l,s[l]);else F7({target:t,proto:!0,forced:nre||d},s);return p[rre]!==g&&e7(p,rre,g,{name:o}),qee[t]=g,s},are=Y8.set,ure=Y8.getterFor("Array Iterator"),sre=ire(Array,"Array",(function(e,t){are(this,{type:"Array Iterator",target:T5(e),index:0,kind:t})}),(function(){var e=ure(this),t=e.target,n=e.kind,r=e.index++;return!t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");qee.Arguments=qee.Array,c9("keys"),c9("values"),c9("entries");var lre=hee.charAt,cre=Y8.set,fre=Y8.getterFor("String Iterator");ire(String,"String",(function(e){cre(this,{type:"String Iterator",string:R7(e),index:0})}),(function(){var e,t=fre(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=lre(n,r),t.index+=e.length,{value:e,done:!1})}));var dre=function(e,t,n){var r=m8(t);r in e?F8.f(e,r,y5(0,n)):e[r]=n},pre=l5.Array,hre=Math.max,gre=y7.f,vre="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],yre={f:function(e){return vre&&"Window"==C5(e)?function(e){try{return gre(e)}catch(e){return function(e,t,n){for(var r=l7(e),o=a7(void 0,r),i=a7(r,r),a=pre(hre(i-o,0)),u=0;o<i;o++,u++)dre(a,u,e[o]);return a.length=u,a}(vre)}}(e):gre(T5(e))}},mre=c5((function(){if("function"==typeof ArrayBuffer){var e=new ArrayBuffer(8);Object.isExtensible(e)&&Object.defineProperty(e,"a",{value:8})}})),bre=Object.isExtensible,wre=c5((function(){bre(1)}))||mre?function(e){return!!P5(e)&&(!mre||"ArrayBuffer"!=C5(e))&&(!bre||bre(e))}:bre,Ere=!c5((function(){return Object.isExtensible(Object.preventExtensions({}))})),Dre=i5((function(e){var t=F8.f,n=!1,r=c8("meta"),o=0,i=function(e){t(e,r,{value:{objectID:"O"+o++,weakData:{}}})},a=e.exports={enable:function(){a.enable=function(){},n=!0;var e=y7.f,t=D5([].splice),o={};o[r]=1,e(o).length&&(y7.f=function(n){for(var o=e(n),i=0,a=o.length;i<a;i++)if(o[i]===r){t(o,i,1);break}return o},F7({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:yre.f}))},fastKey:function(e,t){if(!P5(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!a8(e,r)){if(!wre(e))return"F";if(!t)return"E";i(e)}return e[r].objectID},getWeakData:function(e,t){if(!a8(e,r)){if(!wre(e))return!0;if(!t)return!1;i(e)}return e[r].weakData},onFreeze:function(e){return Ere&&n&&wre(e)&&!a8(e,r)&&i(e),e}};$8[r]=!0})),Sre=Dre.getWeakData,xre=Y8.set,Cre=Y8.getterFor,Are=B9.find,Ore=B9.findIndex,kre=D5([].splice),Bre=0,Fre=function(e){return e.frozen||(e.frozen=new Tre)},Tre=function(){this.entries=[]},_re=function(e,t){return Are(e.entries,(function(e){return e[0]===t}))};Tre.prototype={get:function(e){var t=_re(this,e);if(t)return t[1]},has:function(e){return!!_re(this,e)},set:function(e,t){var n=_re(this,e);n?n[1]=t:this.entries.push([e,t])},delete:function(e){var t=Ore(this.entries,(function(t){return t[0]===e}));return~t&&kre(this.entries,t,1),!!~t}};var Pre,jre={getConstructor:function(e,t,n,r){var o=e((function(e,o){Gee(e,i),xre(e,{type:t,id:Bre++,frozen:void 0}),null!=o&&rte(o,e[r],{that:e,AS_ENTRIES:n})})),i=o.prototype,a=Cre(t),u=function(e,t,n){var r=a(e),o=Sre(O8(t),!0);return!0===o?Fre(r).set(t,n):o[r.id]=n,e};return Lee(i,{delete:function(e){var t=a(this);if(!P5(e))return!1;var n=Sre(e);return!0===n?Fre(t).delete(e):n&&a8(n,t.id)&&delete n[t.id]},has:function(e){var t=a(this);if(!P5(e))return!1;var n=Sre(e);return!0===n?Fre(t).has(e):n&&a8(n,t.id)}}),Lee(i,n?{get:function(e){var t=a(this);if(P5(e)){var n=Sre(e);return!0===n?Fre(t).get(e):n?n[t.id]:void 0}},set:function(e,t){return u(this,e,t)}}:{add:function(e){return u(this,e,!0)}}),o}},Nre=Y8.enforce,Ire=!l5.ActiveXObject&&"ActiveXObject"in l5,Lre=function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},Rre=function(e,t,n){var r=-1!==e.indexOf("Map"),o=-1!==e.indexOf("Weak"),i=r?"set":"add",a=l5[e],u=a&&a.prototype,s=a,l={},c=function(e){var t=D5(u[e]);e7(u,e,"add"==e?function(e){return t(this,0===e?0:e),this}:"delete"==e?function(e){return!(o&&!P5(e))&&t(this,0===e?0:e)}:"get"==e?function(e){return o&&!P5(e)?void 0:t(this,0===e?0:e)}:"has"==e?function(e){return!(o&&!P5(e))&&t(this,0===e?0:e)}:function(e,n){return t(this,0===e?0:e,n),this})};if(k7(e,!_5(a)||!(o||u.forEach&&!c5((function(){(new a).entries().next()})))))s=n.getConstructor(t,e,r,i),Dre.enable();else if(k7(e,!0)){var f=new s,d=f[i](o?{}:-0,1)!=f,p=c5((function(){f.has(1)})),h=dte((function(e){new a(e)})),g=!o&&c5((function(){for(var e=new a,t=5;t--;)e[i](t,t);return!e.has(-0)}));h||((s=t((function(e,t){Gee(e,u);var n=function(e,t,n){var r,o;return zee&&_5(r=t.constructor)&&r!==n&&P5(o=r.prototype)&&o!==n.prototype&&zee(e,o),e}(new a,e,s);return null!=t&&rte(t,n[i],{that:n,AS_ENTRIES:r}),n}))).prototype=u,u.constructor=s),(p||g)&&(c("delete"),c("has"),r&&c("get")),(g||d)&&c(i),o&&u.clear&&delete u.clear}return l[e]=s,F7({global:!0,forced:s!=a},l),Vee(s,e),o||n.setStrong(s,e,r),s}("WeakMap",Lre,jre);if(R8&&Ire){Pre=jre.getConstructor(Lre,"WeakMap",!0),Dre.enable();var Mre=Rre.prototype,zre=D5(Mre.delete),$re=D5(Mre.has),Hre=D5(Mre.get),Vre=D5(Mre.set);Lee(Mre,{delete:function(e){if(P5(e)&&!wre(e)){var t=Nre(this);return t.frozen||(t.frozen=new Pre),zre(this,e)||t.frozen.delete(e)}return zre(this,e)},has:function(e){if(P5(e)&&!wre(e)){var t=Nre(this);return t.frozen||(t.frozen=new Pre),$re(this,e)||t.frozen.has(e)}return $re(this,e)},get:function(e){if(P5(e)&&!wre(e)){var t=Nre(this);return t.frozen||(t.frozen=new Pre),$re(this,e)?Hre(this,e):t.frozen.get(e)}return Hre(this,e)},set:function(e,t){if(P5(e)&&!wre(e)){var n=Nre(this);n.frozen||(n.frozen=new Pre),$re(this,e)?Vre(this,e,t):n.frozen.set(e,t)}else Vre(this,e,t);return this}})}var Ure={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},Wre=E8("span").classList,Gre=Wre&&Wre.constructor&&Wre.constructor.prototype,qre=Gre===Object.prototype?void 0:Gre,Kre=g8("iterator"),Yre=g8("toStringTag"),Xre=sre.values,Zre=function(e,t){if(e){if(e[Kre]!==Xre)try{T8(e,Kre,Xre)}catch(t){e[Kre]=Xre}if(e[Yre]||T8(e,Yre,t),Ure[t])for(var n in sre)if(e[n]!==sre[n])try{T8(e,n,sre[n])}catch(t){e[n]=sre[n]}}};for(var Jre in Ure)Zre(l5[Jre]&&l5[Jre].prototype,Jre);Zre(qre,"DOMTokenList");var Qre=Q8.EXISTS,eoe=F8.f,toe=Function.prototype,noe=D5(toe.toString),roe=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,ooe=D5(roe.exec);f5&&!Qre&&eoe(toe,"name",{configurable:!0,get:function(){try{return ooe(roe,noe(this))[1]}catch(e){return""}}});var ioe=g8("species"),aoe=H5>=51||!c5((function(){var e=[];return(e.constructor={})[ioe]=function(){return{foo:1}},1!==e.slice(Boolean).foo})),uoe=g8("species"),soe=l5.Array,loe=Math.max;function coe(e){return e.getMenuConfig("uploadVideo")}F7({target:"Array",proto:!0,forced:!aoe},{slice:function(e,t){var n,r,o,i=T5(this),a=l7(i),u=a7(e,a),s=a7(void 0===t?a:t,a);if(g9(i)&&(n=i.constructor,(S9(n)&&(n===soe||g9(n.prototype))||P5(n)&&null===(n=n[uoe]))&&(n=void 0),n===soe||void 0===n))return gte(i,u,s);for(r=new(void 0===n?soe:n)(loe(s-u,0)),o=0;u<s;u++,o++)u in i&&dre(r,o,i[u]);return r.length=o,r}});var foe=new WeakMap;function doe(e,t){return e5(this,void 0,void 0,(function(){var n,r,o,i;return t5(this,(function(a){switch(a.label){case 0:return n=function(e){var t=foe.get(e);if(null!=t)return t;var n=coe(e),r=n.onSuccess,o=n.onProgress,i=n.onFailed,a=n.customInsert,u=n.onError;return t=K_(Q3(Q3({},n),{onProgress:function(t){e.showProgressBar(t),o&&o(t)},onSuccess:function(t,n){if(a)return a(n,(function(t,n){return Pne(e,t,n)})),void r(t,n);var o=n.errno,u=void 0===o?1:o,s=n.data,l=void 0===s?{}:s;if(0===u){var c=l.url,f=void 0===c?"":c,d=l.poster;Pne(e,f,void 0===d?"":d),r(t,n)}else i(t,n)},onError:function(e,t,n){u(e,t,n)}})),foe.set(e,t),t}(e),r=t.name,o=t.type,i=t.size,n.addFile({name:r,type:o,size:i,data:t}),[4,n.upload()];case 1:return a.sent(),[2]}}))}))}var poe=function(){function e(){this.title=HP("videoModule.uploadVideo"),this.iconSvg='<svg viewBox="0 0 1056 1024"><path d="M805.902261 521.819882a251.441452 251.441452 0 0 0-251.011972 246.600033 251.051015 251.051015 0 1 0 502.023944 8.823877 253.237463 253.237463 0 0 0-251.011972-255.42391z m59.463561 240.001647v129.898403h-116.701631v-129.898403h-44.041298l101.279368-103.504859 101.279368 103.504859z" p-id="6802"></path><path d="M788.254507 0.000781H99.094092A98.663439 98.663439 0 0 0 0.001171 99.093701v590.067495a98.663439 98.663439 0 0 0 99.092921 99.092921h411.7549a266.434235 266.434235 0 0 1-2.186448-41.815807 275.843767 275.843767 0 0 1 275.180024-270.729042 270.650955 270.650955 0 0 1 103.504859 19.834201V99.093701A101.51363 101.51363 0 0 0 788.254507 0.000781zM295.054441 640.747004V147.507894l394.146189 246.600033z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){var n=this.getMenuConfig(e),r=n.allowedFileTypes,o=void 0===r?[]:r,i=n.customBrowseAndUpload;if(i)i((function(t,n){return Pne(e,t,n)}));else{var a="";o.length>0&&(a='accept="'+o.join(", ")+'"');var u=Mp("body"),s=Mp('<input type="file" '+a+" multiple/>");s.hide(),u.append(s),s.click(),s.on("change",(function(){var t=s[0].files;!function(e,t){var n,r;e5(this,void 0,void 0,(function(){var o,i,a,u,s,l;return t5(this,(function(c){switch(c.label){case 0:if(null==t)return[2];o=Array.prototype.slice.call(t),i=coe(e).customUpload,c.label=1;case 1:c.trys.push([1,9,10,15]),a=r5(o),c.label=2;case 2:return[4,a.next()];case 3:return(u=c.sent()).done?[3,8]:(s=u.value,i?[4,i(s,(function(t,n){return Pne(e,t,n)}))]:[3,5]);case 4:return c.sent(),[3,7];case 5:return[4,doe(e,s)];case 6:c.sent(),c.label=7;case 7:return[3,2];case 8:return[3,15];case 9:return l=c.sent(),n={error:l},[3,15];case 10:return c.trys.push([10,,13,14]),u&&!u.done&&(r=a.return)?[4,r.call(a)]:[3,12];case 11:c.sent(),c.label=12;case 12:return[3,14];case 13:if(n)throw n.error;return[7];case 14:return[7];case 15:return[2]}}))}))}(e,t)}))}},e.prototype.isDisabled=function(e){var t=e.selection;return null==t||!qf.isCollapsed(t)||!!QO.getSelectedElems(e).some((function(t){var n=QO.getNodeType(t);return"pre"===n||"list-item"===n||!!e.isVoid(t)}))},e.prototype.getMenuConfig=function(e){return e.getMenuConfig("uploadVideo")},e}(),hoe=Q8.PROPER,goe=RegExp.prototype,voe=goe.toString,yoe=D5(L9),moe=c5((function(){return"/a/b"!=voe.call({source:"a",flags:"b"})})),boe=hoe&&"toString"!=voe.name;function woe(){return Nee("w-e-insert-video")}(moe||boe)&&e7(RegExp.prototype,"toString",(function(){var e=O8(this),t=R7(e.source),n=e.flags;return"/"+t+"/"+R7(void 0===n&&I5(goe,e)&&!("flags"in goe)?yoe(e):n)}),{unsafe:!0});var Eoe=function(){function e(){this.title=HP("videoModule.editSize"),this.tag="button",this.showModal=!0,this.modalWidth=320,this.$content=null,this.widthInputId=woe(),this.heightInputId=woe(),this.buttonId=woe()}return e.prototype.getSelectedVideoNode=function(e){return QO.getSelectedNodeByType(e,"video")},e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.exec=function(e,t){},e.prototype.isDisabled=function(e){return null==e.selection||null==this.getSelectedVideoNode(e)},e.prototype.getModalPositionNode=function(e){return this.getSelectedVideoNode(e)},e.prototype.getModalContentElem=function(e){var t=this,n=t.widthInputId,r=t.heightInputId,o=t.buttonId,i=n5(S_(HP("videoModule.width"),n,"auto"),2),a=i[0],u=Mp(i[1]),s=n5(S_(HP("videoModule.height"),r,"auto"),2),l=s[0],c=Mp(s[1]),f=n5(C_(o,HP("videoModule.ok")),1)[0];if(null==this.$content){var d=Mp("<div></div>");d.on("click","#"+o,(function(t){t.preventDefault();var o=d.find("#"+n).val().trim(),i=d.find("#"+r).val().trim(),a=parseInt(o),u=parseInt(i),s=a?a.toString():"auto",l=u?u.toString():"auto";e.restoreSelection(),md.setNodes(e,{width:s,height:l},{match:function(e){return QO.checkNodeType(e,"video")}}),e.hidePanelOrModal()})),this.$content=d}var p=this.$content;p.empty(),p.append(a),p.append(l),p.append(f);var h=this.getSelectedVideoNode(e);if(null==h)return p[0];var g=h.width,v=void 0===g?"auto":g,y=h.height,m=void 0===y?"auto":y;return u.val(v),c.val(m),setTimeout((function(){u.focus()})),p[0]},e}(),Doe={renderElems:[Z7],elemsToHtml:[J7],preParseHtml:[d9],parseElemsHtml:[I9],menus:[{key:"insertVideo",factory:function(){return new Nne},config:{onInsertedVideo:function(e){},checkVideo:function(e,t){return!0},parseVideoSrc:function(e){return e}}},{key:"uploadVideo",factory:function(){return new poe},config:{server:"",fieldName:"wangeditor-uploaded-video",maxFileSize:10485760,maxNumberOfFiles:5,allowedFileTypes:["video/*"],meta:{},metaWithUrl:!1,withCredentials:!1,timeout:3e4,onBeforeUpload:function(e){return e},onProgress:function(e){},onSuccess:function(e,t){},onFailed:function(e,t){console.error("'"+e.name+"' upload failed",t)},onError:function(e,t,n){console.error("'"+e.name+" upload error",t,n)}}},{key:"editVideoSize",factory:function(){return new Eoe}}],editorPlugin:function(e){var t=e.isVoid,n=e.normalizeNode,r=e;return r.isVoid=function(e){return"video"===e.type||t(e)},r.normalizeNode=function(e){var t=n5(e,2),o=t[0],i=t[1];return"video"===QO.getNodeType(o)&&QO.isLastNode(r,o)&&md.insertNodes(r,QO.genEmptyParagraph(),{at:[i[0]+1]}),n([o,i])},r}};MP("en",{uploadImgModule:{uploadImage:"Upload Image",uploadError:"{{fileName}} upload error"}}),MP("zh-CN",{uploadImgModule:{uploadImage:"ä¸ä¼ å¾ç",uploadError:"{{fileName}} ä¸ä¼ åºé"}});var Soe="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function xoe(e){var t={exports:{}};return e(t,t.exports),t.exports}var Coe,Aoe,Ooe=function(e){return e&&e.Math==Math&&e},koe=Ooe("object"==typeof globalThis&&globalThis)||Ooe("object"==typeof window&&window)||Ooe("object"==typeof self&&self)||Ooe("object"==typeof Soe&&Soe)||function(){return this}()||Function("return this")(),Boe=function(e){try{return!!e()}catch(e){return!0}},Foe=!Boe((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),Toe=Function.prototype.call,_oe=Toe.bind?Toe.bind(Toe):function(){return Toe.apply(Toe,arguments)},Poe={}.propertyIsEnumerable,joe=Object.getOwnPropertyDescriptor,Noe={f:joe&&!Poe.call({1:2},1)?function(e){var t=joe(this,e);return!!t&&t.enumerable}:Poe},Ioe=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},Loe=Function.prototype,Roe=Loe.bind,Moe=Loe.call,zoe=Roe&&Roe.bind(Moe),$oe=Roe?function(e){return e&&zoe(Moe,e)}:function(e){return e&&function(){return Moe.apply(e,arguments)}},Hoe=$oe({}.toString),Voe=$oe("".slice),Uoe=function(e){return Voe(Hoe(e),8,-1)},Woe=koe.Object,Goe=$oe("".split),qoe=Boe((function(){return!Woe("z").propertyIsEnumerable(0)}))?function(e){return"String"==Uoe(e)?Goe(e,""):Woe(e)}:Woe,Koe=koe.TypeError,Yoe=function(e){if(null==e)throw Koe("Can't call method on "+e);return e},Xoe=function(e){return qoe(Yoe(e))},Zoe=function(e){return"function"==typeof e},Joe=function(e){return"object"==typeof e?null!==e:Zoe(e)},Qoe=function(e){return Zoe(e)?e:void 0},eie=function(e,t){return arguments.length<2?Qoe(koe[e]):koe[e]&&koe[e][t]},tie=$oe({}.isPrototypeOf),nie=eie("navigator","userAgent")||"",rie=koe.process,oie=koe.Deno,iie=rie&&rie.versions||oie&&oie.version,aie=iie&&iie.v8;aie&&(Aoe=(Coe=aie.split("."))[0]>0&&Coe[0]<4?1:+(Coe[0]+Coe[1])),!Aoe&&nie&&(!(Coe=nie.match(/Edge\/(\d+)/))||Coe[1]>=74)&&(Coe=nie.match(/Chrome\/(\d+)/))&&(Aoe=+Coe[1]);var uie=Aoe,sie=!!Object.getOwnPropertySymbols&&!Boe((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&uie&&uie<41})),lie=sie&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,cie=koe.Object,fie=lie?function(e){return"symbol"==typeof e}:function(e){var t=eie("Symbol");return Zoe(t)&&tie(t.prototype,cie(e))},die=koe.String,pie=function(e){try{return die(e)}catch(e){return"Object"}},hie=koe.TypeError,gie=function(e){if(Zoe(e))return e;throw hie(pie(e)+" is not a function")},vie=function(e,t){var n=e[t];return null==n?void 0:gie(n)},yie=koe.TypeError,mie=Object.defineProperty,bie=function(e,t){try{mie(koe,e,{value:t,configurable:!0,writable:!0})}catch(n){koe[e]=t}return t},wie=koe["__core-js_shared__"]||bie("__core-js_shared__",{}),Eie=xoe((function(e){(e.exports=function(e,t){return wie[e]||(wie[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),Die=koe.Object,Sie=function(e){return Die(Yoe(e))},xie=$oe({}.hasOwnProperty),Cie=Object.hasOwn||function(e,t){return xie(Sie(e),t)},Aie=0,Oie=Math.random(),kie=$oe(1..toString),Bie=function(e){return"Symbol("+(void 0===e?"":e)+")_"+kie(++Aie+Oie,36)},Fie=Eie("wks"),Tie=koe.Symbol,_ie=Tie&&Tie.for,Pie=lie?Tie:Tie&&Tie.withoutSetter||Bie,jie=function(e){if(!Cie(Fie,e)||!sie&&"string"!=typeof Fie[e]){var t="Symbol."+e;sie&&Cie(Tie,e)?Fie[e]=Tie[e]:Fie[e]=lie&&_ie?_ie(t):Pie(t)}return Fie[e]},Nie=koe.TypeError,Iie=jie("toPrimitive"),Lie=function(e){var t=function(e,t){if(!Joe(e)||fie(e))return e;var n,r=vie(e,Iie);if(r){if(void 0===t&&(t="default"),n=_oe(r,e,t),!Joe(n)||fie(n))return n;throw Nie("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&Zoe(n=e.toString)&&!Joe(r=_oe(n,e)))return r;if(Zoe(n=e.valueOf)&&!Joe(r=_oe(n,e)))return r;if("string"!==t&&Zoe(n=e.toString)&&!Joe(r=_oe(n,e)))return r;throw yie("Can't convert object to primitive value")}(e,t)}(e,"string");return fie(t)?t:t+""},Rie=koe.document,Mie=Joe(Rie)&&Joe(Rie.createElement),zie=function(e){return Mie?Rie.createElement(e):{}},$ie=!Foe&&!Boe((function(){return 7!=Object.defineProperty(zie("div"),"a",{get:function(){return 7}}).a})),Hie=Object.getOwnPropertyDescriptor,Vie={f:Foe?Hie:function(e,t){if(e=Xoe(e),t=Lie(t),$ie)try{return Hie(e,t)}catch(e){}if(Cie(e,t))return Ioe(!_oe(Noe.f,e,t),e[t])}},Uie=koe.String,Wie=koe.TypeError,Gie=function(e){if(Joe(e))return e;throw Wie(Uie(e)+" is not an object")},qie=koe.TypeError,Kie=Object.defineProperty,Yie={f:Foe?Kie:function(e,t,n){if(Gie(e),t=Lie(t),Gie(n),$ie)try{return Kie(e,t,n)}catch(e){}if("get"in n||"set"in n)throw qie("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},Xie=Foe?function(e,t,n){return Yie.f(e,t,Ioe(1,n))}:function(e,t,n){return e[t]=n,e},Zie=$oe(Function.toString);Zoe(wie.inspectSource)||(wie.inspectSource=function(e){return Zie(e)});var Jie,Qie,eae,tae=wie.inspectSource,nae=koe.WeakMap,rae=Zoe(nae)&&/native code/.test(tae(nae)),oae=Eie("keys"),iae=function(e){return oae[e]||(oae[e]=Bie(e))},aae={},uae=koe.TypeError,sae=koe.WeakMap;if(rae||wie.state){var lae=wie.state||(wie.state=new sae),cae=$oe(lae.get),fae=$oe(lae.has),dae=$oe(lae.set);Jie=function(e,t){if(fae(lae,e))throw new uae("Object already initialized");return t.facade=e,dae(lae,e,t),t},Qie=function(e){return cae(lae,e)||{}},eae=function(e){return fae(lae,e)}}else{var pae=iae("state");aae[pae]=!0,Jie=function(e,t){if(Cie(e,pae))throw new uae("Object already initialized");return t.facade=e,Xie(e,pae,t),t},Qie=function(e){return Cie(e,pae)?e[pae]:{}},eae=function(e){return Cie(e,pae)}}var hae={set:Jie,get:Qie,has:eae,enforce:function(e){return eae(e)?Qie(e):Jie(e,{})},getterFor:function(e){return function(t){var n;if(!Joe(t)||(n=Qie(t)).type!==e)throw uae("Incompatible receiver, "+e+" required");return n}}},gae=Function.prototype,vae=Foe&&Object.getOwnPropertyDescriptor,yae=Cie(gae,"name"),mae={EXISTS:yae,PROPER:yae&&"something"===function(){}.name,CONFIGURABLE:yae&&(!Foe||Foe&&vae(gae,"name").configurable)},bae=xoe((function(e){var t=mae.CONFIGURABLE,n=hae.get,r=hae.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;Zoe(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!Cie(i,"name")||t&&i.name!==f)&&Xie(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==koe?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:Xie(e,n,i)):l?e[n]=i:bie(n,i)})(Function.prototype,"toString",(function(){return Zoe(this)&&n(this).source||tae(this)}))})),wae=Math.ceil,Eae=Math.floor,Dae=function(e){var t=+e;return t!=t||0===t?0:(t>0?Eae:wae)(t)},Sae=Math.max,xae=Math.min,Cae=function(e,t){var n=Dae(e);return n<0?Sae(n+t,0):xae(n,t)},Aae=Math.min,Oae=function(e){return e>0?Aae(Dae(e),9007199254740991):0},kae=function(e){return Oae(e.length)},Bae=function(e){return function(t,n,r){var o,i=Xoe(t),a=kae(i),u=Cae(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},Fae=(Bae(!0),Bae(!1)),Tae=$oe([].push),_ae=function(e,t){var n,r=Xoe(e),o=0,i=[];for(n in r)!Cie(aae,n)&&Cie(r,n)&&Tae(i,n);for(;t.length>o;)Cie(r,n=t[o++])&&(~Fae(i,n)||Tae(i,n));return i},Pae=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],jae=Pae.concat("length","prototype"),Nae={f:Object.getOwnPropertyNames||function(e){return _ae(e,jae)}},Iae={f:Object.getOwnPropertySymbols},Lae=$oe([].concat),Rae=eie("Reflect","ownKeys")||function(e){var t=Nae.f(Gie(e)),n=Iae.f;return n?Lae(t,n(e)):t},Mae=function(e,t){for(var n=Rae(t),r=Yie.f,o=Vie.f,i=0;i<n.length;i++){var a=n[i];Cie(e,a)||r(e,a,o(t,a))}},zae=/#|\.prototype\./,$ae=function(e,t){var n=Vae[Hae(e)];return n==Wae||n!=Uae&&(Zoe(t)?Boe(t):!!t)},Hae=$ae.normalize=function(e){return String(e).replace(zae,".").toLowerCase()},Vae=$ae.data={},Uae=$ae.NATIVE="N",Wae=$ae.POLYFILL="P",Gae=$ae,qae=Vie.f,Kae=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?koe:l?koe[u]||bie(u,{}):(koe[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=qae(n,r))&&a.value:n[r],!Gae(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;Mae(i,o)}(e.sham||o&&o.sham)&&Xie(i,"sham",!0),bae(n,r,i,e)}},Yae=Array.isArray||function(e){return"Array"==Uoe(e)},Xae={};Xae[jie("toStringTag")]="z";var Zae="[object z]"===String(Xae),Jae=jie("toStringTag"),Qae=koe.Object,eue="Arguments"==Uoe(function(){return arguments}()),tue=Zae?Uoe:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=Qae(e),Jae))?n:eue?Uoe(t):"Object"==(r=Uoe(t))&&Zoe(t.callee)?"Arguments":r},nue=function(){},rue=[],oue=eie("Reflect","construct"),iue=/^\s*(?:class|function)\b/,aue=$oe(iue.exec),uue=!iue.exec(nue),sue=function(e){if(!Zoe(e))return!1;try{return oue(nue,rue,e),!0}catch(e){return!1}},lue=!oue||Boe((function(){var e;return sue(sue.call)||!sue(Object)||!sue((function(){e=!0}))||e}))?function(e){if(!Zoe(e))return!1;switch(tue(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return uue||!!aue(iue,tae(e))}:sue,cue=function(e,t,n){var r=Lie(t);r in e?Yie.f(e,r,Ioe(0,n)):e[r]=n},fue=jie("species"),due=$oe([].slice),pue=("slice",uie>=51||!Boe((function(){var e=[];return(e.constructor={})[fue]=function(){return{foo:1}},1!==e.slice(Boolean).foo}))),hue=jie("species"),gue=koe.Array,vue=Math.max;Kae({target:"Array",proto:!0,forced:!pue},{slice:function(e,t){var n,r,o,i=Xoe(this),a=kae(i),u=Cae(e,a),s=Cae(void 0===t?a:t,a);if(Yae(i)&&(n=i.constructor,(lue(n)&&(n===gue||Yae(n.prototype))||Joe(n)&&null===(n=n[hue]))&&(n=void 0),n===gue||void 0===n))return due(i,u,s);for(r=new(void 0===n?gue:n)(vue(s-u,0)),o=0;u<s;u++,o++)u in i&&cue(r,o,i[u]);return r.length=o,r}});var yue=Zae?{}.toString:function(){return"[object "+tue(this)+"]"};Zae||bae(Object.prototype,"toString",yue,{unsafe:!0});var mue,bue=koe.String,wue=function(e){if("Symbol"===tue(e))throw TypeError("Cannot convert a Symbol value to a string");return bue(e)},Eue=function(){var e=Gie(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},Due=koe.RegExp,Sue=Boe((function(){var e=Due("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),xue=Sue||Boe((function(){return!Due("a","y").sticky})),Cue={BROKEN_CARET:Sue||Boe((function(){var e=Due("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:xue,UNSUPPORTED_Y:Sue},Aue=Object.keys||function(e){return _ae(e,Pae)},Oue=Foe?Object.defineProperties:function(e,t){Gie(e);for(var n,r=Xoe(t),o=Aue(t),i=o.length,a=0;i>a;)Yie.f(e,n=o[a++],r[n]);return e},kue=eie("document","documentElement"),Bue=iae("IE_PROTO"),Fue=function(){},Tue=function(e){return"<script>"+e+"<\/script>"},_ue=function(e){e.write(Tue("")),e.close();var t=e.parentWindow.Object;return e=null,t},Pue=function(){try{mue=new ActiveXObject("htmlfile")}catch(e){}var e,t;Pue="undefined"!=typeof document?document.domain&&mue?_ue(mue):((t=zie("iframe")).style.display="none",kue.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(Tue("document.F=Object")),e.close(),e.F):_ue(mue);for(var n=Pae.length;n--;)delete Pue.prototype[Pae[n]];return Pue()};aae[Bue]=!0;var jue,Nue,Iue=Object.create||function(e,t){var n;return null!==e?(Fue.prototype=Gie(e),n=new Fue,Fue.prototype=null,n[Bue]=e):n=Pue(),void 0===t?n:Oue(n,t)},Lue=koe.RegExp,Rue=Boe((function(){var e=Lue(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),Mue=koe.RegExp,zue=Boe((function(){var e=Mue("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),$ue=hae.get,Hue=Eie("native-string-replace",String.prototype.replace),Vue=RegExp.prototype.exec,Uue=Vue,Wue=$oe("".charAt),Gue=$oe("".indexOf),que=$oe("".replace),Kue=$oe("".slice),Yue=(Nue=/b*/g,_oe(Vue,jue=/a/,"a"),_oe(Vue,Nue,"a"),0!==jue.lastIndex||0!==Nue.lastIndex),Xue=Cue.BROKEN_CARET,Zue=void 0!==/()??/.exec("")[1];(Yue||Zue||Xue||Rue||zue)&&(Uue=function(e){var t,n,r,o,i,a,u,s=this,l=$ue(s),c=wue(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=_oe(Uue,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=Xue&&s.sticky,h=_oe(Eue,s),g=s.source,v=0,y=c;if(p&&(h=que(h,"y",""),-1===Gue(h,"g")&&(h+="g"),y=Kue(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==Wue(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),Zue&&(n=new RegExp("^"+g+"$(?!\\s)",h)),Yue&&(r=s.lastIndex),o=_oe(Vue,p?n:s,y),p?o?(o.input=Kue(o.input,v),o[0]=Kue(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:Yue&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),Zue&&o&&o.length>1&&_oe(Hue,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=Iue(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var Jue=Uue;Kae({target:"RegExp",proto:!0,forced:/./.exec!==Jue},{exec:Jue});var Que=Function.prototype,ese=Que.apply,tse=Que.bind,nse=Que.call,rse="object"==typeof Reflect&&Reflect.apply||(tse?nse.bind(ese):function(){return nse.apply(ese,arguments)}),ose=jie("species"),ise=RegExp.prototype,ase=jie("match"),use=koe.TypeError,sse=jie("species"),lse=function(e,t){var n,r=Gie(e).constructor;return void 0===r||null==(n=Gie(r)[sse])?t:function(e){if(lue(e))return e;throw use(pie(e)+" is not a constructor")}(n)},cse=$oe("".charAt),fse=$oe("".charCodeAt),dse=$oe("".slice),pse=function(e){return function(t,n){var r,o,i=wue(Yoe(t)),a=Dae(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=fse(i,a))<55296||r>56319||a+1===u||(o=fse(i,a+1))<56320||o>57343?e?cse(i,a):r:e?dse(i,a,a+2):o-56320+(r-55296<<10)+65536}},hse={codeAt:pse(!1),charAt:pse(!0)},gse=hse.charAt,vse=function(e,t,n){return t+(n?gse(e,t).length:1)},yse=koe.Array,mse=Math.max,bse=function(e,t,n){for(var r=kae(e),o=Cae(t,r),i=Cae(void 0===n?r:n,r),a=yse(mse(i-o,0)),u=0;o<i;o++,u++)cue(a,u,e[o]);return a.length=u,a},wse=koe.TypeError,Ese=function(e,t){var n=e.exec;if(Zoe(n)){var r=_oe(n,e,t);return null!==r&&Gie(r),r}if("RegExp"===Uoe(e))return _oe(Jue,e,t);throw wse("RegExp#exec called on incompatible receiver")},Dse=Cue.UNSUPPORTED_Y,Sse=Math.min,xse=[].push,Cse=$oe(/./.exec),Ase=$oe(xse),Ose=$oe("".slice);!function(e,t,n,r){var o=jie(e),i=!Boe((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!Boe((function(){var e=!1,t=/a/;return(t={}).constructor={},t.constructor[ose]=function(){return t},t.flags="",t[o]=/./[o],t.exec=function(){return e=!0,null},t[o](""),!e}));if(!i||!a||n){var u=$oe(/./[o]),s=function(e,t,n){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(e,n){var r,o,i=wue(Yoe(this)),a=void 0===n?4294967295:n>>>0;if(0===a)return[];if(void 0===e)return[i];if(!Joe(r=e)||!(void 0!==(o=r[ase])?o:"RegExp"==Uoe(r)))return _oe(t,i,e,a);for(var u,s,l,c=[],f=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),d=0,p=new RegExp(e.source,f+"g");(u=_oe(Jue,p,i))&&!((s=p.lastIndex)>d&&(Ase(c,Ose(i,d,u.index)),u.length>1&&u.index<i.length&&rse(xse,c,bse(u,1)),l=u[0].length,d=s,c.length>=a));)p.lastIndex===u.index&&p.lastIndex++;return d===i.length?!l&&Cse(p,"")||Ase(c,""):Ase(c,Ose(i,d)),c.length>a?bse(c,0,a):c}:"0".split(void 0,0).length?function(e,n){return void 0===e&&0===n?[]:_oe(t,this,e,n)}:t,[function(t,n){var o=Yoe(this),i=null==t?void 0:vie(t,e);return i?_oe(i,t,o,n):_oe(r,wue(o),t,n)},function(e,o){var i=Gie(this),a=wue(e),u=n(r,i,a,o,r!==t);if(u.done)return u.value;var s=lse(i,RegExp),l=i.unicode,c=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(Dse?"g":"y"),f=new s(Dse?"^(?:"+i.source+")":i,c),d=void 0===o?4294967295:o>>>0;if(0===d)return[];if(0===a.length)return null===Ese(f,a)?[a]:[];for(var p=0,h=0,g=[];h<a.length;){f.lastIndex=Dse?0:h;var v,y=Ese(f,Dse?Ose(a,h):a);if(null===y||(v=Sse(Oae(f.lastIndex+(Dse?h:0)),a.length))===p)h=vse(a,h,l);else{if(Ase(g,Ose(a,p,h)),g.length===d)return g;for(var m=1;m<=y.length-1;m++)if(Ase(g,y[m]),g.length===d)return g;h=p=v}}return Ase(g,Ose(a,p)),g}]}(o,""[e],(function(e,t,n,r,o){var a=$oe(e),s=t.exec;return s===Jue||s===ise.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));bae(String.prototype,e,s[0]),bae(ise,o,s[1])}r&&Xie(ise[o],"sham",!0)}("split",0,!!Boe((function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var n="ab".split(e);return 2!==n.length||"a"!==n[0]||"b"!==n[1]})),Dse);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var kse=function(){return kse=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e},kse.apply(this,arguments)};function Bse(e,t,n,r){return new(n||(n=Promise))((function(o,i){function a(e){try{s(r.next(e))}catch(e){i(e)}}function u(e){try{s(r.throw(e))}catch(e){i(e)}}function s(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,u)}s((r=r.apply(e,t||[])).next())}))}function Fse(e,t){var n,r,o,i,a={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function u(i){return function(u){return function(i){if(n)throw new TypeError("Generator is already executing.");for(;a;)try{if(n=1,r&&(o=2&i[0]?r.return:i[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,i[1])).done)return o;switch(r=0,o&&(i=[2&i[0],o.value]),i[0]){case 0:case 1:o=i;break;case 4:return a.label++,{value:i[1],done:!1};case 5:a.label++,r=i[1],i=[0];continue;case 7:i=a.ops.pop(),a.trys.pop();continue;default:if(!((o=(o=a.trys).length>0&&o[o.length-1])||6!==i[0]&&2!==i[0])){a=0;continue}if(3===i[0]&&(!o||i[1]>o[0]&&i[1]<o[3])){a.label=i[1];break}if(6===i[0]&&a.label<o[1]){a.label=o[1],o=i;break}if(o&&a.label<o[2]){a.label=o[2],a.ops.push(i);break}o[2]&&a.ops.pop(),a.trys.pop();continue}i=t.call(e,a)}catch(e){i=[6,e],r=0}finally{n=o=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,u])}}}function Tse(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,n=e[Symbol.asyncIterator];return n?n.call(e):(e=function(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(n){t[n]=e[n]&&function(t){return new Promise((function(r,o){!function(e,t,n,r){Promise.resolve(r).then((function(t){e({value:t,done:n})}),t)}(r,o,(t=e[n](t)).done,t.value)}))}}}var _se=jie("unscopables"),Pse=Array.prototype;null==Pse[_se]&&Yie.f(Pse,_se,{configurable:!0,value:Iue(null)});var jse,Nse,Ise,Lse=function(e){Pse[_se][e]=!0},Rse={},Mse=!Boe((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),zse=iae("IE_PROTO"),$se=koe.Object,Hse=$se.prototype,Vse=Mse?$se.getPrototypeOf:function(e){var t=Sie(e);if(Cie(t,zse))return t[zse];var n=t.constructor;return Zoe(n)&&t instanceof n?n.prototype:t instanceof $se?Hse:null},Use=jie("iterator"),Wse=!1;[].keys&&("next"in(Ise=[].keys())?(Nse=Vse(Vse(Ise)))!==Object.prototype&&(jse=Nse):Wse=!0);var Gse=null==jse||Boe((function(){var e={};return jse[Use].call(e)!==e}));Gse&&(jse={}),Zoe(jse[Use])||bae(jse,Use,(function(){return this}));var qse={IteratorPrototype:jse,BUGGY_SAFARI_ITERATORS:Wse},Kse=Yie.f,Yse=jie("toStringTag"),Xse=function(e,t,n){e&&!Cie(e=n?e:e.prototype,Yse)&&Kse(e,Yse,{configurable:!0,value:t})},Zse=qse.IteratorPrototype,Jse=function(){return this},Qse=koe.String,ele=koe.TypeError,tle=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{(e=$oe(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(n,[]),t=n instanceof Array}catch(e){}return function(n,r){return Gie(n),function(e){if("object"==typeof e||Zoe(e))return e;throw ele("Can't set "+Qse(e)+" as a prototype")}(r),t?e(n,r):n.__proto__=r,n}}():void 0),nle=mae.PROPER,rle=mae.CONFIGURABLE,ole=qse.IteratorPrototype,ile=qse.BUGGY_SAFARI_ITERATORS,ale=jie("iterator"),ule=function(){return this},sle=function(e,t,n,r,o,i,a){!function(e,t,n,r){var o=t+" Iterator";e.prototype=Iue(Zse,{next:Ioe(1,n)}),Xse(e,o,!1),Rse[o]=Jse}(n,t,r);var u,s,l,c=function(e){if(e===o&&g)return g;if(!ile&&e in p)return p[e];switch(e){case"keys":case"values":case"entries":return function(){return new n(this,e)}}return function(){return new n(this)}},f=t+" Iterator",d=!1,p=e.prototype,h=p[ale]||p["@@iterator"]||o&&p[o],g=!ile&&h||c(o),v="Array"==t&&p.entries||h;if(v&&(u=Vse(v.call(new e)))!==Object.prototype&&u.next&&(Vse(u)!==ole&&(tle?tle(u,ole):Zoe(u[ale])||bae(u,ale,ule)),Xse(u,f,!0)),nle&&"values"==o&&h&&"values"!==h.name&&(rle?Xie(p,"name","values"):(d=!0,g=function(){return _oe(h,this)})),o)if(s={values:c("values"),keys:i?g:c("keys"),entries:c("entries")},a)for(l in s)(ile||d||!(l in p))&&bae(p,l,s[l]);else Kae({target:t,proto:!0,forced:ile||d},s);return p[ale]!==g&&bae(p,ale,g,{name:o}),Rse[t]=g,s},lle=hae.set,cle=hae.getterFor("Array Iterator"),fle=sle(Array,"Array",(function(e,t){lle(this,{type:"Array Iterator",target:Xoe(e),index:0,kind:t})}),(function(){var e=cle(this),t=e.target,n=e.kind,r=e.index++;return!t||r>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==n?{value:r,done:!1}:"values"==n?{value:t[r],done:!1}:{value:[r,t[r]],done:!1}}),"values");Rse.Arguments=Rse.Array,Lse("keys"),Lse("values"),Lse("entries");var dle=hse.charAt,ple=hae.set,hle=hae.getterFor("String Iterator");sle(String,"String",(function(e){ple(this,{type:"String Iterator",string:wue(e),index:0})}),(function(){var e,t=hle(this),n=t.string,r=t.index;return r>=n.length?{value:void 0,done:!0}:(e=dle(n,r),t.index+=e.length,{value:e,done:!1})}));var gle=function(e,t,n){for(var r in t)bae(e,r,t[r],n);return e},vle=Nae.f,yle="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],mle={f:function(e){return yle&&"Window"==Uoe(e)?function(e){try{return vle(e)}catch(e){return bse(yle)}}(e):vle(Xoe(e))}},ble=Boe((function(){if("function"==typeof ArrayBuffer){var e=new ArrayBuffer(8);Object.isExtensible(e)&&Object.defineProperty(e,"a",{value:8})}})),wle=Object.isExtensible,Ele=Boe((function(){wle(1)}))||ble?function(e){return!!Joe(e)&&(!ble||"ArrayBuffer"!=Uoe(e))&&(!wle||wle(e))}:wle,Dle=!Boe((function(){return Object.isExtensible(Object.preventExtensions({}))})),Sle=xoe((function(e){var t=Yie.f,n=!1,r=Bie("meta"),o=0,i=function(e){t(e,r,{value:{objectID:"O"+o++,weakData:{}}})},a=e.exports={enable:function(){a.enable=function(){},n=!0;var e=Nae.f,t=$oe([].splice),o={};o[r]=1,e(o).length&&(Nae.f=function(n){for(var o=e(n),i=0,a=o.length;i<a;i++)if(o[i]===r){t(o,i,1);break}return o},Kae({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:mle.f}))},fastKey:function(e,t){if(!Joe(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!Cie(e,r)){if(!Ele(e))return"F";if(!t)return"E";i(e)}return e[r].objectID},getWeakData:function(e,t){if(!Cie(e,r)){if(!Ele(e))return!0;if(!t)return!1;i(e)}return e[r].weakData},onFreeze:function(e){return Dle&&n&&Ele(e)&&!Cie(e,r)&&i(e),e}};aae[r]=!0})),xle=$oe($oe.bind),Cle=function(e,t){return gie(e),void 0===t?e:xle?xle(e,t):function(){return e.apply(t,arguments)}},Ale=jie("iterator"),Ole=Array.prototype,kle=jie("iterator"),Ble=function(e){if(null!=e)return vie(e,kle)||vie(e,"@@iterator")||Rse[tue(e)]},Fle=koe.TypeError,Tle=function(e,t,n){var r,o;Gie(e);try{if(!(r=vie(e,"return"))){if("throw"===t)throw n;return n}r=_oe(r,e)}catch(e){o=!0,r=e}if("throw"===t)throw n;if(o)throw r;return Gie(r),n},_le=koe.TypeError,Ple=function(e,t){this.stopped=e,this.result=t},jle=Ple.prototype,Nle=function(e,t,n){var r,o,i,a,u,s,l,c,f=n&&n.that,d=!(!n||!n.AS_ENTRIES),p=!(!n||!n.IS_ITERATOR),h=!(!n||!n.INTERRUPTED),g=Cle(t,f),v=function(e){return r&&Tle(r,"normal",e),new Ple(!0,e)},y=function(e){return d?(Gie(e),h?g(e[0],e[1],v):g(e[0],e[1])):h?g(e,v):g(e)};if(p)r=e;else{if(!(o=Ble(e)))throw _le(pie(e)+" is not iterable");if(void 0!==(c=o)&&(Rse.Array===c||Ole[Ale]===c)){for(i=0,a=kae(e);a>i;i++)if((u=y(e[i]))&&tie(jle,u))return u;return new Ple(!1)}r=function(e,t){var n=arguments.length<2?Ble(e):t;if(gie(n))return Gie(_oe(n,e));throw Fle(pie(e)+" is not iterable")}(e,o)}for(s=r.next;!(l=_oe(s,r)).done;){try{u=y(l.value)}catch(e){Tle(r,"throw",e)}if("object"==typeof u&&u&&tie(jle,u))return u}return new Ple(!1)},Ile=koe.TypeError,Lle=function(e,t){if(tie(t,e))return e;throw Ile("Incorrect invocation")},Rle=jie("iterator"),Mle=!1;try{var zle=0,$le={next:function(){return{done:!!zle++}},return:function(){Mle=!0}};$le[Rle]=function(){return this},Array.from($le,(function(){throw 2}))}catch(Ml){}var Hle=function(e,t){if(!t&&!Mle)return!1;var n=!1;try{var r={};r[Rle]=function(){return{next:function(){return{done:n=!0}}}},e(r)}catch(e){}return n},Vle=jie("species"),Ule=koe.Array,Wle=function(e,t){return new(function(e){var t;return Yae(e)&&(t=e.constructor,(lue(t)&&(t===Ule||Yae(t.prototype))||Joe(t)&&null===(t=t[Vle]))&&(t=void 0)),void 0===t?Ule:t}(e))(0===t?0:t)},Gle=$oe([].push),qle=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=Sie(s),g=qoe(h),v=Cle(l,c),y=kae(g),m=0,b=f||Wle,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:Gle(w,d)}else switch(e){case 4:return!1;case 7:Gle(w,d)}return i?-1:r||o?o:w}},Kle={forEach:qle(0),map:qle(1),filter:qle(2),some:qle(3),every:qle(4),find:qle(5),findIndex:qle(6),filterReject:qle(7)},Yle=Sle.getWeakData,Xle=hae.set,Zle=hae.getterFor,Jle=Kle.find,Qle=Kle.findIndex,ece=$oe([].splice),tce=0,nce=function(e){return e.frozen||(e.frozen=new rce)},rce=function(){this.entries=[]},oce=function(e,t){return Jle(e.entries,(function(e){return e[0]===t}))};rce.prototype={get:function(e){var t=oce(this,e);if(t)return t[1]},has:function(e){return!!oce(this,e)},set:function(e,t){var n=oce(this,e);n?n[1]=t:this.entries.push([e,t])},delete:function(e){var t=Qle(this.entries,(function(t){return t[0]===e}));return~t&&ece(this.entries,t,1),!!~t}};var ice,ace={getConstructor:function(e,t,n,r){var o=e((function(e,o){Lle(e,i),Xle(e,{type:t,id:tce++,frozen:void 0}),null!=o&&Nle(o,e[r],{that:e,AS_ENTRIES:n})})),i=o.prototype,a=Zle(t),u=function(e,t,n){var r=a(e),o=Yle(Gie(t),!0);return!0===o?nce(r).set(t,n):o[r.id]=n,e};return gle(i,{delete:function(e){var t=a(this);if(!Joe(e))return!1;var n=Yle(e);return!0===n?nce(t).delete(e):n&&Cie(n,t.id)&&delete n[t.id]},has:function(e){var t=a(this);if(!Joe(e))return!1;var n=Yle(e);return!0===n?nce(t).has(e):n&&Cie(n,t.id)}}),gle(i,n?{get:function(e){var t=a(this);if(Joe(e)){var n=Yle(e);return!0===n?nce(t).get(e):n?n[t.id]:void 0}},set:function(e,t){return u(this,e,t)}}:{add:function(e){return u(this,e,!0)}}),o}},uce=hae.enforce,sce=!koe.ActiveXObject&&"ActiveXObject"in koe,lce=function(e){return function(){return e(this,arguments.length?arguments[0]:void 0)}},cce=function(e,t,n){var r=-1!==e.indexOf("Map"),o=-1!==e.indexOf("Weak"),i=r?"set":"add",a=koe[e],u=a&&a.prototype,s=a,l={},c=function(e){var t=$oe(u[e]);bae(u,e,"add"==e?function(e){return t(this,0===e?0:e),this}:"delete"==e?function(e){return!(o&&!Joe(e))&&t(this,0===e?0:e)}:"get"==e?function(e){return o&&!Joe(e)?void 0:t(this,0===e?0:e)}:"has"==e?function(e){return!(o&&!Joe(e))&&t(this,0===e?0:e)}:function(e,n){return t(this,0===e?0:e,n),this})};if(Gae(e,!Zoe(a)||!(o||u.forEach&&!Boe((function(){(new a).entries().next()})))))s=n.getConstructor(t,e,r,i),Sle.enable();else if(Gae(e,!0)){var f=new s,d=f[i](o?{}:-0,1)!=f,p=Boe((function(){f.has(1)})),h=Hle((function(e){new a(e)})),g=!o&&Boe((function(){for(var e=new a,t=5;t--;)e[i](t,t);return!e.has(-0)}));h||((s=t((function(e,t){Lle(e,u);var n=function(e,t,n){var r,o;return tle&&Zoe(r=t.constructor)&&r!==n&&Joe(o=r.prototype)&&o!==n.prototype&&tle(e,o),e}(new a,e,s);return null!=t&&Nle(t,n[i],{that:n,AS_ENTRIES:r}),n}))).prototype=u,u.constructor=s),(p||g)&&(c("delete"),c("has"),r&&c("get")),(g||d)&&c(i),o&&u.clear&&delete u.clear}return l[e]=s,Kae({global:!0,forced:s!=a},l),Xse(s,e),o||n.setStrong(s,e,r),s}("WeakMap",lce,ace);if(rae&&sce){ice=ace.getConstructor(lce,"WeakMap",!0),Sle.enable();var fce=cce.prototype,dce=$oe(fce.delete),pce=$oe(fce.has),hce=$oe(fce.get),gce=$oe(fce.set);gle(fce,{delete:function(e){if(Joe(e)&&!Ele(e)){var t=uce(this);return t.frozen||(t.frozen=new ice),dce(this,e)||t.frozen.delete(e)}return dce(this,e)},has:function(e){if(Joe(e)&&!Ele(e)){var t=uce(this);return t.frozen||(t.frozen=new ice),pce(this,e)||t.frozen.has(e)}return pce(this,e)},get:function(e){if(Joe(e)&&!Ele(e)){var t=uce(this);return t.frozen||(t.frozen=new ice),pce(this,e)?hce(this,e):t.frozen.get(e)}return hce(this,e)},set:function(e,t){if(Joe(e)&&!Ele(e)){var n=uce(this);n.frozen||(n.frozen=new ice),pce(this,e)?gce(this,e,t):n.frozen.set(e,t)}else gce(this,e,t);return this}})}var vce={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},yce=zie("span").classList,mce=yce&&yce.constructor&&yce.constructor.prototype,bce=mce===Object.prototype?void 0:mce,wce=jie("iterator"),Ece=jie("toStringTag"),Dce=fle.values,Sce=function(e,t){if(e){if(e[wce]!==Dce)try{Xie(e,wce,Dce)}catch(t){e[wce]=Dce}if(e[Ece]||Xie(e,Ece,t),vce[t])for(var n in fle)if(e[n]!==fle[n])try{Xie(e,n,fle[n])}catch(t){e[n]=fle[n]}}};for(var xce in vce)Sce(koe[xce]&&koe[xce].prototype,xce);Sce(bce,"DOMTokenList");var Cce=function(e,t){var n=[][e];return!!n&&Boe((function(){n.call(null,t||function(){throw 1},1)}))},Ace=Kle.forEach,Oce=Cce("forEach")?[].forEach:function(e){return Ace(this,e,arguments.length>1?arguments[1]:void 0)},kce=function(e){if(e&&e.forEach!==Oce)try{Xie(e,"forEach",Oce)}catch(t){e.forEach=Oce}};for(var Bce in vce)vce[Bce]&&kce(koe[Bce]&&koe[Bce].prototype);kce(bce);var Fce,Tce,_ce,Pce,jce=koe.Promise,Nce=jie("species"),Ice=/(?:ipad|iphone|ipod).*applewebkit/i.test(nie),Lce="process"==Uoe(koe.process),Rce=koe.setImmediate,Mce=koe.clearImmediate,zce=koe.process,$ce=koe.Dispatch,Hce=koe.Function,Vce=koe.MessageChannel,Uce=koe.String,Wce=0,Gce={};try{Fce=koe.location}catch(Ml){}var qce=function(e){if(Cie(Gce,e)){var t=Gce[e];delete Gce[e],t()}},Kce=function(e){return function(){qce(e)}},Yce=function(e){qce(e.data)},Xce=function(e){koe.postMessage(Uce(e),Fce.protocol+"//"+Fce.host)};Rce&&Mce||(Rce=function(e){var t=due(arguments,1);return Gce[++Wce]=function(){rse(Zoe(e)?e:Hce(e),void 0,t)},Tce(Wce),Wce},Mce=function(e){delete Gce[e]},Lce?Tce=function(e){zce.nextTick(Kce(e))}:$ce&&$ce.now?Tce=function(e){$ce.now(Kce(e))}:Vce&&!Ice?(Pce=(_ce=new Vce).port2,_ce.port1.onmessage=Yce,Tce=Cle(Pce.postMessage,Pce)):koe.addEventListener&&Zoe(koe.postMessage)&&!koe.importScripts&&Fce&&"file:"!==Fce.protocol&&!Boe(Xce)?(Tce=Xce,koe.addEventListener("message",Yce,!1)):Tce="onreadystatechange"in zie("script")?function(e){kue.appendChild(zie("script")).onreadystatechange=function(){kue.removeChild(this),qce(e)}}:function(e){setTimeout(Kce(e),0)});var Zce,Jce,Qce,efe,tfe,nfe,rfe,ofe,ife={set:Rce,clear:Mce},afe=/ipad|iphone|ipod/i.test(nie)&&void 0!==koe.Pebble,ufe=/web0s(?!.*chrome)/i.test(nie),sfe=Vie.f,lfe=ife.set,cfe=koe.MutationObserver||koe.WebKitMutationObserver,ffe=koe.document,dfe=koe.process,pfe=koe.Promise,hfe=sfe(koe,"queueMicrotask"),gfe=hfe&&hfe.value;gfe||(Zce=function(){var e,t;for(Lce&&(e=dfe.domain)&&e.exit();Jce;){t=Jce.fn,Jce=Jce.next;try{t()}catch(e){throw Jce?efe():Qce=void 0,e}}Qce=void 0,e&&e.enter()},Ice||Lce||ufe||!cfe||!ffe?!afe&&pfe&&pfe.resolve?((rfe=pfe.resolve(void 0)).constructor=pfe,ofe=Cle(rfe.then,rfe),efe=function(){ofe(Zce)}):Lce?efe=function(){dfe.nextTick(Zce)}:(lfe=Cle(lfe,koe),efe=function(){lfe(Zce)}):(tfe=!0,nfe=ffe.createTextNode(""),new cfe(Zce).observe(nfe,{characterData:!0}),efe=function(){nfe.data=tfe=!tfe}));var vfe,yfe,mfe,bfe,wfe=gfe||function(e){var t={fn:e,next:void 0};Qce&&(Qce.next=t),Jce||(Jce=t,efe()),Qce=t},Efe=function(e){var t,n;this.promise=new e((function(e,r){if(void 0!==t||void 0!==n)throw TypeError("Bad Promise constructor");t=e,n=r})),this.resolve=gie(t),this.reject=gie(n)},Dfe={f:function(e){return new Efe(e)}},Sfe=function(e){try{return{error:!1,value:e()}}catch(e){return{error:!0,value:e}}},xfe="object"==typeof window,Cfe=ife.set,Afe=jie("species"),Ofe="Promise",kfe=hae.getterFor(Ofe),Bfe=hae.set,Ffe=hae.getterFor(Ofe),Tfe=jce&&jce.prototype,_fe=jce,Pfe=Tfe,jfe=koe.TypeError,Nfe=koe.document,Ife=koe.process,Lfe=Dfe.f,Rfe=Lfe,Mfe=!!(Nfe&&Nfe.createEvent&&koe.dispatchEvent),zfe=Zoe(koe.PromiseRejectionEvent),$fe=!1,Hfe=Gae(Ofe,(function(){var e=tae(_fe),t=e!==String(_fe);if(!t&&66===uie)return!0;if(uie>=51&&/native code/.test(e))return!1;var n=new _fe((function(e){e(1)})),r=function(e){e((function(){}),(function(){}))};return(n.constructor={})[Afe]=r,!($fe=n.then((function(){}))instanceof r)||!t&&xfe&&!zfe})),Vfe=Hfe||!Hle((function(e){_fe.all(e).catch((function(){}))})),Ufe=function(e){var t;return!(!Joe(e)||!Zoe(t=e.then))&&t},Wfe=function(e,t){if(!e.notified){e.notified=!0;var n=e.reactions;wfe((function(){for(var r=e.value,o=1==e.state,i=0;n.length>i;){var a,u,s,l=n[i++],c=o?l.ok:l.fail,f=l.resolve,d=l.reject,p=l.domain;try{c?(o||(2===e.rejection&&Yfe(e),e.rejection=1),!0===c?a=r:(p&&p.enter(),a=c(r),p&&(p.exit(),s=!0)),a===l.promise?d(jfe("Promise-chain cycle")):(u=Ufe(a))?_oe(u,a,f,d):f(a)):d(r)}catch(e){p&&!s&&p.exit(),d(e)}}e.reactions=[],e.notified=!1,t&&!e.rejection&&qfe(e)}))}},Gfe=function(e,t,n){var r,o;Mfe?((r=Nfe.createEvent("Event")).promise=t,r.reason=n,r.initEvent(e,!1,!0),koe.dispatchEvent(r)):r={promise:t,reason:n},!zfe&&(o=koe["on"+e])?o(r):"unhandledrejection"===e&&function(e,t){var n=koe.console;n&&n.error&&(1==arguments.length?n.error(e):n.error(e,t))}("Unhandled promise rejection",n)},qfe=function(e){_oe(Cfe,koe,(function(){var t,n=e.facade,r=e.value;if(Kfe(e)&&(t=Sfe((function(){Lce?Ife.emit("unhandledRejection",r,n):Gfe("unhandledrejection",n,r)})),e.rejection=Lce||Kfe(e)?2:1,t.error))throw t.value}))},Kfe=function(e){return 1!==e.rejection&&!e.parent},Yfe=function(e){_oe(Cfe,koe,(function(){var t=e.facade;Lce?Ife.emit("rejectionHandled",t):Gfe("rejectionhandled",t,e.value)}))},Xfe=function(e,t,n){return function(r){e(t,r,n)}},Zfe=function(e,t,n){e.done||(e.done=!0,n&&(e=n),e.value=t,e.state=2,Wfe(e,!0))},Jfe=function(e,t,n){if(!e.done){e.done=!0,n&&(e=n);try{if(e.facade===t)throw jfe("Promise can't be resolved itself");var r=Ufe(t);r?wfe((function(){var n={done:!1};try{_oe(r,t,Xfe(Jfe,n,e),Xfe(Zfe,n,e))}catch(t){Zfe(n,t,e)}})):(e.value=t,e.state=1,Wfe(e,!1))}catch(t){Zfe({done:!1},t,e)}}};if(Hfe&&(Pfe=(_fe=function(e){Lle(this,Pfe),gie(e),_oe(vfe,this);var t=kfe(this);try{e(Xfe(Jfe,t),Xfe(Zfe,t))}catch(e){Zfe(t,e)}}).prototype,(vfe=function(e){Bfe(this,{type:Ofe,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=gle(Pfe,{then:function(e,t){var n=Ffe(this),r=n.reactions,o=Lfe(lse(this,_fe));return o.ok=!Zoe(e)||e,o.fail=Zoe(t)&&t,o.domain=Lce?Ife.domain:void 0,n.parent=!0,r[r.length]=o,0!=n.state&&Wfe(n,!1),o.promise},catch:function(e){return this.then(void 0,e)}}),yfe=function(){var e=new vfe,t=kfe(e);this.promise=e,this.resolve=Xfe(Jfe,t),this.reject=Xfe(Zfe,t)},Dfe.f=Lfe=function(e){return e===_fe||e===mfe?new yfe(e):Rfe(e)},Zoe(jce)&&Tfe!==Object.prototype)){bfe=Tfe.then,$fe||(bae(Tfe,"then",(function(e,t){var n=this;return new _fe((function(e,t){_oe(bfe,n,e,t)})).then(e,t)}),{unsafe:!0}),bae(Tfe,"catch",Pfe.catch,{unsafe:!0}));try{delete Tfe.constructor}catch(Ml){}tle&&tle(Tfe,Pfe)}Kae({global:!0,wrap:!0,forced:Hfe},{Promise:_fe}),Xse(_fe,Ofe,!1),function(e){var t=eie("Promise"),n=Yie.f;Foe&&t&&!t[Nce]&&n(t,Nce,{configurable:!0,get:function(){return this}})}(),mfe=eie(Ofe),Kae({target:Ofe,stat:!0,forced:Hfe},{reject:function(e){var t=Lfe(this);return _oe(t.reject,void 0,e),t.promise}}),Kae({target:Ofe,stat:!0,forced:Hfe},{resolve:function(e){return function(e,t){if(Gie(e),Joe(t)&&t.constructor===e)return t;var n=Dfe.f(e);return(0,n.resolve)(t),n.promise}(this,e)}}),Kae({target:Ofe,stat:!0,forced:Vfe},{all:function(e){var t=this,n=Lfe(t),r=n.resolve,o=n.reject,i=Sfe((function(){var n=gie(t.resolve),i=[],a=0,u=1;Nle(e,(function(e){var s=a++,l=!1;u++,_oe(n,t,e).then((function(e){l||(l=!0,i[s]=e,--u||r(i))}),o)})),--u||r(i)}));return i.error&&o(i.value),n.promise},race:function(e){var t=this,n=Lfe(t),r=n.reject,o=Sfe((function(){var o=gie(t.resolve);Nle(e,(function(e){_oe(o,t,e).then(n.resolve,r)}))}));return o.error&&r(o.value),n.promise}});var Qfe=mae.PROPER,ede=RegExp.prototype,tde=ede.toString,nde=$oe(Eue),rde=Boe((function(){return"/a/b"!=tde.call({source:"a",flags:"b"})})),ode=Qfe&&"toString"!=tde.name;(rde||ode)&&bae(RegExp.prototype,"toString",(function(){var e=Gie(this),t=wue(e.source),n=e.flags;return"/"+t+"/"+wue(void 0===n&&tie(ede,e)&&!("flags"in ede)?nde(e):n)}),{unsafe:!0});var ide=mae.EXISTS,ade=Yie.f,ude=Function.prototype,sde=$oe(ude.toString),lde=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,cde=$oe(lde.exec);Foe&&!ide&&ade(ude,"name",{configurable:!0,get:function(){try{return cde(lde,sde(this))[1]}catch(e){return""}}});var fde=new WeakMap;function dde(e){return e.getMenuConfig("uploadImage")}function pde(e,t){return Bse(this,void 0,void 0,(function(){return Fse(this,(function(n){return[2,new Promise((function(n){var r=new FileReader;r.readAsDataURL(t),r.onload=function(){var o=r.result;if(o){var i=o.toString(),a=0===i.indexOf("data:image")?"":i;M$(e,i,t.name,a),n("ok")}}}))]}))}))}function hde(e,t){return Bse(this,void 0,void 0,(function(){var n,r,o,i;return Fse(this,(function(a){switch(a.label){case 0:return n=function(e){var t=fde.get(e);if(null!=t)return t;var n=dde(e),r=n.onSuccess,o=n.onProgress,i=n.onFailed,a=n.customInsert,u=n.onError;return t=K_(kse(kse({},n),{onProgress:function(t){e.showProgressBar(t),o&&o(t)},onSuccess:function(t,n){if(a)return a(n,(function(t,n,r){return M$(e,t,n,r)})),void r(t,n);var o=n.errno,u=void 0===o?1:o,s=n.data,l=void 0===s?{}:s;if(0===u){if(Array.isArray(l))l.forEach((function(t){var n=t.url,r=void 0===n?"":n,o=t.alt,i=void 0===o?"":o,a=t.href;M$(e,r,i,void 0===a?"":a)}));else{var c=l.url,f=void 0===c?"":c,d=l.alt,p=void 0===d?"":d,h=l.href;M$(e,f,p,void 0===h?"":h)}r(t,n)}else i(t,n)},onError:function(e,t,n){u(e,t,n)}})),fde.set(e,t),t}(e),r=t.name,o=t.type,i=t.size,n.addFile({name:r,type:o,size:i,data:t}),[4,n.upload()];case 1:return a.sent(),[2]}}))}))}function gde(e,t){var n,r;return Bse(this,void 0,void 0,(function(){var o,i,a,u,s,l,c,f,d;return Fse(this,(function(p){switch(p.label){case 0:if(null==t)return[2];o=Array.prototype.slice.call(t),i=dde(e),a=i.customUpload,u=i.base64LimitSize,p.label=1;case 1:p.trys.push([1,11,12,17]),s=Tse(o),p.label=2;case 2:return[4,s.next()];case 3:return(l=p.sent()).done?[3,10]:(c=l.value,f=c.size,u&&f<=u?[4,pde(e,c)]:[3,5]);case 4:return p.sent(),[3,9];case 5:return a?[4,a(c,(function(t,n,r){return M$(e,t,n,r)}))]:[3,7];case 6:return p.sent(),[3,9];case 7:return[4,hde(e,c)];case 8:p.sent(),p.label=9;case 9:return[3,2];case 10:return[3,17];case 11:return d=p.sent(),n={error:d},[3,17];case 12:return p.trys.push([12,,15,16]),l&&!l.done&&(r=s.return)?[4,r.call(s)]:[3,14];case 13:p.sent(),p.label=14;case 14:return[3,16];case 15:if(n)throw n.error;return[7];case 16:return[7];case 17:return[2]}}))}))}var vde=$oe([].join),yde=qoe!=Object,mde=Cce("join",",");Kae({target:"Array",proto:!0,forced:yde||!mde},{join:function(e){return vde(Xoe(this),void 0===e?",":e)}}),ah&&(Mp.fn.append=ah),qp&&(Mp.fn.on=qp),dh&&(Mp.fn.remove=dh),Gp&&(Mp.fn.val=Gp),vh&&(Mp.fn.click=vh),Jp&&(Mp.fn.hide=Jp);var bde=function(){function e(){this.title=HP("uploadImgModule.uploadImage"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M828.708571 585.045333a48.761905 48.761905 0 0 0-48.737523 48.761905v18.529524l-72.143238-72.167619a135.972571 135.972571 0 0 0-191.585524 0l-34.133334 34.133333-120.880762-120.953905a138.898286 138.898286 0 0 0-191.585523 0l-72.167619 72.167619V292.400762a48.786286 48.786286 0 0 1 48.761904-48.761905h341.23581a48.737524 48.737524 0 0 0 34.474667-83.285333 48.737524 48.737524 0 0 0-34.474667-14.287238H146.236952A146.212571 146.212571 0 0 0 0 292.400762v585.289143A146.358857 146.358857 0 0 0 146.236952 1024h584.996572a146.212571 146.212571 0 0 0 146.236952-146.310095V633.807238a48.786286 48.786286 0 0 0-48.761905-48.761905zM146.261333 926.45181a48.737524 48.737524 0 0 1-48.761904-48.761905v-174.128762l141.409523-141.458286a38.497524 38.497524 0 0 1 53.126096 0l154.526476 154.624 209.627428 209.724953H146.236952z m633.734096-48.761905c-0.073143 9.337905-3.145143 18.383238-8.777143 25.843809l-219.843048-220.94019 34.133333-34.133334a37.546667 37.546667 0 0 1 53.613715 0l140.873143 141.897143V877.714286zM1009.615238 160.231619L863.329524 13.897143a48.737524 48.737524 0 0 0-16.091429-10.24c-11.849143-4.87619-25.161143-4.87619-37.059047 0a48.761905 48.761905 0 0 0-16.067048 10.24l-146.236952 146.334476a49.005714 49.005714 0 0 0 69.217523 69.241905l62.902858-63.390476v272.627809a48.761905 48.761905 0 1 0 97.475047 0V166.083048l62.902857 63.390476a48.737524 48.737524 0 0 0 69.217524 0 48.761905 48.761905 0 0 0 0-69.241905z"></path></svg>',this.tag="button"}return e.prototype.getValue=function(e){return""},e.prototype.isActive=function(e){return!1},e.prototype.isDisabled=function(e){return z$(e)},e.prototype.getMenuConfig=function(e){return e.getMenuConfig("uploadImage")},e.prototype.exec=function(e,t){var n=this.getMenuConfig(e),r=n.allowedFileTypes,o=void 0===r?[]:r,i=n.customBrowseAndUpload;if(i)i((function(t,n,r){return M$(e,t,n,r)}));else{var a="";o.length>0&&(a='accept="'+o.join(", ")+'"');var u=Mp("body"),s=Mp('<input type="file" '+a+" multiple/>");s.hide(),u.append(s),s.click(),s.on("change",(function(){var t=s[0].files;gde(e,t)}))}},e}(),wde={menus:[{key:"uploadImage",factory:function(){return new bde},config:{server:"",fieldName:"wangeditor-uploaded-image",maxFileSize:2097152,maxNumberOfFiles:100,allowedFileTypes:["image/*"],meta:{},metaWithUrl:!1,withCredentials:!1,timeout:1e4,onBeforeUpload:function(e){return e},onProgress:function(e){},onSuccess:function(e,t){},onFailed:function(e,t){console.error("'"+e.name+"' upload failed",t)},onError:function(e,t,n){console.error("'"+e.name+"' upload error",n)},base64LimitSize:0}}],editorPlugin:function(e){var t=e.insertData,n=e;return n.insertData=function(r){if(z$(n))t(r);else if(r.getData("text/plain"))t(r);else{var o=r.files;o.length<=0?t(r):Array.prototype.slice.call(o).some((function(e){return"image"===function(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return a}(e.type.split("/"),1)[0]}))?gde(e,o):t(r)}},n}};MP("en",{highLightModule:{selectLang:"Language"}}),MP("zh-CN",{highLightModule:{selectLang:"éæ©è¯­è¨"}});var Ede="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function Dde(e){var t={exports:{}};return e(t,t.exports),t.exports}var Sde,xde,Cde=function(e){return e&&e.Math==Math&&e},Ade=Cde("object"==typeof globalThis&&globalThis)||Cde("object"==typeof window&&window)||Cde("object"==typeof self&&self)||Cde("object"==typeof Ede&&Ede)||function(){return this}()||Function("return this")(),Ode=Object.defineProperty,kde=function(e,t){try{Ode(Ade,e,{value:t,configurable:!0,writable:!0})}catch(n){Ade[e]=t}return t},Bde=Ade["__core-js_shared__"]||kde("__core-js_shared__",{}),Fde=Dde((function(e){(e.exports=function(e,t){return Bde[e]||(Bde[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.19.3",mode:"global",copyright:"Â© 2021 Denis Pushkarev (zloirock.ru)"})})),Tde=Function.prototype,_de=Tde.bind,Pde=Tde.call,jde=_de&&_de.bind(Pde),Nde=_de?function(e){return e&&jde(Pde,e)}:function(e){return e&&function(){return Pde.apply(e,arguments)}},Ide=Ade.TypeError,Lde=function(e){if(null==e)throw Ide("Can't call method on "+e);return e},Rde=Ade.Object,Mde=function(e){return Rde(Lde(e))},zde=Nde({}.hasOwnProperty),$de=Object.hasOwn||function(e,t){return zde(Mde(e),t)},Hde=0,Vde=Math.random(),Ude=Nde(1..toString),Wde=function(e){return"Symbol("+(void 0===e?"":e)+")_"+Ude(++Hde+Vde,36)},Gde=function(e){return"function"==typeof e},qde=function(e){return Gde(e)?e:void 0},Kde=function(e,t){return arguments.length<2?qde(Ade[e]):Ade[e]&&Ade[e][t]},Yde=Kde("navigator","userAgent")||"",Xde=Ade.process,Zde=Ade.Deno,Jde=Xde&&Xde.versions||Zde&&Zde.version,Qde=Jde&&Jde.v8;Qde&&(xde=(Sde=Qde.split("."))[0]>0&&Sde[0]<4?1:+(Sde[0]+Sde[1])),!xde&&Yde&&(!(Sde=Yde.match(/Edge\/(\d+)/))||Sde[1]>=74)&&(Sde=Yde.match(/Chrome\/(\d+)/))&&(xde=+Sde[1]);var epe=xde,tpe=function(e){try{return!!e()}catch(e){return!0}},npe=!!Object.getOwnPropertySymbols&&!tpe((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&epe&&epe<41})),rpe=npe&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,ope=Fde("wks"),ipe=Ade.Symbol,ape=ipe&&ipe.for,upe=rpe?ipe:ipe&&ipe.withoutSetter||Wde,spe=function(e){if(!$de(ope,e)||!npe&&"string"!=typeof ope[e]){var t="Symbol."+e;npe&&$de(ipe,e)?ope[e]=ipe[e]:ope[e]=rpe&&ape?ape(t):upe(t)}return ope[e]},lpe={};lpe[spe("toStringTag")]="z";var cpe="[object z]"===String(lpe),fpe=!tpe((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),dpe=function(e){return"object"==typeof e?null!==e:Gde(e)},ppe=Ade.document,hpe=dpe(ppe)&&dpe(ppe.createElement),gpe=function(e){return hpe?ppe.createElement(e):{}},vpe=!fpe&&!tpe((function(){return 7!=Object.defineProperty(gpe("div"),"a",{get:function(){return 7}}).a})),ype=Ade.String,mpe=Ade.TypeError,bpe=function(e){if(dpe(e))return e;throw mpe(ype(e)+" is not an object")},wpe=Function.prototype.call,Epe=wpe.bind?wpe.bind(wpe):function(){return wpe.apply(wpe,arguments)},Dpe=Nde({}.isPrototypeOf),Spe=Ade.Object,xpe=rpe?function(e){return"symbol"==typeof e}:function(e){var t=Kde("Symbol");return Gde(t)&&Dpe(t.prototype,Spe(e))},Cpe=Ade.String,Ape=function(e){try{return Cpe(e)}catch(e){return"Object"}},Ope=Ade.TypeError,kpe=function(e){if(Gde(e))return e;throw Ope(Ape(e)+" is not a function")},Bpe=function(e,t){var n=e[t];return null==n?void 0:kpe(n)},Fpe=Ade.TypeError,Tpe=Ade.TypeError,_pe=spe("toPrimitive"),Ppe=function(e){var t=function(e,t){if(!dpe(e)||xpe(e))return e;var n,r=Bpe(e,_pe);if(r){if(void 0===t&&(t="default"),n=Epe(r,e,t),!dpe(n)||xpe(n))return n;throw Tpe("Can't convert object to primitive value")}return void 0===t&&(t="number"),function(e,t){var n,r;if("string"===t&&Gde(n=e.toString)&&!dpe(r=Epe(n,e)))return r;if(Gde(n=e.valueOf)&&!dpe(r=Epe(n,e)))return r;if("string"!==t&&Gde(n=e.toString)&&!dpe(r=Epe(n,e)))return r;throw Fpe("Can't convert object to primitive value")}(e,t)}(e,"string");return xpe(t)?t:t+""},jpe=Ade.TypeError,Npe=Object.defineProperty,Ipe={f:fpe?Npe:function(e,t,n){if(bpe(e),t=Ppe(t),bpe(n),vpe)try{return Npe(e,t,n)}catch(e){}if("get"in n||"set"in n)throw jpe("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},Lpe=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},Rpe=fpe?function(e,t,n){return Ipe.f(e,t,Lpe(1,n))}:function(e,t,n){return e[t]=n,e},Mpe=Nde(Function.toString);Gde(Bde.inspectSource)||(Bde.inspectSource=function(e){return Mpe(e)});var zpe,$pe,Hpe,Vpe=Bde.inspectSource,Upe=Ade.WeakMap,Wpe=Gde(Upe)&&/native code/.test(Vpe(Upe)),Gpe=Fde("keys"),qpe=function(e){return Gpe[e]||(Gpe[e]=Wde(e))},Kpe={},Ype=Ade.TypeError,Xpe=Ade.WeakMap;if(Wpe||Bde.state){var Zpe=Bde.state||(Bde.state=new Xpe),Jpe=Nde(Zpe.get),Qpe=Nde(Zpe.has),ehe=Nde(Zpe.set);zpe=function(e,t){if(Qpe(Zpe,e))throw new Ype("Object already initialized");return t.facade=e,ehe(Zpe,e,t),t},$pe=function(e){return Jpe(Zpe,e)||{}},Hpe=function(e){return Qpe(Zpe,e)}}else{var the=qpe("state");Kpe[the]=!0,zpe=function(e,t){if($de(e,the))throw new Ype("Object already initialized");return t.facade=e,Rpe(e,the,t),t},$pe=function(e){return $de(e,the)?e[the]:{}},Hpe=function(e){return $de(e,the)}}var nhe={set:zpe,get:$pe,has:Hpe,enforce:function(e){return Hpe(e)?$pe(e):zpe(e,{})},getterFor:function(e){return function(t){var n;if(!dpe(t)||(n=$pe(t)).type!==e)throw Ype("Incompatible receiver, "+e+" required");return n}}},rhe=Function.prototype,ohe=fpe&&Object.getOwnPropertyDescriptor,ihe=$de(rhe,"name"),ahe={EXISTS:ihe,PROPER:ihe&&"something"===function(){}.name,CONFIGURABLE:ihe&&(!fpe||fpe&&ohe(rhe,"name").configurable)},uhe=Dde((function(e){var t=ahe.CONFIGURABLE,n=nhe.get,r=nhe.enforce,o=String(String).split("String");(e.exports=function(e,n,i,a){var u,s=!!a&&!!a.unsafe,l=!!a&&!!a.enumerable,c=!!a&&!!a.noTargetGet,f=a&&void 0!==a.name?a.name:n;Gde(i)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!$de(i,"name")||t&&i.name!==f)&&Rpe(i,"name",f),(u=r(i)).source||(u.source=o.join("string"==typeof f?f:""))),e!==Ade?(s?!c&&e[n]&&(l=!0):delete e[n],l?e[n]=i:Rpe(e,n,i)):l?e[n]=i:kde(n,i)})(Function.prototype,"toString",(function(){return Gde(this)&&n(this).source||Vpe(this)}))})),she=Nde({}.toString),lhe=Nde("".slice),che=function(e){return lhe(she(e),8,-1)},fhe=spe("toStringTag"),dhe=Ade.Object,phe="Arguments"==che(function(){return arguments}()),hhe=cpe?che:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=function(e,t){try{return e[t]}catch(e){}}(t=dhe(e),fhe))?n:phe?che(t):"Object"==(r=che(t))&&Gde(t.callee)?"Arguments":r},ghe=cpe?{}.toString:function(){return"[object "+hhe(this)+"]"};cpe||uhe(Object.prototype,"toString",ghe,{unsafe:!0});var vhe,yhe={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},mhe=gpe("span").classList,bhe=mhe&&mhe.constructor&&mhe.constructor.prototype,whe=bhe===Object.prototype?void 0:bhe,Ehe=Nde(Nde.bind),Dhe=Ade.Object,She=Nde("".split),xhe=tpe((function(){return!Dhe("z").propertyIsEnumerable(0)}))?function(e){return"String"==che(e)?She(e,""):Dhe(e)}:Dhe,Che=Math.ceil,Ahe=Math.floor,Ohe=function(e){var t=+e;return t!=t||0===t?0:(t>0?Ahe:Che)(t)},khe=Math.min,Bhe=function(e){return e>0?khe(Ohe(e),9007199254740991):0},Fhe=function(e){return Bhe(e.length)},The=Array.isArray||function(e){return"Array"==che(e)},_he=function(){},Phe=[],jhe=Kde("Reflect","construct"),Nhe=/^\s*(?:class|function)\b/,Ihe=Nde(Nhe.exec),Lhe=!Nhe.exec(_he),Rhe=function(e){if(!Gde(e))return!1;try{return jhe(_he,Phe,e),!0}catch(e){return!1}},Mhe=!jhe||tpe((function(){var e;return Rhe(Rhe.call)||!Rhe(Object)||!Rhe((function(){e=!0}))||e}))?function(e){if(!Gde(e))return!1;switch(hhe(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}return Lhe||!!Ihe(Nhe,Vpe(e))}:Rhe,zhe=spe("species"),$he=Ade.Array,Hhe=function(e,t){return new(function(e){var t;return The(e)&&(t=e.constructor,(Mhe(t)&&(t===$he||The(t.prototype))||dpe(t)&&null===(t=t[zhe]))&&(t=void 0)),void 0===t?$he:t}(e))(0===t?0:t)},Vhe=Nde([].push),Uhe=function(e){var t=1==e,n=2==e,r=3==e,o=4==e,i=6==e,a=7==e,u=5==e||i;return function(s,l,c,f){for(var d,p,h=Mde(s),g=xhe(h),v=function(e,t){return kpe(e),void 0===t?e:Ehe?Ehe(e,t):function(){return e.apply(t,arguments)}}(l,c),y=Fhe(g),m=0,b=f||Hhe,w=t?b(s,y):n||a?b(s,0):void 0;y>m;m++)if((u||m in g)&&(p=v(d=g[m],m,h),e))if(t)w[m]=p;else if(p)switch(e){case 3:return!0;case 5:return d;case 6:return m;case 2:Vhe(w,d)}else switch(e){case 4:return!1;case 7:Vhe(w,d)}return i?-1:r||o?o:w}},Whe=[Uhe(0),Uhe(1),Uhe(2),Uhe(3),Uhe(4),Uhe(5),Uhe(6),Uhe(7)][0],Ghe=(vhe=[].forEach)&&tpe((function(){vhe.call(null,(function(){throw 1}),1)}))?[].forEach:function(e){return Whe(this,e,arguments.length>1?arguments[1]:void 0)},qhe=function(e){if(e&&e.forEach!==Ghe)try{Rpe(e,"forEach",Ghe)}catch(t){e.forEach=Ghe}};for(var Khe in yhe)yhe[Khe]&&qhe(Ade[Khe]&&Ade[Khe].prototype);qhe(whe);var Yhe={}.propertyIsEnumerable,Xhe=Object.getOwnPropertyDescriptor,Zhe={f:Xhe&&!Yhe.call({1:2},1)?function(e){var t=Xhe(this,e);return!!t&&t.enumerable}:Yhe},Jhe=function(e){return xhe(Lde(e))},Qhe=Object.getOwnPropertyDescriptor,ege={f:fpe?Qhe:function(e,t){if(e=Jhe(e),t=Ppe(t),vpe)try{return Qhe(e,t)}catch(e){}if($de(e,t))return Lpe(!Epe(Zhe.f,e,t),e[t])}},tge=Math.max,nge=Math.min,rge=function(e,t){var n=Ohe(e);return n<0?tge(n+t,0):nge(n,t)},oge=function(e){return function(t,n,r){var o,i=Jhe(t),a=Fhe(i),u=rge(r,a);if(e&&n!=n){for(;a>u;)if((o=i[u++])!=o)return!0}else for(;a>u;u++)if((e||u in i)&&i[u]===n)return e||u||0;return!e&&-1}},ige=(oge(!0),oge(!1)),age=Nde([].push),uge=function(e,t){var n,r=Jhe(e),o=0,i=[];for(n in r)!$de(Kpe,n)&&$de(r,n)&&age(i,n);for(;t.length>o;)$de(r,n=t[o++])&&(~ige(i,n)||age(i,n));return i},sge=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],lge=sge.concat("length","prototype"),cge={f:Object.getOwnPropertyNames||function(e){return uge(e,lge)}},fge={f:Object.getOwnPropertySymbols},dge=Nde([].concat),pge=Kde("Reflect","ownKeys")||function(e){var t=cge.f(bpe(e)),n=fge.f;return n?dge(t,n(e)):t},hge=function(e,t){for(var n=pge(t),r=Ipe.f,o=ege.f,i=0;i<n.length;i++){var a=n[i];$de(e,a)||r(e,a,o(t,a))}},gge=/#|\.prototype\./,vge=function(e,t){var n=mge[yge(e)];return n==wge||n!=bge&&(Gde(t)?tpe(t):!!t)},yge=vge.normalize=function(e){return String(e).replace(gge,".").toLowerCase()},mge=vge.data={},bge=vge.NATIVE="N",wge=vge.POLYFILL="P",Ege=vge,Dge=ege.f,Sge=function(e,t){var n,r,o,i,a,u=e.target,s=e.global,l=e.stat;if(n=s?Ade:l?Ade[u]||kde(u,{}):(Ade[u]||{}).prototype)for(r in t){if(i=t[r],o=e.noTargetGet?(a=Dge(n,r))&&a.value:n[r],!Ege(s?r:u+(l?".":"#")+r,e.forced)&&void 0!==o){if(typeof i==typeof o)continue;hge(i,o)}(e.sham||o&&o.sham)&&Rpe(i,"sham",!0),uhe(n,r,i,e)}},xge=Object.keys||function(e){return uge(e,sge)},Cge=Object.assign,Age=Object.defineProperty,Oge=Nde([].concat),kge=!Cge||tpe((function(){if(fpe&&1!==Cge({b:1},Cge(Age({},"a",{enumerable:!0,get:function(){Age(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var e={},t={},n=Symbol(),r="abcdefghijklmnopqrst";return e[n]=7,r.split("").forEach((function(e){t[e]=e})),7!=Cge({},e)[n]||xge(Cge({},t)).join("")!=r}))?function(e,t){for(var n=Mde(e),r=arguments.length,o=1,i=fge.f,a=Zhe.f;r>o;)for(var u,s=xhe(arguments[o++]),l=i?Oge(xge(s),i(s)):xge(s),c=l.length,f=0;c>f;)u=l[f++],fpe&&!Epe(a,s,u)||(n[u]=s[u]);return n}:Cge;Sge({target:"Object",stat:!0,forced:Object.assign!==kge},{assign:kge});var Bge=Dde((function(e){var t=function(e){var t=/\blang(?:uage)?-([\w-]+)\b/i,n=0,r={},o={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function e(t){return t instanceof i?new i(t.type,e(t.content),t.alias):Array.isArray(t)?t.map(e):t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++n}),e.__id},clone:function e(t,n){var r,i;switch(n=n||{},o.util.type(t)){case"Object":if(i=o.util.objId(t),n[i])return n[i];for(var a in r={},n[i]=r,t)t.hasOwnProperty(a)&&(r[a]=e(t[a],n));return r;case"Array":return i=o.util.objId(t),n[i]?n[i]:(r=[],n[i]=r,t.forEach((function(t,o){r[o]=e(t,n)})),r);default:return t}},getLanguage:function(e){for(;e&&!t.test(e.className);)e=e.parentElement;return e?(e.className.match(t)||[,"none"])[1].toLowerCase():"none"},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(r){var e=(/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r.stack)||[])[1];if(e){var t=document.getElementsByTagName("script");for(var n in t)if(t[n].src==e)return t[n]}return null}},isActive:function(e,t,n){for(var r="no-"+t;e;){var o=e.classList;if(o.contains(t))return!0;if(o.contains(r))return!1;e=e.parentElement}return!!n}},languages:{plain:r,plaintext:r,text:r,txt:r,extend:function(e,t){var n=o.util.clone(o.languages[e]);for(var r in t)n[r]=t[r];return n},insertBefore:function(e,t,n,r){var i=(r=r||o.languages)[e],a={};for(var u in i)if(i.hasOwnProperty(u)){if(u==t)for(var s in n)n.hasOwnProperty(s)&&(a[s]=n[s]);n.hasOwnProperty(u)||(a[u]=i[u])}var l=r[e];return r[e]=a,o.languages.DFS(o.languages,(function(t,n){n===l&&t!=e&&(this[t]=a)})),a},DFS:function e(t,n,r,i){i=i||{};var a=o.util.objId;for(var u in t)if(t.hasOwnProperty(u)){n.call(t,u,t[u],r||u);var s=t[u],l=o.util.type(s);"Object"!==l||i[a(s)]?"Array"!==l||i[a(s)]||(i[a(s)]=!0,e(s,n,u,i)):(i[a(s)]=!0,e(s,n,null,i))}}},plugins:{},highlightAll:function(e,t){o.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,n){var r={callback:n,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};o.hooks.run("before-highlightall",r),r.elements=Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)),o.hooks.run("before-all-elements-highlight",r);for(var i,a=0;i=r.elements[a++];)o.highlightElement(i,!0===t,r.callback)},highlightElement:function(n,r,i){var a=o.util.getLanguage(n),u=o.languages[a];n.className=n.className.replace(t,"").replace(/\s+/g," ")+" language-"+a;var s=n.parentElement;s&&"pre"===s.nodeName.toLowerCase()&&(s.className=s.className.replace(t,"").replace(/\s+/g," ")+" language-"+a);var l={element:n,language:a,grammar:u,code:n.textContent};function c(e){l.highlightedCode=e,o.hooks.run("before-insert",l),l.element.innerHTML=l.highlightedCode,o.hooks.run("after-highlight",l),o.hooks.run("complete",l),i&&i.call(l.element)}if(o.hooks.run("before-sanity-check",l),(s=l.element.parentElement)&&"pre"===s.nodeName.toLowerCase()&&!s.hasAttribute("tabindex")&&s.setAttribute("tabindex","0"),!l.code)return o.hooks.run("complete",l),void(i&&i.call(l.element));if(o.hooks.run("before-highlight",l),l.grammar)if(r&&e.Worker){var f=new Worker(o.filename);f.onmessage=function(e){c(e.data)},f.postMessage(JSON.stringify({language:l.language,code:l.code,immediateClose:!0}))}else c(o.highlight(l.code,l.grammar,l.language));else c(o.util.encode(l.code))},highlight:function(e,t,n){var r={code:e,grammar:t,language:n};return o.hooks.run("before-tokenize",r),r.tokens=o.tokenize(r.code,r.grammar),o.hooks.run("after-tokenize",r),i.stringify(o.util.encode(r.tokens),r.language)},tokenize:function(e,t){var n=t.rest;if(n){for(var r in n)t[r]=n[r];delete t.rest}var o=new s;return l(o,o.head,e),u(e,o,t,o.head,0),function(e){for(var t=[],n=e.head.next;n!==e.tail;)t.push(n.value),n=n.next;return t}(o)},hooks:{all:{},add:function(e,t){var n=o.hooks.all;n[e]=n[e]||[],n[e].push(t)},run:function(e,t){var n=o.hooks.all[e];if(n&&n.length)for(var r,i=0;r=n[i++];)r(t)}},Token:i};function i(e,t,n,r){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length}function a(e,t,n,r){e.lastIndex=t;var o=e.exec(n);if(o&&r&&o[1]){var i=o[1].length;o.index+=i,o[0]=o[0].slice(i)}return o}function u(e,t,n,r,s,f){for(var d in n)if(n.hasOwnProperty(d)&&n[d]){var p=n[d];p=Array.isArray(p)?p:[p];for(var h=0;h<p.length;++h){if(f&&f.cause==d+","+h)return;var g=p[h],v=g.inside,y=!!g.lookbehind,m=!!g.greedy,b=g.alias;if(m&&!g.pattern.global){var w=g.pattern.toString().match(/[imsuy]*$/)[0];g.pattern=RegExp(g.pattern.source,w+"g")}for(var E=g.pattern||g,D=r.next,S=s;D!==t.tail&&!(f&&S>=f.reach);S+=D.value.length,D=D.next){var x=D.value;if(t.length>e.length)return;if(!(x instanceof i)){var C,A=1;if(m){if(!(C=a(E,S,e,y)))break;var O=C.index,k=C.index+C[0].length,B=S;for(B+=D.value.length;O>=B;)B+=(D=D.next).value.length;if(S=B-=D.value.length,D.value instanceof i)continue;for(var F=D;F!==t.tail&&(B<k||"string"==typeof F.value);F=F.next)A++,B+=F.value.length;A--,x=e.slice(S,B),C.index-=S}else if(!(C=a(E,0,x,y)))continue;O=C.index;var T=C[0],_=x.slice(0,O),P=x.slice(O+T.length),j=S+x.length;f&&j>f.reach&&(f.reach=j);var N=D.prev;if(_&&(N=l(t,N,_),S+=_.length),c(t,N,A),D=l(t,N,new i(d,v?o.tokenize(T,v):T,b,T)),P&&l(t,D,P),A>1){var I={cause:d+","+h,reach:j};u(e,t,n,D.prev,S,I),f&&I.reach>f.reach&&(f.reach=I.reach)}}}}}}function s(){var e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0}function l(e,t,n){var r=t.next,o={value:n,prev:t,next:r};return t.next=o,r.prev=o,e.length++,o}function c(e,t,n){for(var r=t.next,o=0;o<n&&r!==e.tail;o++)r=r.next;t.next=r,r.prev=t,e.length-=o}if(e.Prism=o,i.stringify=function e(t,n){if("string"==typeof t)return t;if(Array.isArray(t)){var r="";return t.forEach((function(t){r+=e(t,n)})),r}var i={type:t.type,content:e(t.content,n),tag:"span",classes:["token",t.type],attributes:{},language:n},a=t.alias;a&&(Array.isArray(a)?Array.prototype.push.apply(i.classes,a):i.classes.push(a)),o.hooks.run("wrap",i);var u="";for(var s in i.attributes)u+=" "+s+'="'+(i.attributes[s]||"").replace(/"/g,"&quot;")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'"'+u+">"+i.content+"</"+i.tag+">"},!e.document)return e.addEventListener?(o.disableWorkerMessageHandler||e.addEventListener("message",(function(t){var n=JSON.parse(t.data),r=n.language,i=n.code,a=n.immediateClose;e.postMessage(o.highlight(i,o.languages[r],r)),a&&e.close()}),!1),o):o;var f=o.util.currentScript();function d(){o.manual||o.highlightAll()}if(f&&(o.filename=f.src,f.hasAttribute("data-manual")&&(o.manual=!0)),!o.manual){var p=document.readyState;"loading"===p||"interactive"===p&&f&&f.defer?document.addEventListener("DOMContentLoaded",d):window.requestAnimationFrame?window.requestAnimationFrame(d):window.setTimeout(d,16)}return o}("undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{});
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */e.exports&&(e.exports=t),void 0!==Ede&&(Ede.Prism=t),t.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:!0},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:!0},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:!0,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:!0,greedy:!0,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:!0},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:!0},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},t.languages.markup.tag.inside["attr-value"].inside.entity=t.languages.markup.entity,t.languages.markup.doctype.inside["internal-subset"].inside=t.languages.markup,t.hooks.add("wrap",(function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"))})),Object.defineProperty(t.languages.markup.tag,"addInlined",{value:function(e,n){var r={};r["language-"+n]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:t.languages[n]},r.cdata=/^<!\[CDATA\[|\]\]>$/i;var o={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:r}};o["language-"+n]={pattern:/[\s\S]+/,inside:t.languages[n]};var i={};i[e]={pattern:RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g,(function(){return e})),"i"),lookbehind:!0,greedy:!0,inside:o},t.languages.insertBefore("markup","cdata",i)}}),Object.defineProperty(t.languages.markup.tag,"addAttribute",{value:function(e,n){t.languages.markup.tag.inside["special-attr"].push({pattern:RegExp(/(^|["'\s])/.source+"(?:"+e+")"+/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,"i"),lookbehind:!0,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:!0,alias:[n,"language-"+n],inside:t.languages[n]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}})}}),t.languages.html=t.languages.markup,t.languages.mathml=t.languages.markup,t.languages.svg=t.languages.markup,t.languages.xml=t.languages.extend("markup",{}),t.languages.ssml=t.languages.xml,t.languages.atom=t.languages.xml,t.languages.rss=t.languages.xml,function(e){var t=/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;e.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,inside:{rule:/^@[\w-]+/,"selector-function-argument":{pattern:/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,lookbehind:!0,alias:"selector"},keyword:{pattern:/(^|[^\w-])(?:and|not|only|or)(?![\w-])/,lookbehind:!0}}},url:{pattern:RegExp("\\burl\\((?:"+t.source+"|"+/(?:[^\\\r\n()"']|\\[\s\S])*/.source+")\\)","i"),greedy:!0,inside:{function:/^url/i,punctuation:/^\(|\)$/,string:{pattern:RegExp("^"+t.source+"$"),alias:"url"}}},selector:{pattern:RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|"+t.source+")*(?=\\s*\\{)"),lookbehind:!0},string:{pattern:t,greedy:!0},property:{pattern:/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,lookbehind:!0},important:/!important\b/i,function:{pattern:/(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,lookbehind:!0},punctuation:/[(){};:,]/},e.languages.css.atrule.inside.rest=e.languages.css;var n=e.languages.markup;n&&(n.tag.addInlined("style","css"),n.tag.addAttribute("style","css"))}(t),t.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/},t.languages.javascript=t.languages.extend("clike",{"class-name":[t.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/}),t.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/,t.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:t.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:t.languages.javascript},{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,lookbehind:!0,inside:t.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:t.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:t.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),t.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:t.languages.javascript}},string:/[\s\S]+/}}}),t.languages.markup&&(t.languages.markup.tag.addInlined("script","javascript"),t.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,"javascript")),t.languages.js=t.languages.javascript,function(){if(void 0!==t&&"undefined"!=typeof document){Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector);var e={js:"javascript",py:"python",rb:"ruby",ps1:"powershell",psm1:"powershell",sh:"bash",bat:"batch",h:"c",tex:"latex"},n="data-src-status",r='pre[data-src]:not([data-src-status="loaded"]):not([data-src-status="loading"])',o=/\blang(?:uage)?-([\w-]+)\b/i;t.hooks.add("before-highlightall",(function(e){e.selector+=", "+r})),t.hooks.add("before-sanity-check",(function(o){var i=o.element;if(i.matches(r)){o.code="",i.setAttribute(n,"loading");var u=i.appendChild(document.createElement("CODE"));u.textContent="Loadingâ¦";var s=i.getAttribute("data-src"),l=o.language;if("none"===l){var c=(/\.(\w+)$/.exec(s)||[,"none"])[1];l=e[c]||c}a(u,l),a(i,l);var f=t.plugins.autoloader;f&&f.loadLanguages(l);var d=new XMLHttpRequest;d.open("GET",s,!0),d.onreadystatechange=function(){4==d.readyState&&(d.status<400&&d.responseText?(i.setAttribute(n,"loaded"),u.textContent=d.responseText,t.highlightElement(u)):(i.setAttribute(n,"failed"),d.status>=400?u.textContent="â Error "+d.status+" while fetching file: "+d.statusText:u.textContent="â Error: File does not exist or is empty"))},d.send(null)}})),t.plugins.fileHighlight={highlight:function(e){for(var n,o=(e||document).querySelectorAll(r),i=0;n=o[i++];)t.highlightElement(n)}};var i=!1;t.fileHighlight=function(){i||(console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."),i=!0),t.plugins.fileHighlight.highlight.apply(this,arguments)}}function a(e,t){var n=e.className;n=n.replace(o," ")+" language-"+t,e.className=n.replace(/\s+/g," ").trim()}}()}));!function(e){var t=e.util.clone(e.languages.javascript),n=/(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source,r=/(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source,o=/(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;function i(e,t){return e=e.replace(/<S>/g,(function(){return n})).replace(/<BRACES>/g,(function(){return r})).replace(/<SPREAD>/g,(function(){return o})),RegExp(e,t)}o=i(o).source,e.languages.jsx=e.languages.extend("markup",t),e.languages.jsx.tag.pattern=i(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source),e.languages.jsx.tag.inside.tag.pattern=/^<\/?[^\s>\/]*/i,e.languages.jsx.tag.inside["attr-value"].pattern=/=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/i,e.languages.jsx.tag.inside.tag.inside["class-name"]=/^[A-Z]\w*(?:\.[A-Z]\w*)*$/,e.languages.jsx.tag.inside.comment=t.comment,e.languages.insertBefore("inside","attr-name",{spread:{pattern:i(/<SPREAD>/.source),inside:e.languages.jsx}},e.languages.jsx.tag),e.languages.insertBefore("inside","special-attr",{script:{pattern:i(/=<BRACES>/.source),inside:{"script-punctuation":{pattern:/^=(?=\{)/,alias:"punctuation"},rest:e.languages.jsx},alias:"language-javascript"}},e.languages.jsx.tag);var a=function(e){return e?"string"==typeof e?e:"string"==typeof e.content?e.content:e.content.map(a).join(""):""},u=function(t){for(var n=[],r=0;r<t.length;r++){var o=t[r],i=!1;if("string"!=typeof o&&("tag"===o.type&&o.content[0]&&"tag"===o.content[0].type?"</"===o.content[0].content[0].content?n.length>0&&n[n.length-1].tagName===a(o.content[0].content[1])&&n.pop():"/>"===o.content[o.content.length-1].content||n.push({tagName:a(o.content[0].content[1]),openedBraces:0}):n.length>0&&"punctuation"===o.type&&"{"===o.content?n[n.length-1].openedBraces++:n.length>0&&n[n.length-1].openedBraces>0&&"punctuation"===o.type&&"}"===o.content?n[n.length-1].openedBraces--:i=!0),(i||"string"==typeof o)&&n.length>0&&0===n[n.length-1].openedBraces){var s=a(o);r<t.length-1&&("string"==typeof t[r+1]||"plain-text"===t[r+1].type)&&(s+=a(t[r+1]),t.splice(r+1,1)),r>0&&("string"==typeof t[r-1]||"plain-text"===t[r-1].type)&&(s=a(t[r-1])+s,t.splice(r-1,1),r--),t[r]=new e.Token("plain-text",s,null,s)}o.content&&"string"!=typeof o.content&&u(o.content)}};e.hooks.add("after-tokenize",(function(e){"jsx"!==e.language&&"tsx"!==e.language||u(e.tokens)}))}(Prism),function(e){e.languages.typescript=e.languages.extend("javascript",{"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,lookbehind:!0,greedy:!0,inside:null},builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/}),e.languages.typescript.keyword.push(/\b(?:abstract|as|declare|implements|is|keyof|readonly|require)\b/,/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,/\btype\b(?=\s*(?:[\{*]|$))/),delete e.languages.typescript.parameter;var t=e.languages.extend("typescript",{});delete t["class-name"],e.languages.typescript["class-name"].inside=t,e.languages.insertBefore("typescript","function",{decorator:{pattern:/@[$\w\xA0-\uFFFF]+/,inside:{at:{pattern:/^@/,alias:"operator"},function:/^[\s\S]+/}},"generic-function":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,greedy:!0,inside:{function:/^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,generic:{pattern:/<[\s\S]+/,alias:"class-name",inside:t}}}}),e.languages.ts=e.languages.typescript}(Prism),Prism.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:!0},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:!0},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:!0,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:!0,greedy:!0,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:!0},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:!0},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.languages.markup.doctype.inside["internal-subset"].inside=Prism.languages.markup,Prism.hooks.add("wrap",(function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"))})),Object.defineProperty(Prism.languages.markup.tag,"addInlined",{value:function(e,t){var n={};n["language-"+t]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:Prism.languages[t]},n.cdata=/^<!\[CDATA\[|\]\]>$/i;var r={"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:n}};r["language-"+t]={pattern:/[\s\S]+/,inside:Prism.languages[t]};var o={};o[e]={pattern:RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g,(function(){return e})),"i"),lookbehind:!0,greedy:!0,inside:r},Prism.languages.insertBefore("markup","cdata",o)}}),Object.defineProperty(Prism.languages.markup.tag,"addAttribute",{value:function(e,t){Prism.languages.markup.tag.inside["special-attr"].push({pattern:RegExp(/(^|["'\s])/.source+"(?:"+e+")"+/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,"i"),lookbehind:!0,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:!0,alias:[t,"language-"+t],inside:Prism.languages[t]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}})}}),Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup,Prism.languages.xml=Prism.languages.extend("markup",{}),Prism.languages.ssml=Prism.languages.xml,Prism.languages.atom=Prism.languages.xml,Prism.languages.rss=Prism.languages.xml,Prism.languages.go=Prism.languages.extend("clike",{string:{pattern:/(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,greedy:!0},keyword:/\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,boolean:/\b(?:_|iota|nil|true|false)\b/,number:/(?:\b0x[a-f\d]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[-+]?\d+)?)i?/i,operator:/[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,builtin:/\b(?:bool|byte|complex(?:64|128)|error|float(?:32|64)|rune|string|u?int(?:8|16|32|64)?|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(?:ln)?|real|recover)\b/}),delete Prism.languages.go["class-name"],function(e){var t=/\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/,n=[{pattern:/\b(?:false|true)\b/i,alias:"boolean"},{pattern:/(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,greedy:!0,lookbehind:!0},{pattern:/(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,greedy:!0,lookbehind:!0},/\b(?:null)\b/i,/\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/],r=/\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i,o=/<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/,i=/[{}\[\](),:;]/;e.languages.php={delimiter:{pattern:/\?>$|^<\?(?:php(?=\s)|=)?/i,alias:"important"},comment:t,variable:/\$+(?:\w+\b|(?=\{))/i,package:{pattern:/(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,lookbehind:!0,inside:{punctuation:/\\/}},"class-name-definition":{pattern:/(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,lookbehind:!0,alias:"class-name"},"function-definition":{pattern:/(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,lookbehind:!0,alias:"function"},keyword:[{pattern:/(\(\s*)\b(?:bool|boolean|int|integer|float|string|object|array)\b(?=\s*\))/i,alias:"type-casting",greedy:!0,lookbehind:!0},{pattern:/([(,?]\s*)\b(?:bool|int|float|string|object|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b(?=\s*\$)/i,alias:"type-hint",greedy:!0,lookbehind:!0},{pattern:/([(,?]\s*[\w|]\|\s*)(?:null|false)\b(?=\s*\$)/i,alias:"type-hint",greedy:!0,lookbehind:!0},{pattern:/(\)\s*:\s*(?:\?\s*)?)\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|self|static|callable|iterable|(?:null|false)(?=\s*\|))\b/i,alias:"return-type",greedy:!0,lookbehind:!0},{pattern:/(\)\s*:\s*(?:\?\s*)?[\w|]\|\s*)(?:null|false)\b/i,alias:"return-type",greedy:!0,lookbehind:!0},{pattern:/\b(?:bool|int|float|string|object|void|array(?!\s*\()|mixed|iterable|(?:null|false)(?=\s*\|))\b/i,alias:"type-declaration",greedy:!0},{pattern:/(\|\s*)(?:null|false)\b/i,alias:"type-declaration",greedy:!0,lookbehind:!0},{pattern:/\b(?:parent|self|static)(?=\s*::)/i,alias:"static-context",greedy:!0},{pattern:/(\byield\s+)from\b/i,lookbehind:!0},/\bclass\b/i,{pattern:/((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:__halt_compiler|abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|namespace|match|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield)\b/i,lookbehind:!0}],"argument-name":{pattern:/([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,lookbehind:!0},"class-name":[{pattern:/(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,greedy:!0,lookbehind:!0},{pattern:/(\|\s*)\b[a-z_]\w*(?!\\)\b/i,greedy:!0,lookbehind:!0},{pattern:/\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,greedy:!0},{pattern:/(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,alias:"class-name-fully-qualified",greedy:!0,lookbehind:!0,inside:{punctuation:/\\/}},{pattern:/(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,alias:"class-name-fully-qualified",greedy:!0,inside:{punctuation:/\\/}},{pattern:/(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,alias:"class-name-fully-qualified",greedy:!0,lookbehind:!0,inside:{punctuation:/\\/}},{pattern:/\b[a-z_]\w*(?=\s*\$)/i,alias:"type-declaration",greedy:!0},{pattern:/(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,alias:["class-name-fully-qualified","type-declaration"],greedy:!0,inside:{punctuation:/\\/}},{pattern:/\b[a-z_]\w*(?=\s*::)/i,alias:"static-context",greedy:!0},{pattern:/(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,alias:["class-name-fully-qualified","static-context"],greedy:!0,inside:{punctuation:/\\/}},{pattern:/([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,alias:"type-hint",greedy:!0,lookbehind:!0},{pattern:/([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,alias:["class-name-fully-qualified","type-hint"],greedy:!0,lookbehind:!0,inside:{punctuation:/\\/}},{pattern:/(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,alias:"return-type",greedy:!0,lookbehind:!0},{pattern:/(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,alias:["class-name-fully-qualified","return-type"],greedy:!0,lookbehind:!0,inside:{punctuation:/\\/}}],constant:n,function:{pattern:/(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,lookbehind:!0,inside:{punctuation:/\\/}},property:{pattern:/(->\s*)\w+/,lookbehind:!0},number:r,operator:o,punctuation:i};var a={pattern:/\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,lookbehind:!0,inside:e.languages.php},u=[{pattern:/<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,alias:"nowdoc-string",greedy:!0,inside:{delimiter:{pattern:/^<<<'[^']+'|[a-z_]\w*;$/i,alias:"symbol",inside:{punctuation:/^<<<'?|[';]$/}}}},{pattern:/<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,alias:"heredoc-string",greedy:!0,inside:{delimiter:{pattern:/^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,alias:"symbol",inside:{punctuation:/^<<<"?|[";]$/}},interpolation:a}},{pattern:/`(?:\\[\s\S]|[^\\`])*`/,alias:"backtick-quoted-string",greedy:!0},{pattern:/'(?:\\[\s\S]|[^\\'])*'/,alias:"single-quoted-string",greedy:!0},{pattern:/"(?:\\[\s\S]|[^\\"])*"/,alias:"double-quoted-string",greedy:!0,inside:{interpolation:a}}];e.languages.insertBefore("php","variable",{string:u,attribute:{pattern:/#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,greedy:!0,inside:{"attribute-content":{pattern:/^(#\[)[\s\S]+(?=\]$)/,lookbehind:!0,inside:{comment:t,string:u,"attribute-class-name":[{pattern:/([^:]|^)\b[a-z_]\w*(?!\\)\b/i,alias:"class-name",greedy:!0,lookbehind:!0},{pattern:/([^:]|^)(?:\\?\b[a-z_]\w*)+/i,alias:["class-name","class-name-fully-qualified"],greedy:!0,lookbehind:!0,inside:{punctuation:/\\/}}],constant:n,number:r,operator:o,punctuation:i}},delimiter:{pattern:/^#\[|\]$/,alias:"punctuation"}}}}),e.hooks.add("before-tokenize",(function(t){/<\?/.test(t.code)&&e.languages["markup-templating"].buildPlaceholders(t,"php",/<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/gi)})),e.hooks.add("after-tokenize",(function(t){e.languages["markup-templating"].tokenizePlaceholders(t,"php")}))}(Prism),Prism.languages.c=Prism.languages.extend("clike",{comment:{pattern:/\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:!0},"class-name":{pattern:/(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,lookbehind:!0},keyword:/\b(?:__attribute__|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,function:/\b[a-z_]\w*(?=\s*\()/i,number:/(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,lookbehind:!0,greedy:!0,alias:"property",inside:{string:[{pattern:/^(#\s*include\s*)<[^>]+>/,lookbehind:!0},Prism.languages.c.string],comment:Prism.languages.c.comment,"macro-name":[{pattern:/(^#\s*define\s+)\w+\b(?!\()/i,lookbehind:!0},{pattern:/(^#\s*define\s+)\w+\b(?=\()/i,lookbehind:!0,alias:"function"}],directive:{pattern:/^(#\s*)[a-z]+/,lookbehind:!0,alias:"keyword"},"directive-hash":/^#/,punctuation:/##|\\(?=[\r\n])/,expression:{pattern:/\S[\s\S]*/,inside:Prism.languages.c}}},constant:/\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/}),delete Prism.languages.c.boolean,Prism.languages.python={comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0},"string-interpolation":{pattern:/(?:f|rf|fr)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,greedy:!0,inside:{interpolation:{pattern:/((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,lookbehind:!0,inside:{"format-spec":{pattern:/(:)[^:(){}]+(?=\}$)/,lookbehind:!0},"conversion-option":{pattern:/![sra](?=[:}]$)/,alias:"punctuation"},rest:null}},string:/[\s\S]+/}},"triple-quoted-string":{pattern:/(?:[rub]|rb|br)?("""|''')[\s\S]*?\1/i,greedy:!0,alias:"string"},string:{pattern:/(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,greedy:!0},function:{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)\w+/i,lookbehind:!0},decorator:{pattern:/(^[\t ]*)@\w+(?:\.\w+)*/im,lookbehind:!0,alias:["annotation","punctuation"],inside:{punctuation:/\./}},keyword:/\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,builtin:/\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,boolean:/\b(?:True|False|None)\b/,number:/\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?\b/i,operator:/[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,punctuation:/[{}[\];(),.:]/},Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest=Prism.languages.python,Prism.languages.py=Prism.languages.python,function(e){var t=/\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,n=/(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source,r={pattern:RegExp(n+/[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),lookbehind:!0,inside:{namespace:{pattern:/^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,inside:{punctuation:/\./}},punctuation:/\./}};e.languages.java=e.languages.extend("clike",{"class-name":[r,{pattern:RegExp(n+/[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),lookbehind:!0,inside:r.inside}],keyword:t,function:[e.languages.clike.function,{pattern:/(::\s*)[a-z_]\w*/,lookbehind:!0}],number:/\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,operator:{pattern:/(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,lookbehind:!0}}),e.languages.insertBefore("java","string",{"triple-quoted-string":{pattern:/"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,greedy:!0,alias:"string"}}),e.languages.insertBefore("java","class-name",{annotation:{pattern:/(^|[^.])@\w+(?:\s*\.\s*\w+)*/,lookbehind:!0,alias:"punctuation"},generics:{pattern:/<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,inside:{"class-name":r,keyword:t,punctuation:/[<>(),.:]/,operator:/[?&|]/}},namespace:{pattern:RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g,(function(){return t.source}))),lookbehind:!0,inside:{punctuation:/\./}}})}(Prism),function(e){var t=/\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,n=/\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g,(function(){return t.source}));e.languages.cpp=e.languages.extend("c",{"class-name":[{pattern:RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g,(function(){return t.source}))),lookbehind:!0},/\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,/\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,/\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/],keyword:t,number:{pattern:/(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,greedy:!0},operator:/>>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,boolean:/\b(?:true|false)\b/}),e.languages.insertBefore("cpp","string",{module:{pattern:RegExp(/(\b(?:module|import)\s+)/.source+"(?:"+/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source+"|"+/<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g,(function(){return n}))+")"),lookbehind:!0,greedy:!0,inside:{string:/^[<"][\s\S]+/,operator:/:/,punctuation:/\./}},"raw-string":{pattern:/R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,alias:"string",greedy:!0}}),e.languages.insertBefore("cpp","keyword",{"generic-function":{pattern:/\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,inside:{function:/^\w+/,generic:{pattern:/<[\s\S]+/,alias:"class-name",inside:e.languages.cpp}}}}),e.languages.insertBefore("cpp","operator",{"double-colon":{pattern:/::/,alias:"punctuation"}}),e.languages.insertBefore("cpp","class-name",{"base-clause":{pattern:/(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,lookbehind:!0,greedy:!0,inside:e.languages.extend("cpp",{})}}),e.languages.insertBefore("inside","double-colon",{"class-name":/\b[a-z_]\w*\b(?!\s*::)/i},e.languages.cpp["base-clause"])}(Prism),function(e){function t(e,t){return e.replace(/<<(\d+)>>/g,(function(e,n){return"(?:"+t[+n]+")"}))}function n(e,n,r){return RegExp(t(e,n),r||"")}function r(e,t){for(var n=0;n<t;n++)e=e.replace(/<<self>>/g,(function(){return"(?:"+e+")"}));return e.replace(/<<self>>/g,"[^\\s\\S]")}var o="bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",i="class enum interface record struct",a="add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",u="abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield";function s(e){return"\\b(?:"+e.trim().replace(/ /g,"|")+")\\b"}var l=s(i),c=RegExp(s(o+" "+i+" "+a+" "+u)),f=s(i+" "+a+" "+u),d=s(o+" "+i+" "+u),p=r(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source,2),h=r(/\((?:[^()]|<<self>>)*\)/.source,2),g=/@?\b[A-Za-z_]\w*\b/.source,v=t(/<<0>>(?:\s*<<1>>)?/.source,[g,p]),y=t(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source,[f,v]),m=/\[\s*(?:,\s*)*\]/.source,b=t(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source,[y,m]),w=t(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,[p,h,m]),E=t(/\(<<0>>+(?:,<<0>>+)+\)/.source,[w]),D=t(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source,[E,y,m]),S={keyword:c,punctuation:/[<>()?,.:[\]]/},x=/'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source,C=/"(?:\\.|[^\\"\r\n])*"/.source,A=/@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;e.languages.csharp=e.languages.extend("clike",{string:[{pattern:n(/(^|[^$\\])<<0>>/.source,[A]),lookbehind:!0,greedy:!0},{pattern:n(/(^|[^@$\\])<<0>>/.source,[C]),lookbehind:!0,greedy:!0},{pattern:RegExp(x),greedy:!0,alias:"character"}],"class-name":[{pattern:n(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source,[y]),lookbehind:!0,inside:S},{pattern:n(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source,[g,D]),lookbehind:!0,inside:S},{pattern:n(/(\busing\s+)<<0>>(?=\s*=)/.source,[g]),lookbehind:!0},{pattern:n(/(\b<<0>>\s+)<<1>>/.source,[l,v]),lookbehind:!0,inside:S},{pattern:n(/(\bcatch\s*\(\s*)<<0>>/.source,[y]),lookbehind:!0,inside:S},{pattern:n(/(\bwhere\s+)<<0>>/.source,[g]),lookbehind:!0},{pattern:n(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source,[b]),lookbehind:!0,inside:S},{pattern:n(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,[D,d,g]),inside:S}],keyword:c,number:/(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:ul|lu|[dflmu])?\b/i,operator:/>>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,punctuation:/\?\.?|::|[{}[\];(),.:]/}),e.languages.insertBefore("csharp","number",{range:{pattern:/\.\./,alias:"operator"}}),e.languages.insertBefore("csharp","punctuation",{"named-parameter":{pattern:n(/([(,]\s*)<<0>>(?=\s*:)/.source,[g]),lookbehind:!0,alias:"punctuation"}}),e.languages.insertBefore("csharp","class-name",{namespace:{pattern:n(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,[g]),lookbehind:!0,inside:{punctuation:/\./}},"type-expression":{pattern:n(/(\b(?:default|typeof|sizeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source,[h]),lookbehind:!0,alias:"class-name",inside:S},"return-type":{pattern:n(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,[D,y]),inside:S,alias:"class-name"},"constructor-invocation":{pattern:n(/(\bnew\s+)<<0>>(?=\s*[[({])/.source,[D]),lookbehind:!0,inside:S,alias:"class-name"},"generic-method":{pattern:n(/<<0>>\s*<<1>>(?=\s*\()/.source,[g,p]),inside:{function:n(/^<<0>>/.source,[g]),generic:{pattern:RegExp(p),alias:"class-name",inside:S}}},"type-list":{pattern:n(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,[l,v,g,D,c.source,h,/\bnew\s*\(\s*\)/.source]),lookbehind:!0,inside:{"record-arguments":{pattern:n(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source,[v,h]),lookbehind:!0,greedy:!0,inside:e.languages.csharp},keyword:c,"class-name":{pattern:RegExp(D),greedy:!0,inside:S},punctuation:/[,()]/}},preprocessor:{pattern:/(^[\t ]*)#.*/m,lookbehind:!0,alias:"property",inside:{directive:{pattern:/(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,lookbehind:!0,alias:"keyword"}}}});var O=C+"|"+x,k=t(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,[O]),B=r(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source,[k]),2),F=/\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source,T=t(/<<0>>(?:\s*\(<<1>>*\))?/.source,[y,B]);e.languages.insertBefore("csharp","class-name",{attribute:{pattern:n(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,[F,T]),lookbehind:!0,greedy:!0,inside:{target:{pattern:n(/^<<0>>(?=\s*:)/.source,[F]),alias:"keyword"},"attribute-arguments":{pattern:n(/\(<<0>>*\)/.source,[B]),inside:e.languages.csharp},"class-name":{pattern:RegExp(y),inside:{punctuation:/\./}},punctuation:/[:,]/}}});var _=/:[^}\r\n]+/.source,P=r(t(/[^"'/()]|<<0>>|\(<<self>>*\)/.source,[k]),2),j=t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source,[P,_]),N=r(t(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source,[O]),2),I=t(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source,[N,_]);function L(t,r){return{interpolation:{pattern:n(/((?:^|[^{])(?:\{\{)*)<<0>>/.source,[t]),lookbehind:!0,inside:{"format-string":{pattern:n(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source,[r,_]),lookbehind:!0,inside:{punctuation:/^:/}},punctuation:/^\{|\}$/,expression:{pattern:/[\s\S]+/,alias:"language-csharp",inside:e.languages.csharp}}},string:/[\s\S]+/}}e.languages.insertBefore("csharp","string",{"interpolation-string":[{pattern:n(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,[j]),lookbehind:!0,greedy:!0,inside:L(j,P)},{pattern:n(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source,[I]),lookbehind:!0,greedy:!0,inside:L(I,N)}]})}(Prism),Prism.languages.dotnet=Prism.languages.cs=Prism.languages.csharp,Prism.languages["visual-basic"]={comment:{pattern:/(?:['ââ]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,inside:{keyword:/^REM/i}},directive:{pattern:/#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:[^\S\r\n]_[^\S\r\n]*(?:\r\n?|\n)|.)+/i,alias:"comment",greedy:!0},string:{pattern:/\$?["ââ](?:["ââ]{2}|[^"ââ])*["ââ]C?/i,greedy:!0},date:{pattern:/#[^\S\r\n]*(?:\d+([/-])\d+\1\d+(?:[^\S\r\n]+(?:\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?))?|\d+[^\S\r\n]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[^\S\r\n]*(?:AM|PM))?)[^\S\r\n]*#/i,alias:"builtin"},number:/(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:U?[ILS]|[FRD])?/i,boolean:/\b(?:True|False|Nothing)\b/i,keyword:/\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Until|Xor)\b/i,operator:[/[+\-*/\\^<=>&#@$%!]/,{pattern:/([^\S\r\n])_(?=[^\S\r\n]*[\r\n])/,lookbehind:!0}],punctuation:/[{}().,:?]/},Prism.languages.vb=Prism.languages["visual-basic"],Prism.languages.vba=Prism.languages["visual-basic"],Prism.languages.sql={comment:{pattern:/(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,lookbehind:!0},variable:[{pattern:/@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,greedy:!0},/@[\w.$]+/],string:{pattern:/(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,greedy:!0,lookbehind:!0},function:/\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,keyword:/\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:_INSERT|COL)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:S|ING)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,boolean:/\b(?:TRUE|FALSE|NULL)\b/i,number:/\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,operator:/[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|IN|ILIKE|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,punctuation:/[;[\]()`,.]/},function(e){e.languages.ruby=e.languages.extend("clike",{comment:[/#.*/,{pattern:/^=begin\s[\s\S]*?^=end/m,greedy:!0}],"class-name":{pattern:/(\b(?:class)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|protected|private|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/});var t={pattern:/#\{[^}]+\}/,inside:{delimiter:{pattern:/^#\{|\}$/,alias:"tag"},rest:e.languages.ruby}};delete e.languages.ruby.function,e.languages.insertBefore("ruby","keyword",{regex:[{pattern:RegExp(/%r/.source+"(?:"+[/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,/\((?:[^()\\]|\\[\s\S])*\)/.source,/\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source,/\[(?:[^\[\]\\]|\\[\s\S])*\]/.source,/<(?:[^<>\\]|\\[\s\S])*>/.source].join("|")+")"+/[egimnosux]{0,6}/.source),greedy:!0,inside:{interpolation:t}},{pattern:/(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,lookbehind:!0,greedy:!0,inside:{interpolation:t}}],variable:/[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,symbol:{pattern:/(^|[^:]):[a-zA-Z_]\w*(?:[?!]|\b)/,lookbehind:!0},"method-definition":{pattern:/(\bdef\s+)[\w.]+/,lookbehind:!0,inside:{function:/\w+$/,rest:e.languages.ruby}}}),e.languages.insertBefore("ruby","number",{builtin:/\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,constant:/\b[A-Z]\w*(?:[?!]|\b)/}),e.languages.ruby.string=[{pattern:RegExp(/%[qQiIwWxs]?/.source+"(?:"+[/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,/\((?:[^()\\]|\\[\s\S])*\)/.source,/\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/.source,/\[(?:[^\[\]\\]|\\[\s\S])*\]/.source,/<(?:[^<>\\]|\\[\s\S])*>/.source].join("|")+")"),greedy:!0,inside:{interpolation:t}},{pattern:/("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,greedy:!0,inside:{interpolation:t}},{pattern:/<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,alias:"heredoc-string",greedy:!0,inside:{delimiter:{pattern:/^<<[-~]?[a-z_]\w*|[a-z_]\w*$/i,alias:"symbol",inside:{punctuation:/^<<[-~]?/}},interpolation:t}},{pattern:/<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,alias:"heredoc-string",greedy:!0,inside:{delimiter:{pattern:/^<<[-~]?'[a-z_]\w*'|[a-z_]\w*$/i,alias:"symbol",inside:{punctuation:/^<<[-~]?'|'$/}}}}],e.languages.rb=e.languages.ruby}(Prism),Prism.languages.swift={comment:{pattern:/(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,lookbehind:!0,greedy:!0},"string-literal":[{pattern:RegExp(/(^|[^"#])/.source+"(?:"+/"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source+"|"+/"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source+")"+/(?!["#])/.source),lookbehind:!0,greedy:!0,inside:{interpolation:{pattern:/(\\\()(?:[^()]|\([^()]*\))*(?=\))/,lookbehind:!0,inside:null},"interpolation-punctuation":{pattern:/^\)|\\\($/,alias:"punctuation"},punctuation:/\\(?=[\r\n])/,string:/[\s\S]+/}},{pattern:RegExp(/(^|[^"#])(#+)/.source+"(?:"+/"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source+"|"+/"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source+")\\2"),lookbehind:!0,greedy:!0,inside:{interpolation:{pattern:/(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,lookbehind:!0,inside:null},"interpolation-punctuation":{pattern:/^\)|\\#+\($/,alias:"punctuation"},string:/[\s\S]+/}}],directive:{pattern:RegExp(/#/.source+"(?:"+/(?:elseif|if)\b/.source+"(?:[ \t]*"+/(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source+")+|"+/(?:else|endif)\b/.source+")"),alias:"property",inside:{"directive-name":/^#\w+/,boolean:/\b(?:true|false)\b/,number:/\b\d+(?:\.\d+)*\b/,operator:/!|&&|\|\||[<>]=?/,punctuation:/[(),]/}},literal:{pattern:/#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,alias:"constant"},"other-directive":{pattern:/#\w+\b/,alias:"property"},attribute:{pattern:/@\w+/,alias:"atrule"},"function-definition":{pattern:/(\bfunc\s+)\w+/,lookbehind:!0,alias:"function"},label:{pattern:/\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,lookbehind:!0,alias:"important"},keyword:/\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,boolean:/\b(?:true|false)\b/,nil:{pattern:/\bnil\b/,alias:"constant"},"short-argument":/\$\d+\b/,omit:{pattern:/\b_\b/,alias:"keyword"},number:/\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,"class-name":/\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,function:/\b[a-z_]\w*(?=\s*\()/i,constant:/\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,operator:/[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,punctuation:/[{}[\]();,.:\\]/},Prism.languages.swift["string-literal"].forEach((function(e){e.inside.interpolation.inside=Prism.languages.swift})),function(e){var t="\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b",n={pattern:/(^(["']?)\w+\2)[ \t]+\S.*/,lookbehind:!0,alias:"punctuation",inside:null},r={bash:n,environment:{pattern:RegExp("\\$"+t),alias:"constant"},variable:[{pattern:/\$?\(\([\s\S]+?\)\)/,greedy:!0,inside:{variable:[{pattern:/(^\$\(\([\s\S]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,operator:/--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,greedy:!0,inside:{variable:/^\$\(|^`|\)$|`$/}},{pattern:/\$\{[^}]+\}/,greedy:!0,inside:{operator:/:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,punctuation:/[\[\]]/,environment:{pattern:RegExp("(\\{)"+t),lookbehind:!0,alias:"constant"}}},/\$(?:\w+|[#?*!@$])/],entity:/\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|x[0-9a-fA-F]{1,2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})/};e.languages.bash={shebang:{pattern:/^#!\s*\/.*/,alias:"important"},comment:{pattern:/(^|[^"{\\$])#.*/,lookbehind:!0},"function-name":[{pattern:/(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,lookbehind:!0,alias:"function"},{pattern:/\b[\w-]+(?=\s*\(\s*\)\s*\{)/,alias:"function"}],"for-or-select":{pattern:/(\b(?:for|select)\s+)\w+(?=\s+in\s)/,alias:"variable",lookbehind:!0},"assign-left":{pattern:/(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,inside:{environment:{pattern:RegExp("(^|[\\s;|&]|[<>]\\()"+t),lookbehind:!0,alias:"constant"}},alias:"variable",lookbehind:!0},string:[{pattern:/((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,lookbehind:!0,greedy:!0,inside:r},{pattern:/((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,lookbehind:!0,greedy:!0,inside:{bash:n}},{pattern:/(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,lookbehind:!0,greedy:!0,inside:r},{pattern:/(^|[^$\\])'[^']*'/,lookbehind:!0,greedy:!0},{pattern:/\$'(?:[^'\\]|\\[\s\S])*'/,greedy:!0,inside:{entity:r.entity}}],environment:{pattern:RegExp("\\$?"+t),alias:"constant"},variable:r.variable,function:{pattern:/(^|[\s;|&]|[<>]\()(?:add|apropos|apt|aptitude|apt-cache|apt-get|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,lookbehind:!0},keyword:{pattern:/(^|[\s;|&]|[<>]\()(?:if|then|else|elif|fi|for|while|in|case|esac|function|select|do|done|until)(?=$|[)\s;|&])/,lookbehind:!0},builtin:{pattern:/(^|[\s;|&]|[<>]\()(?:\.|:|break|cd|continue|eval|exec|exit|export|getopts|hash|pwd|readonly|return|shift|test|times|trap|umask|unset|alias|bind|builtin|caller|command|declare|echo|enable|help|let|local|logout|mapfile|printf|read|readarray|source|type|typeset|ulimit|unalias|set|shopt)(?=$|[)\s;|&])/,lookbehind:!0,alias:"class-name"},boolean:{pattern:/(^|[\s;|&]|[<>]\()(?:true|false)(?=$|[)\s;|&])/,lookbehind:!0},"file-descriptor":{pattern:/\B&\d\b/,alias:"important"},operator:{pattern:/\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,inside:{"file-descriptor":{pattern:/^\d/,alias:"important"}}},punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,number:{pattern:/(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,lookbehind:!0}},n.inside=e.languages.bash;for(var o=["comment","function-name","for-or-select","assign-left","string","environment","function","keyword","builtin","boolean","file-descriptor","operator","punctuation","number"],i=r.variable[1].inside,a=0;a<o.length;a++)i[o[a]]=e.languages.bash[o[a]];e.languages.shell=e.languages.bash}(Prism),function(e){var t=/(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;function n(e){return e=e.replace(/<inner>/g,(function(){return t})),RegExp(/((?:^|[^\\])(?:\\{2})*)/.source+"(?:"+e+")")}var r=/(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source,o=/\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g,(function(){return r})),i=/\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;e.languages.markdown=e.languages.extend("markup",{}),e.languages.insertBefore("markdown","prolog",{"front-matter-block":{pattern:/(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,lookbehind:!0,greedy:!0,inside:{punctuation:/^---|---$/,"font-matter":{pattern:/\S+(?:\s+\S+)*/,alias:["yaml","language-yaml"],inside:e.languages.yaml}}},blockquote:{pattern:/^>(?:[\t ]*>)*/m,alias:"punctuation"},table:{pattern:RegExp("^"+o+i+"(?:"+o+")*","m"),inside:{"table-data-rows":{pattern:RegExp("^("+o+i+")(?:"+o+")*$"),lookbehind:!0,inside:{"table-data":{pattern:RegExp(r),inside:e.languages.markdown},punctuation:/\|/}},"table-line":{pattern:RegExp("^("+o+")"+i+"$"),lookbehind:!0,inside:{punctuation:/\||:?-{3,}:?/}},"table-header-row":{pattern:RegExp("^"+o+"$"),inside:{"table-header":{pattern:RegExp(r),alias:"important",inside:e.languages.markdown},punctuation:/\|/}}}},code:[{pattern:/((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,lookbehind:!0,alias:"keyword"},{pattern:/^```[\s\S]*?^```$/m,greedy:!0,inside:{"code-block":{pattern:/^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,lookbehind:!0},"code-language":{pattern:/^(```).+/,lookbehind:!0},punctuation:/```/}}],title:[{pattern:/\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,alias:"important",inside:{punctuation:/==+$|--+$/}},{pattern:/(^\s*)#.+/m,lookbehind:!0,alias:"important",inside:{punctuation:/^#+|#+$/}}],hr:{pattern:/(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,lookbehind:!0,alias:"punctuation"},list:{pattern:/(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,lookbehind:!0,alias:"punctuation"},"url-reference":{pattern:/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,inside:{variable:{pattern:/^(!?\[)[^\]]+/,lookbehind:!0},string:/(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,punctuation:/^[\[\]!:]|[<>]/},alias:"url"},bold:{pattern:n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^..)[\s\S]+(?=..$)/,lookbehind:!0,inside:{}},punctuation:/\*\*|__/}},italic:{pattern:n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^.)[\s\S]+(?=.$)/,lookbehind:!0,inside:{}},punctuation:/[*_]/}},strike:{pattern:n(/(~~?)(?:(?!~)<inner>)+\2/.source),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^~~?)[\s\S]+(?=\1$)/,lookbehind:!0,inside:{}},punctuation:/~~?/}},"code-snippet":{pattern:/(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,lookbehind:!0,greedy:!0,alias:["code","keyword"]},url:{pattern:n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),lookbehind:!0,greedy:!0,inside:{operator:/^!/,content:{pattern:/(^\[)[^\]]+(?=\])/,lookbehind:!0,inside:{}},variable:{pattern:/(^\][ \t]?\[)[^\]]+(?=\]$)/,lookbehind:!0},url:{pattern:/(^\]\()[^\s)]+/,lookbehind:!0},string:{pattern:/(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,lookbehind:!0}}}}),["url","bold","italic","strike"].forEach((function(t){["url","bold","italic","strike","code-snippet"].forEach((function(n){t!==n&&(e.languages.markdown[t].inside.content.inside[n]=e.languages.markdown[n])}))})),e.hooks.add("after-tokenize",(function(e){"markdown"!==e.language&&"md"!==e.language||function e(t){if(t&&"string"!=typeof t)for(var n=0,r=t.length;n<r;n++){var o=t[n];if("code"===o.type){var i=o.content[1],a=o.content[3];if(i&&a&&"code-language"===i.type&&"code-block"===a.type&&"string"==typeof i.content){var u=i.content.replace(/\b#/g,"sharp").replace(/\b\+\+/g,"pp"),s="language-"+(u=(/[a-z][\w-]*/i.exec(u)||[""])[0].toLowerCase());a.alias?"string"==typeof a.alias?a.alias=[a.alias,s]:a.alias.push(s):a.alias=[s]}}else e(o.content)}}(e.tokens)})),e.hooks.add("wrap",(function(t){if("code-block"===t.type){for(var n="",r=0,o=t.classes.length;r<o;r++){var i=t.classes[r],l=/language-(.+)/.exec(i);if(l){n=l[1];break}}var c=e.languages[n];if(c)t.content=e.highlight(function(e){var t=e.replace(a,"");return t.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi,(function(e,t){var n;return"#"===(t=t.toLowerCase())[0]?(n="x"===t[1]?parseInt(t.slice(2),16):Number(t.slice(1)),s(n)):u[t]||e}))}(t.content),c,n);else if(n&&"none"!==n&&e.plugins.autoloader){var f="md-"+(new Date).valueOf()+"-"+Math.floor(1e16*Math.random());t.attributes.id=f,e.plugins.autoloader.loadLanguages(n,(function(){var t=document.getElementById(f);t&&(t.innerHTML=e.highlight(t.textContent,e.languages[n],n))}))}}}));var a=RegExp(e.languages.markup.tag.pattern.source,"gi"),u={amp:"&",lt:"<",gt:">",quot:'"'},s=String.fromCodePoint||String.fromCharCode;e.languages.md=e.languages.markdown}(Prism),Prism.languages.lua={comment:/^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,string:{pattern:/(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,greedy:!0},number:/\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,keyword:/\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,function:/(?!\d)\w+(?=\s*(?:[({]))/,operator:[/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,{pattern:/(^|[^.])\.\.(?!\.)/,lookbehind:!0}],punctuation:/[\[\](){},;]|\.+|:+/},Prism.languages.groovy=Prism.languages.extend("clike",{string:[{pattern:/("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,greedy:!0},{pattern:/(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,greedy:!0}],keyword:/\b(?:as|def|in|abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,number:/\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,operator:{pattern:/(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,lookbehind:!0},punctuation:/\.+|[{}[\];(),:$]/}),Prism.languages.insertBefore("groovy","string",{shebang:{pattern:/#!.+/,alias:"comment"}}),Prism.languages.insertBefore("groovy","punctuation",{"spock-block":/\b(?:setup|given|when|then|and|cleanup|expect|where):/}),Prism.languages.insertBefore("groovy","function",{annotation:{pattern:/(^|[^.])@\w+/,lookbehind:!0,alias:"punctuation"}}),Prism.hooks.add("wrap",(function(e){if("groovy"===e.language&&"string"===e.type){var t=e.content[0];if("'"!=t){var n=/([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;"$"===t&&(n=/([^\$])(?:\$(?:\{.*?\}|[\w.]+))/),e.content=e.content.replace(/&lt;/g,"<").replace(/&amp;/g,"&"),e.content=Prism.highlight(e.content,{expression:{pattern:n,lookbehind:!0,inside:Prism.languages.groovy}}),e.classes.push("/"===t?"regex":"gstring")}}}));var Fge=["comment","prolog","doctype","cdata","punctuation","namespace","property","tag","boolean","number","constant","symbol","deleted","selector","attr-name","string","builtin","inserted","operator","entity","url","string","atrule","attr-value","keyword","function","class-name","regex","important","variable","bold","italic","entity","char"];function Tge(e){return"string"==typeof e?e.length:"string"==typeof e.content?e.content.length:e.content.reduce((function(e,t){return e+Tge(t)}),0)}var _ge,Pge=Ade.String,jge=function(e){if("Symbol"===hhe(e))throw TypeError("Cannot convert a Symbol value to a string");return Pge(e)},Nge=function(){var e=bpe(this),t="";return e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.sticky&&(t+="y"),t},Ige=Ade.RegExp,Lge=tpe((function(){var e=Ige("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),Rge=Lge||tpe((function(){return!Ige("a","y").sticky})),Mge={BROKEN_CARET:Lge||tpe((function(){var e=Ige("^r","gy");return e.lastIndex=2,null!=e.exec("str")})),MISSED_STICKY:Rge,UNSUPPORTED_Y:Lge},zge=fpe?Object.defineProperties:function(e,t){bpe(e);for(var n,r=Jhe(t),o=xge(t),i=o.length,a=0;i>a;)Ipe.f(e,n=o[a++],r[n]);return e},$ge=Kde("document","documentElement"),Hge=qpe("IE_PROTO"),Vge=function(){},Uge=function(e){return"<script>"+e+"<\/script>"},Wge=function(e){e.write(Uge("")),e.close();var t=e.parentWindow.Object;return e=null,t},Gge=function(){try{_ge=new ActiveXObject("htmlfile")}catch(e){}var e,t;Gge="undefined"!=typeof document?document.domain&&_ge?Wge(_ge):((t=gpe("iframe")).style.display="none",$ge.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(Uge("document.F=Object")),e.close(),e.F):Wge(_ge);for(var n=sge.length;n--;)delete Gge.prototype[sge[n]];return Gge()};Kpe[Hge]=!0;var qge,Kge,Yge=Object.create||function(e,t){var n;return null!==e?(Vge.prototype=bpe(e),n=new Vge,Vge.prototype=null,n[Hge]=e):n=Gge(),void 0===t?n:zge(n,t)},Xge=Ade.RegExp,Zge=tpe((function(){var e=Xge(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)})),Jge=Ade.RegExp,Qge=tpe((function(){var e=Jge("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")})),eve=nhe.get,tve=Fde("native-string-replace",String.prototype.replace),nve=RegExp.prototype.exec,rve=nve,ove=Nde("".charAt),ive=Nde("".indexOf),ave=Nde("".replace),uve=Nde("".slice),sve=(Kge=/b*/g,Epe(nve,qge=/a/,"a"),Epe(nve,Kge,"a"),0!==qge.lastIndex||0!==Kge.lastIndex),lve=Mge.BROKEN_CARET,cve=void 0!==/()??/.exec("")[1];(sve||cve||lve||Zge||Qge)&&(rve=function(e){var t,n,r,o,i,a,u,s=this,l=eve(s),c=jge(e),f=l.raw;if(f)return f.lastIndex=s.lastIndex,t=Epe(rve,f,c),s.lastIndex=f.lastIndex,t;var d=l.groups,p=lve&&s.sticky,h=Epe(Nge,s),g=s.source,v=0,y=c;if(p&&(h=ave(h,"y",""),-1===ive(h,"g")&&(h+="g"),y=uve(c,s.lastIndex),s.lastIndex>0&&(!s.multiline||s.multiline&&"\n"!==ove(c,s.lastIndex-1))&&(g="(?: "+g+")",y=" "+y,v++),n=new RegExp("^(?:"+g+")",h)),cve&&(n=new RegExp("^"+g+"$(?!\\s)",h)),sve&&(r=s.lastIndex),o=Epe(nve,p?n:s,y),p?o?(o.input=uve(o.input,v),o[0]=uve(o[0],v),o.index=s.lastIndex,s.lastIndex+=o[0].length):s.lastIndex=0:sve&&o&&(s.lastIndex=s.global?o.index+o[0].length:r),cve&&o&&o.length>1&&Epe(tve,o[0],n,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&d)for(o.groups=a=Yge(null),i=0;i<d.length;i++)a[(u=d[i])[0]]=o[u[1]];return o});var fve=rve;Sge({target:"RegExp",proto:!0,forced:/./.exec!==fve},{exec:fve});var dve=Function.prototype,pve=dve.apply,hve=dve.bind,gve=dve.call,vve="object"==typeof Reflect&&Reflect.apply||(hve?gve.bind(pve):function(){return gve.apply(pve,arguments)}),yve=spe("species"),mve=RegExp.prototype,bve=spe("match"),wve=Ade.TypeError,Eve=spe("species"),Dve=Nde("".charAt),Sve=Nde("".charCodeAt),xve=Nde("".slice),Cve=function(e){return function(t,n){var r,o,i=jge(Lde(t)),a=Ohe(n),u=i.length;return a<0||a>=u?e?"":void 0:(r=Sve(i,a))<55296||r>56319||a+1===u||(o=Sve(i,a+1))<56320||o>57343?e?Dve(i,a):r:e?xve(i,a,a+2):o-56320+(r-55296<<10)+65536}},Ave=(Cve(!1),Cve(!0)),Ove=function(e,t,n){return t+(n?Ave(e,t).length:1)},kve=Ade.Array,Bve=Math.max,Fve=function(e,t,n){for(var r,o,i,a,u=Fhe(e),s=rge(t,u),l=rge(void 0===n?u:n,u),c=kve(Bve(l-s,0)),f=0;s<l;s++,f++)r=c,o=f,i=e[s],void 0,(a=Ppe(o))in r?Ipe.f(r,a,Lpe(0,i)):r[a]=i;return c.length=f,c},Tve=Ade.TypeError,_ve=function(e,t){var n=e.exec;if(Gde(n)){var r=Epe(n,e,t);return null!==r&&bpe(r),r}if("RegExp"===che(e))return Epe(fve,e,t);throw Tve("RegExp#exec called on incompatible receiver")},Pve=Mge.UNSUPPORTED_Y,jve=Math.min,Nve=[].push,Ive=Nde(/./.exec),Lve=Nde(Nve),Rve=Nde("".slice);!function(e,t,n,r){var o=spe(e),i=!tpe((function(){var t={};return t[o]=function(){return 7},7!=""[e](t)})),a=i&&!tpe((function(){var e=!1,t=/a/;return(t={}).constructor={},t.constructor[yve]=function(){return t},t.flags="",t[o]=/./[o],t.exec=function(){return e=!0,null},t[o](""),!e}));if(!i||!a||n){var u=Nde(/./[o]),s=function(e,t,n){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(e,n){var r,o,i=jge(Lde(this)),a=void 0===n?4294967295:n>>>0;if(0===a)return[];if(void 0===e)return[i];if(!dpe(r=e)||!(void 0!==(o=r[bve])?o:"RegExp"==che(r)))return Epe(t,i,e,a);for(var u,s,l,c=[],f=(e.ignoreCase?"i":"")+(e.multiline?"m":"")+(e.unicode?"u":"")+(e.sticky?"y":""),d=0,p=new RegExp(e.source,f+"g");(u=Epe(fve,p,i))&&!((s=p.lastIndex)>d&&(Lve(c,Rve(i,d,u.index)),u.length>1&&u.index<i.length&&vve(Nve,c,Fve(u,1)),l=u[0].length,d=s,c.length>=a));)p.lastIndex===u.index&&p.lastIndex++;return d===i.length?!l&&Ive(p,"")||Lve(c,""):Lve(c,Rve(i,d)),c.length>a?Fve(c,0,a):c}:"0".split(void 0,0).length?function(e,n){return void 0===e&&0===n?[]:Epe(t,this,e,n)}:t,[function(t,n){var o=Lde(this),i=null==t?void 0:Bpe(t,e);return i?Epe(i,t,o,n):Epe(r,jge(o),t,n)},function(e,o){var i=bpe(this),a=jge(e),u=n(r,i,a,o,r!==t);if(u.done)return u.value;var s=function(e,t){var n,r=bpe(e).constructor;return void 0===r||null==(n=bpe(r)[Eve])?t:function(e){if(Mhe(e))return e;throw wve(Ape(e)+" is not a constructor")}(n)}(i,RegExp),l=i.unicode,c=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(Pve?"g":"y"),f=new s(Pve?"^(?:"+i.source+")":i,c),d=void 0===o?4294967295:o>>>0;if(0===d)return[];if(0===a.length)return null===_ve(f,a)?[a]:[];for(var p=0,h=0,g=[];h<a.length;){f.lastIndex=Pve?0:h;var v,y=_ve(f,Pve?Rve(a,h):a);if(null===y||(v=jve(Bhe(f.lastIndex+(Pve?h:0)),a.length))===p)h=Ove(a,h,l);else{if(Lve(g,Rve(a,p,h)),g.length===d)return g;for(var m=1;m<=y.length-1;m++)if(Lve(g,y[m]),g.length===d)return g;h=p=v}}return Lve(g,Rve(a,p)),g}]}(o,""[e],(function(e,t,n,r,o){var a=Nde(e),s=t.exec;return s===fve||s===mve.exec?i&&!o?{done:!0,value:u(t,n,r)}:{done:!0,value:a(n,t,r)}:{done:!1}}));uhe(String.prototype,e,s[0]),uhe(mve,o,s[1])}r&&Rpe(mve[o],"sham",!0)}("split",0,!!tpe((function(){var e=/(?:)/,t=e.exec;e.exec=function(){return t.apply(this,arguments)};var n="ab".split(e);return 2!==n.length||"a"!==n[0]||"b"!==n[1]})),Pve),Sge({global:!0},{globalThis:Ade}),Vp&&(Mp.fn.attr=Vp);var Mve=ahe.PROPER,zve=RegExp.prototype,$ve=zve.toString,Hve=Nde(Nge),Vve=tpe((function(){return"/a/b"!=$ve.call({source:"a",flags:"b"})})),Uve=Mve&&"toString"!=$ve.name;(Vve||Uve)&&uhe(RegExp.prototype,"toString",(function(){var e=bpe(this),t=jge(e.source),n=e.flags;return"/"+t+"/"+jge(void 0===n&&Dpe(zve,e)&&!("flags"in zve)?Hve(e):n)}),{unsafe:!0});var Wve=function(){function e(){this.title=HP("highLightModule.selectLang"),this.iconSvg='<svg viewBox="0 0 1024 1024"><path d="M64 64v896h896V64H64z m487.6 698.8c0 87.2-51.2 127-125.8 127-67.4 0-106.4-34.8-126.4-77l68.6-41.4c13.2 23.4 25.2 43.2 54.2 43.2 27.6 0 45.2-10.8 45.2-53V475.4h84.2v287.4z m199.2 127c-78.2 0-128.8-37.2-153.4-86l68.6-39.6c18 29.4 41.6 51.2 83 51.2 34.8 0 57.2-17.4 57.2-41.6 0-28.8-22.8-39-61.4-56l-21-9c-60.8-25.8-101-58.4-101-127 0-63.2 48.2-111.2 123.2-111.2 53.6 0 92 18.6 119.6 67.4L800 580c-14.4-25.8-30-36-54.2-36-24.6 0-40.2 15.6-40.2 36 0 25.2 15.6 35.4 51.8 51.2l21 9c71.6 30.6 111.8 62 111.8 132.4 0 75.6-59.6 117.2-139.4 117.2z"></path></svg>',this.tag="select",this.width=95,this.selectPanelWidth=115}return e.prototype.getOptions=function(e){var t=[],n=e.getMenuConfig("codeSelectLang").codeLangs,r=void 0===n?[]:n;t.push({text:"plain text",value:""}),r.forEach((function(e){var n=e.text,r=e.value;t.push({text:n,value:r})}));var o=this.getValue(e);return t.forEach((function(e){e.value===o?e.selected=!0:delete e.selected})),t},e.prototype.isActive=function(e){return!1},e.prototype.getValue=function(e){var t=this.getSelectCodeElem(e);if(null==t)return"";if(!Sf.isElement(t))return"";var n=t.language.toString(),r=e.getMenuConfig("codeSelectLang").codeLangs;return(void 0===r?[]:r).some((function(e){return e.value===n}))?n:""},e.prototype.isDisabled=function(e){return null==e.selection||!this.getSelectCodeElem(e)},e.prototype.exec=function(e,t){if(null!=this.getSelectCodeElem(e)){var n={language:t.toString()};md.setNodes(e,n,{match:function(e){return QO.checkNodeType(e,"code")}})}},e.prototype.getSelectCodeElem=function(e){var t=QO.getSelectedNodeByType(e,"code");if(null==t)return null;var n=QO.getParentNode(e,t);return Sf.isElement(n)?"pre"!==n.type?null:t:null},e}(),Gve={renderStyle:function(e,t){var n=e,r=t,o="";return Fge.forEach((function(e){n[e]&&(o=e)})),o&&function(e,t){null==e.data&&(e.data={});var n=e.data;null==n.props&&(n.props={}),Object.assign(n.props,{className:t})}(r,o="token "+o),r},parseStyleHtml:function(e,t,n){var r=Mp(e);if(!Sf.isElement(t))return t;if("code"!==QO.getNodeType(t))return t;var o=t,i=r.attr("class")||"";return 0===i.indexOf("language-")?o.language=i.split("-")[1]||"":o.language=i.toLowerCase(),o},menus:[{key:"codeSelectLang",factory:function(){return new Wve},config:{codeLangs:[{text:"CSS",value:"css"},{text:"HTML",value:"html"},{text:"XML",value:"xml"},{text:"Javascript",value:"javascript"},{text:"Typescript",value:"typescript"},{text:"JSX",value:"jsx"},{text:"Go",value:"go"},{text:"PHP",value:"php"},{text:"C",value:"c"},{text:"Python",value:"python"},{text:"Java",value:"java"},{text:"C++",value:"cpp"},{text:"C#",value:"csharp"},{text:"Visual Basic",value:"visual-basic"},{text:"SQL",value:"sql"},{text:"Ruby",value:"ruby"},{text:"Swift",value:"swift"},{text:"Bash",value:"bash"},{text:"Lua",value:"lua"},{text:"Groovy",value:"groovy"},{text:"Markdown",value:"markdown"}]}}],elemsToHtml:[{type:"code",elemToHtml:function(e,t){var n=e.language,r=void 0===n?"":n;return"<code "+(r?'class="language-'+r+'"':"")+">"+t+"</code>"}}]},qve=/"/g,Kve=Nde("".replace);Sge({target:"String",proto:!0,forced:tpe((function(){var e="".anchor('"');return e!==e.toLowerCase()||e.split('"').length>3}))},{anchor:function(e){return"a","name",t=e,n=jge(Lde(this)),r="<a",(r+=' name="'+Kve(jge(t),qve,"&quot;")+'"')+">"+n+"</a>";// removed by dead control flow
{ var t, n, r; }}});var Yve=function(e){var t,n,r,o=function(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,o,i=n.call(e),a=[];try{for(;(void 0===t||t-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(e){o={error:e}}finally{try{r&&!r.done&&(n=i.return)&&n.call(i)}finally{if(o)throw o.error}}return a}(e,2),i=o[0],a=o[1],u=[],s=function(e){if(!ed.isText(e))return null;var t=QO.getParentNode(null,e);if(t&&"code"===QO.getNodeType(t)){var n=QO.getParentNode(null,t);if(n&&"pre"===QO.getNodeType(n))return t}return null}(i);if(null==s)return u;var l=s.language,c=void 0===l?"":l;if(!c)return u;var f=function(e,t){if(!t)return[];var n=Bge.languages[t];return n?Bge.tokenize(e.text,n):[]}(i,c),d=0;try{for(var p=
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function(e){var t="function"==typeof Symbol&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(f),h=p.next();!h.done;h=p.next()){var g=h.value,v=d+Tge(g);"string"!=typeof g&&u.push(((r={})[g.type]=!0,r.anchor={path:a,offset:d},r.focus={path:a,offset:v},r)),d=v}}catch(e){t={error:e}}finally{try{h&&!h.done&&(n=p.return)&&n.call(p)}finally{if(t)throw t.error}}return u},Xve=function(){return Xve=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var o in t=arguments[n])Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o]);return e},Xve.apply(this,arguments)},Zve=function(){function e(){throw new Error("ä¸è½å®ä¾å\nCan not construct a instance")}return e.setEditorConfig=function(e){void 0===e&&(e={}),this.editorConfig=Xve(Xve({},this.editorConfig),e)},e.setSimpleEditorConfig=function(e){void 0===e&&(e={}),this.simpleEditorConfig=Xve(Xve({},this.simpleEditorConfig),e)},e.setToolbarConfig=function(e){void 0===e&&(e={}),this.toolbarConfig=Xve(Xve({},this.toolbarConfig),e)},e.setSimpleToolbarConfig=function(e){void 0===e&&(e={}),this.simpleToolbarConfig=Xve(Xve({},this.simpleToolbarConfig),e)},e.registerPlugin=function(e){this.plugins.push(e)},e.registerMenu=function(e,t){!function(e,t){var n=e.key,r=e.factory,o=e.config,i=oA(oA({},o),t||{});if(null!=nk[n])throw new Error("Duplicated key '"+n+"' in menu items");nk[n]=r,function(e,t){null!=t&&(tk[e]=t)}(n,i)}(e,t)},e.registerRenderElem=function(e){!function(e){var t=e.type,n=e.renderElem;zT[t||""]=n}(e)},e.registerRenderStyle=function(e){!function(e){MT.push(e)}(e)},e.registerElemToHtml=function(e){!function(e){var t=e.type,n=e.elemToHtml;gk[t||""]=n}(e)},e.registerStyleToHtml=function(e){!function(e){hk.push(e)}(e)},e.registerPreParseHtml=function(e){!function(e){rF.push(e)}(e)},e.registerParseElemHtml=function(e){!function(e){var t=e.selector,n=e.parseElemHtml;iF[t]=n}(e)},e.registerParseStyleHtml=function(e){!function(e){oF.push(e)}(e)},e.registerModule=function(e){Jve(e)},e.editorConfig={},e.simpleEditorConfig={},e.toolbarConfig={},e.simpleToolbarConfig={},e.plugins=[],e}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function Jve(e){var t=e.menus,n=e.renderElems,r=e.renderStyle,o=e.elemsToHtml,i=e.styleToHtml,a=e.preParseHtml,u=e.parseElemsHtml,s=e.parseStyleHtml,l=e.editorPlugin;t&&t.forEach((function(e){return Zve.registerMenu(e)})),n&&n.forEach((function(e){return Zve.registerRenderElem(e)})),r&&Zve.registerRenderStyle(r),o&&o.forEach((function(e){return Zve.registerElemToHtml(e)})),i&&Zve.registerStyleToHtml(i),a&&a.forEach((function(e){return Zve.registerPreParseHtml(e)})),u&&u.forEach((function(e){return Zve.registerParseElemHtml(e)})),s&&Zve.registerParseStyleHtml(s),l&&Zve.registerPlugin(l)}Yq.forEach((function(e){return Jve(e)})),Jve(g0),Jve(J3),Jve(Doe),Jve(wde),Jve(Gve);var Qve='<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>';var eye={link:{menuKeys:["editLink","unLink","viewLink"]},image:{menuKeys:["imageWidth30","imageWidth50","imageWidth100","editImage","viewImageLink","deleteImage"]},pre:{menuKeys:["enter","codeBlock","codeSelectLang"]},table:{menuKeys:["enter","tableHeader","tableFullWidth","insertTableRow","deleteTableRow","insertTableCol","deleteTableCol","deleteTable"]},divider:{menuKeys:["enter"]},video:{menuKeys:["enter","editVideoSize"]}};var tye={hoverbarKeys:Xve(Xve({},eye),{text:{menuKeys:["headerSelect","insertLink","bulletedList","|","bold","through","color","bgColor","clearStyle"]}})};Zve.setEditorConfig(Xve(Xve({},tye),{decorate:Yve}));var nye={hoverbarKeys:eye};Zve.setSimpleEditorConfig(Xve(Xve({},nye),{decorate:Yve}));var rye={toolbarKeys:["headerSelect","blockquote","|","bold","underline","italic",{key:"group-more-style",title:HP("editor.more"),iconSvg:'<svg viewBox="0 0 1024 1024"><path d="M204.8 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M505.6 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M806.4 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path></svg>',menuKeys:["through","code","sup","sub","clearStyle"]},"color","bgColor","|","fontSize","fontFamily","lineHeight","|","bulletedList","numberedList","todo",{key:"group-justify",title:HP("editor.justify"),iconSvg:'<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',menuKeys:["justifyLeft","justifyRight","justifyCenter","justifyJustify"]},{key:"group-indent",title:HP("editor.indent"),iconSvg:'<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>',menuKeys:["indent","delIndent"]},"|","emotion","insertLink",{key:"group-image",title:HP("editor.image"),iconSvg:Qve,menuKeys:["insertImage","uploadImage"]},{key:"group-video",title:HP("editor.video"),iconSvg:'<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>',menuKeys:["insertVideo","uploadVideo"]},"insertTable","codeBlock","divider","|","undo","redo","|","fullScreen"]};Zve.setToolbarConfig(rye);var oye={toolbarKeys:["blockquote","header1","header2","header3","|","bold","underline","italic","through","color","bgColor","clearStyle","|","bulletedList","numberedList","todo","justifyLeft","justifyRight","justifyCenter","|","insertLink",{key:"group-image",title:HP("editor.image"),iconSvg:Qve,menuKeys:["insertImage","uploadImage"]},"insertVideo","insertTable","codeBlock","|","undo","redo","|","fullScreen"]};function iye(e){void 0===e&&(e={});var t=e.selector,n=void 0===t?"":t,r=e.content,o=void 0===r?[]:r,i=e.html,a=e.config,u=void 0===a?{}:a,s=e.mode,l="simple"===(void 0===s?"default":s)?Zve.simpleEditorConfig:Zve.editorConfig,c=Xve(Xve({},l.hoverbarKeys||{}),u.hoverbarKeys||{});return I_({selector:n,config:Xve(Xve(Xve({},l),u),{hoverbarKeys:c}),content:o,html:i,plugins:Zve.plugins})}function aye(e){var t=e.selector,n=e.editor,r=e.config,o=void 0===r?{}:r,i=e.mode,a=void 0===i?"default":i;if(!t)throw new Error("Cannot find 'selector' when create toolbar");var u="simple"===a?Zve.simpleToolbarConfig:Zve.toolbarConfig,s=function(e,t){if(null==e)throw new Error("Cannot create toolbar, because editor is null");var n=t.selector,r=t.config,o=void 0===r?{}:r;if(function(e,t){return LF(e,"data-w-e-toolbar",t)}(e,n))throw new Error("Repeated create toolbar by selector '"+n+"'");var i=oA({toolbarKeys:[],excludeKeys:[],insertKeys:{index:0,keys:[]},modalAppendToBody:!1},o||{}),a=new $_(n,i);return uO.set(a,e),sO.set(e,a),a}(n,{selector:t,config:Xve(Xve({},u),o)});return s}Zve.setSimpleToolbarConfig(oye);var uye={};
//# sourceMappingURL=index.esm.js.map

;// ./node_modules/@wangeditor/editor-for-vue/dist/index.esm.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));


function genErrorInfo(fnName) {
  let info = `\u8BF7\u4F7F\u7528 '@${fnName}' \u4E8B\u4EF6\uFF0C\u4E0D\u8981\u653E\u5728 props \u4E2D`;
  info += `
Please use '@${fnName}' event instead of props`;
  return info;
}
var _export_sfc = (sfc, props) => {
  for (const [key, val] of props) {
    sfc[key] = val;
  }
  return sfc;
};
const _sfc_main$1 = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  props: {
    mode: {
      type: String,
      default: "default"
    },
    defaultContent: {
      type: Array,
      default: []
    },
    defaultHtml: {
      type: String,
      default: ""
    },
    defaultConfig: {
      type: Object,
      default: {}
    },
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(props, context) {
    const box = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const editorRef = (0,reactivity_esm_bundler/* shallowRef */.IJ)(null);
    const curValue = (0,reactivity_esm_bundler/* ref */.KR)("");
    const initEditor = () => {
      if (!box.value)
        return;
      const defaultContent = (0,reactivity_esm_bundler/* toRaw */.ux)(props.defaultContent);
      iye({
        selector: box.value,
        mode: props.mode,
        content: defaultContent || [],
        html: props.defaultHtml || props.modelValue || "",
        config: __spreadProps(__spreadValues({}, props.defaultConfig), {
          onCreated(editor) {
            editorRef.value = editor;
            context.emit("onCreated", editor);
            if (props.defaultConfig.onCreated) {
              const info = genErrorInfo("onCreated");
              throw new Error(info);
            }
          },
          onChange(editor) {
            const editorHtml = editor.getHtml();
            curValue.value = editorHtml;
            context.emit("update:modelValue", editorHtml);
            context.emit("onChange", editor);
            if (props.defaultConfig.onChange) {
              const info = genErrorInfo("onChange");
              throw new Error(info);
            }
          },
          onDestroyed(editor) {
            context.emit("onDestroyed", editor);
            if (props.defaultConfig.onDestroyed) {
              const info = genErrorInfo("onDestroyed");
              throw new Error(info);
            }
          },
          onMaxLength(editor) {
            context.emit("onMaxLength", editor);
            if (props.defaultConfig.onMaxLength) {
              const info = genErrorInfo("onMaxLength");
              throw new Error(info);
            }
          },
          onFocus(editor) {
            context.emit("onFocus", editor);
            if (props.defaultConfig.onFocus) {
              const info = genErrorInfo("onFocus");
              throw new Error(info);
            }
          },
          onBlur(editor) {
            context.emit("onBlur", editor);
            if (props.defaultConfig.onBlur) {
              const info = genErrorInfo("onBlur");
              throw new Error(info);
            }
          },
          customAlert(info, type) {
            context.emit("customAlert", info, type);
            if (props.defaultConfig.customAlert) {
              const info2 = genErrorInfo("customAlert");
              throw new Error(info2);
            }
          },
          customPaste: (editor, event) => {
            if (props.defaultConfig.customPaste) {
              const info = genErrorInfo("customPaste");
              throw new Error(info);
            }
            let res;
            context.emit("customPaste", editor, event, (val) => {
              res = val;
            });
            return res;
          }
        })
      });
    };
    function setHtml(newHtml) {
      const editor = editorRef.value;
      if (editor == null)
        return;
      editor.setHtml(newHtml);
    }
    (0,runtime_core_esm_bundler/* onMounted */.sV)(() => {
      initEditor();
    });
    (0,runtime_core_esm_bundler/* watch */.wB)(() => props.modelValue, (newVal) => {
      if (newVal === curValue.value)
        return;
      setHtml(newVal);
    });
    return {
      box
    };
  }
});
const _hoisted_1$1 = {
  ref: "box",
  style: { "height": "100%" }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", _hoisted_1$1, null, 512);
}
var Editor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const _sfc_main = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  props: {
    editor: {
      type: Object
    },
    mode: {
      type: String,
      default: "default"
    },
    defaultConfig: {
      type: Object,
      default: {}
    }
  },
  setup(props) {
    const selector = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const create = (editor) => {
      if (!selector.value)
        return;
      if (editor == null) {
        throw new Error("Not found instance of Editor when create <Toolbar/> component");
      }
      if (QO.getToolbar(editor))
        return;
      aye({
        editor,
        selector: selector.value || "<div></div>",
        mode: props.mode,
        config: props.defaultConfig
      });
    };
    (0,runtime_core_esm_bundler/* watchEffect */.nT)(() => {
      const { editor } = props;
      if (editor == null)
        return;
      create(editor);
    });
    return {
      selector
    };
  }
});
const _hoisted_1 = { ref: "selector" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", _hoisted_1, null, 512);
}
var Toolbar = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);

//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ 1849:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(2074);

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ 1883:
/***/ (function(module) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ 1898:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var classof = __webpack_require__(3062);
var Iterators = __webpack_require__(2228);
var wellKnownSymbol = __webpack_require__(1602);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ 2074:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 2228:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 2586:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ lib_axios; }
});

;// ./node_modules/axios/lib/helpers/bind.js


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

;// ./node_modules/axios/lib/utils.js




// utils is a library of generic helper functions non-specific to axios

const {toString: utils_toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = utils_toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
}

const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length|0]
  }

  return str;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

/* harmony default export */ var utils = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: utils_hasOwnProperty,
  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
});

;// ./node_modules/axios/lib/core/AxiosError.js




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const AxiosError_prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(AxiosError_prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ var core_AxiosError = (AxiosError);

;// ./node_modules/axios/lib/helpers/null.js
// eslint-disable-next-line strict
/* harmony default export */ var helpers_null = (null);

;// ./node_modules/axios/lib/helpers/toFormData.js




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (helpers_null || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ var helpers_toFormData = (toFormData);

;// ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && helpers_toFormData(params, this, options);
}

const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

AxiosURLSearchParams_prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

AxiosURLSearchParams_prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ var helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

;// ./node_modules/axios/lib/helpers/buildURL.js





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function buildURL_encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || buildURL_encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new helpers_AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

;// ./node_modules/axios/lib/core/InterceptorManager.js




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ var core_InterceptorManager = (InterceptorManager);

;// ./node_modules/axios/lib/defaults/transitional.js


/* harmony default export */ var defaults_transitional = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});

;// ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js



/* harmony default export */ var classes_URLSearchParams = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : helpers_AxiosURLSearchParams);

;// ./node_modules/axios/lib/platform/browser/classes/FormData.js


/* harmony default export */ var classes_FormData = (typeof FormData !== 'undefined' ? FormData : null);

;// ./node_modules/axios/lib/platform/browser/classes/Blob.js


/* harmony default export */ var classes_Blob = (typeof Blob !== 'undefined' ? Blob : null);

;// ./node_modules/axios/lib/platform/browser/index.js




/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
 const isStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();


/* harmony default export */ var browser = ({
  isBrowser: true,
  classes: {
    URLSearchParams: classes_URLSearchParams,
    FormData: classes_FormData,
    Blob: classes_Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});

;// ./node_modules/axios/lib/helpers/toURLEncodedForm.js






function toURLEncodedForm(data, options) {
  return helpers_toFormData(data, new browser.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (browser.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

;// ./node_modules/axios/lib/helpers/formDataToJSON.js




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ var helpers_formDataToJSON = (formDataToJSON);

;// ./node_modules/axios/lib/defaults/index.js










const DEFAULT_CONTENT_TYPE = {
  'Content-Type': undefined
};

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: defaults_transitional,

  adapter: ['xhr', 'http'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return helpers_toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: browser.classes.FormData,
    Blob: browser.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

/* harmony default export */ var lib_defaults = (defaults);

;// ./node_modules/axios/lib/helpers/parseHeaders.js




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ var parseHeaders = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});

;// ./node_modules/axios/lib/core/AxiosHeaders.js





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);

/* harmony default export */ var core_AxiosHeaders = (AxiosHeaders);

;// ./node_modules/axios/lib/core/transformData.js






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || lib_defaults;
  const context = response || config;
  const headers = core_AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

;// ./node_modules/axios/lib/cancel/isCancel.js


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

;// ./node_modules/axios/lib/cancel/CanceledError.js





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, core_AxiosError, {
  __CANCEL__: true
});

/* harmony default export */ var cancel_CanceledError = (CanceledError);

;// ./node_modules/axios/lib/core/settle.js




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new core_AxiosError(
      'Request failed with status code ' + response.status,
      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

;// ./node_modules/axios/lib/helpers/cookies.js





/* harmony default export */ var cookies = (browser.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

// Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })());

;// ./node_modules/axios/lib/helpers/isAbsoluteURL.js


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

;// ./node_modules/axios/lib/helpers/combineURLs.js


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

;// ./node_modules/axios/lib/core/buildFullPath.js





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

;// ./node_modules/axios/lib/helpers/isURLSameOrigin.js





/* harmony default export */ var isURLSameOrigin = (browser.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })());

;// ./node_modules/axios/lib/helpers/parseProtocol.js


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

;// ./node_modules/axios/lib/helpers/speedometer.js


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ var helpers_speedometer = (speedometer);

;// ./node_modules/axios/lib/adapters/xhr.js
















function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = helpers_speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ var xhr = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = core_AxiosHeaders.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && (browser.isStandardBrowserEnv || browser.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false); // Let the browser set it
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = core_AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || defaults_transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new core_AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (browser.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && browser.protocols.indexOf(protocol) === -1) {
      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});

;// ./node_modules/axios/lib/adapters/adapters.js





const knownAdapters = {
  http: helpers_null,
  xhr: xhr
}

utils.forEach(knownAdapters, (fn, value) => {
  if(fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

/* harmony default export */ var adapters = ({
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      if((adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter)) {
        break;
      }
    }

    if (!adapter) {
      if (adapter === false) {
        throw new core_AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          'ERR_NOT_SUPPORT'
        );
      }

      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ?
          `Adapter '${nameOrAdapter}' is not available in the build` :
          `Unknown adapter '${nameOrAdapter}'`
      );
    }

    if (!utils.isFunction(adapter)) {
      throw new TypeError('adapter is not a function');
    }

    return adapter;
  },
  adapters: knownAdapters
});

;// ./node_modules/axios/lib/core/dispatchRequest.js









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new cancel_CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = core_AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = core_AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

;// ./node_modules/axios/lib/core/mergeConfig.js





const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? thing.toJSON() : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

;// ./node_modules/axios/lib/env/data.js
const VERSION = "1.3.6";
;// ./node_modules/axios/lib/helpers/validator.js





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new core_AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        core_AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ var validator = ({
  assertOptions,
  validators
});

;// ./node_modules/axios/lib/core/Axios.js











const Axios_validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new core_InterceptorManager(),
      response: new core_InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: Axios_validators.function,
          serialize: Axios_validators.function
        }, true);
      }
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    let contextHeaders;

    // Flatten headers
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    contextHeaders && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ var core_Axios = (Axios);

;// ./node_modules/axios/lib/cancel/CancelToken.js




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new cancel_CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ var cancel_CancelToken = (CancelToken);

;// ./node_modules/axios/lib/helpers/spread.js


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

;// ./node_modules/axios/lib/helpers/isAxiosError.js




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

;// ./node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ var helpers_HttpStatusCode = (HttpStatusCode);

;// ./node_modules/axios/lib/axios.js



















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new core_Axios(defaultConfig);
  const instance = bind(core_Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(lib_defaults);

// Expose Axios class to allow class inheritance
axios.Axios = core_Axios;

// Expose Cancel & CancelToken
axios.CanceledError = cancel_CanceledError;
axios.CancelToken = cancel_CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = helpers_toFormData;

// Expose AxiosError class
axios.AxiosError = core_AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = core_AxiosHeaders;

axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.HttpStatusCode = helpers_HttpStatusCode;

axios.default = axios;

// this module should only have a default export
/* harmony default export */ var lib_axios = (axios);


/***/ }),

/***/ 2612:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(1229);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2847:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ lodash_es_merge; }
});

;// ./node_modules/lodash-es/_listCacheClear.js
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ var _listCacheClear = (listCacheClear);

;// ./node_modules/lodash-es/eq.js
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* harmony default export */ var lodash_es_eq = (eq);

;// ./node_modules/lodash-es/_assocIndexOf.js


/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (lodash_es_eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/* harmony default export */ var _assocIndexOf = (assocIndexOf);

;// ./node_modules/lodash-es/_listCacheDelete.js


/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/* harmony default export */ var _listCacheDelete = (listCacheDelete);

;// ./node_modules/lodash-es/_listCacheGet.js


/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ var _listCacheGet = (listCacheGet);

;// ./node_modules/lodash-es/_listCacheHas.js


/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

/* harmony default export */ var _listCacheHas = (listCacheHas);

;// ./node_modules/lodash-es/_listCacheSet.js


/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/* harmony default export */ var _listCacheSet = (listCacheSet);

;// ./node_modules/lodash-es/_ListCache.js






/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

/* harmony default export */ var _ListCache = (ListCache);

;// ./node_modules/lodash-es/_stackClear.js


/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

/* harmony default export */ var _stackClear = (stackClear);

;// ./node_modules/lodash-es/_stackDelete.js
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/* harmony default export */ var _stackDelete = (stackDelete);

;// ./node_modules/lodash-es/_stackGet.js
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ var _stackGet = (stackGet);

;// ./node_modules/lodash-es/_stackHas.js
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ var _stackHas = (stackHas);

;// ./node_modules/lodash-es/_freeGlobal.js
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ var _freeGlobal = (freeGlobal);

;// ./node_modules/lodash-es/_root.js


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

/* harmony default export */ var _root = (root);

;// ./node_modules/lodash-es/_Symbol.js


/** Built-in value references. */
var _Symbol_Symbol = _root.Symbol;

/* harmony default export */ var _Symbol = (_Symbol_Symbol);

;// ./node_modules/lodash-es/_getRawTag.js


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ var _getRawTag = (getRawTag);

;// ./node_modules/lodash-es/_objectToString.js
/** Used for built-in method references. */
var _objectToString_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return _objectToString_nativeObjectToString.call(value);
}

/* harmony default export */ var _objectToString = (objectToString);

;// ./node_modules/lodash-es/_baseGetTag.js




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

/* harmony default export */ var _baseGetTag = (baseGetTag);

;// ./node_modules/lodash-es/isObject.js
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ var lodash_es_isObject = (isObject);

;// ./node_modules/lodash-es/isFunction.js



/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!lodash_es_isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ var lodash_es_isFunction = (isFunction);

;// ./node_modules/lodash-es/_coreJsData.js


/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

/* harmony default export */ var _coreJsData = (coreJsData);

;// ./node_modules/lodash-es/_isMasked.js


/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/* harmony default export */ var _isMasked = (isMasked);

;// ./node_modules/lodash-es/_toSource.js
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ var _toSource = (toSource);

;// ./node_modules/lodash-es/_baseIsNative.js





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var _baseIsNative_funcProto = Function.prototype,
    _baseIsNative_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _baseIsNative_funcToString = _baseIsNative_funcProto.toString;

/** Used to check objects for own properties. */
var _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!lodash_es_isObject(value) || _isMasked(value)) {
    return false;
  }
  var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

/* harmony default export */ var _baseIsNative = (baseIsNative);

;// ./node_modules/lodash-es/_getValue.js
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ var _getValue = (getValue);

;// ./node_modules/lodash-es/_getNative.js



/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

/* harmony default export */ var _getNative = (getNative);

;// ./node_modules/lodash-es/_Map.js



/* Built-in method references that are verified to be native. */
var Map = _getNative(_root, 'Map');

/* harmony default export */ var _Map = (Map);

;// ./node_modules/lodash-es/_nativeCreate.js


/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

/* harmony default export */ var _nativeCreate = (nativeCreate);

;// ./node_modules/lodash-es/_hashClear.js


/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

/* harmony default export */ var _hashClear = (hashClear);

;// ./node_modules/lodash-es/_hashDelete.js
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _hashDelete = (hashDelete);

;// ./node_modules/lodash-es/_hashGet.js


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var _hashGet_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return _hashGet_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ var _hashGet = (hashGet);

;// ./node_modules/lodash-es/_hashHas.js


/** Used for built-in method references. */
var _hashHas_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : _hashHas_hasOwnProperty.call(data, key);
}

/* harmony default export */ var _hashHas = (hashHas);

;// ./node_modules/lodash-es/_hashSet.js


/** Used to stand-in for `undefined` hash values. */
var _hashSet_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? _hashSet_HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ var _hashSet = (hashSet);

;// ./node_modules/lodash-es/_Hash.js






/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

/* harmony default export */ var _Hash = (Hash);

;// ./node_modules/lodash-es/_mapCacheClear.js




/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

/* harmony default export */ var _mapCacheClear = (mapCacheClear);

;// ./node_modules/lodash-es/_isKeyable.js
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/* harmony default export */ var _isKeyable = (isKeyable);

;// ./node_modules/lodash-es/_getMapData.js


/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/* harmony default export */ var _getMapData = (getMapData);

;// ./node_modules/lodash-es/_mapCacheDelete.js


/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _mapCacheDelete = (mapCacheDelete);

;// ./node_modules/lodash-es/_mapCacheGet.js


/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

/* harmony default export */ var _mapCacheGet = (mapCacheGet);

;// ./node_modules/lodash-es/_mapCacheHas.js


/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

/* harmony default export */ var _mapCacheHas = (mapCacheHas);

;// ./node_modules/lodash-es/_mapCacheSet.js


/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ var _mapCacheSet = (mapCacheSet);

;// ./node_modules/lodash-es/_MapCache.js






/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

/* harmony default export */ var _MapCache = (MapCache);

;// ./node_modules/lodash-es/_stackSet.js




/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ var _stackSet = (stackSet);

;// ./node_modules/lodash-es/_Stack.js







/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

/* harmony default export */ var _Stack = (Stack);

;// ./node_modules/lodash-es/_defineProperty.js


var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* harmony default export */ var _defineProperty = (defineProperty);

;// ./node_modules/lodash-es/_baseAssignValue.js


/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ var _baseAssignValue = (baseAssignValue);

;// ./node_modules/lodash-es/_assignMergeValue.js



/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !lodash_es_eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignMergeValue = (assignMergeValue);

;// ./node_modules/lodash-es/_createBaseFor.js
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/* harmony default export */ var _createBaseFor = (createBaseFor);

;// ./node_modules/lodash-es/_baseFor.js


/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = _createBaseFor();

/* harmony default export */ var _baseFor = (baseFor);

;// ./node_modules/lodash-es/_cloneBuffer.js


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/* harmony default export */ var _cloneBuffer = (cloneBuffer);

;// ./node_modules/lodash-es/_Uint8Array.js


/** Built-in value references. */
var Uint8Array = _root.Uint8Array;

/* harmony default export */ var _Uint8Array = (Uint8Array);

;// ./node_modules/lodash-es/_cloneArrayBuffer.js


/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

/* harmony default export */ var _cloneArrayBuffer = (cloneArrayBuffer);

;// ./node_modules/lodash-es/_cloneTypedArray.js


/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ var _cloneTypedArray = (cloneTypedArray);

;// ./node_modules/lodash-es/_copyArray.js
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/* harmony default export */ var _copyArray = (copyArray);

;// ./node_modules/lodash-es/_baseCreate.js


/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!lodash_es_isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/* harmony default export */ var _baseCreate = (baseCreate);

;// ./node_modules/lodash-es/_overArg.js
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ var _overArg = (overArg);

;// ./node_modules/lodash-es/_getPrototype.js


/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

/* harmony default export */ var _getPrototype = (getPrototype);

;// ./node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var _isPrototype_objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || _isPrototype_objectProto;

  return value === proto;
}

/* harmony default export */ var _isPrototype = (isPrototype);

;// ./node_modules/lodash-es/_initCloneObject.js




/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

/* harmony default export */ var _initCloneObject = (initCloneObject);

;// ./node_modules/lodash-es/isObjectLike.js
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);

;// ./node_modules/lodash-es/_baseIsArguments.js



/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;
}

/* harmony default export */ var _baseIsArguments = (baseIsArguments);

;// ./node_modules/lodash-es/isArguments.js



/** Used for built-in method references. */
var isArguments_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/* harmony default export */ var lodash_es_isArguments = (isArguments);

;// ./node_modules/lodash-es/isArray.js
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ var lodash_es_isArray = (isArray);

;// ./node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/* harmony default export */ var lodash_es_isLength = (isLength);

;// ./node_modules/lodash-es/isArrayLike.js



/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);
}

/* harmony default export */ var lodash_es_isArrayLike = (isArrayLike);

;// ./node_modules/lodash-es/isArrayLikeObject.js



/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return lodash_es_isObjectLike(value) && lodash_es_isArrayLike(value);
}

/* harmony default export */ var lodash_es_isArrayLikeObject = (isArrayLikeObject);

;// ./node_modules/lodash-es/stubFalse.js
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ var lodash_es_stubFalse = (stubFalse);

;// ./node_modules/lodash-es/isBuffer.js



/** Detect free variable `exports`. */
var isBuffer_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var isBuffer_freeModule = isBuffer_freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var isBuffer_moduleExports = isBuffer_freeModule && isBuffer_freeModule.exports === isBuffer_freeExports;

/** Built-in value references. */
var isBuffer_Buffer = isBuffer_moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = isBuffer_Buffer ? isBuffer_Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || lodash_es_stubFalse;

/* harmony default export */ var lodash_es_isBuffer = (isBuffer);

;// ./node_modules/lodash-es/isPlainObject.js




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var isPlainObject_funcProto = Function.prototype,
    isPlainObject_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var isPlainObject_funcToString = isPlainObject_funcProto.toString;

/** Used to check objects for own properties. */
var isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = isPlainObject_funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = isPlainObject_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    isPlainObject_funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ var lodash_es_isPlainObject = (isPlainObject);

;// ./node_modules/lodash-es/_baseIsTypedArray.js




/** `Object#toString` result references. */
var _baseIsTypedArray_argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    _baseIsTypedArray_funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    _baseIsTypedArray_objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[_baseIsTypedArray_objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return lodash_es_isObjectLike(value) &&
    lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

/* harmony default export */ var _baseIsTypedArray = (baseIsTypedArray);

;// ./node_modules/lodash-es/_baseUnary.js
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ var _baseUnary = (baseUnary);

;// ./node_modules/lodash-es/_nodeUtil.js


/** Detect free variable `exports`. */
var _nodeUtil_freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var _nodeUtil_freeModule = _nodeUtil_freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var _nodeUtil_moduleExports = _nodeUtil_freeModule && _nodeUtil_freeModule.exports === _nodeUtil_freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = _nodeUtil_moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = _nodeUtil_freeModule && _nodeUtil_freeModule.require && _nodeUtil_freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* harmony default export */ var _nodeUtil = (nodeUtil);

;// ./node_modules/lodash-es/isTypedArray.js




/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

/* harmony default export */ var lodash_es_isTypedArray = (isTypedArray);

;// ./node_modules/lodash-es/_safeGet.js
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/* harmony default export */ var _safeGet = (safeGet);

;// ./node_modules/lodash-es/_assignValue.js



/** Used for built-in method references. */
var _assignValue_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignValue = (assignValue);

;// ./node_modules/lodash-es/_copyObject.js



/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

/* harmony default export */ var _copyObject = (copyObject);

;// ./node_modules/lodash-es/_baseTimes.js
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/* harmony default export */ var _baseTimes = (baseTimes);

;// ./node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var _isIndex_MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? _isIndex_MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* harmony default export */ var _isIndex = (isIndex);

;// ./node_modules/lodash-es/_arrayLikeKeys.js







/** Used for built-in method references. */
var _arrayLikeKeys_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = lodash_es_isArray(value),
      isArg = !isArr && lodash_es_isArguments(value),
      isBuff = !isArr && !isArg && lodash_es_isBuffer(value),
      isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _arrayLikeKeys = (arrayLikeKeys);

;// ./node_modules/lodash-es/_nativeKeysIn.js
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _nativeKeysIn = (nativeKeysIn);

;// ./node_modules/lodash-es/_baseKeysIn.js




/** Used for built-in method references. */
var _baseKeysIn_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!lodash_es_isObject(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _baseKeysIn = (baseKeysIn);

;// ./node_modules/lodash-es/keysIn.js




/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

/* harmony default export */ var lodash_es_keysIn = (keysIn);

;// ./node_modules/lodash-es/toPlainObject.js



/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return _copyObject(value, lodash_es_keysIn(value));
}

/* harmony default export */ var lodash_es_toPlainObject = (toPlainObject);

;// ./node_modules/lodash-es/_baseMergeDeep.js
















/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object, key),
      srcValue = _safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = lodash_es_isArray(srcValue),
        isBuff = !isArr && lodash_es_isBuffer(srcValue),
        isTyped = !isArr && !isBuff && lodash_es_isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (lodash_es_isArray(objValue)) {
        newValue = objValue;
      }
      else if (lodash_es_isArrayLikeObject(objValue)) {
        newValue = _copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (lodash_es_isPlainObject(srcValue) || lodash_es_isArguments(srcValue)) {
      newValue = objValue;
      if (lodash_es_isArguments(objValue)) {
        newValue = lodash_es_toPlainObject(objValue);
      }
      else if (!lodash_es_isObject(objValue) || lodash_es_isFunction(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}

/* harmony default export */ var _baseMergeDeep = (baseMergeDeep);

;// ./node_modules/lodash-es/_baseMerge.js








/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack);
    if (lodash_es_isObject(srcValue)) {
      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, lodash_es_keysIn);
}

/* harmony default export */ var _baseMerge = (baseMerge);

;// ./node_modules/lodash-es/identity.js
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ var lodash_es_identity = (identity);

;// ./node_modules/lodash-es/_apply.js
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* harmony default export */ var _apply = (apply);

;// ./node_modules/lodash-es/_overRest.js


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

/* harmony default export */ var _overRest = (overRest);

;// ./node_modules/lodash-es/constant.js
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/* harmony default export */ var lodash_es_constant = (constant);

;// ./node_modules/lodash-es/_baseSetToString.js




/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty ? lodash_es_identity : function(func, string) {
  return _defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': lodash_es_constant(string),
    'writable': true
  });
};

/* harmony default export */ var _baseSetToString = (baseSetToString);

;// ./node_modules/lodash-es/_shortOut.js
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/* harmony default export */ var _shortOut = (shortOut);

;// ./node_modules/lodash-es/_setToString.js



/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

/* harmony default export */ var _setToString = (setToString);

;// ./node_modules/lodash-es/_baseRest.js




/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, lodash_es_identity), func + '');
}

/* harmony default export */ var _baseRest = (baseRest);

;// ./node_modules/lodash-es/_isIterateeCall.js





/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!lodash_es_isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (lodash_es_isArrayLike(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return lodash_es_eq(object[index], value);
  }
  return false;
}

/* harmony default export */ var _isIterateeCall = (isIterateeCall);

;// ./node_modules/lodash-es/_createAssigner.js



/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return _baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/* harmony default export */ var _createAssigner = (createAssigner);

;// ./node_modules/lodash-es/merge.js



/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = _createAssigner(function(object, source, srcIndex) {
  _baseMerge(object, source, srcIndex);
});

/* harmony default export */ var lodash_es_merge = (merge);


/***/ }),

/***/ 2886:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);
var inspectSource = __webpack_require__(9965);

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 2929:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(3938);
var isArrayIteratorMethod = __webpack_require__(9034);
var toLength = __webpack_require__(3747);
var bind = __webpack_require__(6885);
var getIteratorMethod = __webpack_require__(1898);
var iteratorClose = __webpack_require__(9868);

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),

/***/ 3062:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__(3129);
var classofRaw = __webpack_require__(8569);
var wellKnownSymbol = __webpack_require__(1602);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ 3075:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var redefine = __webpack_require__(7485);

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 3105:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(3938);
var defineProperties = __webpack_require__(5318);
var enumBugKeys = __webpack_require__(290);
var hiddenKeys = __webpack_require__(7708);
var html = __webpack_require__(8890);
var documentCreateElement = __webpack_require__(3262);
var sharedKey = __webpack_require__(5904);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ 3129:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(1602);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3164:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-iterator-helpers
var $ = __webpack_require__(1605);
var anObject = __webpack_require__(3938);
var toPositiveInteger = __webpack_require__(5955);
var createIteratorProxy = __webpack_require__(1523);

var IteratorProxy = createIteratorProxy(function (arg) {
  var iterator = this.iterator;
  var next = this.next;
  var result, done;
  while (this.remaining) {
    this.remaining--;
    result = anObject(next.call(iterator));
    done = this.done = !!result.done;
    if (done) return;
  }
  result = anObject(next.call(iterator, arg));
  done = this.done = !!result.done;
  if (!done) return result.value;
});

$({ target: 'Iterator', proto: true, real: true }, {
  drop: function drop(limit) {
    return new IteratorProxy({
      iterator: anObject(this),
      remaining: toPositiveInteger(limit)
    });
  }
});


/***/ }),

/***/ 3262:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);
var isObject = __webpack_require__(5335);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 3610:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(5077);
var IE8_DOM_DEFINE = __webpack_require__(7694);
var anObject = __webpack_require__(3938);
var toPrimitive = __webpack_require__(874);

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 3725:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-iterator-helpers
var $ = __webpack_require__(1605);
var global = __webpack_require__(200);
var anInstance = __webpack_require__(5190);
var createNonEnumerableProperty = __webpack_require__(7712);
var fails = __webpack_require__(2074);
var has = __webpack_require__(1883);
var wellKnownSymbol = __webpack_require__(1602);
var IteratorPrototype = (__webpack_require__(9306).IteratorPrototype);
var IS_PURE = __webpack_require__(6926);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var NativeIterator = global.Iterator;

// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE
  || typeof NativeIterator != 'function'
  || NativeIterator.prototype !== IteratorPrototype
  // FF44- non-standard `Iterator` passes previous tests
  || !fails(function () { NativeIterator({}); });

var IteratorConstructor = function Iterator() {
  anInstance(this, IteratorConstructor);
};

if (IS_PURE) {
  IteratorPrototype = {};
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

if (!has(IteratorPrototype, TO_STRING_TAG)) {
  createNonEnumerableProperty(IteratorPrototype, TO_STRING_TAG, 'Iterator');
}

if (FORCED || !has(IteratorPrototype, 'constructor') || IteratorPrototype.constructor === Object) {
  createNonEnumerableProperty(IteratorPrototype, 'constructor', IteratorConstructor);
}

IteratorConstructor.prototype = IteratorPrototype;

$({ global: true, forced: FORCED }, {
  Iterator: IteratorConstructor
});


/***/ }),

/***/ 3747:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(7317);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 3751:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $9: function() { return /* binding */ useCssVars; },
/* harmony export */   $V: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.$V; },
/* harmony export */   $u: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.$u; },
/* harmony export */   $y: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.$y; },
/* harmony export */   BA: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.BA; },
/* harmony export */   Bi: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Bi; },
/* harmony export */   Bs: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Bs; },
/* harmony export */   C4: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.C4; },
/* harmony export */   CE: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.CE; },
/* harmony export */   D: function() { return /* binding */ useCssModule; },
/* harmony export */   D$: function() { return /* binding */ withModifiers; },
/* harmony export */   Df: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Df; },
/* harmony export */   Dl: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Dl; },
/* harmony export */   E: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.E; },
/* harmony export */   E3: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.E3; },
/* harmony export */   EW: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EW; },
/* harmony export */   EY: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.EY; },
/* harmony export */   Ef: function() { return /* binding */ createApp; },
/* harmony export */   F: function() { return /* binding */ TransitionGroup; },
/* harmony export */   FK: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.FK; },
/* harmony export */   Fv: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fv; },
/* harmony export */   Fw: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Fw; },
/* harmony export */   GM: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.GM; },
/* harmony export */   Gc: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Gc; },
/* harmony export */   Gt: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Gt; },
/* harmony export */   Gw: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Gw; },
/* harmony export */   Gy: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Gy; },
/* harmony export */   H4: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.H4; },
/* harmony export */   HF: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.HF; },
/* harmony export */   Ht: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Ht; },
/* harmony export */   IG: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.IG; },
/* harmony export */   IJ: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.IJ; },
/* harmony export */   Ib: function() { return /* binding */ initDirectivesForSSR; },
/* harmony export */   Ic: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Ic; },
/* harmony export */   Im: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Im; },
/* harmony export */   Jo: function() { return /* binding */ vModelText; },
/* harmony export */   K9: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.K9; },
/* harmony export */   KC: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KC; },
/* harmony export */   KR: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.KR; },
/* harmony export */   KT: function() { return /* binding */ useHost; },
/* harmony export */   Kf: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Kf; },
/* harmony export */   Kh: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Kh; },
/* harmony export */   LJ: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.LJ; },
/* harmony export */   LM: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.LM; },
/* harmony export */   Lk: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Lk; },
/* harmony export */   Lu: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Lu; },
/* harmony export */   MZ: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.MZ; },
/* harmony export */   Mw: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Mw; },
/* harmony export */   NP: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.NP; },
/* harmony export */   Ng: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Ng; },
/* harmony export */   OA: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.OA; },
/* harmony export */   OW: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.OW; },
/* harmony export */   PP: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.PP; },
/* harmony export */   PR: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.PR; },
/* harmony export */   PS: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.PS; },
/* harmony export */   PT: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.PT; },
/* harmony export */   Pn: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Pn; },
/* harmony export */   Po: function() { return /* binding */ defineSSRCustomElement; },
/* harmony export */   Pr: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Pr; },
/* harmony export */   Q3: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Q3; },
/* harmony export */   QP: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.QP; },
/* harmony export */   QW: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.QW; },
/* harmony export */   QZ: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.QZ; },
/* harmony export */   Qi: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Qi; },
/* harmony export */   Qv: function() { return /* binding */ hydrate; },
/* harmony export */   R1: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.R1; },
/* harmony export */   R8: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.R8; },
/* harmony export */   RG: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.RG; },
/* harmony export */   SS: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.SS; },
/* harmony export */   Tb: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Tb; },
/* harmony export */   Tm: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Tm; },
/* harmony export */   Tq: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Tq; },
/* harmony export */   Tr: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Tr; },
/* harmony export */   U4: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.U4; },
/* harmony export */   U_: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.U_; },
/* harmony export */   Ul: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Ul; },
/* harmony export */   Vq: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Vq; },
/* harmony export */   Vy: function() { return /* binding */ VueElement; },
/* harmony export */   WQ: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.WQ; },
/* harmony export */   Wv: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Wv; },
/* harmony export */   X2: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.X2; },
/* harmony export */   XL: function() { return /* binding */ vModelRadio; },
/* harmony export */   XX: function() { return /* binding */ render; },
/* harmony export */   Xq: function() { return /* binding */ defineCustomElement; },
/* harmony export */   Y4: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Y4; },
/* harmony export */   Y5: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Y5; },
/* harmony export */   YY: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.YY; },
/* harmony export */   Yj: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Yj; },
/* harmony export */   Yv: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.Yv; },
/* harmony export */   ZH: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ZH; },
/* harmony export */   ZQ: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ZQ; },
/* harmony export */   _B: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__._B; },
/* harmony export */   _U: function() { return /* binding */ useShadowRoot; },
/* harmony export */   aG: function() { return /* binding */ vShow; },
/* harmony export */   aT: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.aT; },
/* harmony export */   bF: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.bF; },
/* harmony export */   bU: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.bU; },
/* harmony export */   bj: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.bj; },
/* harmony export */   bn: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.bn; },
/* harmony export */   bo: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.bo; },
/* harmony export */   ch: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ch; },
/* harmony export */   ci: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ci; },
/* harmony export */   dA: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.dA; },
/* harmony export */   dY: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.dY; },
/* harmony export */   ds: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ds; },
/* harmony export */   eB: function() { return /* binding */ Transition; },
/* harmony export */   eW: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.eW; },
/* harmony export */   eX: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.eX; },
/* harmony export */   fE: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.fE; },
/* harmony export */   fn: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.fn; },
/* harmony export */   g2: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.g2; },
/* harmony export */   g8: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.g8; },
/* harmony export */   gN: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.gN; },
/* harmony export */   gW: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.gW; },
/* harmony export */   gh: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.gh; },
/* harmony export */   h: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h; },
/* harmony export */   hi: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.hi; },
/* harmony export */   hp: function() { return /* binding */ vModelDynamic; },
/* harmony export */   i9: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.i9; },
/* harmony export */   iD: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.iD; },
/* harmony export */   jC: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.jC; },
/* harmony export */   jR: function() { return /* binding */ withKeys; },
/* harmony export */   jr: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.jr; },
/* harmony export */   jt: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.jt; },
/* harmony export */   ju: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ju; },
/* harmony export */   k6: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.k6; },
/* harmony export */   lH: function() { return /* binding */ vModelCheckbox; },
/* harmony export */   lW: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.lW; },
/* harmony export */   lt: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.lt; },
/* harmony export */   m1: function() { return /* binding */ createSSRApp; },
/* harmony export */   mu: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.mu; },
/* harmony export */   n: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.n; },
/* harmony export */   nD: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nD; },
/* harmony export */   nI: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nI; },
/* harmony export */   nT: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.nT; },
/* harmony export */   o5: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.o5; },
/* harmony export */   p9: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.p9; },
/* harmony export */   pI: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pI; },
/* harmony export */   pM: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pM; },
/* harmony export */   pR: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.pR; },
/* harmony export */   qG: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.qG; },
/* harmony export */   qL: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.qL; },
/* harmony export */   qP: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.qP; },
/* harmony export */   qR: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.qR; },
/* harmony export */   rE: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.rE; },
/* harmony export */   rO: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.rO; },
/* harmony export */   rU: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.rU; },
/* harmony export */   rY: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.rY; },
/* harmony export */   rk: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.rk; },
/* harmony export */   sV: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.sV; },
/* harmony export */   tB: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.tB; },
/* harmony export */   tC: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.tC; },
/* harmony export */   tG: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.tG; },
/* harmony export */   tY: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.tY; },
/* harmony export */   u1: function() { return /* binding */ vModelSelect; },
/* harmony export */   uX: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.uX; },
/* harmony export */   uY: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.uY; },
/* harmony export */   ux: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.ux; },
/* harmony export */   v6: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.v6; },
/* harmony export */   v_: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.v_; },
/* harmony export */   vv: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.vv; },
/* harmony export */   wB: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.wB; },
/* harmony export */   wX: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.wX; },
/* harmony export */   wk: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.wk; },
/* harmony export */   xo: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.xo; },
/* harmony export */   y$: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.y$; },
/* harmony export */   yC: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.yC; },
/* harmony export */   zz: function() { return /* reexport safe */ _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.zz; }
/* harmony export */ });
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(641);
/* harmony import */ var _vue_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(953);
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/




let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
     false && 0;
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};

const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(
  {},
  _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .BaseTransitionPropsValidators */ .QP,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__.h)(_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .BaseTransition */ .pR, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve);
        }
      });
    };
  };
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve);
        }
      });
      callHook(onLeave, [el, resolve]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isObject */ .Gv)(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toNumber */ .Ro)(val);
  if (false) // removed by dead control flow
{}
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}

function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}

const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
if (false) // removed by dead control flow
{}
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}

const CSS_VAR_TEXT = Symbol( false ? 0 : "");
function useCssVars(getter) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentInstance */ .nI)();
  if (!instance) {
     false && 0;
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  if (false) // removed by dead control flow
{}
  const setVars = () => {
    const vars = getter(instance.proxy);
    if (instance.ce) {
      setVarsOnNode(instance.ce, vars);
    } else {
      setVarsOnVNode(instance.subTree, vars);
    }
    updateTeleports(vars);
  };
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .onBeforeUpdate */ .Ic)(() => {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .queuePostFlushCb */ .Dl)(setVars);
  });
  (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .onMounted */ .sV)(() => {
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .watch */ .wB)(setVars, _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .NOOP */ .tE, { flush: "post" });
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .onUnmounted */ .hi)(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */ .FK) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .Static */ .jC) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor) break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    let cssText = "";
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
      cssText += `--${key}: ${vars[key]};`;
    }
    style[CSS_VAR_TEXT] = cssText;
  }
}

const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (false) // removed by dead control flow
{}
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .capitalize */ .ZH)(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}

const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSpecialBooleanAttr */ .J$)(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .includeBooleanAttr */ .Y2)(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSymbol */ .Bm)(value) ? String(value) : value
      );
    }
  }
}

function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .includeBooleanAttr */ .Y2)(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if (false) // removed by dead control flow
{}
  }
  needRemove && el.removeAttribute(attrName || key);
}

function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value =  false ? 0 : nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
         false ? 0 : nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .callWithAsyncErrorHandling */ .qL)(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function sanitizeEventValue(value, propName) {
  if (isFunction(value) || isArray(value)) {
    return value;
  }
  warn(
    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof value}.`
  );
  return NOOP;
}
function patchStopImmediatePropagation(e, value) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}

const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isOn */ .Mp)(key)) {
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isModelListener */ .CP)(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(nextValue))
  ) {
    patchDOMProp(el, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(value)) {
    return false;
  }
  return key in el;
}

const REMOVAL = {};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, extraOptions, _createApp) {
  const Comp = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .defineComponent */ .pM)(options, extraOptions);
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isPlainObject */ .Qd)(Comp)) (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(Comp, extraOptions);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, _createApp);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options, extraOptions) => {
  return /* @__PURE__ */ defineCustomElement(options, extraOptions, createSSRApp);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, _createApp = createApp) {
    super();
    this._def = _def;
    this._props = _props;
    this._createApp = _createApp;
    this._isVueCE = true;
    /**
     * @internal
     */
    this._instance = null;
    /**
     * @internal
     */
    this._app = null;
    /**
     * @internal
     */
    this._nonce = this._def.nonce;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._styleChildren = /* @__PURE__ */ new WeakSet();
    this._ob = null;
    if (this.shadowRoot && _createApp !== createApp) {
      this._root = this.shadowRoot;
    } else {
      if (false) // removed by dead control flow
{}
      if (_def.shadowRoot !== false) {
        this.attachShadow({ mode: "open" });
        this._root = this.shadowRoot;
      } else {
        this._root = this;
      }
    }
  }
  connectedCallback() {
    if (!this.isConnected) return;
    if (!this.shadowRoot && !this._resolved) {
      this._parseSlots();
    }
    this._connected = true;
    let parent = this;
    while (parent = parent && (parent.parentNode || parent.host)) {
      if (parent instanceof VueElement) {
        this._parent = parent;
        break;
      }
    }
    if (!this._instance) {
      if (this._resolved) {
        this._mount(this._def);
      } else {
        if (parent && parent._pendingResolve) {
          this._pendingResolve = parent._pendingResolve.then(() => {
            this._pendingResolve = void 0;
            this._resolveDef();
          });
        } else {
          this._resolveDef();
        }
      }
    }
  }
  _setParent(parent = this._parent) {
    if (parent) {
      this._instance.parent = parent._instance;
      this._inheritParentContext(parent);
    }
  }
  _inheritParentContext(parent = this._parent) {
    if (parent && this._app) {
      Object.setPrototypeOf(
        this._app._context.provides,
        parent._instance.provides
      );
    }
  }
  disconnectedCallback() {
    this._connected = false;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .nextTick */ .dY)(() => {
      if (!this._connected) {
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        this._app && this._app.unmount();
        if (this._instance) this._instance.ce = void 0;
        this._app = this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    if (this._pendingResolve) {
      return;
    }
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve = (def, isAsync = false) => {
      this._resolved = true;
      this._pendingResolve = void 0;
      const { props, styles } = def;
      let numberProps;
      if (props && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(props)) {
        for (const key in props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toNumber */ .Ro)(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      this._resolveProps(def);
      if (this.shadowRoot) {
        this._applyStyles(styles);
      } else if (false) // removed by dead control flow
{}
      this._mount(def);
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      this._pendingResolve = asyncDef().then((def) => {
        def.configureApp = this._def.configureApp;
        resolve(this._def = def, true);
      });
    } else {
      resolve(this._def);
    }
  }
  _mount(def) {
    if (false) // removed by dead control flow
{}
    this._app = this._createApp(def);
    this._inheritParentContext();
    if (def.configureApp) {
      def.configureApp(this._app);
    }
    this._app._ceVNode = this._createVNode();
    this._app.mount(this._root);
    const exposed = this._instance && this._instance.exposed;
    if (!exposed) return;
    for (const key in exposed) {
      if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hasOwn */ .$3)(this, key)) {
        Object.defineProperty(this, key, {
          // unwrap ref to be consistent with public instance behavior
          get: () => (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .unref */ .R1)(exposed[key])
        });
      } else if (false) // removed by dead control flow
{}
    }
  }
  _resolveProps(def) {
    const { props } = def;
    const declaredPropKeys = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(props) ? props : Object.keys(props || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key]);
      }
    }
    for (const key of declaredPropKeys.map(_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val, true, true);
        }
      });
    }
  }
  _setAttr(key) {
    if (key.startsWith("data-v-")) return;
    const has = this.hasAttribute(key);
    let value = has ? this.getAttribute(key) : REMOVAL;
    const camelKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .camelize */ .PT)(key);
    if (has && this._numberProps && this._numberProps[camelKey]) {
      value = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .toNumber */ .Ro)(value);
    }
    this._setProp(camelKey, value, false, true);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
    if (val !== this._props[key]) {
      if (val === REMOVAL) {
        delete this._props[key];
      } else {
        this._props[key] = val;
        if (key === "key" && this._app) {
          this._app._ceVNode.key = val;
        }
      }
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        const ob = this._ob;
        ob && ob.disconnect();
        if (val === true) {
          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(key), val + "");
        } else if (!val) {
          this.removeAttribute((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(key));
        }
        ob && ob.observe(this, { attributes: true });
      }
    }
  }
  _update() {
    const vnode = this._createVNode();
    if (this._app) vnode.appContext = this._app._context;
    render(vnode, this._root);
  }
  _createVNode() {
    const baseProps = {};
    if (!this.shadowRoot) {
      baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
    }
    const vnode = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .createVNode */ .bF)(this._def, (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)(baseProps, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.ce = this;
        instance.isCE = true;
        if (false) // removed by dead control flow
{}
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(
              event,
              (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isPlainObject */ .Qd)(args[0]) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({ detail: args }, args[0]) : { detail: args }
            )
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(event) !== event) {
            dispatch((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(event), args);
          }
        };
        this._setParent();
      };
    }
    return vnode;
  }
  _applyStyles(styles, owner) {
    if (!styles) return;
    if (owner) {
      if (owner === this._def || this._styleChildren.has(owner)) {
        return;
      }
      this._styleChildren.add(owner);
    }
    const nonce = this._nonce;
    for (let i = styles.length - 1; i >= 0; i--) {
      const s = document.createElement("style");
      if (nonce) s.setAttribute("nonce", nonce);
      s.textContent = styles[i];
      this.shadowRoot.prepend(s);
      if (false) // removed by dead control flow
{}
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _parseSlots() {
    const slots = this._slots = {};
    let n;
    while (n = this.firstChild) {
      const slotName = n.nodeType === 1 && n.getAttribute("slot") || "default";
      (slots[slotName] || (slots[slotName] = [])).push(n);
      this.removeChild(n);
    }
  }
  /**
   * Only called when shadowRoot is false
   */
  _renderSlots() {
    const outlets = (this._teleportTarget || this).querySelectorAll("slot");
    const scopeId = this._instance.type.__scopeId;
    for (let i = 0; i < outlets.length; i++) {
      const o = outlets[i];
      const slotName = o.getAttribute("name") || "default";
      const content = this._slots[slotName];
      const parent = o.parentNode;
      if (content) {
        for (const n of content) {
          if (scopeId && n.nodeType === 1) {
            const id = scopeId + "-s";
            const walker = document.createTreeWalker(n, 1);
            n.setAttribute(id, "");
            let child;
            while (child = walker.nextNode()) {
              child.setAttribute(id, "");
            }
          }
          parent.insertBefore(n, o);
        }
      } else {
        while (o.firstChild) parent.insertBefore(o.firstChild, o);
      }
      parent.removeChild(o);
    }
  }
  /**
   * @internal
   */
  _injectChildStyle(comp) {
    this._applyStyles(comp.styles, comp);
  }
  /**
   * @internal
   */
  _removeChildStyle(comp) {
    if (false) // removed by dead control flow
{}
  }
}
function useHost(caller) {
  const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentInstance */ .nI)();
  const el = instance && instance.ce;
  if (el) {
    return el;
  } else if (false) // removed by dead control flow
{}
  return null;
}
function useShadowRoot() {
  const el =  false ? 0 : useHost();
  return el && el.shadowRoot;
}

function useCssModule(name = "$style") {
  {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentInstance */ .nI)();
    if (!instance) {
       false && 0;
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
       false && 0;
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
    }
    const mod = modules[name];
    if (!mod) {
       false && 0;
      return _vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .EMPTY_OBJ */ .MZ;
    }
    return mod;
  }
}

const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .getCurrentInstance */ .nI)();
    const state = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .useTransitionState */ .Gy)();
    let prevChildren;
    let children;
    (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .onUpdated */ .$u)(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        prevChildren = [];
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
      prevChildren = [];
    });
    return () => {
      const rawProps = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_2__/* .toRaw */ .ux)(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || _vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .Fragment */ .FK;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .setTransitionHooks */ .MZ)(
              child,
              (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .resolveTransitionHooks */ .OW)(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .getTransitionRawChildren */ .Df)(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .setTransitionHooks */ .MZ)(
            child,
            (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .resolveTransitionHooks */ .OW)(child, cssTransitionProps, state, instance)
          );
        } else if (false) // removed by dead control flow
{}
      }
      return (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .createVNode */ .bF)(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}

const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(fn) ? (value) => (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .invokeArrayFns */ .DY)(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseToNumber */ .bB)(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseToNumber */ .bB)(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(modelValue)) {
        const index = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseIndexOf */ .u3)(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .vM)(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(value)) {
    checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseIndexOf */ .u3)(value, vnode.props.value) > -1;
  } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .vM)(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .BX)(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .BX)(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .BX)(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .vM)(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseToNumber */ .bB)(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .nextTick */ .dY)(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  const isArrayValue = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(value);
  if (isMultiple && !isArrayValue && !(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .vM)(value)) {
     false && 0;
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseIndexOf */ .u3)(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .BX)(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseEqual */ .BX)(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .cy)(value)) {
      if (vnode.props && (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .looseIndexOf */ .u3)(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isSet */ .vM)(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}

const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .hyphenate */ .Tg)(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};

const rendererOptions = /* @__PURE__ */ (0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .extend */ .X$)({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .createRenderer */ .K9)(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : (0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_0__/* .createHydrationRenderer */ .ci)(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (false) // removed by dead control flow
{}
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!(0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isFunction */ .Tn)(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  if (false) // removed by dead control flow
{}
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, resolveRootNamespace(container));
    }
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  if (isRuntimeOnly()) {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn(
          `The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`
        );
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn(msg);
        return compilerOptions;
      },
      set() {
        warn(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if ((0,_vue_shared__WEBPACK_IMPORTED_MODULE_1__/* .isString */ .Kg)(container)) {
    const res = document.querySelector(container);
    if (false) // removed by dead control flow
{}
    return res;
  }
  if (false) // removed by dead control flow
{}
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
} ;




/***/ }),

/***/ 3938:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(5335);

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ 4287:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  r: function() { return /* binding */ initAMapApiLoader; },
  E: function() { return /* binding */ lazyAMapApiLoaderInstance; }
});

;// ./node_modules/@vuemap/amap-jsapi-loader/dist/index.mjs
var d,e=d||(d={});e.notload="notload";e.loading="loading";e.loaded="loaded";e.failed="failed";let g={key:"",AMap:{version:"1.4.15",plugins:[]},AMapUI:{version:"1.1",plugins:[]},Loca:{version:"1.3.2"}},m={AMap:d.notload,AMapUI:d.notload,Loca:d.notload},n={AMap:[],AMapUI:[],Loca:[]},p=[];function q(a){"function"==typeof a&&(m.AMap===d.loaded?a(window.AMap):p.push(a))}function r(a){let h=[];a.AMapUI&&h.push(t(a.AMapUI));a.Loca&&h.push(u(a.Loca));return Promise.all(h)}
function t(a){return new Promise((h,b)=>{let f=[];if(a.plugins)for(var c=0;c<a.plugins.length;c+=1)-1==g.AMapUI.plugins.indexOf(a.plugins[c])&&f.push(a.plugins[c]);if(m.AMapUI===d.failed)b("\u524d\u6b21\u8bf7\u6c42 AMapUI \u5931\u8d25");else if(m.AMapUI===d.notload){m.AMapUI=d.loading;g.AMapUI.version=a.version||g.AMapUI.version;c=g.AMapUI.version;let k=document.body||document.head,l=document.createElement("script");l.type="text/javascript";l.src=`https://webapi.amap.com/ui/${c}/main.js`;l.onerror=
()=>{m.AMapUI=d.failed;b("\u8bf7\u6c42 AMapUI \u5931\u8d25")};l.onload=()=>{m.AMapUI=d.loaded;if(f.length)window.AMapUI.loadUI(f,function(){for(let a=0,b=f.length;a<b;a++){let b=f[a].split("/").slice(-1)[0];window.AMapUI[b]=arguments[a]}for(h();n.AMapUI.length;)n.AMapUI.splice(0,1)[0]()});else for(h();n.AMapUI.length;)n.AMapUI.splice(0,1)[0]()};k.appendChild(l)}else m.AMapUI===d.loaded?a.version&&a.version!==g.AMapUI.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c AMapUI \u6df7\u7528"):f.length?
window.AMapUI.loadUI(f,function(){for(let a=0,b=f.length;a<b;a++){let b=f[a].split("/").slice(-1)[0];window.AMapUI[b]=arguments[a]}h()}):h():a.version&&a.version!==g.AMapUI.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c AMapUI \u6df7\u7528"):n.AMapUI.push(a=>{a?b(a):f.length?window.AMapUI.loadUI(f,function(){for(let a=0,b=f.length;a<b;a++){let b=f[a].split("/").slice(-1)[0];window.AMapUI[b]=arguments[a]}h()}):h()})})}
function u(a){return new Promise((h,b)=>{if(m.Loca===d.failed)b("\u524d\u6b21\u8bf7\u6c42 Loca \u5931\u8d25");else if(m.Loca===d.notload){m.Loca=d.loading;g.Loca.version=a.version||g.Loca.version;let l=g.Loca.version;var f=g.AMap.version.startsWith("2"),c=l.startsWith("2");if(f&&!c||!f&&c)b("JSAPI \u4e0e Loca \u7248\u672c\u4e0d\u5bf9\u5e94\uff01\uff01");else{f=g.key;c=document.body||document.head;var k=document.createElement("script");k.type="text/javascript";k.src=`https://webapi.amap.com/loca?v=${l}&key=${f}`;
k.onerror=()=>{m.Loca=d.failed;b("\u8bf7\u6c42 AMapUI \u5931\u8d25")};k.onload=()=>{m.Loca=d.loaded;for(h();n.Loca.length;)n.Loca.splice(0,1)[0]()};c.appendChild(k)}}else m.Loca===d.loaded?a.version&&a.version!==g.Loca.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c Loca \u6df7\u7528"):h():a.version&&a.version!==g.Loca.version?b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c Loca \u6df7\u7528"):n.Loca.push(a=>{a?b(a):b()})})}
/* harmony default export */ var dist = ({load:function(a){if("undefined"===typeof window)throw Error("AMap JSAPI can only be used in Browser.");return new Promise((h,b)=>{if(m.AMap==d.failed)b("");else if(m.AMap==d.notload){let {key:l,version:k,plugins:v}=a;if(l){window.AMap&&"lbs.amap.com"!==location.host&&b("\u7981\u6b62\u591a\u79cdAPI\u52a0\u8f7d\u65b9\u5f0f\u6df7\u7528");g.key=l;g.AMap.version=k||g.AMap.version;g.AMap.plugins=v||g.AMap.plugins;m.AMap=d.loading;var f=document.body||document.head;window.___onAPILoaded=function(c){delete window.___onAPILoaded;
if(c)m.AMap=d.failed,b(c);else for(m.AMap=d.loaded,r(a).then(()=>{h(window.AMap)}).catch(b);p.length;)p.splice(0,1)[0]()};var c=document.createElement("script");c.type="text/javascript";c.src="https://webapi.amap.com/maps?callback=___onAPILoaded&v="+g.AMap.version+"&key="+l+"&plugin="+g.AMap.plugins.join(",");c.onerror=a=>{m.AMap=d.failed;b(a)};f.appendChild(c)}else b("\u8bf7\u586b\u5199key")}else if(m.AMap==d.loaded)if(a.key&&a.key!==g.key)b("\u591a\u4e2a\u4e0d\u4e00\u81f4\u7684 key");else if(a.version&&
a.version!==g.AMap.version)b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c JSAPI \u6df7\u7528");else{f=[];if(a.plugins)for(c=0;c<a.plugins.length;c+=1)-1==g.AMap.plugins.indexOf(a.plugins[c])&&f.push(a.plugins[c]);f.length?window.AMap.plugin(f,()=>{r(a).then(()=>{h(window.AMap)}).catch(b)}):r(a).then(()=>{h(window.AMap)}).catch(b)}else if(a.key&&a.key!==g.key)b("\u591a\u4e2a\u4e0d\u4e00\u81f4\u7684 key");else if(a.version&&a.version!==g.AMap.version)b("\u4e0d\u5141\u8bb8\u591a\u4e2a\u7248\u672c JSAPI \u6df7\u7528");
else{var k=[];if(a.plugins)for(c=0;c<a.plugins.length;c+=1)-1==g.AMap.plugins.indexOf(a.plugins[c])&&k.push(a.plugins[c]);q(()=>{k.length?window.AMap.plugin(k,()=>{r(a).then(()=>{h(window.AMap)}).catch(b)}):r(a).then(()=>{h(window.AMap)}).catch(b)})}})},reset:function(){delete window.AMap;delete window.AMapUI;delete window.Loca;g={key:"",AMap:{version:"1.4.15",plugins:[]},AMapUI:{version:"1.1",plugins:[]},Loca:{version:"1.3.2"}};m={AMap:d.notload,AMapUI:d.notload,Loca:d.notload};n={AMap:[],AMapUI:[],
Loca:[]}}});
//# sourceMappingURL=index.mjs.map

// EXTERNAL MODULE: ./node_modules/lodash-es/merge.js + 95 modules
var merge = __webpack_require__(2847);
;// ./node_modules/@vuemap/vue-amap/es/services/amap-api-loader.mjs



const DEFAULT_AMP_CONFIG = {
  "key": "",
  // ç³è¯·å¥½çWebç«¯å¼åèKeyï¼é¦æ¬¡è°ç¨ load æ¶å¿å¡«
  "version": "2.0",
  // æå®è¦å è½½ç JSAPI ççæ¬ï¼ç¼ºçæ¶é»è®¤ä¸º 1.4.15
  "plugins": [],
  // éè¦ä½¿ç¨ççæä»¶åè¡¨ï¼å¦æ¯ä¾å°º'AMap.Scale'ç­
  // 'Loca': { // æ¯å¦å è½½ Locaï¼ ç¼ºçä¸å è½½
  //   'version': '2.0.0' // Loca çæ¬ï¼ç¼ºç 1.3.2
  // },
  serviceHost: "",
  securityJsCode: ""
};
function AMapAPILoader(config = {}) {
  config = (0,merge/* default */.A)({}, DEFAULT_AMP_CONFIG, config);
  if (config.serviceHost) {
    window._AMapSecurityConfig = {
      serviceHost: config.serviceHost
    };
  } else if (config.securityJsCode) {
    window._AMapSecurityConfig = {
      securityJsCode: config.securityJsCode
    };
  }
  return dist.load(config);
}


//# sourceMappingURL=amap-api-loader.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/services/injected-amap-api-instance.mjs


let lazyAMapApiLoaderInstance = null;
const initAMapApiLoader = (config) => {
  if (lazyAMapApiLoaderInstance)
    return;
  if (!lazyAMapApiLoaderInstance) {
    if (config.offline) {
      lazyAMapApiLoaderInstance = new Promise((resolve) => {
        console.log("@vuemap/vue-amap\u79BB\u7EBF\u90E8\u7F72");
        resolve(window.AMap);
      });
    } else {
      lazyAMapApiLoaderInstance = AMapAPILoader(config);
    }
  }
  lazyAMapApiLoaderInstance.then();
};


//# sourceMappingURL=injected-amap-api-instance.mjs.map


/***/ }),

/***/ 4361:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(1883);
var ownKeys = __webpack_require__(5816);
var getOwnPropertyDescriptorModule = __webpack_require__(7632);
var definePropertyModule = __webpack_require__(3610);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 4789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(6347);
var enumBugKeys = __webpack_require__(290);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 4977:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(2074);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5077:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(2074);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 5190:
/***/ (function(module) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ 5225:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__(1849);

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 5318:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(5077);
var definePropertyModule = __webpack_require__(3610);
var anObject = __webpack_require__(3938);
var objectKeys = __webpack_require__(1641);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ 5335:
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ 5476:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(8664);
var requireObjectCoercible = __webpack_require__(1229);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 5816:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(6492);
var getOwnPropertyNamesModule = __webpack_require__(4789);
var getOwnPropertySymbolsModule = __webpack_require__(8916);
var anObject = __webpack_require__(3938);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 5904:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var shared = __webpack_require__(2);
var uid = __webpack_require__(665);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(7317);

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ 5975:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);
var createNonEnumerableProperty = __webpack_require__(7712);

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 6123:
/***/ (function() {

"use strict";
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 6166:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bt: function() { return /* binding */ createWebHashHistory; },
/* harmony export */   aE: function() { return /* binding */ createRouter; },
/* harmony export */   lq: function() { return /* binding */ useRoute; },
/* harmony export */   rd: function() { return /* binding */ useRouter; }
/* harmony export */ });
/* unused harmony exports NavigationFailureType, RouterLink, RouterView, START_LOCATION, createMemoryHistory, createRouterMatcher, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, viewDepthKey */
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(641);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(953);
/*!
  * vue-router v4.0.16
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */



const hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
const PolySymbol = (name) => 
// vr = vue router
hasSymbol
    ? Symbol(( false) ? 0 : name)
    : (( false) ? 0 : '_vr_') + name;
// rvlm = Router View Location Matched
/**
 * RouteRecord being rendered by the closest ancestor Router View. Used for
 * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View
 * Location Matched
 *
 * @internal
 */
const matchedRouteKey = /*#__PURE__*/ PolySymbol(( false) ? 0 : 'rvlm');
/**
 * Allows overriding the router view depth to control which component in
 * `matched` is rendered. rvd stands for Router View Depth
 *
 * @internal
 */
const viewDepthKey = /*#__PURE__*/ PolySymbol(( false) ? 0 : 'rvd');
/**
 * Allows overriding the router instance returned by `useRouter` in tests. r
 * stands for router
 *
 * @internal
 */
const routerKey = /*#__PURE__*/ PolySymbol(( false) ? 0 : 'r');
/**
 * Allows overriding the current route returned by `useRoute` in tests. rl
 * stands for route location
 *
 * @internal
 */
const routeLocationKey = /*#__PURE__*/ PolySymbol(( false) ? 0 : 'rl');
/**
 * Allows overriding the current route used by router-view. Internally this is
 * used when the `route` prop is passed.
 *
 * @internal
 */
const routerViewLocationKey = /*#__PURE__*/ PolySymbol(( false) ? 0 : 'rvl');

const isBrowser = typeof window !== 'undefined';

function isESModule(obj) {
    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');
}
const assign = Object.assign;
function applyToParams(fn, params) {
    const newParams = {};
    for (const key in params) {
        const value = params[key];
        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);
    }
    return newParams;
}
const noop = () => { };

function warn(msg) {
    // avoid using ...args as it breaks in older Edge builds
    const args = Array.from(arguments).slice(1);
    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));
}

const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');
/**
 * Transforms an URI into a normalized history location
 *
 * @param parseQuery
 * @param location - URI to normalize
 * @param currentLocation - current absolute location. Allows resolving relative
 * paths. Must start with `/`. Defaults to `/`
 * @returns a normalized history location
 */
function parseURL(parseQuery, location, currentLocation = '/') {
    let path, query = {}, searchString = '', hash = '';
    // Could use URL and URLSearchParams but IE 11 doesn't support it
    const searchPos = location.indexOf('?');
    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);
    if (searchPos > -1) {
        path = location.slice(0, searchPos);
        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);
        query = parseQuery(searchString);
    }
    if (hashPos > -1) {
        path = path || location.slice(0, hashPos);
        // keep the # character
        hash = location.slice(hashPos, location.length);
    }
    // no search and no query
    path = resolveRelativePath(path != null ? path : location, currentLocation);
    // empty path means a relative query or hash `?foo=f`, `#thing`
    return {
        fullPath: path + (searchString && '?') + searchString + hash,
        path,
        query,
        hash,
    };
}
/**
 * Stringifies a URL object
 *
 * @param stringifyQuery
 * @param location
 */
function stringifyURL(stringifyQuery, location) {
    const query = location.query ? stringifyQuery(location.query) : '';
    return location.path + (query && '?') + query + (location.hash || '');
}
/**
 * Strips off the base from the beginning of a location.pathname in a non
 * case-sensitive way.
 *
 * @param pathname - location.pathname
 * @param base - base to strip off
 */
function stripBase(pathname, base) {
    // no base or base is not found at the beginning
    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
    return pathname.slice(base.length) || '/';
}
/**
 * Checks if two RouteLocation are equal. This means that both locations are
 * pointing towards the same {@link RouteRecord} and that all `params`, `query`
 * parameters and `hash` are the same
 *
 * @param a - first {@link RouteLocation}
 * @param b - second {@link RouteLocation}
 */
function isSameRouteLocation(stringifyQuery, a, b) {
    const aLastIndex = a.matched.length - 1;
    const bLastIndex = b.matched.length - 1;
    return (aLastIndex > -1 &&
        aLastIndex === bLastIndex &&
        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&
        isSameRouteLocationParams(a.params, b.params) &&
        stringifyQuery(a.query) === stringifyQuery(b.query) &&
        a.hash === b.hash);
}
/**
 * Check if two `RouteRecords` are equal. Takes into account aliases: they are
 * considered equal to the `RouteRecord` they are aliasing.
 *
 * @param a - first {@link RouteRecord}
 * @param b - second {@link RouteRecord}
 */
function isSameRouteRecord(a, b) {
    // since the original record has an undefined value for aliasOf
    // but all aliases point to the original record, this will always compare
    // the original record
    return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
    if (Object.keys(a).length !== Object.keys(b).length)
        return false;
    for (const key in a) {
        if (!isSameRouteLocationParamsValue(a[key], b[key]))
            return false;
    }
    return true;
}
function isSameRouteLocationParamsValue(a, b) {
    return Array.isArray(a)
        ? isEquivalentArray(a, b)
        : Array.isArray(b)
            ? isEquivalentArray(b, a)
            : a === b;
}
/**
 * Check if two arrays are the same or if an array with one single entry is the
 * same as another primitive value. Used to check query and parameters
 *
 * @param a - array of values
 * @param b - array of values or a single value
 */
function isEquivalentArray(a, b) {
    return Array.isArray(b)
        ? a.length === b.length && a.every((value, i) => value === b[i])
        : a.length === 1 && a[0] === b;
}
/**
 * Resolves a relative path that starts with `.`.
 *
 * @param to - path location we are resolving
 * @param from - currentLocation.path, should start with `/`
 */
function resolveRelativePath(to, from) {
    if (to.startsWith('/'))
        return to;
    if (false) // removed by dead control flow
{}
    if (!to)
        return from;
    const fromSegments = from.split('/');
    const toSegments = to.split('/');
    let position = fromSegments.length - 1;
    let toPosition;
    let segment;
    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        // can't go below zero
        if (position === 1 || segment === '.')
            continue;
        if (segment === '..')
            position--;
        // found something that is not relative path
        else
            break;
    }
    return (fromSegments.slice(0, position).join('/') +
        '/' +
        toSegments
            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))
            .join('/'));
}

var NavigationType;
(function (NavigationType) {
    NavigationType["pop"] = "pop";
    NavigationType["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function (NavigationDirection) {
    NavigationDirection["back"] = "back";
    NavigationDirection["forward"] = "forward";
    NavigationDirection["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
/**
 * Starting location for Histories
 */
const START = '';
// Generic utils
/**
 * Normalizes a base by removing any trailing slash and reading the base tag if
 * present.
 *
 * @param base - base to normalize
 */
function normalizeBase(base) {
    if (!base) {
        if (isBrowser) {
            // respect <base> tag
            const baseEl = document.querySelector('base');
            base = (baseEl && baseEl.getAttribute('href')) || '/';
            // strip full URL origin
            base = base.replace(/^\w+:\/\/[^\/]+/, '');
        }
        else {
            base = '/';
        }
    }
    // ensure leading slash when it was removed by the regex above avoid leading
    // slash with hash because the file could be read from the disk like file://
    // and the leading slash would cause problems
    if (base[0] !== '/' && base[0] !== '#')
        base = '/' + base;
    // remove the trailing slash so all other method can just do `base + fullPath`
    // to build an href
    return removeTrailingSlash(base);
}
// remove any character before the hash
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location) {
    return base.replace(BEFORE_HASH_RE, '#') + location;
}

function getElementPosition(el, offset) {
    const docRect = document.documentElement.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    return {
        behavior: offset.behavior,
        left: elRect.left - docRect.left - (offset.left || 0),
        top: elRect.top - docRect.top - (offset.top || 0),
    };
}
const computeScrollPosition = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset,
});
function scrollToPosition(position) {
    let scrollToOptions;
    if ('el' in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');
        /**
         * `id`s can accept pretty much any characters, including CSS combinators
         * like `>` or `~`. It's still possible to retrieve elements using
         * `document.getElementById('~')` but it needs to be escaped when using
         * `document.querySelector('#\\~')` for it to be valid. The only
         * requirements for `id`s are them to be unique on the page and to not be
         * empty (`id=""`). Because of that, when passing an id selector, it should
         * be properly escaped for it to work with `querySelector`. We could check
         * for the id selector to be simple (no CSS combinators `+ >~`) but that
         * would make things inconsistent since they are valid characters for an
         * `id` but would need to be escaped when using `querySelector`, breaking
         * their usage and ending up in no selector returned. Selectors need to be
         * escaped:
         *
         * - `#1-thing` becomes `#\31 -thing`
         * - `#with~symbols` becomes `#with\\~symbols`
         *
         * - More information about  the topic can be found at
         *   https://mathiasbynens.be/notes/html5-id-class.
         * - Practical example: https://mathiasbynens.be/demo/html5-id
         */
        if (false) // removed by dead control flow
{}
        const el = typeof positionEl === 'string'
            ? isIdSelector
                ? document.getElementById(positionEl.slice(1))
                : document.querySelector(positionEl)
            : positionEl;
        if (!el) {
            ( false) &&
                0;
            return;
        }
        scrollToOptions = getElementPosition(el, position);
    }
    else {
        scrollToOptions = position;
    }
    if ('scrollBehavior' in document.documentElement.style)
        window.scrollTo(scrollToOptions);
    else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
    }
}
function getScrollKey(path, delta) {
    const position = history.state ? history.state.position - delta : -1;
    return position + path;
}
const scrollPositions = new Map();
function saveScrollPosition(key, scrollPosition) {
    scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
    const scroll = scrollPositions.get(key);
    // consume it so it's not used again
    scrollPositions.delete(key);
    return scroll;
}
// TODO: RFC about how to save scroll position
/**
 * ScrollBehavior instance used by the router to compute and restore the scroll
 * position when navigating.
 */
// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {
//   // returns a scroll position that can be saved in history
//   compute(): ScrollPositionEntry
//   // can take an extended ScrollPositionEntry
//   scroll(position: ScrollPosition): void
// }
// export const scrollHandler: ScrollHandler<ScrollPosition> = {
//   compute: computeScroll,
//   scroll: scrollToPosition,
// }

let createBaseLocation = () => location.protocol + '//' + location.host;
/**
 * Creates a normalized history location from a window.location object
 * @param location -
 */
function createCurrentLocation(base, location) {
    const { pathname, search, hash } = location;
    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end
    const hashPos = base.indexOf('#');
    if (hashPos > -1) {
        let slicePos = hash.includes(base.slice(hashPos))
            ? base.slice(hashPos).length
            : 1;
        let pathFromHash = hash.slice(slicePos);
        // prepend the starting slash to hash so the url starts with /#
        if (pathFromHash[0] !== '/')
            pathFromHash = '/' + pathFromHash;
        return stripBase(pathFromHash, '');
    }
    const path = stripBase(pathname, base);
    return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
    let listeners = [];
    let teardowns = [];
    // TODO: should it be a stack? a Dict. Check if the popstate listener
    // can trigger twice
    let pauseState = null;
    const popStateHandler = ({ state, }) => {
        const to = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
            currentLocation.value = to;
            historyState.value = state;
            // ignore the popstate and reset the pauseState
            if (pauseState && pauseState === from) {
                pauseState = null;
                return;
            }
            delta = fromState ? state.position - fromState.position : 0;
        }
        else {
            replace(to);
        }
        // console.log({ deltaFromCurrent })
        // Here we could also revert the navigation by calling history.go(-delta)
        // this listener will have to be adapted to not trigger again and to wait for the url
        // to be updated before triggering the listeners. Some kind of validation function would also
        // need to be passed to the listeners so the navigation can be accepted
        // call all listeners
        listeners.forEach(listener => {
            listener(currentLocation.value, from, {
                delta,
                type: NavigationType.pop,
                direction: delta
                    ? delta > 0
                        ? NavigationDirection.forward
                        : NavigationDirection.back
                    : NavigationDirection.unknown,
            });
        });
    };
    function pauseListeners() {
        pauseState = currentLocation.value;
    }
    function listen(callback) {
        // setup the listener and prepare teardown callbacks
        listeners.push(callback);
        const teardown = () => {
            const index = listeners.indexOf(callback);
            if (index > -1)
                listeners.splice(index, 1);
        };
        teardowns.push(teardown);
        return teardown;
    }
    function beforeUnloadListener() {
        const { history } = window;
        if (!history.state)
            return;
        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');
    }
    function destroy() {
        for (const teardown of teardowns)
            teardown();
        teardowns = [];
        window.removeEventListener('popstate', popStateHandler);
        window.removeEventListener('beforeunload', beforeUnloadListener);
    }
    // setup the listeners and prepare teardown callbacks
    window.addEventListener('popstate', popStateHandler);
    window.addEventListener('beforeunload', beforeUnloadListener);
    return {
        pauseListeners,
        listen,
        destroy,
    };
}
/**
 * Creates a state object
 */
function buildState(back, current, forward, replaced = false, computeScroll = false) {
    return {
        back,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null,
    };
}
function useHistoryStateNavigation(base) {
    const { history, location } = window;
    // private variables
    const currentLocation = {
        value: createCurrentLocation(base, location),
    };
    const historyState = { value: history.state };
    // build current history entry as this is a fresh navigation
    if (!historyState.value) {
        changeLocation(currentLocation.value, {
            back: null,
            current: currentLocation.value,
            forward: null,
            // the length is off by one, we need to decrease it
            position: history.length - 1,
            replaced: true,
            // don't add a scroll as the user may have an anchor and we want
            // scrollBehavior to be triggered without a saved position
            scroll: null,
        }, true);
    }
    function changeLocation(to, state, replace) {
        /**
         * if a base tag is provided and we are on a normal domain, we have to
         * respect the provided `base` attribute because pushState() will use it and
         * potentially erase anything before the `#` like at
         * https://github.com/vuejs/router/issues/685 where a base of
         * `/folder/#` but a base of `/` would erase the `/folder/` section. If
         * there is no host, the `<base>` tag makes no sense and if there isn't a
         * base tag we can just use everything after the `#`.
         */
        const hashIndex = base.indexOf('#');
        const url = hashIndex > -1
            ? (location.host && document.querySelector('base')
                ? base
                : base.slice(hashIndex)) + to
            : createBaseLocation() + base + to;
        try {
            // BROWSER QUIRK
            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds
            history[replace ? 'replaceState' : 'pushState'](state, '', url);
            historyState.value = state;
        }
        catch (err) {
            if ((false)) // removed by dead control flow
{}
            else {
                console.error(err);
            }
            // Force the navigation, this also resets the call count
            location[replace ? 'replace' : 'assign'](url);
        }
    }
    function replace(to, data) {
        const state = assign({}, history.state, buildState(historyState.value.back, 
        // keep back and forward entries but override current position
        to, historyState.value.forward, true), data, { position: historyState.value.position });
        changeLocation(to, state, true);
        currentLocation.value = to;
    }
    function push(to, data) {
        // Add to current entry the information of where we are going
        // as well as saving the current position
        const currentState = assign({}, 
        // use current history state to gracefully handle a wrong call to
        // history.replaceState
        // https://github.com/vuejs/router/issues/366
        historyState.value, history.state, {
            forward: to,
            scroll: computeScrollPosition(),
        });
        if (false) // removed by dead control flow
{}
        changeLocation(currentState.current, currentState, true);
        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
        changeLocation(to, state, false);
        currentLocation.value = to;
    }
    return {
        location: currentLocation,
        state: historyState,
        push,
        replace,
    };
}
/**
 * Creates an HTML5 history. Most common history for single page applications.
 *
 * @param base -
 */
function createWebHistory(base) {
    base = normalizeBase(base);
    const historyNavigation = useHistoryStateNavigation(base);
    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
    function go(delta, triggerListeners = true) {
        if (!triggerListeners)
            historyListeners.pauseListeners();
        history.go(delta);
    }
    const routerHistory = assign({
        // it's overridden right after
        location: '',
        base,
        go,
        createHref: createHref.bind(null, base),
    }, historyNavigation, historyListeners);
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => historyNavigation.location.value,
    });
    Object.defineProperty(routerHistory, 'state', {
        enumerable: true,
        get: () => historyNavigation.state.value,
    });
    return routerHistory;
}

/**
 * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.
 * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.
 *
 * @param base - Base applied to all urls, defaults to '/'
 * @returns a history object that can be passed to the router constructor
 */
function createMemoryHistory(base = '') {
    let listeners = [];
    let queue = [START];
    let position = 0;
    base = normalizeBase(base);
    function setLocation(location) {
        position++;
        if (position === queue.length) {
            // we are at the end, we can simply append a new entry
            queue.push(location);
        }
        else {
            // we are in the middle, we remove everything from here in the queue
            queue.splice(position);
            queue.push(location);
        }
    }
    function triggerListeners(to, from, { direction, delta }) {
        const info = {
            direction,
            delta,
            type: NavigationType.pop,
        };
        for (const callback of listeners) {
            callback(to, from, info);
        }
    }
    const routerHistory = {
        // rewritten by Object.defineProperty
        location: START,
        // TODO: should be kept in queue
        state: {},
        base,
        createHref: createHref.bind(null, base),
        replace(to) {
            // remove current entry and decrement position
            queue.splice(position--, 1);
            setLocation(to);
        },
        push(to, data) {
            setLocation(to);
        },
        listen(callback) {
            listeners.push(callback);
            return () => {
                const index = listeners.indexOf(callback);
                if (index > -1)
                    listeners.splice(index, 1);
            };
        },
        destroy() {
            listeners = [];
            queue = [START];
            position = 0;
        },
        go(delta, shouldTrigger = true) {
            const from = this.location;
            const direction = 
            // we are considering delta === 0 going forward, but in abstract mode
            // using 0 for the delta doesn't make sense like it does in html5 where
            // it reloads the page
            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
            position = Math.max(0, Math.min(position + delta, queue.length - 1));
            if (shouldTrigger) {
                triggerListeners(this.location, from, {
                    direction,
                    delta,
                });
            }
        },
    };
    Object.defineProperty(routerHistory, 'location', {
        enumerable: true,
        get: () => queue[position],
    });
    return routerHistory;
}

/**
 * Creates a hash history. Useful for web applications with no host (e.g.
 * `file://`) or when configuring a server to handle any URL is not possible.
 *
 * @param base - optional base to provide. Defaults to `location.pathname +
 * location.search` If there is a `<base>` tag in the `head`, its value will be
 * ignored in favor of this parameter **but note it affects all the
 * history.pushState() calls**, meaning that if you use a `<base>` tag, it's
 * `href` value **has to match this parameter** (ignoring anything after the
 * `#`).
 *
 * @example
 * ```js
 * // at https://example.com/folder
 * createWebHashHistory() // gives a url of `https://example.com/folder#`
 * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`
 * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`
 * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`
 * // you should avoid doing this because it changes the original url and breaks copying urls
 * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`
 *
 * // at file:///usr/etc/folder/index.html
 * // for locations with no `host`, the base is ignored
 * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`
 * ```
 */
function createWebHashHistory(base) {
    // Make sure this implementation is fine in terms of encoding, specially for IE11
    // for `file://`, directly use the pathname and ignore the base
    // location.pathname contains an initial `/` even at the root: `https://example.com`
    base = location.host ? base || location.pathname + location.search : '';
    // allow the user to provide a `#` in the middle: `/base/#/app`
    if (!base.includes('#'))
        base += '#';
    if (false) // removed by dead control flow
{}
    return createWebHistory(base);
}

function isRouteLocation(route) {
    return typeof route === 'string' || (route && typeof route === 'object');
}
function isRouteName(name) {
    return typeof name === 'string' || typeof name === 'symbol';
}

/**
 * Initial route location where the router is. Can be used in navigation guards
 * to differentiate the initial navigation.
 *
 * @example
 * ```js
 * import { START_LOCATION } from 'vue-router'
 *
 * router.beforeEach((to, from) => {
 *   if (from === START_LOCATION) {
 *     // initial navigation
 *   }
 * })
 * ```
 */
const START_LOCATION_NORMALIZED = {
    path: '/',
    name: undefined,
    params: {},
    query: {},
    hash: '',
    fullPath: '/',
    matched: [],
    meta: {},
    redirectedFrom: undefined,
};

const NavigationFailureSymbol = /*#__PURE__*/ PolySymbol(( false) ? 0 : 'nf');
/**
 * Enumeration with all possible types for navigation failures. Can be passed to
 * {@link isNavigationFailure} to check for specific failures.
 */
var NavigationFailureType;
(function (NavigationFailureType) {
    /**
     * An aborted navigation is a navigation that failed because a navigation
     * guard returned `false` or called `next(false)`
     */
    NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
    /**
     * A cancelled navigation is a navigation that failed because a more recent
     * navigation finished started (not necessarily finished).
     */
    NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
    /**
     * A duplicated navigation is a navigation that failed because it was
     * initiated while already being at the exact same location.
     */
    NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
// DEV only debug messages
const ErrorTypeMessages = {
    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {
        return `No match for\n ${JSON.stringify(location)}${currentLocation
            ? '\nwhile being at\n' + JSON.stringify(currentLocation)
            : ''}`;
    },
    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {
        return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
    },
    [4 /* NAVIGATION_ABORTED */]({ from, to }) {
        return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
    },
    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {
        return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
    },
    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {
        return `Avoided redundant navigation to current location: "${from.fullPath}".`;
    },
};
function createRouterError(type, params) {
    // keep full error messages in cjs versions
    if (false) // removed by dead control flow
{}
    else {
        return assign(new Error(), {
            type,
            [NavigationFailureSymbol]: true,
        }, params);
    }
}
function isNavigationFailure(error, type) {
    return (error instanceof Error &&
        NavigationFailureSymbol in error &&
        (type == null || !!(error.type & type)));
}
const propertiesToLog = ['params', 'query', 'hash'];
function stringifyRoute(to) {
    if (typeof to === 'string')
        return to;
    if ('path' in to)
        return to.path;
    const location = {};
    for (const key of propertiesToLog) {
        if (key in to)
            location[key] = to[key];
    }
    return JSON.stringify(location, null, 2);
}

// default pattern for a param: non greedy everything but /
const BASE_PARAM_PATTERN = '[^/]+?';
const BASE_PATH_PARSER_OPTIONS = {
    sensitive: false,
    strict: false,
    start: true,
    end: true,
};
// Special Regex characters that must be escaped in static tokens
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
/**
 * Creates a path parser from an array of Segments (a segment is an array of Tokens)
 *
 * @param segments - array of segments returned by tokenizePath
 * @param extraOptions - optional options for the regexp
 * @returns a PathParser
 */
function tokensToParser(segments, extraOptions) {
    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
    // the amount of scores is the same as the length of segments except for the root segment "/"
    const score = [];
    // the regexp as a string
    let pattern = options.start ? '^' : '';
    // extracted keys
    const keys = [];
    for (const segment of segments) {
        // the root segment needs special treatment
        const segmentScores = segment.length ? [] : [90 /* Root */];
        // allow trailing slash
        if (options.strict && !segment.length)
            pattern += '/';
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
            const token = segment[tokenIndex];
            // resets the score if we are inside a sub segment /:a-other-:b
            let subSegmentScore = 40 /* Segment */ +
                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);
            if (token.type === 0 /* Static */) {
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    pattern += '/';
                pattern += token.value.replace(REGEX_CHARS_RE, '\\$&');
                subSegmentScore += 40 /* Static */;
            }
            else if (token.type === 1 /* Param */) {
                const { value, repeatable, optional, regexp } = token;
                keys.push({
                    name: value,
                    repeatable,
                    optional,
                });
                const re = regexp ? regexp : BASE_PARAM_PATTERN;
                // the user provided a custom regexp /:id(\\d+)
                if (re !== BASE_PARAM_PATTERN) {
                    subSegmentScore += 10 /* BonusCustomRegExp */;
                    // make sure the regexp is valid before using it
                    try {
                        new RegExp(`(${re})`);
                    }
                    catch (err) {
                        throw new Error(`Invalid custom RegExp for param "${value}" (${re}): ` +
                            err.message);
                    }
                }
                // when we repeat we must take care of the repeating leading slash
                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;
                // prepend the slash if we are starting a new segment
                if (!tokenIndex)
                    subPattern =
                        // avoid an optional / if there are more segments e.g. /:p?-static
                        // or /:p?-:p2
                        optional && segment.length < 2
                            ? `(?:/${subPattern})`
                            : '/' + subPattern;
                if (optional)
                    subPattern += '?';
                pattern += subPattern;
                subSegmentScore += 20 /* Dynamic */;
                if (optional)
                    subSegmentScore += -8 /* BonusOptional */;
                if (repeatable)
                    subSegmentScore += -20 /* BonusRepeatable */;
                if (re === '.*')
                    subSegmentScore += -50 /* BonusWildcard */;
            }
            segmentScores.push(subSegmentScore);
        }
        // an empty array like /home/ -> [[{home}], []]
        // if (!segment.length) pattern += '/'
        score.push(segmentScores);
    }
    // only apply the strict bonus to the last score
    if (options.strict && options.end) {
        const i = score.length - 1;
        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;
    }
    // TODO: dev only warn double trailing slash
    if (!options.strict)
        pattern += '/?';
    if (options.end)
        pattern += '$';
    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else
    else if (options.strict)
        pattern += '(?:/|$)';
    const re = new RegExp(pattern, options.sensitive ? '' : 'i');
    function parse(path) {
        const match = path.match(re);
        const params = {};
        if (!match)
            return null;
        for (let i = 1; i < match.length; i++) {
            const value = match[i] || '';
            const key = keys[i - 1];
            params[key.name] = value && key.repeatable ? value.split('/') : value;
        }
        return params;
    }
    function stringify(params) {
        let path = '';
        // for optional parameters to allow to be empty
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
            if (!avoidDuplicatedSlash || !path.endsWith('/'))
                path += '/';
            avoidDuplicatedSlash = false;
            for (const token of segment) {
                if (token.type === 0 /* Static */) {
                    path += token.value;
                }
                else if (token.type === 1 /* Param */) {
                    const { value, repeatable, optional } = token;
                    const param = value in params ? params[value] : '';
                    if (Array.isArray(param) && !repeatable)
                        throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
                    const text = Array.isArray(param) ? param.join('/') : param;
                    if (!text) {
                        if (optional) {
                            // if we have more than one optional param like /:a?-static and there are more segments, we don't need to
                            // care about the optional param
                            if (segment.length < 2 && segments.length > 1) {
                                // remove the last slash as we could be at the end
                                if (path.endsWith('/'))
                                    path = path.slice(0, -1);
                                // do not append a slash on the next iteration
                                else
                                    avoidDuplicatedSlash = true;
                            }
                        }
                        else
                            throw new Error(`Missing required param "${value}"`);
                    }
                    path += text;
                }
            }
        }
        return path;
    }
    return {
        re,
        score,
        keys,
        parse,
        stringify,
    };
}
/**
 * Compares an array of numbers as used in PathParser.score and returns a
 * number. This function can be used to `sort` an array
 *
 * @param a - first array of numbers
 * @param b - second array of numbers
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 * should be sorted first
 */
function compareScoreArray(a, b) {
    let i = 0;
    while (i < a.length && i < b.length) {
        const diff = b[i] - a[i];
        // only keep going if diff === 0
        if (diff)
            return diff;
        i++;
    }
    // if the last subsegment was Static, the shorter segments should be sorted first
    // otherwise sort the longest segment first
    if (a.length < b.length) {
        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */
            ? -1
            : 1;
    }
    else if (a.length > b.length) {
        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */
            ? 1
            : -1;
    }
    return 0;
}
/**
 * Compare function that can be used with `sort` to sort an array of PathParser
 *
 * @param a - first PathParser
 * @param b - second PathParser
 * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b
 */
function comparePathParserScore(a, b) {
    let i = 0;
    const aScore = a.score;
    const bScore = b.score;
    while (i < aScore.length && i < bScore.length) {
        const comp = compareScoreArray(aScore[i], bScore[i]);
        // do not return if both are equal
        if (comp)
            return comp;
        i++;
    }
    if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
            return 1;
        if (isLastScoreNegative(bScore))
            return -1;
    }
    // if a and b share the same score entries but b has more, sort b first
    return bScore.length - aScore.length;
    // this is the ternary version
    // return aScore.length < bScore.length
    //   ? 1
    //   : aScore.length > bScore.length
    //   ? -1
    //   : 0
}
/**
 * This allows detecting splats at the end of a path: /home/:id(.*)*
 *
 * @param score - score to check
 * @returns true if the last entry is negative
 */
function isLastScoreNegative(score) {
    const last = score[score.length - 1];
    return score.length > 0 && last[last.length - 1] < 0;
}

const ROOT_TOKEN = {
    type: 0 /* Static */,
    value: '',
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
// After some profiling, the cache seems to be unnecessary because tokenizePath
// (the slowest part of adding a route) is very fast
// const tokenCache = new Map<string, Token[][]>()
function tokenizePath(path) {
    if (!path)
        return [[]];
    if (path === '/')
        return [[ROOT_TOKEN]];
    if (!path.startsWith('/')) {
        throw new Error(( false)
            ? 0
            : `Invalid path "${path}"`);
    }
    // if (tokenCache.has(path)) return tokenCache.get(path)!
    function crash(message) {
        throw new Error(`ERR (${state})/"${buffer}": ${message}`);
    }
    let state = 0 /* Static */;
    let previousState = state;
    const tokens = [];
    // the segment will always be valid because we get into the initial state
    // with the leading /
    let segment;
    function finalizeSegment() {
        if (segment)
            tokens.push(segment);
        segment = [];
    }
    // index on the path
    let i = 0;
    // char at index
    let char;
    // buffer of the value read
    let buffer = '';
    // custom regexp for a param
    let customRe = '';
    function consumeBuffer() {
        if (!buffer)
            return;
        if (state === 0 /* Static */) {
            segment.push({
                type: 0 /* Static */,
                value: buffer,
            });
        }
        else if (state === 1 /* Param */ ||
            state === 2 /* ParamRegExp */ ||
            state === 3 /* ParamRegExpEnd */) {
            if (segment.length > 1 && (char === '*' || char === '+'))
                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
            segment.push({
                type: 1 /* Param */,
                value: buffer,
                regexp: customRe,
                repeatable: char === '*' || char === '+',
                optional: char === '*' || char === '?',
            });
        }
        else {
            crash('Invalid state to consume buffer');
        }
        buffer = '';
    }
    function addCharToBuffer() {
        buffer += char;
    }
    while (i < path.length) {
        char = path[i++];
        if (char === '\\' && state !== 2 /* ParamRegExp */) {
            previousState = state;
            state = 4 /* EscapeNext */;
            continue;
        }
        switch (state) {
            case 0 /* Static */:
                if (char === '/') {
                    if (buffer) {
                        consumeBuffer();
                    }
                    finalizeSegment();
                }
                else if (char === ':') {
                    consumeBuffer();
                    state = 1 /* Param */;
                }
                else {
                    addCharToBuffer();
                }
                break;
            case 4 /* EscapeNext */:
                addCharToBuffer();
                state = previousState;
                break;
            case 1 /* Param */:
                if (char === '(') {
                    state = 2 /* ParamRegExp */;
                }
                else if (VALID_PARAM_RE.test(char)) {
                    addCharToBuffer();
                }
                else {
                    consumeBuffer();
                    state = 0 /* Static */;
                    // go back one character if we were not modifying
                    if (char !== '*' && char !== '?' && char !== '+')
                        i--;
                }
                break;
            case 2 /* ParamRegExp */:
                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)
                // it already works by escaping the closing )
                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#
                // is this really something people need since you can also write
                // /prefix_:p()_suffix
                if (char === ')') {
                    // handle the escaped )
                    if (customRe[customRe.length - 1] == '\\')
                        customRe = customRe.slice(0, -1) + char;
                    else
                        state = 3 /* ParamRegExpEnd */;
                }
                else {
                    customRe += char;
                }
                break;
            case 3 /* ParamRegExpEnd */:
                // same as finalizing a param
                consumeBuffer();
                state = 0 /* Static */;
                // go back one character if we were not modifying
                if (char !== '*' && char !== '?' && char !== '+')
                    i--;
                customRe = '';
                break;
            default:
                crash('Unknown state');
                break;
        }
    }
    if (state === 2 /* ParamRegExp */)
        crash(`Unfinished custom RegExp for param "${buffer}"`);
    consumeBuffer();
    finalizeSegment();
    // tokenCache.set(path, tokens)
    return tokens;
}

function createRouteRecordMatcher(record, parent, options) {
    const parser = tokensToParser(tokenizePath(record.path), options);
    // warn against params with the same name
    if ((false)) // removed by dead control flow
{}
    const matcher = assign(parser, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: [],
    });
    if (parent) {
        // both are aliases or both are not aliases
        // we don't want to mix them because the order is used when
        // passing originalRecord in Matcher.addRoute
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
            parent.children.push(matcher);
    }
    return matcher;
}

/**
 * Creates a Router Matcher.
 *
 * @internal
 * @param routes - array of initial routes
 * @param globalOptions - global route options
 */
function createRouterMatcher(routes, globalOptions) {
    // normalized ordered array of matchers
    const matchers = [];
    const matcherMap = new Map();
    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
    function getRecordMatcher(name) {
        return matcherMap.get(name);
    }
    function addRoute(record, parent, originalRecord) {
        // used later on to remove by name
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        // we might be the child of an alias
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        // generate an array of records to correctly handle aliases
        const normalizedRecords = [
            mainNormalizedRecord,
        ];
        if ('alias' in record) {
            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;
            for (const alias of aliases) {
                normalizedRecords.push(assign({}, mainNormalizedRecord, {
                    // this allows us to hold a copy of the `components` option
                    // so that async components cache is hold on the original record
                    components: originalRecord
                        ? originalRecord.record.components
                        : mainNormalizedRecord.components,
                    path: alias,
                    // we might be the child of an alias
                    aliasOf: originalRecord
                        ? originalRecord.record
                        : mainNormalizedRecord,
                    // the aliases are always of the same kind as the original since they
                    // are defined on the same record
                }));
            }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
            const { path } = normalizedRecord;
            // Build up the path for nested routes if the child isn't an absolute
            // route. Only add the / delimiter if the child path isn't empty and if the
            // parent path doesn't have a trailing slash
            if (parent && path[0] !== '/') {
                const parentPath = parent.record.path;
                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';
                normalizedRecord.path =
                    parent.record.path + (path && connectingSlash + path);
            }
            if (false) // removed by dead control flow
{}
            // create the object before hand so it can be passed to children
            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
            if (false)
                // removed by dead control flow
{}
            // if we are an alias we must tell the original record that we exist
            // so we can be removed
            if (originalRecord) {
                originalRecord.alias.push(matcher);
                if ((false)) // removed by dead control flow
{}
            }
            else {
                // otherwise, the first record is the original and others are aliases
                originalMatcher = originalMatcher || matcher;
                if (originalMatcher !== matcher)
                    originalMatcher.alias.push(matcher);
                // remove the route if named and only for the top record (avoid in nested calls)
                // this works because the original record is the first one
                if (isRootAdd && record.name && !isAliasRecord(matcher))
                    removeRoute(record.name);
            }
            if ('children' in mainNormalizedRecord) {
                const children = mainNormalizedRecord.children;
                for (let i = 0; i < children.length; i++) {
                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
                }
            }
            // if there was no original record, then the first one was not an alias and all
            // other alias (if any) need to reference this record when adding children
            originalRecord = originalRecord || matcher;
            // TODO: add normalized records for more flexibility
            // if (parent && isAliasRecord(originalRecord)) {
            //   parent.children.push(originalRecord)
            // }
            insertMatcher(matcher);
        }
        return originalMatcher
            ? () => {
                // since other matchers are aliases, they should be removed by the original matcher
                removeRoute(originalMatcher);
            }
            : noop;
    }
    function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
            const matcher = matcherMap.get(matcherRef);
            if (matcher) {
                matcherMap.delete(matcherRef);
                matchers.splice(matchers.indexOf(matcher), 1);
                matcher.children.forEach(removeRoute);
                matcher.alias.forEach(removeRoute);
            }
        }
        else {
            const index = matchers.indexOf(matcherRef);
            if (index > -1) {
                matchers.splice(index, 1);
                if (matcherRef.record.name)
                    matcherMap.delete(matcherRef.record.name);
                matcherRef.children.forEach(removeRoute);
                matcherRef.alias.forEach(removeRoute);
            }
        }
    }
    function getRoutes() {
        return matchers;
    }
    function insertMatcher(matcher) {
        let i = 0;
        while (i < matchers.length &&
            comparePathParserScore(matcher, matchers[i]) >= 0 &&
            // Adding children with empty path should still appear before the parent
            // https://github.com/vuejs/router/issues/1124
            (matcher.record.path !== matchers[i].record.path ||
                !isRecordChildOf(matcher, matchers[i])))
            i++;
        matchers.splice(i, 0, matcher);
        // only add the original record to the name map
        if (matcher.record.name && !isAliasRecord(matcher))
            matcherMap.set(matcher.record.name, matcher);
    }
    function resolve(location, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ('name' in location && location.name) {
            matcher = matcherMap.get(location.name);
            if (!matcher)
                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
                    location,
                });
            name = matcher.record.name;
            params = assign(
            // paramsFromLocation is a new object
            paramsFromLocation(currentLocation.params, 
            // only keep params that exist in the resolved location
            // TODO: only keep optional params coming from a parent record
            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);
            // throws if cannot be stringified
            path = matcher.stringify(params);
        }
        else if ('path' in location) {
            // no need to resolve the path with the matcher as it was provided
            // this also allows the user to control the encoding
            path = location.path;
            if (false) // removed by dead control flow
{}
            matcher = matchers.find(m => m.re.test(path));
            // matcher should have a value after the loop
            if (matcher) {
                // TODO: dev warning of unused params if provided
                // we know the matcher works because we tested the regexp
                params = matcher.parse(path);
                name = matcher.record.name;
            }
            // location is a relative path
        }
        else {
            // match by name or path of current route
            matcher = currentLocation.name
                ? matcherMap.get(currentLocation.name)
                : matchers.find(m => m.re.test(currentLocation.path));
            if (!matcher)
                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {
                    location,
                    currentLocation,
                });
            name = matcher.record.name;
            // since we are navigating to the same location, we don't need to pick the
            // params like when `name` is provided
            params = assign({}, currentLocation.params, location.params);
            path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
            // reversed order so parents are at the beginning
            matched.unshift(parentMatcher.record);
            parentMatcher = parentMatcher.parent;
        }
        return {
            name,
            path,
            params,
            matched,
            meta: mergeMetaFields(matched),
        };
    }
    // add initial routes
    routes.forEach(route => addRoute(route));
    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
    const newParams = {};
    for (const key of keys) {
        if (key in params)
            newParams[key] = params[key];
    }
    return newParams;
}
/**
 * Normalizes a RouteRecordRaw. Creates a copy
 *
 * @param record
 * @returns the normalized version
 */
function normalizeRouteRecord(record) {
    return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: undefined,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: new Set(),
        updateGuards: new Set(),
        enterCallbacks: {},
        components: 'components' in record
            ? record.components || {}
            : { default: record.component },
    };
}
/**
 * Normalize the optional `props` in a record to always be an object similar to
 * components. Also accept a boolean for components.
 * @param record
 */
function normalizeRecordProps(record) {
    const propsObject = {};
    // props does not exist on redirect records but we can set false directly
    const props = record.props || false;
    if ('component' in record) {
        propsObject.default = props;
    }
    else {
        // NOTE: we could also allow a function to be applied to every component.
        // Would need user feedback for use cases
        for (const name in record.components)
            propsObject[name] = typeof props === 'boolean' ? props : props[name];
    }
    return propsObject;
}
/**
 * Checks if a record or any of its parent is an alias
 * @param record
 */
function isAliasRecord(record) {
    while (record) {
        if (record.record.aliasOf)
            return true;
        record = record.parent;
    }
    return false;
}
/**
 * Merge meta fields of an array of records
 *
 * @param matched - array of matched records
 */
function mergeMetaFields(matched) {
    return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
    const options = {};
    for (const key in defaults) {
        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
    }
    return options;
}
function isSameParam(a, b) {
    return (a.name === b.name &&
        a.optional === b.optional &&
        a.repeatable === b.repeatable);
}
/**
 * Check if a path and its alias have the same required params
 *
 * @param a - original record
 * @param b - alias record
 */
function checkSameParams(a, b) {
    for (const key of a.keys) {
        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
    }
    for (const key of b.keys) {
        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))
            return warn(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key.name}"`);
    }
}
function checkMissingParamsInAbsolutePath(record, parent) {
    for (const key of parent.keys) {
        if (!record.keys.find(isSameParam.bind(null, key)))
            return warn(`Absolute path "${record.record.path}" should have the exact same param named "${key.name}" as its parent "${parent.record.path}".`);
    }
}
function isRecordChildOf(record, parent) {
    return parent.children.some(child => child === record || isRecordChildOf(record, child));
}

/**
 * Encoding Rules â£ = Space Path: â£ " < > # ? { } Query: â£ " < > # & = Hash: â£ "
 * < > `
 *
 * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)
 * defines some extra characters to be encoded. Most browsers do not encode them
 * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to
 * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)
 * plus `-._~`. This extra safety should be applied to query by patching the
 * string returned by encodeURIComponent encodeURI also encodes `[\]^`. `\`
 * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\`
 * into a `/` if directly typed in. The _backtick_ (`````) should also be
 * encoded everywhere because some browsers like FF encode it when directly
 * written while others don't. Safari and IE don't encode ``"<>{}``` in hash.
 */
// const EXTRA_RESERVED_RE = /[!'()*]/g
// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)
const HASH_RE = /#/g; // %23
const AMPERSAND_RE = /&/g; // %26
const SLASH_RE = /\//g; // %2F
const EQUAL_RE = /=/g; // %3D
const IM_RE = /\?/g; // %3F
const PLUS_RE = /\+/g; // %2B
/**
 * NOTE: It's not clear to me if we should encode the + symbol in queries, it
 * seems to be less flexible than not doing so and I can't find out the legacy
 * systems requiring this for regular requests like text/html. In the standard,
 * the encoding of the plus character is only mentioned for
 * application/x-www-form-urlencoded
 * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo
 * leave the plus character as is in queries. To be more flexible, we allow the
 * plus character on the query but it can also be manually encoded by the user.
 *
 * Resources:
 * - https://url.spec.whatwg.org/#urlencoded-parsing
 * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20
 */
const ENC_BRACKET_OPEN_RE = /%5B/g; // [
const ENC_BRACKET_CLOSE_RE = /%5D/g; // ]
const ENC_CARET_RE = /%5E/g; // ^
const ENC_BACKTICK_RE = /%60/g; // `
const ENC_CURLY_OPEN_RE = /%7B/g; // {
const ENC_PIPE_RE = /%7C/g; // |
const ENC_CURLY_CLOSE_RE = /%7D/g; // }
const ENC_SPACE_RE = /%20/g; // }
/**
 * Encode characters that need to be encoded on the path, search and hash
 * sections of the URL.
 *
 * @internal
 * @param text - string to encode
 * @returns encoded string
 */
function commonEncode(text) {
    return encodeURI('' + text)
        .replace(ENC_PIPE_RE, '|')
        .replace(ENC_BRACKET_OPEN_RE, '[')
        .replace(ENC_BRACKET_CLOSE_RE, ']');
}
/**
 * Encode characters that need to be encoded on the hash section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeHash(text) {
    return commonEncode(text)
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^');
}
/**
 * Encode characters that need to be encoded query values on the query
 * section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeQueryValue(text) {
    return (commonEncode(text)
        // Encode the space as +, encode the + to differentiate it from the space
        .replace(PLUS_RE, '%2B')
        .replace(ENC_SPACE_RE, '+')
        .replace(HASH_RE, '%23')
        .replace(AMPERSAND_RE, '%26')
        .replace(ENC_BACKTICK_RE, '`')
        .replace(ENC_CURLY_OPEN_RE, '{')
        .replace(ENC_CURLY_CLOSE_RE, '}')
        .replace(ENC_CARET_RE, '^'));
}
/**
 * Like `encodeQueryValue` but also encodes the `=` character.
 *
 * @param text - string to encode
 */
function encodeQueryKey(text) {
    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');
}
/**
 * Encode characters that need to be encoded on the path section of the URL.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodePath(text) {
    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');
}
/**
 * Encode characters that need to be encoded on the path section of the URL as a
 * param. This function encodes everything {@link encodePath} does plus the
 * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty
 * string instead.
 *
 * @param text - string to encode
 * @returns encoded string
 */
function encodeParam(text) {
    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');
}
/**
 * Decode text using `decodeURIComponent`. Returns the original text if it
 * fails.
 *
 * @param text - string to decode
 * @returns decoded string
 */
function decode(text) {
    try {
        return decodeURIComponent('' + text);
    }
    catch (err) {
        ( false) && 0;
    }
    return '' + text;
}

/**
 * Transforms a queryString into a {@link LocationQuery} object. Accept both, a
 * version with the leading `?` and without Should work as URLSearchParams

 * @internal
 *
 * @param search - search string to parse
 * @returns a query object
 */
function parseQuery(search) {
    const query = {};
    // avoid creating an object with an empty key and empty value
    // because of split('&')
    if (search === '' || search === '?')
        return query;
    const hasLeadingIM = search[0] === '?';
    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');
    for (let i = 0; i < searchParams.length; ++i) {
        // pre decode the + into space
        const searchParam = searchParams[i].replace(PLUS_RE, ' ');
        // allow the = character
        const eqPos = searchParam.indexOf('=');
        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key in query) {
            // an extra variable for ts types
            let currentValue = query[key];
            if (!Array.isArray(currentValue)) {
                currentValue = query[key] = [currentValue];
            }
            currentValue.push(value);
        }
        else {
            query[key] = value;
        }
    }
    return query;
}
/**
 * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it
 * doesn't prepend a `?`
 *
 * @internal
 *
 * @param query - query object to stringify
 * @returns string version of the query without the leading `?`
 */
function stringifyQuery(query) {
    let search = '';
    for (let key in query) {
        const value = query[key];
        key = encodeQueryKey(key);
        if (value == null) {
            // only null adds the value
            if (value !== undefined) {
                search += (search.length ? '&' : '') + key;
            }
            continue;
        }
        // keep null values
        const values = Array.isArray(value)
            ? value.map(v => v && encodeQueryValue(v))
            : [value && encodeQueryValue(value)];
        values.forEach(value => {
            // skip undefined values in arrays as if they were not present
            // smaller code than using filter
            if (value !== undefined) {
                // only append & with non-empty search
                search += (search.length ? '&' : '') + key;
                if (value != null)
                    search += '=' + value;
            }
        });
    }
    return search;
}
/**
 * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting
 * numbers into strings, removing keys with an undefined value and replacing
 * undefined with null in arrays
 *
 * @param query - query object to normalize
 * @returns a normalized query object
 */
function normalizeQuery(query) {
    const normalizedQuery = {};
    for (const key in query) {
        const value = query[key];
        if (value !== undefined) {
            normalizedQuery[key] = Array.isArray(value)
                ? value.map(v => (v == null ? null : '' + v))
                : value == null
                    ? value
                    : '' + value;
        }
    }
    return normalizedQuery;
}

/**
 * Create a list of callbacks that can be reset. Used to create before and after navigation guards list
 */
function useCallbacks() {
    let handlers = [];
    function add(handler) {
        handlers.push(handler);
        return () => {
            const i = handlers.indexOf(handler);
            if (i > -1)
                handlers.splice(i, 1);
        };
    }
    function reset() {
        handlers = [];
    }
    return {
        add,
        list: () => handlers,
        reset,
    };
}

function registerGuard(record, name, guard) {
    const removeFromList = () => {
        record[name].delete(guard);
    };
    onUnmounted(removeFromList);
    onDeactivated(removeFromList);
    onActivated(() => {
        record[name].add(guard);
    });
    record[name].add(guard);
}
/**
 * Add a navigation guard that triggers whenever the component for the current
 * location is about to be left. Similar to {@link beforeRouteLeave} but can be
 * used in any component. The guard is removed when the component is unmounted.
 *
 * @param leaveGuard - {@link NavigationGuard}
 */
function onBeforeRouteLeave(leaveGuard) {
    if (false) // removed by dead control flow
{}
    const activeRecord = inject(matchedRouteKey, 
    // to avoid warning
    {}).value;
    if (!activeRecord) {
        ( false) &&
            0;
        return;
    }
    registerGuard(activeRecord, 'leaveGuards', leaveGuard);
}
/**
 * Add a navigation guard that triggers whenever the current location is about
 * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any
 * component. The guard is removed when the component is unmounted.
 *
 * @param updateGuard - {@link NavigationGuard}
 */
function onBeforeRouteUpdate(updateGuard) {
    if (false) // removed by dead control flow
{}
    const activeRecord = inject(matchedRouteKey, 
    // to avoid warning
    {}).value;
    if (!activeRecord) {
        ( false) &&
            0;
        return;
    }
    registerGuard(activeRecord, 'updateGuards', updateGuard);
}
function guardToPromiseFn(guard, to, from, record, name) {
    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place
    const enterCallbackArray = record &&
        // name is defined if record is because of the function overload
        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
    return () => new Promise((resolve, reject) => {
        const next = (valid) => {
            if (valid === false)
                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {
                    from,
                    to,
                }));
            else if (valid instanceof Error) {
                reject(valid);
            }
            else if (isRouteLocation(valid)) {
                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {
                    from: to,
                    to: valid,
                }));
            }
            else {
                if (enterCallbackArray &&
                    // since enterCallbackArray is truthy, both record and name also are
                    record.enterCallbacks[name] === enterCallbackArray &&
                    typeof valid === 'function')
                    enterCallbackArray.push(valid);
                resolve();
            }
        };
        // wrapping with Promise.resolve allows it to work with both async and sync guards
        const guardReturn = guard.call(record && record.instances[name], to, from, ( false) ? 0 : next);
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
            guardCall = guardCall.then(next);
        if (false) // removed by dead control flow
{}
        guardCall.catch(err => reject(err));
    });
}
function canOnlyBeCalledOnce(next, to, from) {
    let called = 0;
    return function () {
        if (called++ === 1)
            warn(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
        // @ts-expect-error: we put it in the original one because it's easier to check
        next._called = true;
        if (called === 1)
            next.apply(null, arguments);
    };
}
function extractComponentsGuards(matched, guardType, to, from) {
    const guards = [];
    for (const record of matched) {
        for (const name in record.components) {
            let rawComponent = record.components[name];
            if ((false)) // removed by dead control flow
{}
            // skip update and leave guards if the route component is not mounted
            if (guardType !== 'beforeRouteEnter' && !record.instances[name])
                continue;
            if (isRouteComponent(rawComponent)) {
                // __vccOpts is added by vue-class-component and contain the regular options
                const options = rawComponent.__vccOpts || rawComponent;
                const guard = options[guardType];
                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
            }
            else {
                // start requesting the chunk already
                let componentPromise = rawComponent();
                if (false) // removed by dead control flow
{}
                guards.push(() => componentPromise.then(resolved => {
                    if (!resolved)
                        return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
                    const resolvedComponent = isESModule(resolved)
                        ? resolved.default
                        : resolved;
                    // replace the function with the resolved component
                    record.components[name] = resolvedComponent;
                    // __vccOpts is added by vue-class-component and contain the regular options
                    const options = resolvedComponent.__vccOpts || resolvedComponent;
                    const guard = options[guardType];
                    return guard && guardToPromiseFn(guard, to, from, record, name)();
                }));
            }
        }
    }
    return guards;
}
/**
 * Allows differentiating lazy components from functional components and vue-class-component
 *
 * @param component
 */
function isRouteComponent(component) {
    return (typeof component === 'object' ||
        'displayName' in component ||
        'props' in component ||
        '__vccOpts' in component);
}

// TODO: we could allow currentRoute as a prop to expose `isActive` and
// `isExactActive` behavior should go through an RFC
function useLink(props) {
    const router = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(routerKey);
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(routeLocationKey);
    const route = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => router.resolve((0,vue__WEBPACK_IMPORTED_MODULE_1__/* .unref */ .R1)(props.to)));
    const activeRecordIndex = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
            return -1;
        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index > -1)
            return index;
        // possible parent record
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
        // we are dealing with nested routes
        length > 1 &&
            // if the parent and matched route have the same path, this link is
            // referring to the empty child. Or we currently are on a different
            // child of the same parent
            getOriginalPath(routeMatched) === parentRecordPath &&
            // avoid comparing the child with its parent
            currentMatched[currentMatched.length - 1].path !== parentRecordPath
            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))
            : index);
    });
    const isActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => activeRecordIndex.value > -1 &&
        includesParams(currentRoute.params, route.value.params));
    const isExactActive = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => activeRecordIndex.value > -1 &&
        activeRecordIndex.value === currentRoute.matched.length - 1 &&
        isSameRouteLocationParams(currentRoute.params, route.value.params));
    function navigate(e = {}) {
        if (guardEvent(e)) {
            return router[(0,vue__WEBPACK_IMPORTED_MODULE_1__/* .unref */ .R1)(props.replace) ? 'replace' : 'push']((0,vue__WEBPACK_IMPORTED_MODULE_1__/* .unref */ .R1)(props.to)
            // avoid uncaught errors are they are logged anyway
            ).catch(noop);
        }
        return Promise.resolve();
    }
    // devtools only
    if (false) // removed by dead control flow
{}
    return {
        route,
        href: (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => route.value.href),
        isActive,
        isExactActive,
        navigate,
    };
}
const RouterLinkImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .defineComponent */ .pM)({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
        to: {
            type: [String, Object],
            required: true,
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: 'page',
        },
    },
    useLink,
    setup(props, { slots }) {
        const link = (0,vue__WEBPACK_IMPORTED_MODULE_1__/* .reactive */ .Kh)(useLink(props));
        const { options } = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(routerKey);
        const elClass = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => ({
            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,
            // [getLinkClass(
            //   props.inactiveClass,
            //   options.linkInactiveClass,
            //   'router-link-inactive'
            // )]: !link.isExactActive,
            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,
        }));
        return () => {
            const children = slots.default && slots.default(link);
            return props.custom
                ? children
                : (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('a', {
                    'aria-current': link.isExactActive
                        ? props.ariaCurrentValue
                        : null,
                    href: link.href,
                    // this would override user added attrs but Vue will still add
                    // the listener so we end up triggering both
                    onClick: link.navigate,
                    class: elClass.value,
                }, children);
        };
    },
});
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to render a link that triggers a navigation on click.
 */
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
    // don't redirect with control keys
    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
        return;
    // don't redirect when preventDefault called
    if (e.defaultPrevented)
        return;
    // don't redirect on right click
    if (e.button !== undefined && e.button !== 0)
        return;
    // don't redirect if `target="_blank"`
    // @ts-expect-error getAttribute does exist
    if (e.currentTarget && e.currentTarget.getAttribute) {
        // @ts-expect-error getAttribute exists
        const target = e.currentTarget.getAttribute('target');
        if (/\b_blank\b/i.test(target))
            return;
    }
    // this may be a Weex event which doesn't have this method
    if (e.preventDefault)
        e.preventDefault();
    return true;
}
function includesParams(outer, inner) {
    for (const key in inner) {
        const innerValue = inner[key];
        const outerValue = outer[key];
        if (typeof innerValue === 'string') {
            if (innerValue !== outerValue)
                return false;
        }
        else {
            if (!Array.isArray(outerValue) ||
                outerValue.length !== innerValue.length ||
                innerValue.some((value, i) => value !== outerValue[i]))
                return false;
        }
    }
    return true;
}
/**
 * Get the original path value of a record by following its aliasOf
 * @param record
 */
function getOriginalPath(record) {
    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';
}
/**
 * Utility class to get the active class based on defaults.
 * @param propClass
 * @param globalClass
 * @param defaultClass
 */
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null
    ? propClass
    : globalClass != null
        ? globalClass
        : defaultClass;

const RouterViewImpl = /*#__PURE__*/ (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .defineComponent */ .pM)({
    name: 'RouterView',
    // #674 we manually inherit them
    inheritAttrs: false,
    props: {
        name: {
            type: String,
            default: 'default',
        },
        route: Object,
    },
    // Better compat for @vue/compat users
    // https://github.com/vuejs/router/issues/1315
    compatConfig: { MODE: 3 },
    setup(props, { attrs, slots }) {
        ( false) && 0;
        const injectedRoute = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(routerViewLocationKey);
        const routeToDisplay = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => props.route || injectedRoute.value);
        const depth = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(viewDepthKey, 0);
        const matchedRouteRef = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => routeToDisplay.value.matched[depth]);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .provide */ .Gt)(viewDepthKey, depth + 1);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .provide */ .Gt)(matchedRouteKey, matchedRouteRef);
        (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .provide */ .Gt)(routerViewLocationKey, routeToDisplay);
        const viewRef = (0,vue__WEBPACK_IMPORTED_MODULE_1__/* .ref */ .KR)();
        // watch at the same time the component instance, the route record we are
        // rendering, and the name
        (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .watch */ .wB)(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
            // copy reused instances
            if (to) {
                // this will update the instance for new instances as well as reused
                // instances when navigating to a new route
                to.instances[name] = instance;
                // the component instance is reused for a different route or name so
                // we copy any saved update or leave guards. With async setup, the
                // mounting component will mount before the matchedRoute changes,
                // making instance === oldInstance, so we check if guards have been
                // added before. This works because we remove guards when
                // unmounting/deactivating components
                if (from && from !== to && instance && instance === oldInstance) {
                    if (!to.leaveGuards.size) {
                        to.leaveGuards = from.leaveGuards;
                    }
                    if (!to.updateGuards.size) {
                        to.updateGuards = from.updateGuards;
                    }
                }
            }
            // trigger beforeRouteEnter next callbacks
            if (instance &&
                to &&
                // if there is no instance but to and from are the same this might be
                // the first visit
                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));
            }
        }, { flush: 'post' });
        return () => {
            const route = routeToDisplay.value;
            const matchedRoute = matchedRouteRef.value;
            const ViewComponent = matchedRoute && matchedRoute.components[props.name];
            // we need the value at the time we render because when we unmount, we
            // navigated to a different location so the value is different
            const currentName = props.name;
            if (!ViewComponent) {
                return normalizeSlot(slots.default, { Component: ViewComponent, route });
            }
            // props from route configuration
            const routePropsOption = matchedRoute.props[props.name];
            const routeProps = routePropsOption
                ? routePropsOption === true
                    ? route.params
                    : typeof routePropsOption === 'function'
                        ? routePropsOption(route)
                        : routePropsOption
                : null;
            const onVnodeUnmounted = vnode => {
                // remove the instance reference to prevent leak
                if (vnode.component.isUnmounted) {
                    matchedRoute.instances[currentName] = null;
                }
            };
            const component = (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)(ViewComponent, assign({}, routeProps, attrs, {
                onVnodeUnmounted,
                ref: viewRef,
            }));
            if (false) // removed by dead control flow
{}
            return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) ||
                component);
        };
    },
});
function normalizeSlot(slot, data) {
    if (!slot)
        return null;
    const slotContent = slot(data);
    return slotContent.length === 1 ? slotContent[0] : slotContent;
}
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
/**
 * Component to display the current route the user is at.
 */
const RouterView = RouterViewImpl;
// warn against deprecated usage with <transition> & <keep-alive>
// due to functional component being no longer eager in Vue 3
function warnDeprecatedUsage() {
    const instance = getCurrentInstance();
    const parentName = instance.parent && instance.parent.type.name;
    if (parentName &&
        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {
        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';
        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\n` +
            `Use slot props instead:\n\n` +
            `<router-view v-slot="{ Component }">\n` +
            `  <${comp}>\n` +
            `    <component :is="Component" />\n` +
            `  </${comp}>\n` +
            `</router-view>`);
    }
}

function formatRouteLocation(routeLocation, tooltip) {
    const copy = assign({}, routeLocation, {
        // remove variables that can contain vue instances
        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),
    });
    return {
        _custom: {
            type: null,
            readOnly: true,
            display: routeLocation.fullPath,
            tooltip,
            value: copy,
        },
    };
}
function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
// to support multiple router instances
let routerId = 0;
function addDevtools(app, router, matcher) {
    // Take over router.beforeEach and afterEach
    // make sure we are not registering the devtool twice
    if (router.__hasDevtools)
        return;
    router.__hasDevtools = true;
    // increment to support multiple router instances
    const id = routerId++;
    setupDevtoolsPlugin({
        id: 'org.vuejs.router' + (id ? '.' + id : ''),
        label: 'Vue Router',
        packageName: 'vue-router',
        homepage: 'https://router.vuejs.org',
        logo: 'https://router.vuejs.org/logo.png',
        componentStateTypes: ['Routing'],
        app,
    }, api => {
        // display state added by the router
        api.on.inspectComponent((payload, ctx) => {
            if (payload.instanceData) {
                payload.instanceData.state.push({
                    type: 'Routing',
                    key: '$route',
                    editable: false,
                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),
                });
            }
        });
        // mark router-link as active and display tags on router views
        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {
            if (componentInstance.__vrv_devtools) {
                const info = componentInstance.__vrv_devtools;
                node.tags.push({
                    label: (info.name ? `${info.name.toString()}: ` : '') + info.path,
                    textColor: 0,
                    tooltip: 'This component is rendered by &lt;router-view&gt;',
                    backgroundColor: PINK_500,
                });
            }
            // if multiple useLink are used
            if (Array.isArray(componentInstance.__vrl_devtools)) {
                componentInstance.__devtoolsApi = api;
                componentInstance.__vrl_devtools.forEach(devtoolsData => {
                    let backgroundColor = ORANGE_400;
                    let tooltip = '';
                    if (devtoolsData.isExactActive) {
                        backgroundColor = LIME_500;
                        tooltip = 'This is exactly active';
                    }
                    else if (devtoolsData.isActive) {
                        backgroundColor = BLUE_600;
                        tooltip = 'This link is active';
                    }
                    node.tags.push({
                        label: devtoolsData.route.path,
                        textColor: 0,
                        tooltip,
                        backgroundColor,
                    });
                });
            }
        });
        watch(router.currentRoute, () => {
            // refresh active state
            refreshRoutesView();
            api.notifyComponentUpdate();
            api.sendInspectorTree(routerInspectorId);
            api.sendInspectorState(routerInspectorId);
        });
        const navigationsLayerId = 'router:navigations:' + id;
        api.addTimelineLayer({
            id: navigationsLayerId,
            label: `Router${id ? ' ' + id : ''} Navigations`,
            color: 0x40a8c4,
        });
        // const errorsLayerId = 'router:errors'
        // api.addTimelineLayer({
        //   id: errorsLayerId,
        //   label: 'Router Errors',
        //   color: 0xea5455,
        // })
        router.onError((error, to) => {
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'Error during Navigation',
                    subtitle: to.fullPath,
                    logType: 'error',
                    time: api.now(),
                    data: { error },
                    groupId: to.meta.__navigationId,
                },
            });
        });
        // attached to `meta` and used to group events
        let navigationId = 0;
        router.beforeEach((to, from) => {
            const data = {
                guard: formatDisplay('beforeEach'),
                from: formatRouteLocation(from, 'Current Location during this navigation'),
                to: formatRouteLocation(to, 'Target location'),
            };
            // Used to group navigations together, hide from devtools
            Object.defineProperty(to.meta, '__navigationId', {
                value: navigationId++,
            });
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    time: api.now(),
                    title: 'Start of navigation',
                    subtitle: to.fullPath,
                    data,
                    groupId: to.meta.__navigationId,
                },
            });
        });
        router.afterEach((to, from, failure) => {
            const data = {
                guard: formatDisplay('afterEach'),
            };
            if (failure) {
                data.failure = {
                    _custom: {
                        type: Error,
                        readOnly: true,
                        display: failure ? failure.message : '',
                        tooltip: 'Navigation Failure',
                        value: failure,
                    },
                };
                data.status = formatDisplay('â');
            }
            else {
                data.status = formatDisplay('â');
            }
            // we set here to have the right order
            data.from = formatRouteLocation(from, 'Current Location during this navigation');
            data.to = formatRouteLocation(to, 'Target location');
            api.addTimelineEvent({
                layerId: navigationsLayerId,
                event: {
                    title: 'End of navigation',
                    subtitle: to.fullPath,
                    time: api.now(),
                    data,
                    logType: failure ? 'warning' : 'default',
                    groupId: to.meta.__navigationId,
                },
            });
        });
        /**
         * Inspector of Existing routes
         */
        const routerInspectorId = 'router-inspector:' + id;
        api.addInspector({
            id: routerInspectorId,
            label: 'Routes' + (id ? ' ' + id : ''),
            icon: 'book',
            treeFilterPlaceholder: 'Search routes',
        });
        function refreshRoutesView() {
            // the routes view isn't active
            if (!activeRoutesPayload)
                return;
            const payload = activeRoutesPayload;
            // children routes will appear as nested
            let routes = matcher.getRoutes().filter(route => !route.parent);
            // reset match state to false
            routes.forEach(resetMatchStateOnRouteRecord);
            // apply a match state if there is a payload
            if (payload.filter) {
                routes = routes.filter(route => 
                // save matches state based on the payload
                isRouteMatching(route, payload.filter.toLowerCase()));
            }
            // mark active routes
            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));
            payload.rootNodes = routes.map(formatRouteRecordForInspector);
        }
        let activeRoutesPayload;
        api.on.getInspectorTree(payload => {
            activeRoutesPayload = payload;
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                refreshRoutesView();
            }
        });
        /**
         * Display information about the currently selected route record
         */
        api.on.getInspectorState(payload => {
            if (payload.app === app && payload.inspectorId === routerInspectorId) {
                const routes = matcher.getRoutes();
                const route = routes.find(route => route.record.__vd_id === payload.nodeId);
                if (route) {
                    payload.state = {
                        options: formatRouteRecordMatcherForStateInspector(route),
                    };
                }
            }
        });
        api.sendInspectorTree(routerInspectorId);
        api.sendInspectorState(routerInspectorId);
    });
}
function modifierForKey(key) {
    if (key.optional) {
        return key.repeatable ? '*' : '?';
    }
    else {
        return key.repeatable ? '+' : '';
    }
}
function formatRouteRecordMatcherForStateInspector(route) {
    const { record } = route;
    const fields = [
        { editable: false, key: 'path', value: record.path },
    ];
    if (record.name != null) {
        fields.push({
            editable: false,
            key: 'name',
            value: record.name,
        });
    }
    fields.push({ editable: false, key: 'regexp', value: route.re });
    if (route.keys.length) {
        fields.push({
            editable: false,
            key: 'keys',
            value: {
                _custom: {
                    type: null,
                    readOnly: true,
                    display: route.keys
                        .map(key => `${key.name}${modifierForKey(key)}`)
                        .join(' '),
                    tooltip: 'Param keys',
                    value: route.keys,
                },
            },
        });
    }
    if (record.redirect != null) {
        fields.push({
            editable: false,
            key: 'redirect',
            value: record.redirect,
        });
    }
    if (route.alias.length) {
        fields.push({
            editable: false,
            key: 'aliases',
            value: route.alias.map(alias => alias.record.path),
        });
    }
    fields.push({
        key: 'score',
        editable: false,
        value: {
            _custom: {
                type: null,
                readOnly: true,
                display: route.score.map(score => score.join(', ')).join(' | '),
                tooltip: 'Score used to sort routes',
                value: route.score,
            },
        },
    });
    return fields;
}
/**
 * Extracted from tailwind palette
 */
const PINK_500 = 0xec4899;
const BLUE_600 = 0x2563eb;
const LIME_500 = 0x84cc16;
const CYAN_400 = 0x22d3ee;
const ORANGE_400 = 0xfb923c;
// const GRAY_100 = 0xf4f4f5
const DARK = 0x666666;
function formatRouteRecordForInspector(route) {
    const tags = [];
    const { record } = route;
    if (record.name != null) {
        tags.push({
            label: String(record.name),
            textColor: 0,
            backgroundColor: CYAN_400,
        });
    }
    if (record.aliasOf) {
        tags.push({
            label: 'alias',
            textColor: 0,
            backgroundColor: ORANGE_400,
        });
    }
    if (route.__vd_match) {
        tags.push({
            label: 'matches',
            textColor: 0,
            backgroundColor: PINK_500,
        });
    }
    if (route.__vd_exactActive) {
        tags.push({
            label: 'exact',
            textColor: 0,
            backgroundColor: LIME_500,
        });
    }
    if (route.__vd_active) {
        tags.push({
            label: 'active',
            textColor: 0,
            backgroundColor: BLUE_600,
        });
    }
    if (record.redirect) {
        tags.push({
            label: 'redirect: ' +
                (typeof record.redirect === 'string' ? record.redirect : 'Object'),
            textColor: 0xffffff,
            backgroundColor: DARK,
        });
    }
    // add an id to be able to select it. Using the `path` is not possible because
    // empty path children would collide with their parents
    let id = record.__vd_id;
    if (id == null) {
        id = String(routeRecordId++);
        record.__vd_id = id;
    }
    return {
        id,
        label: record.path,
        tags,
        children: route.children.map(formatRouteRecordForInspector),
    };
}
//  incremental id for route records and inspector state
let routeRecordId = 0;
const EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
function markRouteRecordActive(route, currentRoute) {
    // no route will be active if matched is empty
    // reset the matching state
    const isExactActive = currentRoute.matched.length &&
        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);
    route.__vd_exactActive = route.__vd_active = isExactActive;
    if (!isExactActive) {
        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));
    }
    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));
}
function resetMatchStateOnRouteRecord(route) {
    route.__vd_match = false;
    route.children.forEach(resetMatchStateOnRouteRecord);
}
function isRouteMatching(route, filter) {
    const found = String(route.re).match(EXTRACT_REGEXP_RE);
    route.__vd_match = false;
    if (!found || found.length < 3) {
        return false;
    }
    // use a regexp without $ at the end to match nested routes better
    const nonEndingRE = new RegExp(found[1].replace(/\$$/, ''), found[2]);
    if (nonEndingRE.test(filter)) {
        // mark children as matches
        route.children.forEach(child => isRouteMatching(child, filter));
        // exception case: `/`
        if (route.record.path !== '/' || filter === '/') {
            route.__vd_match = route.re.test(filter);
            return true;
        }
        // hide the / route
        return false;
    }
    const path = route.record.path.toLowerCase();
    const decodedPath = decode(path);
    // also allow partial matching on the path
    if (!filter.startsWith('/') &&
        (decodedPath.includes(filter) || path.includes(filter)))
        return true;
    if (decodedPath.startsWith(filter) || path.startsWith(filter))
        return true;
    if (route.record.name && String(route.record.name).includes(filter))
        return true;
    return route.children.some(child => isRouteMatching(child, filter));
}
function omit(obj, keys) {
    const ret = {};
    for (const key in obj) {
        if (!keys.includes(key)) {
            // @ts-expect-error
            ret[key] = obj[key];
        }
    }
    return ret;
}

/**
 * Creates a Router instance that can be used by a Vue app.
 *
 * @param options - {@link RouterOptions}
 */
function createRouter(options) {
    const matcher = createRouterMatcher(options.routes, options);
    const parseQuery$1 = options.parseQuery || parseQuery;
    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
    const routerHistory = options.history;
    if (false)
        // removed by dead control flow
{}
    const beforeGuards = useCallbacks();
    const beforeResolveGuards = useCallbacks();
    const afterGuards = useCallbacks();
    const currentRoute = (0,vue__WEBPACK_IMPORTED_MODULE_1__/* .shallowRef */ .IJ)(START_LOCATION_NORMALIZED);
    let pendingLocation = START_LOCATION_NORMALIZED;
    // leave the scrollRestoration if no scrollBehavior is provided
    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }
    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);
    const encodeParams = applyToParams.bind(null, encodeParam);
    const decodeParams = 
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode);
    function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
            parent = matcher.getRecordMatcher(parentOrRoute);
            record = route;
        }
        else {
            record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
    }
    function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
            matcher.removeRoute(recordMatcher);
        }
        else if ((false)) // removed by dead control flow
{}
    }
    function getRoutes() {
        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);
    }
    function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
    }
    function resolve(rawLocation, currentLocation) {
        // const objectLocation = routerLocationAsObject(rawLocation)
        // we create a copy to modify it later
        currentLocation = assign({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === 'string') {
            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);
            const href = routerHistory.createHref(locationNormalized.fullPath);
            if ((false)) // removed by dead control flow
{}
            // locationNormalized is always a new object
            return assign(locationNormalized, matchedRoute, {
                params: decodeParams(matchedRoute.params),
                hash: decode(locationNormalized.hash),
                redirectedFrom: undefined,
                href,
            });
        }
        let matcherLocation;
        // path could be relative in object as well
        if ('path' in rawLocation) {
            if (false) // removed by dead control flow
{}
            matcherLocation = assign({}, rawLocation, {
                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,
            });
        }
        else {
            // remove any nullish param
            const targetParams = assign({}, rawLocation.params);
            for (const key in targetParams) {
                if (targetParams[key] == null) {
                    delete targetParams[key];
                }
            }
            // pass encoded values to the matcher so it can produce encoded path and fullPath
            matcherLocation = assign({}, rawLocation, {
                params: encodeParams(rawLocation.params),
            });
            // current location params are decoded, we need to encode them in case the
            // matcher merges the params
            currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash = rawLocation.hash || '';
        if (false) // removed by dead control flow
{}
        // decoding them) the matcher might have merged current location params so
        // we need to run the decoding again
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
            hash: encodeHash(hash),
            path: matchedRoute.path,
        }));
        const href = routerHistory.createHref(fullPath);
        if ((false)) // removed by dead control flow
{}
        return assign({
            fullPath,
            // keep the hash encoded so fullPath is effectively path + encodedQuery +
            // hash
            hash,
            query: 
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery
                ? normalizeQuery(rawLocation.query)
                : (rawLocation.query || {}),
        }, matchedRoute, {
            redirectedFrom: undefined,
            href,
        });
    }
    function locationAsObject(to) {
        return typeof to === 'string'
            ? parseURL(parseQuery$1, to, currentRoute.value.path)
            : assign({}, to);
    }
    function checkCanceledNavigation(to, from) {
        if (pendingLocation !== to) {
            return createRouterError(8 /* NAVIGATION_CANCELLED */, {
                from,
                to,
            });
        }
    }
    function push(to) {
        return pushWithRedirect(to);
    }
    function replace(to) {
        return push(assign(locationAsObject(to), { replace: true }));
    }
    function handleRedirectRecord(to) {
        const lastMatched = to.matched[to.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
            const { redirect } = lastMatched;
            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;
            if (typeof newTargetLocation === 'string') {
                newTargetLocation =
                    newTargetLocation.includes('?') || newTargetLocation.includes('#')
                        ? (newTargetLocation = locationAsObject(newTargetLocation))
                        : // force empty params
                            { path: newTargetLocation };
                // @ts-expect-error: force empty params when a string is passed to let
                // the router parse them again
                newTargetLocation.params = {};
            }
            if (false) // removed by dead control flow
{}
            return assign({
                query: to.query,
                hash: to.hash,
                params: to.params,
            }, newTargetLocation);
        }
    }
    function pushWithRedirect(to, redirectedFrom) {
        const targetLocation = (pendingLocation = resolve(to));
        const from = currentRoute.value;
        const data = to.state;
        const force = to.force;
        // to could be a string where `replace` is a function
        const replace = to.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
                state: data,
                force,
                replace,
            }), 
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation);
        // if it was a redirect we already called `pushWithRedirect` above
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });
            // trigger scroll to allow scrolling to the same anchor
            handleScroll(from, from, 
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true, 
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false);
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))
            .catch((error) => isNavigationFailure(error)
            ? // navigation redirects still mark the router as ready
                isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)
                    ? error
                    : markAsReady(error) // also returns the error
            : // reject any unknown error
                triggerError(error, toLocation, from))
            .then((failure) => {
            if (failure) {
                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
                    if (false) // removed by dead control flow
{}
                    return pushWithRedirect(
                    // keep options
                    assign(locationAsObject(failure.to), {
                        state: data,
                        force,
                        replace,
                    }), 
                    // preserve the original redirectedFrom if any
                    redirectedFrom || toLocation);
                }
            }
            else {
                // if we fail we don't finalize the navigation
                failure = finalizeNavigation(toLocation, from, true, replace, data);
            }
            triggerAfterEach(toLocation, from, failure);
            return failure;
        });
    }
    /**
     * Helper to reject and skip all navigation guards if a new navigation happened
     * @param to
     * @param from
     */
    function checkCanceledNavigationAndReject(to, from) {
        const error = checkCanceledNavigation(to, from);
        return error ? Promise.reject(error) : Promise.resolve();
    }
    // TODO: refactor the whole before guards by internally using router.beforeEach
    function navigate(to, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
        // all components here have been resolved once because we are leaving
        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);
        // leavingRecords is already reversed
        for (const record of leavingRecords) {
            record.leaveGuards.forEach(guard => {
                guards.push(guardToPromiseFn(guard, to, from));
            });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
        guards.push(canceledNavigationCheck);
        // run the queue of per route beforeRouteLeave guards
        return (runGuardQueue(guards)
            .then(() => {
            // check global guards beforeEach
            guards = [];
            for (const guard of beforeGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            .then(() => {
            // check in components beforeRouteUpdate
            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);
            for (const record of updatingRecords) {
                record.updateGuards.forEach(guard => {
                    guards.push(guardToPromiseFn(guard, to, from));
                });
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check the route beforeEnter
            guards = [];
            for (const record of to.matched) {
                // do not trigger beforeEnter on reused views
                if (record.beforeEnter && !from.matched.includes(record)) {
                    if (Array.isArray(record.beforeEnter)) {
                        for (const beforeEnter of record.beforeEnter)
                            guards.push(guardToPromiseFn(beforeEnter, to, from));
                    }
                    else {
                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));
                    }
                }
            }
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>
            // clear existing enterCallbacks, these are added by extractComponentsGuards
            to.matched.forEach(record => (record.enterCallbacks = {}));
            // check in-component beforeRouteEnter
            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);
            guards.push(canceledNavigationCheck);
            // run the queue of per route beforeEnter guards
            return runGuardQueue(guards);
        })
            .then(() => {
            // check global guards beforeResolve
            guards = [];
            for (const guard of beforeResolveGuards.list()) {
                guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
        })
            // catch any navigation canceled
            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)
            ? err
            : Promise.reject(err)));
    }
    function triggerAfterEach(to, from, failure) {
        // navigation is confirmed, call afterGuards
        // TODO: wrap with error handlers
        for (const guard of afterGuards.list())
            guard(to, from, failure);
    }
    /**
     * - Cleans up any navigation guards
     * - Changes the url if necessary
     * - Calls the scrollBehavior
     */
    function finalizeNavigation(toLocation, from, isPush, replace, data) {
        // a more recent navigation took place
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
            return error;
        // only consider as push if it's not the first navigation
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        // change URL only if the user did a push/replace and if it's not the initial navigation because
        // it's just reflecting the url
        if (isPush) {
            // on the initial navigation, we want to reuse the scroll position from
            // history state if it exists
            if (replace || isFirstNavigation)
                routerHistory.replace(toLocation.fullPath, assign({
                    scroll: isFirstNavigation && state && state.scroll,
                }, data));
            else
                routerHistory.push(toLocation.fullPath, data);
        }
        // accept current navigation
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
    }
    let removeHistoryListener;
    // attach listener to history to trigger navigations
    function setupListeners() {
        // avoid setting up listeners twice due to an invalid first navigation
        if (removeHistoryListener)
            return;
        removeHistoryListener = routerHistory.listen((to, _from, info) => {
            // cannot be a redirect route because it was in history
            const toLocation = resolve(to);
            // due to dynamic routing, and to hash history with manual navigation
            // (manually changing the url or calling history.hash = '#/somewhere'),
            // there could be a redirect record in history
            const shouldRedirect = handleRedirectRecord(toLocation);
            if (shouldRedirect) {
                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
                return;
            }
            pendingLocation = toLocation;
            const from = currentRoute.value;
            // TODO: should be moved to web history?
            if (isBrowser) {
                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
            }
            navigate(toLocation, from)
                .catch((error) => {
                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {
                    return error;
                }
                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {
                    // Here we could call if (info.delta) routerHistory.go(-info.delta,
                    // false) but this is bug prone as we have no way to wait the
                    // navigation to be finished before calling pushWithRedirect. Using
                    // a setTimeout of 16ms seems to work but there is not guarantee for
                    // it to work on every browser. So Instead we do not restore the
                    // history entry and trigger a new navigation as requested by the
                    // navigation guard.
                    // the error is already handled by router.push we just want to avoid
                    // logging the error
                    pushWithRedirect(error.to, toLocation
                    // avoid an uncaught rejection, let push call triggerError
                    )
                        .then(failure => {
                        // manual change in hash history #916 ending up in the URL not
                        // changing but it was changed by the manual url change, so we
                        // need to manually change it ourselves
                        if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ |
                            16 /* NAVIGATION_DUPLICATED */) &&
                            !info.delta &&
                            info.type === NavigationType.pop) {
                            routerHistory.go(-1, false);
                        }
                    })
                        .catch(noop);
                    // avoid the then branch
                    return Promise.reject();
                }
                // do not restore history on unknown direction
                if (info.delta)
                    routerHistory.go(-info.delta, false);
                // unrecognized error, transfer to the global handler
                return triggerError(error, toLocation, from);
            })
                .then((failure) => {
                failure =
                    failure ||
                        finalizeNavigation(
                        // after navigation, all matched components are resolved
                        toLocation, from, false);
                // revert the navigation
                if (failure) {
                    if (info.delta) {
                        routerHistory.go(-info.delta, false);
                    }
                    else if (info.type === NavigationType.pop &&
                        isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {
                        // manual change in hash history #916
                        // it's like a push but lacks the information of the direction
                        routerHistory.go(-1, false);
                    }
                }
                triggerAfterEach(toLocation, from, failure);
            })
                .catch(noop);
        });
    }
    // Initialization and Errors
    let readyHandlers = useCallbacks();
    let errorHandlers = useCallbacks();
    let ready;
    /**
     * Trigger errorHandlers added via onError and throws the error as well
     *
     * @param error - error to throw
     * @param to - location we were navigating to when the error happened
     * @param from - location we were navigating from when the error happened
     * @returns the error as a rejected promise
     */
    function triggerError(error, to, from) {
        markAsReady(error);
        const list = errorHandlers.list();
        if (list.length) {
            list.forEach(handler => handler(error, to, from));
        }
        else {
            if ((false)) // removed by dead control flow
{}
            console.error(error);
        }
        return Promise.reject(error);
    }
    function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            readyHandlers.add([resolve, reject]);
        });
    }
    function markAsReady(err) {
        if (!ready) {
            // still not ready if an error happened
            ready = !err;
            setupListeners();
            readyHandlers
                .list()
                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));
            readyHandlers.reset();
        }
        return err;
    }
    // Scroll behavior
    function handleScroll(to, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
            return Promise.resolve();
        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||
            ((isFirstNavigation || !isPush) &&
                history.state &&
                history.state.scroll) ||
            null;
        return (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .nextTick */ .dY)()
            .then(() => scrollBehavior(to, from, scrollPosition))
            .then(position => position && scrollToPosition(position))
            .catch(err => triggerError(err, to, from));
    }
    const go = (delta) => routerHistory.go(delta);
    let started;
    const installedApps = new Set();
    const router = {
        currentRoute,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve,
        options,
        push,
        replace,
        go,
        back: () => go(-1),
        forward: () => go(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorHandlers.add,
        isReady,
        install(app) {
            const router = this;
            app.component('RouterLink', RouterLink);
            app.component('RouterView', RouterView);
            app.config.globalProperties.$router = router;
            Object.defineProperty(app.config.globalProperties, '$route', {
                enumerable: true,
                get: () => (0,vue__WEBPACK_IMPORTED_MODULE_1__/* .unref */ .R1)(currentRoute),
            });
            // this initial navigation is only necessary on client, on server it doesn't
            // make sense because it will create an extra unnecessary navigation and could
            // lead to problems
            if (isBrowser &&
                // used for the initial navigation client side to avoid pushing
                // multiple times when the router is used in multiple apps
                !started &&
                currentRoute.value === START_LOCATION_NORMALIZED) {
                // see above
                started = true;
                push(routerHistory.location).catch(err => {
                    if ((false))
                        // removed by dead control flow
{}
                });
            }
            const reactiveRoute = {};
            for (const key in START_LOCATION_NORMALIZED) {
                // @ts-expect-error: the key matches
                reactiveRoute[key] = (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .computed */ .EW)(() => currentRoute.value[key]);
            }
            app.provide(routerKey, router);
            app.provide(routeLocationKey, (0,vue__WEBPACK_IMPORTED_MODULE_1__/* .reactive */ .Kh)(reactiveRoute));
            app.provide(routerViewLocationKey, currentRoute);
            const unmountApp = app.unmount;
            installedApps.add(app);
            app.unmount = function () {
                installedApps.delete(app);
                // the router is not attached to an app anymore
                if (installedApps.size < 1) {
                    // invalidate the current navigation
                    pendingLocation = START_LOCATION_NORMALIZED;
                    removeHistoryListener && removeHistoryListener();
                    removeHistoryListener = null;
                    currentRoute.value = START_LOCATION_NORMALIZED;
                    started = false;
                    ready = false;
                }
                unmountApp();
            };
            if (false) // removed by dead control flow
{}
        },
    };
    return router;
}
function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
    const leavingRecords = [];
    const updatingRecords = [];
    const enteringRecords = [];
    const len = Math.max(from.matched.length, to.matched.length);
    for (let i = 0; i < len; i++) {
        const recordFrom = from.matched[i];
        if (recordFrom) {
            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))
                updatingRecords.push(recordFrom);
            else
                leavingRecords.push(recordFrom);
        }
        const recordTo = to.matched[i];
        if (recordTo) {
            // the type doesn't matter because we are comparing per reference
            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {
                enteringRecords.push(recordTo);
            }
        }
    }
    return [leavingRecords, updatingRecords, enteringRecords];
}

/**
 * Returns the router instance. Equivalent to using `$router` inside
 * templates.
 */
function useRouter() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(routerKey);
}
/**
 * Returns the current route location. Equivalent to using `$route` inside
 * templates.
 */
function useRoute() {
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__/* .inject */ .WQ)(routeLocationKey);
}




/***/ }),

/***/ 6262:
/***/ (function(__unused_webpack_module, exports) {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
// runtime helper for setting properties on components
// in a tree-shakable way
exports.A = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ 6278:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  y$: function() { return /* binding */ createStore; },
  Pj: function() { return /* binding */ useStore; }
});

// UNUSED EXPORTS: Store, createLogger, createNamespacedHelpers, default, mapActions, mapGetters, mapMutations, mapState, storeKey

// EXTERNAL MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var runtime_core_esm_bundler = __webpack_require__(641);
// EXTERNAL MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(953);
;// ./node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
    // @ts-expect-error navigator and windows are not available in all environments
    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : {};
}
const isProxyAvailable = typeof Proxy === 'function';

;// ./node_modules/@vue/devtools-api/lib/esm/const.js
const HOOK_SETUP = 'devtools-plugin:setup';
const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';

;// ./node_modules/@vue/devtools-api/lib/esm/time.js
let supported;
let perf;
function isPerformanceSupported() {
    var _a;
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else if (typeof globalThis !== 'undefined' && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
        supported = true;
        perf = globalThis.perf_hooks.performance;
    }
    else {
        supported = false;
    }
    return supported;
}
function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
}

;// ./node_modules/@vue/devtools-api/lib/esm/proxy.js


class ApiProxy {
    constructor(plugin, hook) {
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) {
            for (const id in plugin.settings) {
                const item = plugin.settings[id];
                defaultSettings[id] = item.defaultValue;
            }
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
            const raw = localStorage.getItem(localSettingsSaveId);
            const data = JSON.parse(raw);
            Object.assign(currentSettings, data);
        }
        catch (e) {
            // noop
        }
        this.fallbacks = {
            getSettings() {
                return currentSettings;
            },
            setSettings(value) {
                try {
                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
                }
                catch (e) {
                    // noop
                }
                currentSettings = value;
            },
            now() {
                return now();
            },
        };
        if (hook) {
            hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
                if (pluginId === this.plugin.id) {
                    this.fallbacks.setSettings(value);
                }
            });
        }
        this.proxiedOn = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target.on[prop];
                }
                else {
                    return (...args) => {
                        this.onQueue.push({
                            method: prop,
                            args,
                        });
                    };
                }
            },
        });
        this.proxiedTarget = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target[prop];
                }
                else if (prop === 'on') {
                    return this.proxiedOn;
                }
                else if (Object.keys(this.fallbacks).includes(prop)) {
                    return (...args) => {
                        this.targetQueue.push({
                            method: prop,
                            args,
                            resolve: () => { },
                        });
                        return this.fallbacks[prop](...args);
                    };
                }
                else {
                    return (...args) => {
                        return new Promise((resolve) => {
                            this.targetQueue.push({
                                method: prop,
                                args,
                                resolve,
                            });
                        });
                    };
                }
            },
        });
    }
    async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue) {
            this.target.on[item.method](...item.args);
        }
        for (const item of this.targetQueue) {
            item.resolve(await this.target[item.method](...item.args));
        }
    }
}

;// ./node_modules/@vue/devtools-api/lib/esm/index.js






function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    }
    else {
        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
            pluginDescriptor: descriptor,
            setupFn,
            proxy,
        });
        if (proxy) {
            setupFn(proxy.proxiedTarget);
        }
    }
}

;// ./node_modules/vuex/dist/vuex.esm-bundler.js
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */



var storeKey = 'store';

function useStore (key) {
  if ( key === void 0 ) key = null;

  return (0,runtime_core_esm_bundler/* inject */.WQ)(key !== null ? key : storeKey)
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function find (list, f) {
  return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
  if ( cache === void 0 ) cache = [];

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  var hit = find(cache, function (c) { return c.original === obj; });
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {};
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset state
  resetStoreState(store, state, hot);
}

function resetStoreState (store, state, hot) {
  var oldState = store._state;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldState.
    // using partial to return function with only arguments preserved in closure environment.
    computedObj[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      // TODO: use `computed` when it's possible. at the moment we can't due to
      // https://github.com/vuejs/vuex/pull/1883
      get: function () { return computedObj[key](); },
      enumerable: true // for local getters
    });
  });

  store._state = (0,reactivity_esm_bundler/* reactive */.Kh)({
    data: state
  });

  // enable strict mode for new state
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldState) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldState.data = null;
      });
    }
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && ("production" !== 'production')) // removed by dead control flow
{}
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if ((false)) // removed by dead control flow
{}
      parentState[moduleName] = module.state;
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) // removed by dead control flow
{}
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) // removed by dead control flow
{}
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by state update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if ((false)) // removed by dead control flow
{}
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  (0,runtime_core_esm_bundler/* watch */.wB)(function () { return store._state.data; }, function () {
    if ((false)) // removed by dead control flow
{}
  }, { deep: true, flush: 'sync' });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if ((false)) // removed by dead control flow
{}

  return { type: type, payload: payload, options: options }
}

var LABEL_VUEX_BINDINGS = 'vuex bindings';
var MUTATIONS_LAYER_ID = 'vuex:mutations';
var ACTIONS_LAYER_ID = 'vuex:actions';
var INSPECTOR_ID = 'vuex';

var actionId = 0;

function addDevtools (app, store) {
  setupDevtoolsPlugin(
    {
      id: 'org.vuejs.vuex',
      app: app,
      label: 'Vuex',
      homepage: 'https://next.vuex.vuejs.org/',
      logo: 'https://vuejs.org/images/icons/favicon-96x96.png',
      packageName: 'vuex',
      componentStateTypes: [LABEL_VUEX_BINDINGS]
    },
    function (api) {
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: 'Vuex Mutations',
        color: COLOR_LIME_500
      });

      api.addTimelineLayer({
        id: ACTIONS_LAYER_ID,
        label: 'Vuex Actions',
        color: COLOR_LIME_500
      });

      api.addInspector({
        id: INSPECTOR_ID,
        label: 'Vuex',
        icon: 'storage',
        treeFilterPlaceholder: 'Filter stores...'
      });

      api.on.getInspectorTree(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          if (payload.filter) {
            var nodes = [];
            flattenStoreForInspectorTree(nodes, store._modules.root, payload.filter, '');
            payload.rootNodes = nodes;
          } else {
            payload.rootNodes = [
              formatStoreForInspectorTree(store._modules.root, '')
            ];
          }
        }
      });

      api.on.getInspectorState(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          makeLocalGetters(store, modulePath);
          payload.state = formatStoreForInspectorState(
            getStoreModule(store._modules, modulePath),
            modulePath === 'root' ? store.getters : store._makeLocalGettersCache,
            modulePath
          );
        }
      });

      api.on.editInspectorState(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          var path = payload.path;
          if (modulePath !== 'root') {
            path = modulePath.split('/').filter(Boolean).concat( path);
          }
          store._withCommit(function () {
            payload.set(store._state.data, path, payload.state.value);
          });
        }
      });

      store.subscribe(function (mutation, state) {
        var data = {};

        if (mutation.payload) {
          data.payload = mutation.payload;
        }

        data.state = state;

        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);

        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: mutation.type,
            data: data
          }
        });
      });

      store.subscribeAction({
        before: function (action, state) {
          var data = {};
          if (action.payload) {
            data.payload = action.payload;
          }
          action._id = actionId++;
          action._time = Date.now();
          data.state = state;

          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: action._time,
              title: action.type,
              groupId: action._id,
              subtitle: 'start',
              data: data
            }
          });
        },
        after: function (action, state) {
          var data = {};
          var duration = Date.now() - action._time;
          data.duration = {
            _custom: {
              type: 'duration',
              display: (duration + "ms"),
              tooltip: 'Action duration',
              value: duration
            }
          };
          if (action.payload) {
            data.payload = action.payload;
          }
          data.state = state;

          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: Date.now(),
              title: action.type,
              groupId: action._id,
              subtitle: 'end',
              data: data
            }
          });
        }
      });
    }
  );
}

// extracted from tailwind palette
var COLOR_LIME_500 = 0x84cc16;
var COLOR_DARK = 0x666666;
var COLOR_WHITE = 0xffffff;

var TAG_NAMESPACED = {
  label: 'namespaced',
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};

/**
 * @param {string} path
 */
function extractNameFromPath (path) {
  return path && path !== 'root' ? path.split('/').slice(-2, -1)[0] : 'Root'
}

/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorNode}
 */
function formatStoreForInspectorTree (module, path) {
  return {
    id: path || 'root',
    // all modules end with a `/`, we want the last segment only
    // cart/ -> cart
    // nested/cart/ -> cart
    label: extractNameFromPath(path),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(function (moduleName) { return formatStoreForInspectorTree(
        module._children[moduleName],
        path + moduleName + '/'
      ); }
    )
  }
}

/**
 * @param {import('@vue/devtools-api').CustomInspectorNode[]} result
 * @param {*} module
 * @param {string} filter
 * @param {string} path
 */
function flattenStoreForInspectorTree (result, module, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || 'root',
      label: path.endsWith('/') ? path.slice(0, path.length - 1) : path || 'Root',
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module._children).forEach(function (moduleName) {
    flattenStoreForInspectorTree(result, module._children[moduleName], filter, path + moduleName + '/');
  });
}

/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorState}
 */
function formatStoreForInspectorState (module, getters, path) {
  getters = path === 'root' ? getters : getters[path];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module.state).map(function (key) { return ({
      key: key,
      editable: true,
      value: module.state[key]
    }); })
  };

  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree).map(function (key) { return ({
      key: key.endsWith('/') ? extractNameFromPath(key) : key,
      editable: false,
      value: canThrow(function () { return tree[key]; })
    }); });
  }

  return storeState
}

function transformPathsToObjectTree (getters) {
  var result = {};
  Object.keys(getters).forEach(function (key) {
    var path = key.split('/');
    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function (p) {
        if (!target[p]) {
          target[p] = {
            _custom: {
              value: {},
              display: p,
              tooltip: 'Module',
              abstract: true
            }
          };
        }
        target = target[p]._custom.value;
      });
      target[leafKey] = canThrow(function () { return getters[key]; });
    } else {
      result[key] = canThrow(function () { return getters[key]; });
    }
  });
  return result
}

function getStoreModule (moduleMap, path) {
  var names = path.split('/').filter(function (n) { return n; });
  return names.reduce(
    function (module, moduleName, i) {
      var child = module[moduleName];
      if (!child) {
        throw new Error(("Missing module \"" + moduleName + "\" for path \"" + path + "\"."))
      }
      return i === names.length - 1 ? child : child._children
    },
    path === 'root' ? moduleMap : moduleMap.root._children
  )
}

function canThrow (cb) {
  try {
    return cb()
  } catch (e) {
    return e
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: { configurable: true } };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
  return key in this._children
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if ((false)) // removed by dead control flow
{}

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if ((false)) // removed by dead control flow
{}
    return
  }

  if (!child.runtime) {
    return
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key)
  }

  return false
};

function update (path, targetModule, newModule) {
  if ((false)) // removed by dead control flow
{}

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if ((false)) // removed by dead control flow
{}
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

function createStore (options) {
  return new Store(options)
}

var Store = function Store (options) {
  var this$1$1 = this;
  if ( options === void 0 ) options = {};

  if ((false)) // removed by dead control flow
{}

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;
  var devtools = options.devtools;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = Object.create(null);
  this._devtools = devtools;

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store state, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreState(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1$1); });
};

var prototypeAccessors = { state: { configurable: true } };

Store.prototype.install = function install (app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;

  var useDevtools = this._devtools !== undefined
    ? this._devtools
    : ( false) || false;

  if (useDevtools) {
    addDevtools(app, this);
  }
};

prototypeAccessors.state.get = function () {
  return this._state.data
};

prototypeAccessors.state.set = function (v) {
  if ((false)) // removed by dead control flow
{}
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if ((false)) // removed by dead control flow
{}
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1$1.state); });

  if (
    false
  ) // removed by dead control flow
{}
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if ((false)) // removed by dead control flow
{}
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1$1.state); });
  } catch (e) {
    if ((false)) // removed by dead control flow
{}
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1$1.state); });
      } catch (e) {
        if ((false)) // removed by dead control flow
{}
      }
      resolve(res);
    }, function (error) {
      try {
        this$1$1._actionSubscribers
          .filter(function (sub) { return sub.error; })
          .forEach(function (sub) { return sub.error(action, this$1$1.state, error); });
      } catch (e) {
        if ((false)) // removed by dead control flow
{}
      }
      reject(error);
    });
  })
};

Store.prototype.subscribe = function subscribe (fn, options) {
  return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch$1 (getter, cb, options) {
    var this$1$1 = this;

  if ((false)) // removed by dead control flow
{}
  return (0,runtime_core_esm_bundler/* watch */.wB)(function () { return getter(this$1$1.state, this$1$1.getters); }, cb, Object.assign({}, options))
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1$1 = this;

  this._withCommit(function () {
    this$1$1._state.data = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if ((false)) // removed by dead control flow
{}

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreState(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if ((false)) // removed by dead control flow
{}

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
  if (typeof path === 'string') { path = [path]; }

  if ((false)) // removed by dead control flow
{}

  return this._modules.isRegistered(path)
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if (false) // removed by dead control flow
{}
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if (false) // removed by dead control flow
{}
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if (false) // removed by dead control flow
{}
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (false) // removed by dead control flow
{}
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if (false) // removed by dead control flow
{}
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (false) // removed by dead control flow
{}
  return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
  if ( ref === void 0 ) ref = {};
  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
  var logger = ref.logger; if ( logger === void 0 ) logger = console;

  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + (mutation.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + (action.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  }
}

function startMessage (logger, message, collapsed) {
  var startMessage = collapsed
    ? logger.groupCollapsed
    : logger.group;

  // render
  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage (logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('ââ log end ââ');
  }
}

function getFormattedTime () {
  var time = new Date();
  return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
  return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num
}

var index = {
  version: '4.0.2',
  Store: Store,
  storeKey: storeKey,
  createStore: createStore,
  useStore: useStore,
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};

/* harmony default export */ var vuex_esm_bundler = ((/* unused pure expression or super */ null && (index)));



/***/ }),

/***/ 6347:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(1883);
var toIndexedObject = __webpack_require__(5476);
var indexOf = (__webpack_require__(8186).indexOf);
var hiddenKeys = __webpack_require__(7708);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 6492:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var path = __webpack_require__(9720);
var global = __webpack_require__(200);

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 6539:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toInteger = __webpack_require__(7317);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 6843:
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 6885:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var aFunction = __webpack_require__(9085);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 6926:
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 7168:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(2074);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 7317:
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 7485:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);
var createNonEnumerableProperty = __webpack_require__(7712);
var has = __webpack_require__(1883);
var setGlobal = __webpack_require__(5975);
var inspectSource = __webpack_require__(9965);
var InternalStateModule = __webpack_require__(9206);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 7632:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(5077);
var propertyIsEnumerableModule = __webpack_require__(9304);
var createPropertyDescriptor = __webpack_require__(6843);
var toIndexedObject = __webpack_require__(5476);
var toPrimitive = __webpack_require__(874);
var has = __webpack_require__(1883);
var IE8_DOM_DEFINE = __webpack_require__(7694);

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 7694:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(5077);
var fails = __webpack_require__(2074);
var createElement = __webpack_require__(3262);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 7708:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 7712:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(5077);
var definePropertyModule = __webpack_require__(3610);
var createPropertyDescriptor = __webpack_require__(6843);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 7970:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var has = __webpack_require__(1883);
var toObject = __webpack_require__(2612);
var sharedKey = __webpack_require__(5904);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(7168);

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 8186:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(5476);
var toLength = __webpack_require__(3747);
var toAbsoluteIndex = __webpack_require__(6539);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 8569:
/***/ (function(module) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 8664:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var fails = __webpack_require__(2074);
var classof = __webpack_require__(8569);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 8736:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ installer; }
});

// EXTERNAL MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var runtime_core_esm_bundler = __webpack_require__(641);
// EXTERNAL MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(953);
;// ./node_modules/@vuemap/vue-amap-util/dist/index.mjs


function isMapInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.Map;
}
function isOverlayGroupInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.OverlayGroup;
}
function isIndoorMapInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.IndoorMap;
}
function isLabelsLayerInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.LabelsLayer;
}
function isVectorLayerInstance(instance) {
  if (!instance) {
    return false;
  }
  return instance instanceof AMap.VectorLayer;
}
function convertEventToLowerCase(functionName) {
  if (!functionName || functionName.length < 4) {
    return functionName;
  }
  const func = functionName.substring(3, functionName.length);
  const firstLetter = functionName[2].toLowerCase();
  return firstLetter + func;
}
const eventReg = /^on[A-Z]+/;
function loadScript(url, callback) {
  if (!url) {
    throw new Error("\u8BF7\u4F20\u5165url");
  }
  const script = document.createElement("script");
  script.type = "text/javascript";
  script.async = true;
  script.defer = true;
  script.src = url;
  document.body.appendChild(script);
  if (callback) {
    script.addEventListener("load", () => {
      callback();
    });
  }
}
function convertLnglat(lnglat) {
  if (Array.isArray(lnglat)) {
    return lnglat.map(convertLnglat);
  }
  return lnglat.toArray();
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var camelcase = function () {
	var str = [].map.call(arguments, function (str) {
		return str.trim();
	}).filter(function (str) {
		return str.length;
	}).join('-');

	if (!str.length) {
		return '';
	}

	if (str.length === 1 || !(/[_.\- ]+/).test(str) ) {
		if (str[0] === str[0].toLowerCase() && str.slice(1) !== str.slice(1).toLowerCase()) {
			return str;
		}

		return str.toLowerCase();
	}

	return str
	.replace(/^[_.\- ]+/, '')
	.toLowerCase()
	.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
		return p1.toUpperCase();
	});
};

var camelCase = camelcase;

var uppercamelcase = function () {
	var cased = camelCase.apply(camelCase, arguments);
	return cased.charAt(0).toUpperCase() + cased.slice(1);
};

var upperCamelCase = /*@__PURE__*/getDefaultExportFromCjs(uppercamelcase);

let eventHelper;
class EventHelper {
  constructor() {
    this._listener = /* @__PURE__ */ new Map();
  }
  addListener(instance, eventName, handler, context) {
    if (!AMap)
      throw new Error("please wait for Map API load");
    if (!instance.on) {
      return;
    }
    instance.on(eventName, handler, context);
    if (!this._listener.get(instance))
      this._listener.set(instance, {});
    const listenerMap = this._listener.get(instance);
    if (!listenerMap[eventName])
      listenerMap[eventName] = [];
    listenerMap[eventName].push(handler);
  }
  removeListener(instance, eventName, handler) {
    if (!AMap)
      throw new Error("please wait for Map API load");
    if (!instance.off) {
      return;
    }
    if (!this._listener.get(instance) || !this._listener.get(instance)[eventName])
      return;
    const listenerArr = this._listener.get(instance)[eventName];
    if (handler) {
      const lIndex = listenerArr.indexOf(handler);
      instance.off(eventName, listenerArr[lIndex]);
      listenerArr.splice(lIndex, 1);
    } else {
      listenerArr.forEach((listener) => {
        instance.off(eventName, listener);
      });
      this._listener.get(instance)[eventName] = [];
    }
  }
  addListenerOnce(instance, eventName, handler, context) {
    return instance.on(eventName, handler, context, true);
  }
  trigger(instance, eventName, args) {
    return instance.emit(eventName, args);
  }
  clearListeners(instance) {
    const listeners = this._listener.get(instance);
    if (!listeners)
      return;
    Object.keys(listeners).map((eventName) => {
      instance.clearEvents(eventName);
    });
  }
}
eventHelper = eventHelper || new EventHelper();
var eventHelper$1 = eventHelper;

var registerComponent = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  inject: {
    parentInstance: {
      default: null
    }
  },
  inheritAttrs: false,
  props: {
    visible: {
      type: Boolean,
      default: true
    },
    // æ¯å¦æ¾ç¤ºï¼é»è®¤ true
    zIndex: {
      type: Number
    },
    reEventWhenUpdate: {
      type: Boolean,
      default: false
    },
    // æ¯å¦å¨ç»ä»¶æ´æ°æ¶éæ°æ³¨åäºä»¶ï¼ä¸»è¦ç¨äºæ°ç»æ´æ°æ¶ï¼ç»å®äºäºä»¶ä½äºä»¶çå¯¹è±¡ä¸ä¼æ´æ°é®é¢
    extraOptions: {
      type: Object
    }
    // é¢å¤æ©å±å±æ§
  },
  emits: ["init"],
  data() {
    return {
      needInitComponents: [],
      unwatchFns: [],
      propsRedirect: {},
      converters: {},
      isDestroy: false,
      cacheEvents: {},
      isMounted: false
    };
  },
  created() {
    this.$amapComponent = null;
    this.$parentComponent = null;
  },
  mounted() {
    if (this.parentInstance) {
      if (this.parentInstance.$amapComponent) {
        this.register();
      } else {
        this.parentInstance.addChildComponent(this);
      }
    }
  },
  beforeUnmount() {
    if (!this.$amapComponent)
      return;
    this.unregisterEvents();
    this.unwatchFns.forEach((item) => item());
    this.unwatchFns = [];
    this.destroyComponent();
    this.isDestroy = true;
  },
  beforeUpdate() {
    if (this.reEventWhenUpdate && this.isMounted && this.$amapComponent) {
      this.unregisterEvents();
    }
  },
  updated() {
    if (this.reEventWhenUpdate && this.isMounted && this.$amapComponent) {
      this.registerEvents();
    }
  },
  methods: {
    getHandlerFun(prop) {
      if (this[`__${prop}`]) {
        return this[`__${prop}`];
      }
      if (!this.$amapComponent) {
        return null;
      }
      return this.$amapComponent[`set${upperCamelCase(prop)}`];
    },
    convertProps() {
      const props = {};
      const { $props, propsRedirect } = this;
      if (this.extraOptions) {
        Object.assign(props, this.extraOptions);
      }
      const result = Object.keys($props).reduce((res, _key) => {
        let key = _key;
        const propsValue = this.convertSignalProp(key, $props[key]);
        if (propsValue === void 0)
          return res;
        if (propsRedirect && propsRedirect[_key])
          key = propsRedirect[key];
        props[key] = propsValue;
        return res;
      }, props);
      Object.keys(result).forEach((key) => {
        result[key] = this.convertProxyToRaw(result[key]);
      });
      return result;
    },
    convertProxyToRaw(value) {
      if ((0,reactivity_esm_bundler/* isProxy */.ju)(value)) {
        return (0,reactivity_esm_bundler/* toRaw */.ux)(value);
      }
      return (0,reactivity_esm_bundler/* unref */.R1)(value);
    },
    convertSignalProp(key, sourceData) {
      if (this.converters && this.converters[key]) {
        return this.converters[key].call(this, sourceData);
      }
      return sourceData;
    },
    registerEvents() {
      const $props = this.$attrs;
      Object.keys($props).forEach((key) => {
        if (eventReg.test(key)) {
          const eventKey = convertEventToLowerCase(key);
          eventHelper$1.addListener(this.$amapComponent, eventKey, $props[key]);
          this.cacheEvents[eventKey] = $props[key];
        }
      });
    },
    unregisterEvents() {
      Object.keys(this.cacheEvents).forEach((eventKey) => {
        eventHelper$1.removeListener(this.$amapComponent, eventKey, this.cacheEvents[eventKey]);
        delete this.cacheEvents[eventKey];
      });
    },
    setPropWatchers() {
      const { propsRedirect, $props } = this;
      Object.keys($props).forEach((prop) => {
        let handleProp = prop;
        if (propsRedirect && propsRedirect[prop])
          handleProp = propsRedirect[prop];
        const handleFun = this.getHandlerFun(handleProp);
        if (!handleFun)
          return;
        const watchOptions = {
          deep: false
        };
        const propValueType = Object.prototype.toString.call($props[prop]);
        if (propValueType === "[object Object]" || propValueType === "[object Array]") {
          watchOptions.deep = true;
        }
        const unwatch = this.$watch(prop, (nv) => {
          handleFun.call(this.$amapComponent, this.convertProxyToRaw(this.convertSignalProp(prop, nv)));
        }, watchOptions);
        this.unwatchFns.push(unwatch);
      });
    },
    // some prop can not init by initial created methods
    initProps() {
      const props = ["editable", "visible", "zooms"];
      props.forEach((propStr) => {
        if (this[propStr] !== void 0) {
          const handleFun = this.getHandlerFun(propStr);
          handleFun && handleFun.call(this.$amapComponent, this.convertProxyToRaw(this.convertSignalProp(propStr, this[propStr])));
        }
      });
    },
    lazyRegister() {
      const $parent = this.parentInstance;
      if ($parent && $parent.addChildComponent) {
        $parent.addChildComponent(this);
      }
    },
    addChildComponent(component) {
      this.needInitComponents.push(component);
    },
    createChildren() {
      while (this.needInitComponents.length > 0) {
        this.needInitComponents[0].register();
        this.needInitComponents.splice(0, 1);
      }
    },
    register() {
      if (this.parentInstance && !this.$parentComponent) {
        this.$parentComponent = this.parentInstance.$amapComponent;
      }
      const res = this["__initComponent"] && this["__initComponent"](this.convertProps());
      if (res && res.then)
        res.then((instance) => this.registerRest(instance));
      else
        this.registerRest(res);
    },
    registerRest(instance) {
      if (!this.$amapComponent && instance)
        this.$amapComponent = instance;
      this.registerEvents();
      this.initProps();
      this.setPropWatchers();
      this.$emit("init", this.$amapComponent, this);
      this.$nextTick(() => {
        this.createChildren();
      });
      this.isMounted = true;
    },
    // helper method
    $$getInstance() {
      return this.$amapComponent;
    },
    destroyComponent() {
      this.$amapComponent.setMap && this.$amapComponent.setMap(null);
      this.$amapComponent.close && this.$amapComponent.close();
      this.$amapComponent.editor && this.$amapComponent.editor.close();
    },
    __visible(flag) {
      if (!!this.$amapComponent && !!this.$amapComponent.show && !!this.$amapComponent.hide) {
        flag === false ? this.$amapComponent.hide() : this.$amapComponent.show();
      }
    },
    __zIndex(value) {
      if (this.$amapComponent && this.$amapComponent.setzIndex) {
        this.$amapComponent.setzIndex(value);
      }
    }
  }
});

function guid() {
  const s = [];
  const hexDigits = "0123456789abcdef";
  for (let i = 0; i < 36; i++) {
    s[i] = hexDigits.substr(Math.floor(Math.random() * 16), 1);
  }
  s[14] = "4";
  s[19] = hexDigits.substr(s[19] & 3 | 8, 1);
  s[8] = s[13] = s[18] = s[23] = "-";
  return s.join("");
}

function toPixel(arr) {
  return new AMap.Pixel(arr[0], arr[1]);
}
function toSize(arr) {
  return new AMap.Size(arr[0], arr[1]);
}
function pixelTo(pixel) {
  if (Array.isArray(pixel))
    return pixel;
  return [pixel.getX(), pixel.getY()];
}
function toLngLat(arr) {
  return new AMap.LngLat(arr[0], arr[1]);
}
function lngLatTo(lngLat) {
  if (!lngLat)
    return;
  if (Array.isArray(lngLat))
    return lngLat.slice();
  return [lngLat.getLng(), lngLat.getLat()];
}
function toBounds(arrs) {
  return new AMap.Bounds(toLngLat(arrs[0]), toLngLat(arrs[1]));
}

const withInstall = (main, extra) => {
  main.install = (app) => {
    for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key, comp] of Object.entries(extra)) {
      main[key] = comp;
    }
  }
  return main;
};
const withInstallFunction = (fn, name) => {
  fn.install = (app) => {
    app.config.globalProperties[name] = fn;
  };
  return fn;
};

const makeInstaller = (components = []) => {
  const apps = [];
  const install = (app) => {
    if (apps.includes(app))
      return;
    apps.push(app);
    components.forEach((c) => app.use(c));
  };
  return {
    install
  };
};


//# sourceMappingURL=index.mjs.map

// EXTERNAL MODULE: ./node_modules/@vuemap/vue-amap/es/services/injected-amap-api-instance.mjs + 2 modules
var injected_amap_api_instance = __webpack_require__(4287);
;// ./node_modules/@vuemap/vue-amap/es/packages/amap/amap.vue2.mjs





var script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmap",
  mixins: [registerComponent],
  provide() {
    return {
      parentInstance: this
    };
  },
  props: {
    vid: {
      type: String
    },
    // å°å¾ID
    center: {
      type: Array
    },
    // åå§ä¸­å¿ç»çº¬åº¦
    zoom: {
      type: Number
    },
    // å°å¾æ¾ç¤ºçç¼©æ¾çº§å«ï¼å¯ä»¥è®¾ç½®ä¸ºæµ®ç¹æ°ï¼è¥centerä¸levelæªèµå¼ï¼å°å¾åå§åé»è®¤æ¾ç¤ºç¨æ·æå¨åå¸èå´ã
    rotation: {
      type: Number
    },
    // å°å¾é¡ºæ¶éæè½¬è§åº¦ï¼åå¼èå´ [0-360] ï¼é»è®¤å¼ï¼0
    pitch: {
      type: Number
    },
    // ä¿¯ä»°è§åº¦ï¼é»è®¤ 0ï¼æå¤§å¼æ ¹æ®å°å¾å½å zoom çº§å«ä¸æ­å¢å¤§ï¼2Då°å¾ä¸æ æ ã
    viewMode: {
      type: String
    },
    // å°å¾è§å¾æ¨¡å¼, é»è®¤ä¸ºâ2Dâï¼å¯éâ3Dâï¼éæ©â3Dâä¼æ¾ç¤º 3D å°å¾ææã
    features: {
      type: Array
    },
    // è®¾ç½®å°å¾ä¸æ¾ç¤ºçåç´ ç§ç±», æ¯æ'bg'ï¼å°å¾èæ¯ï¼ã'point'ï¼POIç¹ï¼ã'road'ï¼éè·¯ï¼ã'building'ï¼å»ºç­ç©ï¼ï¼é»è®¤å¼ï¼['bg','point','road','building']
    layers: {
      type: Array
    },
    // å°å¾å¾å±æ°ç»ï¼æ°ç»å¯ä»¥æ¯å¾å± ä¸­çä¸ä¸ªæå¤ä¸ªï¼é»è®¤ä¸ºæ®éäºç»´å°å¾ã å½å å å¤ä¸ª å¾å± æ¶ï¼æ®éäºç»´å°å¾ééè¿å®ä¾åä¸ä¸ªTileLayerç±»å®ç°ã å¦æä½ å¸æåå»ºä¸ä¸ªé»è®¤åºå¾å¾å±ï¼ä½¿ç¨ AMap.createDefaultLayer()
    zooms: {
      type: Array
    },
    // å¾æ¾ç¤ºçç¼©æ¾çº§å«èå´, é»è®¤ä¸º [2, 20] ï¼åå¼èå´ [2 ~ 30]
    resizeEnable: {
      type: Boolean,
      default: true
    },
    // æ¯å¦çæ§å°å¾å®¹å¨å°ºå¯¸ååï¼é»è®¤å¼ä¸ºfalseãæ­¤å±æ§å¯è¢« setStatus/getStatus æ¹æ³æ§å¶
    dragEnable: {
      type: Boolean,
      default: true
    },
    // å°å¾æ¯å¦å¯éè¿é¼ æ ææ½å¹³ç§», é»è®¤ä¸º trueãæ­¤å±æ§å¯è¢« setStatus/getStatus æ¹æ³æ§å¶
    zoomEnable: {
      type: Boolean,
      default: true
    },
    // å°å¾æ¯å¦å¯ç¼©æ¾ï¼é»è®¤å¼ä¸º trueãæ­¤å±æ§å¯è¢« setStatus/getStatus æ¹æ³æ§å¶
    jogEnable: {
      type: Boolean,
      default: true
    },
    // å°å¾æ¯å¦ä½¿ç¨ç¼å¨ææï¼é»è®¤å¼ä¸ºtrueãæ­¤å±æ§å¯è¢«setStatus/getStatus æ¹æ³æ§å¶
    pitchEnable: {
      type: Boolean,
      default: true
    },
    // æ¯å¦åè®¸è®¾ç½®ä¿¯ä»°è§åº¦, 3D è§å¾ä¸ä¸º true, 2D è§å¾ä¸æ æããæ­¤å±æ§å¯è¢«setStatus/getStatus æ¹æ³æ§å¶
    rotateEnable: {
      type: Boolean,
      default: true
    },
    // å°å¾æ¯å¦å¯æè½¬, å¾é»è®¤ä¸ºtrueãæ­¤å±æ§å¯è¢«setStatus/getStatus æ¹æ³æ§å¶
    animateEnable: {
      type: Boolean,
      default: true
    },
    // å°å¾å¹³ç§»è¿ç¨ä¸­æ¯å¦ä½¿ç¨å¨ç»ï¼å¦è°ç¨panByãpanToãsetCenterãsetZoomAndCenterç­å½æ°, å°å¯¹å°å¾äº§çå¹³ç§»æä½, æ¯å¦ä½¿ç¨å¨ç»å¹³ç§»çææï¼, é»è®¤ä¸ºtrue, å³ä½¿ç¨å¨ç»
    keyboardEnable: {
      type: Boolean,
      default: true
    },
    // å°å¾æ¯å¦å¯éè¿é®çæ§å¶, é»è®¤ä¸ºtrue, æ¹åé®æ§å¶å°å¾å¹³ç§»ï¼"+"å"-"å¯ä»¥æ§å¶å°å¾çç¼©æ¾, Ctrl+âââé¡ºæ¶éæè½¬ï¼Ctrl+âââéæ¶éæè½¬ãæ­¤å±æ§å¯è¢«setStatus/getStatus æ¹æ³æ§å¶
    doubleClickZoom: {
      type: Boolean,
      default: true
    },
    // å°å¾æ¯å¦å¯éè¿åå»é¼ æ æ¾å¤§å°å¾, é»è®¤ä¸ºtrueãæ­¤å±æ§å¯è¢«setStatus/getStatus æ¹æ³æ§å¶
    scrollWheel: {
      type: Boolean,
      default: true
    },
    // å°å¾æ¯å¦å¯éè¿é¼ æ æ»è½®ç¼©æ¾æµè§ï¼é»è®¤ä¸ºtrueãæ­¤å±æ§å¯è¢«setStatus/getStatus æ¹æ³æ§å¶
    touchZoom: {
      type: Boolean,
      default: true
    },
    // å°å¾å¨ç§»å¨ç»ç«¯ä¸æ¯å¦å¯éè¿å¤ç¹è§¦æ§ç¼©æ¾æµè§å°å¾ï¼é»è®¤ä¸ºtrueãå³é­æå¿ç¼©æ¾å°å¾ï¼è¯·è®¾ç½®ä¸ºfalseã
    touchZoomCenter: {
      type: Number
    },
    // å¯ç¼ºçï¼å½touchZoomCenter=1çæ¶åï¼ææºç«¯åæç¼©æ¾çä»¥å°å¾ä¸­å¿ä¸ºä¸­å¿ï¼å¦åé»è®¤ä»¥åæä¸­é´ç¹ä¸ºä¸­å¿ãé»è®¤ï¼1
    showLabel: {
      type: Boolean,
      default: true
    },
    // æ¯å¦å±ç¤ºå°å¾æå­å POI ä¿¡æ¯ãé»è®¤ true
    defaultCursor: {
      type: String
    },
    // å°å¾é»è®¤é¼ æ æ ·å¼ãåæ° defaultCursor åºç¬¦å CSS ç cursor å±æ§è§èã
    isHotspot: {
      type: Boolean
    },
    // æ¯å¦å¼å¯å°å¾ç­ç¹åæ æ³¨ç hover ææãPCç«¯é»è®¤æ¯true, ç§»å¨ç«¯é»è®¤æ¯ falseã
    mapStyle: {
      type: String
    },
    // è®¾ç½®å°å¾çæ¾ç¤ºæ ·å¼ï¼ç®åæ¯æä¸¤ç§å°å¾æ ·å¼ï¼ ç¬¬ä¸ç§ï¼èªå®ä¹å°å¾æ ·å¼ï¼å¦ "amap://styles/d6bf8c1d69cea9f5c696185ad4ac4c86" å¯åå¾å°å¾èªå®ä¹å¹³å°å®å¶èªå·±çä¸ªæ§å°å¾æ ·å¼ï¼ ç¬¬äºç§ï¼å®æ¹æ ·å¼æ¨¡ç,å¦"amap://styles/grey"ã å¶ä»æ¨¡çæ ·å¼åèªå®ä¹å°å¾çä½¿ç¨è¯´æè§å¼åæå
    wallColor: {
      type: [String, Array]
    },
    // å°å¾æ¥¼åçä¾§é¢é¢è²
    roofColor: {
      type: [String, Array]
    },
    // å°å¾æ¥¼åçé¡¶é¢é¢è²
    showBuildingBlock: {
      type: Boolean,
      default: true
    },
    // æ¯å¦å±ç¤ºå°å¾ 3D æ¥¼åï¼é»è®¤ true
    showIndoorMap: {
      type: Boolean,
      default: false
    },
    // æ¯å¦èªå¨å±ç¤ºå®¤åå°å¾ï¼é»è®¤æ¯ false
    skyColor: {
      type: [String, Array]
    },
    // å¤©ç©ºé¢è²ï¼3D æ¨¡å¼ä¸å¸¦æä¿¯ä»°è§æ¶ä¼æ¾ç¤º
    labelRejectMask: {
      type: Boolean,
      default: false
    },
    // æå­æ¯å¦æç»æ©æ¨¡å¾å±è¿è¡æ©æ¨¡
    mask: {
      type: Array
    },
    // ä¸º Map å®ä¾æå®æ©æ¨¡çè·¯å¾ï¼åå¾å±å°åªæ¾ç¤ºè·¯å¾èå´åå¾åï¼3Dè§å¾ä¸ææã æ ¼å¼ä¸ºä¸ä¸ªç»çº¬åº¦çä¸ç»´ãäºç»´æä¸ç»´æ°ç»ã
    WebGLParams: {
      type: Object
    },
    // é¢å¤éç½®çWebGLåæ° eg: preserveDrawingBuffer
    terrain: {
      type: Boolean,
      default: false
    }
    //æ¯å¦å¼å¯å°å½¢ï¼é»è®¤ä¸å¼å¯
  },
  emits: ["update:zoom", "update:center", "update:rotation", "update:pitch"],
  data() {
    return {};
  },
  computed: {},
  mounted() {
    this.createMap();
  },
  beforeUnmount() {
    if (this.$amapComponent) {
      this.$amapComponent.destroy();
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  methods: {
    createMap() {
      injected_amap_api_instance/* lazyAMapApiLoaderInstance */.E.then(() => {
        const mapElement = this.$el.querySelector(".el-vue-amap");
        const elementID = this.vid || guid();
        mapElement.id = elementID;
        this.$nextTick(() => {
          this.$amapComponent = new AMap.Map(elementID, this.convertProps());
          this.register();
          this.bindModelEvents();
        });
      }).catch((e) => {
        console.warn("init map error: ", e);
      });
    },
    bindModelEvents() {
      this.$amapComponent.on("zoomchange", () => {
        this.$emit("update:zoom", this.$amapComponent.getZoom());
      });
      this.$amapComponent.on("rotatechange", () => {
        this.$emit("update:rotation", this.$amapComponent.getRotation());
        this.$emit("update:pitch", this.$amapComponent.getPitch());
      });
      this.$amapComponent.on("dragging", () => {
        this.$emit("update:center", this.getCenter());
        this.$emit("update:pitch", this.$amapComponent.getPitch());
      });
      this.$amapComponent.on("touchmove", () => {
        this.$emit("update:center", this.getCenter());
      });
    },
    getCenter() {
      const center = this.$amapComponent.getCenter();
      return [center.lng, center.lat];
    },
    __dragEnable(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ dragEnable: flag });
      }
    },
    __zoomEnable(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ zoomEnable: flag });
      }
    },
    __jogEnable(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ jogEnable: flag });
      }
    },
    __keyboardEnable(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ keyboardEnable: flag });
      }
    },
    __doubleClickZoom(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ doubleClickZoom: flag });
      }
    },
    __scrollWheel(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ scrollWheel: flag });
      }
    },
    __rotateEnable(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ rotateEnable: flag });
      }
    },
    __resizeEnable(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ resizeEnable: flag });
      }
    },
    __showIndoorMap(flag) {
      if (this.$amapComponent) {
        this.$amapComponent.setStatus({ showIndoorMap: flag });
      }
    }
  }
});


//# sourceMappingURL=amap.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/amap/amap.vue3.mjs


const _hoisted_1 = { class: "el-vue-amap-container" };
const _hoisted_2 = /* @__PURE__ */ (0,runtime_core_esm_bundler/* createElementVNode */.Lk)(
  "div",
  { class: "el-vue-amap" },
  null,
  -1
  /* HOISTED */
);
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", _hoisted_1, [
    _hoisted_2,
    (0,runtime_core_esm_bundler/* renderSlot */.RG)(_ctx.$slots, "default")
  ]);
}


//# sourceMappingURL=amap.vue3.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/amap/amap.vue4.mjs

//# sourceMappingURL=amap.vue4.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/amap/amap.vue.mjs




script.render = render;
script.__file = "src/vue-amap/packages/amap/amap.vue";


//# sourceMappingURL=amap.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/amap/index.mjs



script.install = (app) => {
  app.component(script.name, script);
  return app;
};
const ElAmap = script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/ControlBar/ControlBar.vue2.mjs



var ControlBar_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapControlControlBar",
  mixins: [registerComponent],
  props: {
    position: {
      type: [String, Object]
    },
    // æ§ä»¶åé ä½ç½® { top: 5; left: 5; right: 5; bottom: 5 } æè 'LT': å·¦ä¸è§, 'RT': å³ä¸è§, 'LB': å·¦ä¸è§, 'RB': å³ä¸è§
    offset: {
      type: Array
    },
    // ç¸å¯¹äºå°å¾å®¹å¨å·¦ä¸è§çåç§»éï¼æ­£æ°ä»£è¡¨åå³ä¸åç§»ãé»è®¤ä¸ºAMap.Pixel(10,10)
    showControlButton: {
      type: Boolean,
      default: true
    }
    // æ¯å¦æ¾ç¤ºå¾æãæè½¬æé®ãé»è®¤ä¸º true
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.ControlBar"], () => {
          this.$amapComponent = new AMap.ControlBar(options);
          this.$parentComponent.addControl(this.$amapComponent);
          resolve();
        });
      });
    },
    destroyComponent() {
      if (this.$amapComponent && this.$parentComponent) {
        if (!this.parentInstance.isDestroy) {
          this.$parentComponent.removeControl(this.$amapComponent);
        }
        this.$amapComponent = null;
        this.$parentComponent = null;
      }
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=ControlBar.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/ControlBar/ControlBar.vue.mjs


ControlBar_vue2_script.__file = "src/vue-amap/packages/control/ControlBar/ControlBar.vue";


//# sourceMappingURL=ControlBar.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/ControlBar/index.mjs



ControlBar_vue2_script.install = (app) => {
  app.component(ControlBar_vue2_script.name, ControlBar_vue2_script);
  return app;
};
const ElAmapControlControlBar = ControlBar_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/HawkEye/HawkEye.vue2.mjs



var HawkEye_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapControlHawkEye",
  mixins: [registerComponent],
  props: {
    autoMove: {
      type: Boolean,
      default: true
    },
    // æ¯å¦éä¸»å¾è§å£ååç§»å¨
    showRectangle: {
      type: Boolean,
      default: true
    },
    // æ¯å¦æ¾ç¤ºè§å£ç©å½¢
    showButton: {
      type: Boolean,
      default: true
    },
    // æ¯å¦æ¾ç¤ºæå¼å³é­çæé®
    isOpen: {
      type: Boolean,
      default: true
    },
    // é»è®¤æ¯å¦å±å¼
    mapStyle: {
      type: String
    },
    // ç¼©ç¥å¾è¦æ¾ç¤ºçå°å¾èªå®ä¹æ ·å¼ï¼å¦'amap://styles/dark'
    layers: {
      type: Array
    },
    // ç¼©ç¥å¾è¦æ¾ç¤ºçå¾å±ç±»åï¼é»è®¤ä¸ºæ®éç¢éå°å¾
    width: {
      type: String
    },
    // ç¼©ç¥å¾çå®½åº¦ï¼åCSSï¼å¦'200px'
    height: {
      type: String
    },
    // ç¼©ç¥å¾çé«åº¦ï¼åCSSï¼å¦'200px'
    offset: {
      type: Array
    },
    // ç¼©ç¥å¾è·ç¦»å°å¾å³ä¸è§çåç´ è·ç¦»ï¼å¦ [2,2]
    borderStyle: {
      type: String
    },
    // ç¼©ç¥å¾çè¾¹æ¡æ ·å¼ï¼åCSSï¼å¦"double solid solid double"
    borderColor: {
      type: String
    },
    // ç¼©ç¥å¾çè¾¹æ¡é¢è²ï¼åCSSï¼å¦'silver'
    borderRadius: {
      type: String
    },
    // ç¼©ç¥å¾çè¾¹æ¡è§åº¦ï¼åCSSï¼å¦'5px'
    borderWidth: {
      type: String
    },
    // ç¼©ç¥å¾çè¾¹æ¡å®½åº¦ï¼åCSSï¼å¦'2px'
    buttonSize: {
      type: String
    }
    // ç®­å¤´æé®çåç´ å°ºå¯¸ï¼åCSSï¼å¦'12px'
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.HawkEye"], () => {
          this.$amapComponent = new AMap.HawkEye(options);
          this.$parentComponent.addControl(this.$amapComponent);
          resolve();
        });
      });
    },
    destroyComponent() {
      if (this.$amapComponent && this.$parentComponent) {
        if (!this.parentInstance.isDestroy) {
          this.$parentComponent.removeControl(this.$amapComponent);
        }
        this.$amapComponent = null;
        this.$parentComponent = null;
      }
    },
    __isOpen(flag) {
      flag === false ? this.$amapComponent.close() : this.$amapComponent.open();
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=HawkEye.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/HawkEye/HawkEye.vue.mjs


HawkEye_vue2_script.__file = "src/vue-amap/packages/control/HawkEye/HawkEye.vue";


//# sourceMappingURL=HawkEye.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/HawkEye/index.mjs



HawkEye_vue2_script.install = (app) => {
  app.component(HawkEye_vue2_script.name, HawkEye_vue2_script);
  return app;
};
const ElAmapControlHawkEye = HawkEye_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/MapType/MapType.vue2.mjs



var MapType_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapControlMapType",
  mixins: [registerComponent],
  props: {
    defaultType: {
      type: Number
    },
    // åå§åé»è®¤å¾å±ç±»åã åå¼ä¸º0ï¼é»è®¤åºå¾ åå¼ä¸º1ï¼å«æå¾ é»è®¤å¼ï¼0
    showTraffic: {
      type: Boolean,
      default: false
    },
    // å å å®æ¶äº¤éå¾å± é»è®¤å¼ï¼false
    showRoad: {
      type: Boolean,
      default: false
    }
    // å å è·¯ç½å¾å± é»è®¤å¼ï¼false
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.MapType"], () => {
          this.$amapComponent = new AMap.MapType(options);
          this.$parentComponent.addControl(this.$amapComponent);
          resolve();
        });
      });
    },
    destroyComponent() {
      if (this.$amapComponent && this.$parentComponent) {
        if (!this.parentInstance.isDestroy) {
          this.$parentComponent.removeControl(this.$amapComponent);
        }
        this.$amapComponent = null;
        this.$parentComponent = null;
      }
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=MapType.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/MapType/MapType.vue.mjs


MapType_vue2_script.__file = "src/vue-amap/packages/control/MapType/MapType.vue";


//# sourceMappingURL=MapType.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/MapType/index.mjs



MapType_vue2_script.install = (app) => {
  app.component(MapType_vue2_script.name, MapType_vue2_script);
  return app;
};
const ElAmapControlMapType = MapType_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/Scale/Scale.vue2.mjs



var Scale_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapControlScale",
  mixins: [registerComponent],
  props: {
    position: {
      type: [String, Object]
    },
    // æ§ä»¶åé ä½ç½® { top: 5; left: 5; right: 5; bottom: 5 } æè 'LT': å·¦ä¸è§, 'RT': å³ä¸è§, 'LB': å·¦ä¸è§, 'RB': å³ä¸è§
    offset: {
      type: Array
    }
    // ç¸å¯¹äºå°å¾å®¹å¨å·¦ä¸è§çåç§»éï¼æ­£æ°ä»£è¡¨åå³ä¸åç§»ãé»è®¤ä¸ºAMap.Pixel(10,10)
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.Scale"], () => {
          this.$amapComponent = new AMap.Scale(options);
          this.$parentComponent.addControl(this.$amapComponent);
          resolve();
        });
      });
    },
    destroyComponent() {
      if (this.$amapComponent && this.$parentComponent) {
        if (!this.parentInstance.isDestroy) {
          this.$parentComponent.removeControl(this.$amapComponent);
        }
        this.$amapComponent = null;
        this.$parentComponent = null;
      }
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Scale.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/Scale/Scale.vue.mjs


Scale_vue2_script.__file = "src/vue-amap/packages/control/Scale/Scale.vue";


//# sourceMappingURL=Scale.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/Scale/index.mjs



Scale_vue2_script.install = (app) => {
  app.component(Scale_vue2_script.name, Scale_vue2_script);
  return app;
};
const ElAmapControlScale = Scale_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/ToolBar/ToolBar.vue2.mjs



var ToolBar_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapControlToolBar",
  mixins: [registerComponent],
  props: {
    position: {
      type: [String, Object]
    },
    // æ§ä»¶åé ä½ç½® { top: 5; left: 5; right: 5; bottom: 5 } æè 'LT': å·¦ä¸è§, 'RT': å³ä¸è§, 'LB': å·¦ä¸è§, 'RB': å³ä¸è§
    offset: {
      type: Array
    }
    // ç¸å¯¹äºå°å¾å®¹å¨å·¦ä¸è§çåç§»éï¼æ­£æ°ä»£è¡¨åå³ä¸åç§»ãé»è®¤ä¸ºAMap.Pixel(10,10)
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.ToolBar"], () => {
          this.$amapComponent = new AMap.ToolBar(options);
          this.$parentComponent.addControl(this.$amapComponent);
          resolve();
        });
      });
    },
    destroyComponent() {
      if (this.$amapComponent && this.$parentComponent) {
        if (!this.parentInstance.isDestroy) {
          this.$parentComponent.removeControl(this.$amapComponent);
        }
        this.$amapComponent = null;
        this.$parentComponent = null;
      }
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=ToolBar.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/ToolBar/ToolBar.vue.mjs


ToolBar_vue2_script.__file = "src/vue-amap/packages/control/ToolBar/ToolBar.vue";


//# sourceMappingURL=ToolBar.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/ToolBar/index.mjs



ToolBar_vue2_script.install = (app) => {
  app.component(ToolBar_vue2_script.name, ToolBar_vue2_script);
  return app;
};
const ElAmapControlToolBar = ToolBar_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/SearchBox/SearchBox.vue2.mjs



var SearchBox_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapSearchBox",
  mixins: [registerComponent],
  props: {
    type: {
      type: String
    },
    //è¾å¥æç¤ºæ¶éå®POIç±»åï¼å¤ä¸ªç±»åç¨â|âåéï¼ç®ååªæ¯æPoiç±»åç¼ç å¦â050000â é»è®¤å¼ï¼ææç±»å«
    city: {
      type: String
    },
    //è¾å¥æç¤ºæ¶éå®åå¸ãå¯éå¼ï¼åå¸åï¼ä¸­ææä¸­æå¨æ¼ï¼ãcitycodeãadcodeï¼é»è®¤å¼ï¼âå¨å½â
    datatype: {
      type: String
    },
    //è¿åçæ°æ®ç±»åãå¯éå¼ï¼all-è¿åæææ°æ®ç±»åãpoi-è¿åPOIæ°æ®ç±»åãbus-è¿åå¬äº¤ç«ç¹æ°æ®ç±»åãbusline-è¿åå¬äº¤çº¿è·¯æ°æ®ç±»åç®åææ¶ä¸æ¯æå¤ç§ç±»å
    citylimit: {
      type: Boolean,
      default: false
    },
    //è¿åçæ°æ®ç±»åãå¯éå¼ï¼all-è¿åæææ°æ®ç±»åãpoi-è¿åPOIæ°æ®ç±»åãbus-è¿åå¬äº¤ç«ç¹æ°æ®ç±»åãbusline-è¿åå¬äº¤çº¿è·¯æ°æ®ç±»åç®åææ¶ä¸æ¯æå¤ç§ç±»å
    inputId: {
      type: String
    },
    //è¾å¥æ¡çID
    inputCustom: {
      type: Boolean,
      default: false
    },
    //æ¯å¦èªå®ä¹inputï¼èªå®ä¹çæ¶åå°ä½¿ç¨ç¨æ·çinputId
    outputId: {
      type: String
    },
    //å¯éåæ°ï¼æå®ä¸ä¸ªç°æçdivçidæèåç´ ï¼ä½ä¸ºå±ç¤ºæç¤ºç»æçå®¹å¨ï¼å½æå®äºinputçæ¶åææï¼ç¼ºççæ¶åå°èªå¨åå»ºä¸ä¸ªæ¾ç¤ºç»æé¢æ¿
    outPutDirAuto: {
      type: Boolean,
      default: true
    },
    //é»è®¤ä¸ºtrueï¼è¡¨ç¤ºæ¯å¦å¨inputä½äºé¡µé¢è¾ä¸æ¹çæ¶åèªå¨å°è¾å¥é¢æ¿æ¾ç¤ºå¨inputä¸æ¹ä»¥é¿åè¢«é®æ¡
    closeResultOnScroll: {
      type: Boolean,
      default: true
    },
    //é¡µé¢æ»å¨æ¶å³é­æç´¢ç»æåè¡¨ï¼é»è®¤ true
    lang: {
      type: String
    },
    //è®¾ç½®æ£ç´¢è¯­è¨ç±»åï¼é»è®¤ä¸­æ 'zh_cn'
    placeholder: {
      type: String
    },
    debounce: {
      type: Number,
      default: 100
    }
    // æå¨å¤åå¢å é²æ
  },
  data() {
    return {
      saveInputId: "",
      saveVisible: true
    };
  },
  created() {
    this.saveInputId = guid();
  },
  methods: {
    __initComponent(options) {
      if (options.inputId) {
        this.saveInputId = options.inputId;
        delete options.inputId;
      }
      if (options.visible) {
        this.saveVisible = options.visible;
      }
      options.input = this.saveInputId;
      if (options.outputId) {
        options.output = options.outputId;
        delete options.outputId;
      }
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.AutoComplete"], () => {
          const debounce = this.debounce;
          AMap.Autocomplete.prototype.onInPut = function(event) {
            clearTimeout(this._inputTimer);
            this._inputTimer = setTimeout(() => {
              this.output && this.autoSearch();
            }, debounce);
          };
          this.$amapComponent = new AMap.AutoComplete(options);
          resolve();
        });
      });
    },
    __visible(flag) {
      this.saveVisible = flag;
    },
    __citylimit(flag) {
      this.$amapComponent.setCityLimit(flag);
    }
  }
});


//# sourceMappingURL=SearchBox.vue2.mjs.map

// EXTERNAL MODULE: ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
var runtime_dom_esm_bundler = __webpack_require__(3751);
;// ./node_modules/@vuemap/vue-amap/es/packages/control/SearchBox/SearchBox.vue3.mjs


const SearchBox_vue3_hoisted_1 = { class: "el-vue-search-box-container" };
const SearchBox_vue3_hoisted_2 = ["id", "placeholder"];
function SearchBox_vue3_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* withDirectives */.bo)(((0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)(
    "div",
    SearchBox_vue3_hoisted_1,
    [
      !_ctx.inputCustom ? ((0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("input", {
        key: 0,
        id: _ctx.saveInputId,
        type: "text",
        placeholder: _ctx.placeholder
      }, null, 8, SearchBox_vue3_hoisted_2)) : (0,runtime_core_esm_bundler/* createCommentVNode */.Q3)("v-if", true)
    ],
    512
    /* NEED_PATCH */
  )), [
    [runtime_dom_esm_bundler/* vShow */.aG, _ctx.visible && !_ctx.inputCustom]
  ]);
}


//# sourceMappingURL=SearchBox.vue3.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/SearchBox/SearchBox.vue4.mjs

//# sourceMappingURL=SearchBox.vue4.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/SearchBox/SearchBox.vue.mjs




SearchBox_vue2_script.render = SearchBox_vue3_render;
SearchBox_vue2_script.__file = "src/vue-amap/packages/control/SearchBox/SearchBox.vue";


//# sourceMappingURL=SearchBox.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/SearchBox/index.mjs



SearchBox_vue2_script.install = (app) => {
  app.component(SearchBox_vue2_script.name, SearchBox_vue2_script);
  return app;
};
const ElAmapSearchBox = SearchBox_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/infoWindow/InfoWindow/InfoWindow.vue2.mjs



var InfoWindow_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapInfoWindow",
  mixins: [registerComponent],
  props: {
    isCustom: {
      type: Boolean,
      default: false
    },
    // æ¯å¦èªå®ä¹çªä½ãè®¾ä¸ºtrueæ¶ï¼ä¿¡æ¯çªä½å¤æ¡ååå®¹å®å¨æç§contentæè®¾çå¼æ·»å ï¼é»è®¤ä¸ºfalseï¼å³å¨ç³»ç»é»è®¤çä¿¡æ¯çªä½å¤æ¡ä¸­æ¾ç¤ºcontentåå®¹ï¼
    autoMove: {
      type: Boolean,
      default: true
    },
    // æ¯å¦èªå¨è°æ´çªä½å°è§éåï¼å½ä¿¡æ¯çªä½è¶åºè§éèå´æ¶ï¼éè¿è¯¥å±æ§è®¾ç½®æ¯å¦èªå¨å¹³ç§»å°å¾ï¼ä½¿ä¿¡æ¯çªä½å®å¨æ¾ç¤ºï¼
    avoid: {
      type: Array
    },
    // autoMove ä¸º true æ¶ï¼èªå¨å¹³ç§»å°è§éååçä¸å³ä¸å·¦çé¿è®©å®½åº¦ãé»è®¤å¼ï¼ [20, 20, 20, 20]
    closeWhenClickMap: {
      type: Boolean,
      default: false
    },
    // ç¹æ è®°æ¾ç¤ºä½ç½®åç§»éï¼é»è®¤å¼ä¸º [0,0] ãMarkeræå®positionåï¼é»è®¤ä»¥markerå·¦ä¸è§ä½ç½®ä¸ºåºåç¹ï¼è¥è®¾ç½®äºanchorï¼åä»¥anchorè®¾ç½®ä½ç½®ä¸ºåºåç¹ï¼ï¼å¯¹åæç»å®çpositionä½ç½®ï¼è¥éä½¿markeræå®ä½ç½®å¯¹åå¨positionå¤ï¼éæ ¹æ®markerçå°ºå¯¸è®¾ç½®ä¸å®çåç§»éã
    content: {
      type: [String, Object]
    },
    // æ¾ç¤ºåå®¹ï¼å¯ä»¥æ¯HTMLè¦ç´ å­ç¬¦ä¸²æèHTMLElementå¯¹è±¡
    size: {
      type: Array
    },
    // ä¿¡æ¯çªä½å°ºå¯¸ï¼isCustomä¸ºtrueæ¶ï¼è¯¥å±æ§æ æï¼
    anchor: {
      type: String
    },
    // ä¿¡æ¯çªä½éç¹ãé»è®¤å¼ï¼'bottom-center'ãå¯éå¼ï¼'top-left'|'top-center'|'top-right'|'middle-left'|'center'|'middle-right'|'bottom-left'|'bottom-center'|'bottom-right'
    offset: {
      type: Array
    },
    // ä¿¡æ¯çªä½æ¾ç¤ºä½ç½®åç§»éãé»è®¤åºåç¹ä¸ºä¿¡æ¯çªä½çåºé¨ä¸­å¿ãé»è®¤å¼: [0, 0]
    position: {
      type: Array
    }
    // ä¿¡æ¯çªä½æ¾ç¤ºåºç¹ä½ç½®
  },
  emits: ["update:visible"],
  data() {
    return {
      converters: {}
    };
  },
  unmounted() {
    if (this.$amapComponent) {
      this.$amapComponent.close();
    }
  },
  updated() {
    if (!this.content && this.$amapComponent) {
      this.$amapComponent.setContent(this.$refs.info);
    }
  },
  methods: {
    __initComponent(options) {
      if (!options.content) {
        options.content = this.getSlotContent();
      }
      this.$amapComponent = new AMap.InfoWindow(options);
      this.$amapComponent.on("close", () => {
        this.$emit("update:visible", false);
      });
      if (this.visible !== false) {
        this.$amapComponent.open(this.$parentComponent, this.position);
      }
      if (!this.content && this.$amapComponent) {
        const config = { attributes: true, childList: true, subtree: true };
        const observer = new MutationObserver(() => {
          this.$amapComponent.setContent(this.getSlotContent());
        });
        observer.observe(this.$refs.info, config);
        this.observer = observer;
      }
    },
    getSlotContent() {
      return this.$refs.info;
    },
    destroyComponent() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      if (this.$amapComponent) {
        if (this.$amapComponent.getIsOpen()) {
          this.$amapComponent.close();
        }
        this.$amapComponent = null;
        this.$parentComponent = null;
      }
    },
    __position(position) {
      if (this.visible) {
        this.$amapComponent.open(this.$parentComponent, position);
      } else {
        this.$amapComponent.setPosition(position);
      }
    },
    __visible(flag) {
      const position = this.$amapComponent.getPosition();
      if (position) {
        flag === false ? this.$amapComponent.close() : this.$amapComponent.open(this.$parentComponent, [position.lng, position.lat]);
      }
    }
  }
});


//# sourceMappingURL=InfoWindow.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/infoWindow/InfoWindow/InfoWindow.vue3.mjs


const InfoWindow_vue3_hoisted_1 = { style: { "display": "none" } };
const InfoWindow_vue3_hoisted_2 = { ref: "info" };
function InfoWindow_vue3_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", InfoWindow_vue3_hoisted_1, [
    (0,runtime_core_esm_bundler/* createElementVNode */.Lk)(
      "div",
      InfoWindow_vue3_hoisted_2,
      [
        (0,runtime_core_esm_bundler/* renderSlot */.RG)(_ctx.$slots, "default")
      ],
      512
      /* NEED_PATCH */
    )
  ]);
}


//# sourceMappingURL=InfoWindow.vue3.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/infoWindow/InfoWindow/InfoWindow.vue.mjs



InfoWindow_vue2_script.render = InfoWindow_vue3_render;
InfoWindow_vue2_script.__file = "src/vue-amap/packages/infoWindow/InfoWindow/InfoWindow.vue";


//# sourceMappingURL=InfoWindow.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/infoWindow/InfoWindow/index.mjs



InfoWindow_vue2_script.install = (app) => {
  app.component(InfoWindow_vue2_script.name, InfoWindow_vue2_script);
  return app;
};
const ElAmapInfoWindow = InfoWindow_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Canvas/Canvas.vue2.mjs



var Canvas_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerCanvas",
  mixins: [registerComponent],
  props: {
    canvas: {
      required: true,
      type: Object
    },
    // Canvas DOM å¯¹è±¡
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    bounds: {
      type: [Array, Object]
    },
    // å¾ççèå´å¤§å°ç»çº¬åº¦ï¼å¦æä¼ éæ°å­æ°ç»ç±»å: [minlng,minlat,maxlng,maxlat] æ AMap.Bounds
    opacity: {
      type: Number
    }
    // éæåº¦ï¼é»è®¤ 1
  },
  data() {
    return {
      handlers: {}
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.CanvasLayer(options);
      this.$parentComponent.addLayer(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.removeLayer(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Canvas.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Canvas/Canvas.vue.mjs


Canvas_vue2_script.__file = "src/vue-amap/packages/layer/data/Canvas/Canvas.vue";


//# sourceMappingURL=Canvas.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Canvas/index.mjs



Canvas_vue2_script.install = (app) => {
  app.component(Canvas_vue2_script.name, Canvas_vue2_script);
  return app;
};
const ElAmapLayerCanvas = Canvas_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Custom/Custom.vue2.mjs



var Custom_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerCustom",
  mixins: [registerComponent],
  props: {
    canvas: {
      required: true,
      type: Object
    },
    // canvas å¯¹è±¡
    render: {
      type: Function
    },
    // ç»å¶å½æ°ï¼åå§åå®ææ¶åï¼å¼åèéè¦ç»è¯¥å¾å±è®¾å®renderæ¹æ³ï¼è¯¥æ¹æ³éè¦å®ç°å¾å±çç»å¶ï¼APIä¼å¨åéçæ¶æºèªå¨è°ç¨è¯¥æ¹æ³
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2, 20]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    alwaysRender: {
      type: Boolean,
      default: false
    }
    // æ¯å¦ä¸»å¨
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      const canvas = options.canvas;
      delete options.canvas;
      this.$amapComponent = new AMap.CustomLayer(canvas, options);
      this.$amapComponent.setMap(this.$parentComponent);
    },
    destroyComponent() {
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Custom.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Custom/Custom.vue.mjs


Custom_vue2_script.__file = "src/vue-amap/packages/layer/data/Custom/Custom.vue";


//# sourceMappingURL=Custom.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Custom/index.mjs



Custom_vue2_script.install = (app) => {
  app.component(Custom_vue2_script.name, Custom_vue2_script);
  return app;
};
const ElAmapLayerCustom = Custom_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Flexible/Flexible.vue2.mjs



var Flexible_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerFlexible",
  mixins: [registerComponent],
  props: {
    cacheSize: {
      type: Number
    },
    // ç¼å­ç¦çæ°é
    createTile: {
      type: Function
    },
    // ç±å¼åèå®ç°ï¼ç±APIèªå¨è°ç¨ï¼xyzåå«ä¸ºåçæ¨ªåçºµåç¼å·åå±çº§ï¼åçå¤§å° 256ãåè®¾æ¯æ¬¡åå»ºçè´´çä¸ºA(æ¯æimgæècanvas)ï¼å½åå»ºæèè·åæåæ¶è¯·åè°success(A)ï¼ä¸éè¦æ¾ç¤ºæèå¤±è´¥æ¶è¯·åè°fail()
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Array
    },
    // ç­åå¾éæåº¦åºé´æ°ç»ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæï¼é»è®¤ï¼ [0,1]
    tileSize: {
      type: Number
    }
    // åçå¤§å°ï¼åå¼ï¼ 256  128  64ãé»è®¤å¼ä¸º256
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.TileLayer.Flexible(options);
      this.$amapComponent.setMap(this.$parentComponent);
    },
    destroyComponent() {
      this.$amapComponent.destroy();
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Flexible.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Flexible/Flexible.vue.mjs


Flexible_vue2_script.__file = "src/vue-amap/packages/layer/data/Flexible/Flexible.vue";


//# sourceMappingURL=Flexible.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Flexible/index.mjs



Flexible_vue2_script.install = (app) => {
  app.component(Flexible_vue2_script.name, Flexible_vue2_script);
  return app;
};
const ElAmapLayerFlexible = Flexible_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/GLCustom/GLCustom.vue2.mjs



var GLCustom_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerGlCustom",
  mixins: [registerComponent],
  props: {
    init: {
      type: Function
    },
    // åå§åçæ¶åï¼å¼åèå¯ä»¥å¨è¿ä¸ªå½æ°åæ°éé¢è·å gl ä¸ä¸æï¼è¿è¡ä¸äºåå§åçæä½ã
    render: {
      type: Function
    },
    // ç»å¶å½æ°ï¼åå§åå®ææ¶åï¼å¼åèéè¦ç»è¯¥å¾å±è®¾å®renderæ¹æ³ï¼è¯¥æ¹æ³éè¦å®ç°å¾å±çç»å¶ï¼APIä¼å¨åéçæ¶æºèªå¨è°ç¨è¯¥æ¹æ³
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2, 20]
    opacity: {
      type: Number
    }
    // éæåº¦ï¼é»è®¤ 1
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.GLCustomLayer(options);
      this.$amapComponent.setMap(this.$parentComponent);
    },
    destroyComponent() {
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=GLCustom.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/GLCustom/GLCustom.vue.mjs


GLCustom_vue2_script.__file = "src/vue-amap/packages/layer/data/GLCustom/GLCustom.vue";


//# sourceMappingURL=GLCustom.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/GLCustom/index.mjs



GLCustom_vue2_script.install = (app) => {
  app.component(GLCustom_vue2_script.name, GLCustom_vue2_script);
  return app;
};
const ElAmapLayerGlCustom = GLCustom_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/HeatMap/HeatMap.vue2.mjs



var HeatMap_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerHeatMap",
  mixins: [registerComponent],
  props: {
    radius: {
      type: Number
    },
    // ç­åå¾ä¸­åä¸ªç¹çåå¾ï¼é»è®¤ï¼30ï¼åä½ï¼pixel
    gradient: {
      type: Object
    },
    // ç­åå¾çæ¸ååºé´ï¼ç­åå¾æç§è®¾ç½®çé¢è²åé´éæ¾ç¤ºç­åå¾ï¼ä¾{0.4:'rgb(0, 255, 255)',0.85:'rgb(100, 0, 255)',},å¶ä¸­ key è¡¨ç¤ºé´éä½ç½®ï¼åå¼èå´ï¼ [0,1] ï¼value ä¸ºé¢è²å¼ãé»è®¤ï¼heatmap.jsæ åéè²æ¹æ¡
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Array
    },
    // ç­åå¾éæåº¦åºé´æ°ç»ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæï¼é»è®¤ï¼ [0,1]
    config: {
      type: Object
    },
    // 3Dç­åå¾å±æ§
    dataSet: {
      type: Object
    }
    // ç­åå¾æ°æ®é
  },
  data() {
    return {
      propsRedirect: {
        config: "3d"
      }
    };
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.HeatMap"], () => {
          delete options.dataSet;
          this.$amapComponent = new AMap.HeatMap(this.$parentComponent, options);
          if (this.dataSet) {
            this.$amapComponent.setDataSet(this.dataSet);
          }
          resolve();
        });
      });
    },
    destroyComponent() {
      this.$amapComponent.setDataSet({
        data: []
      });
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=HeatMap.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/HeatMap/HeatMap.vue.mjs


HeatMap_vue2_script.__file = "src/vue-amap/packages/layer/data/HeatMap/HeatMap.vue";


//# sourceMappingURL=HeatMap.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/HeatMap/index.mjs



HeatMap_vue2_script.install = (app) => {
  app.component(HeatMap_vue2_script.name, HeatMap_vue2_script);
  return app;
};
const ElAmapLayerHeatMap = HeatMap_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Image/Image.vue2.mjs



var Image_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerImage",
  mixins: [registerComponent],
  props: {
    url: {
      type: String,
      required: true
    },
    // å¾çå°åé¾æ¥
    zoom: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    bounds: {
      type: [Array, Object]
    },
    // å¾ççèå´å¤§å°ç»çº¬åº¦ï¼å¦æä¼ éæ°å­æ°ç»ç±»å: [minlng,minlat,maxlng,maxlat] æ AMap.Bounds
    opacity: {
      type: Number
    }
    // éæåº¦ï¼é»è®¤ 1
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.ImageLayer(options);
      this.$parentComponent.addLayer(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.removeLayer(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __url(value) {
      this.$amapComponent.setImageUrl(value);
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Image.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Image/Image.vue.mjs


Image_vue2_script.__file = "src/vue-amap/packages/layer/data/Image/Image.vue";


//# sourceMappingURL=Image.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Image/index.mjs



Image_vue2_script.install = (app) => {
  app.component(Image_vue2_script.name, Image_vue2_script);
  return app;
};
const ElAmapLayerImage = Image_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Labels/Labels.vue2.mjs



var Labels_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerLabels",
  mixins: [registerComponent],
  provide() {
    return {
      parentInstance: this
    };
  },
  props: {
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    collision: {
      type: Boolean,
      default: true
    },
    // æ æ³¨å±åçæ æ³¨æ¯å¦é¿è®©
    allowCollision: {
      type: Boolean,
      default: false
    }
    // æ æ³¨å±åçæ æ³¨æ¯å¦åè®¸å¶å®æ æ³¨å±å¯¹å®é¿è®©
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.LabelsLayer(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    $$add(markers) {
      this.$amapComponent.add(markers);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.removeLayer(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  }
});


//# sourceMappingURL=Labels.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Labels/Labels.vue3.mjs


function Labels_vue3_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", null, [
    (0,runtime_core_esm_bundler/* renderSlot */.RG)(_ctx.$slots, "default")
  ]);
}


//# sourceMappingURL=Labels.vue3.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Labels/Labels.vue.mjs



Labels_vue2_script.render = Labels_vue3_render;
Labels_vue2_script.__file = "src/vue-amap/packages/layer/data/Labels/Labels.vue";


//# sourceMappingURL=Labels.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Labels/index.mjs



Labels_vue2_script.install = (app) => {
  app.component(Labels_vue2_script.name, Labels_vue2_script);
  return app;
};
const ElAmapLayerLabels = Labels_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Vector/Vector.vue2.mjs



var Vector_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerVector",
  mixins: [registerComponent],
  provide() {
    return {
      parentInstance: this
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.VectorLayer(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.removeLayer(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  }
});


//# sourceMappingURL=Vector.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Vector/Vector.vue3.mjs


function Vector_vue3_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", null, [
    (0,runtime_core_esm_bundler/* renderSlot */.RG)(_ctx.$slots, "default")
  ]);
}


//# sourceMappingURL=Vector.vue3.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Vector/Vector.vue.mjs



Vector_vue2_script.render = Vector_vue3_render;
Vector_vue2_script.__file = "src/vue-amap/packages/layer/data/Vector/Vector.vue";


//# sourceMappingURL=Vector.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Vector/index.mjs



Vector_vue2_script.install = (app) => {
  app.component(Vector_vue2_script.name, Vector_vue2_script);
  return app;
};
const ElAmapLayerVector = Vector_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Buildings/Buildings.vue2.mjs



var Buildings_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerBuildings",
  mixins: [registerComponent],
  props: {
    wallColor: {
      type: [String, Array]
    },
    // æ¥¼åä¾§é¢é¢è²ï¼æ¯æ rgbaãrgbãåå­è¿å¶ç­
    roofColor: {
      type: [String, Array]
    },
    // æ¥¼åé¡¶é¢é¢è²ï¼æ¯æ rgbaãrgbãåå­è¿å¶ç­
    heightFactor: {
      type: Number
    },
    // æ¥¼åçé«åº¦ç³»æ°å å­ï¼é»è®¤ä¸º 1ï¼ä¹å°±æ¯æ­£å¸¸é«åº¦
    styleOpts: {
      type: Object
    },
    // æ¥¼åçå´æ åæ ·å¼è®¾ç½®
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    }
    // éæåº¦ï¼é»è®¤ 1
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Buildings(options);
      this.$parentComponent.add(this.$amapComponent);
      if (this.styleOpts) {
        this.__styleOpts(this.styleOpts);
      }
    },
    destroyComponent() {
      this.$amapComponent.destroy();
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __styleOpts(value) {
      this.$amapComponent.setStyle(value);
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Buildings.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Buildings/Buildings.vue.mjs


Buildings_vue2_script.__file = "src/vue-amap/packages/layer/official/Buildings/Buildings.vue";


//# sourceMappingURL=Buildings.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Buildings/index.mjs



Buildings_vue2_script.install = (app) => {
  app.component(Buildings_vue2_script.name, Buildings_vue2_script);
  return app;
};
const ElAmapLayerBuildings = Buildings_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/DefaultLayer/DefaultLayer.vue2.mjs



var DefaultLayer_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerDefault",
  mixins: [registerComponent],
  props: {
    zoom: {
      type: Array
    },
    opacity: {
      type: Number
    }
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = AMap.createDefaultLayer(options);
      this.$parentComponent.add(this.$amapComponent);
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=DefaultLayer.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/DefaultLayer/DefaultLayer.vue.mjs


DefaultLayer_vue2_script.__file = "src/vue-amap/packages/layer/official/DefaultLayer/DefaultLayer.vue";


//# sourceMappingURL=DefaultLayer.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/DefaultLayer/index.mjs



DefaultLayer_vue2_script.install = (app) => {
  app.component(DefaultLayer_vue2_script.name, DefaultLayer_vue2_script);
  return app;
};
const ElAmapLayerDefault = DefaultLayer_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/DistrictLayer/DistrictLayer.vue2.mjs



var DistrictLayer_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerDistrict",
  mixins: [registerComponent],
  props: {
    type: {
      type: String,
      default: "Country",
      validator: (value) => {
        return ["World", "Country", "Province"].indexOf(value) !== -1;
      }
    },
    adcode: {
      type: String
    },
    // è¡æ¿åºçç¼ç  adcodeä¸çå¸è¡æ¿åºå¯¹ç§è¡¨ï¼ä¸è½½å°åï¼https://a.amap.com/lbs/static/file/AMap_adcode_citycode.xlsx.zip
    SOC: {
      type: String
    },
    // è®¾å®æ¾ç¤ºçå½å®¶,å¯¹åºä¸è½½å°åï¼ https://a.amap.com/jsapi_demos/static/demo-center/js/soc-list.json
    depth: {
      type: Number
    },
    // è®¾å®æ°æ®çå±çº§æ·±åº¦ï¼depthä¸º0çæ¶ååªæ¾ç¤ºå½å®¶é¢ï¼depthä¸º1çæ¶åæ¾ç¤ºççº§ï¼ å½å½å®¶ä¸ºä¸­å½æ¶è®¾ç½®depthä¸º2çå¯ä»¥æ¾ç¤ºå¸ä¸çº§
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    styles: {
      type: Object
    }
    // ä¸ºç®æè¡æ¿åºå¾è®¾å®åé¢çå¡«åé¢è²åæè¾¹é¢è²ã stylesåå­æ®µçå¼å¯ä»¥æ¯é¢è²å¼ï¼ä¹å¯ä»¥æ¯ä¸ä¸ªè¿åé¢è²å¼* çåè°å½æ°functionã
  },
  methods: {
    __initComponent(options) {
      if (this.type === "World") {
        this.$amapComponent = new AMap.DistrictLayer.World(options);
      } else if (this.type === "Country") {
        this.$amapComponent = new AMap.DistrictLayer.Country(options);
      } else if (this.type === "Province") {
        this.$amapComponent = new AMap.DistrictLayer.Province(options);
      }
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __SOC(value) {
      this.$amapComponent.setSOC(value);
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=DistrictLayer.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/DistrictLayer/DistrictLayer.vue.mjs


DistrictLayer_vue2_script.__file = "src/vue-amap/packages/layer/official/DistrictLayer/DistrictLayer.vue";


//# sourceMappingURL=DistrictLayer.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/DistrictLayer/index.mjs



DistrictLayer_vue2_script.install = (app) => {
  app.component(DistrictLayer_vue2_script.name, DistrictLayer_vue2_script);
  return app;
};
const ElAmapLayerDistrict = DistrictLayer_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/IndoorMap/IndoorMap.vue2.mjs



var IndoorMap_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerIndoorMap",
  mixins: [registerComponent],
  props: {
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åå°åºéºé¢æ¶çé¼ æ æ ·å¼
    hideFloorBar: {
      type: Boolean,
      default: false
    }
    // æ¯å¦éèæ¥¼å±åæ¢æ§ä»¶ï¼é»è®¤å¼ï¼false
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.IndoorMap"], () => {
          this.$amapComponent = new AMap.IndoorMap(options);
          const layers = this.$parentComponent.getLayers();
          layers.push(this.$amapComponent);
          this.$parentComponent.setLayers(layers);
          resolve();
        });
      });
    },
    destroyComponent() {
      const layers = this.$parentComponent.getLayers();
      let index = -1;
      for (let i = 0; i < layers.length; i++) {
        if (isIndoorMapInstance(layers[i])) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        layers.splice(index, 1);
        this.$parentComponent.setLayers(layers);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __hideFloorBar(flag) {
      flag === false ? this.$amapComponent.hideFloorBar() : this.$amapComponent.showFloorBar();
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=IndoorMap.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/IndoorMap/IndoorMap.vue.mjs


IndoorMap_vue2_script.__file = "src/vue-amap/packages/layer/official/IndoorMap/IndoorMap.vue";


//# sourceMappingURL=IndoorMap.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/IndoorMap/index.mjs



IndoorMap_vue2_script.install = (app) => {
  app.component(IndoorMap_vue2_script.name, IndoorMap_vue2_script);
  return app;
};
const ElAmapLayerIndoorMap = IndoorMap_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/RoadNet/RoadNet.vue2.mjs



var RoadNet_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerRoadNet",
  mixins: [registerComponent],
  props: {
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    tileSize: {
      type: Number
    }
    // åçå¤§å°ï¼åå¼ï¼ 256ï¼è¡¨ç¤ºåçå¤§å°ä¸º256 256ï¼ 128ï¼è¡¨ç¤ºåçå¤§å°ä¸º128 128ï¼ 64ï¼è¡¨ç¤ºåçå¤§å°ä¸º64*64ãé»è®¤å¼ä¸º256
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.TileLayer.RoadNet(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      this.$amapComponent.destroy();
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=RoadNet.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/RoadNet/RoadNet.vue.mjs


RoadNet_vue2_script.__file = "src/vue-amap/packages/layer/official/RoadNet/RoadNet.vue";


//# sourceMappingURL=RoadNet.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/RoadNet/index.mjs



RoadNet_vue2_script.install = (app) => {
  app.component(RoadNet_vue2_script.name, RoadNet_vue2_script);
  return app;
};
const ElAmapLayerRoadNet = RoadNet_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Satellite/Satellite.vue2.mjs



var Satellite_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerSatellite",
  mixins: [registerComponent],
  props: {
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    tileSize: {
      type: Number
    }
    // åçå¤§å°ï¼åå¼ï¼ 256ï¼è¡¨ç¤ºåçå¤§å°ä¸º256 256ï¼ 128ï¼è¡¨ç¤ºåçå¤§å°ä¸º128 128ï¼ 64ï¼è¡¨ç¤ºåçå¤§å°ä¸º64*64ãé»è®¤å¼ä¸º256
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.TileLayer.Satellite(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      this.$amapComponent.destroy();
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Satellite.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Satellite/Satellite.vue.mjs


Satellite_vue2_script.__file = "src/vue-amap/packages/layer/official/Satellite/Satellite.vue";


//# sourceMappingURL=Satellite.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Satellite/index.mjs



Satellite_vue2_script.install = (app) => {
  app.component(Satellite_vue2_script.name, Satellite_vue2_script);
  return app;
};
const ElAmapLayerSatellite = Satellite_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/TileLayer/TileLayer.vue2.mjs



var TileLayer_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerTile",
  mixins: [registerComponent],
  props: {
    tileUrl: {
      type: String,
      required: true
    },
    // åçåå¾å°å å¦ï¼' https://abc{0,1,2,3}.amap.com/tile?x=[x]&y=[y]&z=[z] ' [x] ã [y] ã [z] åå«æ¿ä»£åççxyzã
    zoom: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    dataZooms: {
      type: Array
    },
    // æ°æ®æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    tileSize: {
      type: Number
    }
    // åçå¤§å°ï¼åå¼ï¼ 256ï¼è¡¨ç¤ºåçå¤§å°ä¸º256 256ï¼ 128ï¼è¡¨ç¤ºåçå¤§å°ä¸º128 128ï¼ 64ï¼è¡¨ç¤ºåçå¤§å°ä¸º64*64ãé»è®¤å¼ä¸º256
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.TileLayer(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=TileLayer.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/TileLayer/TileLayer.vue.mjs


TileLayer_vue2_script.__file = "src/vue-amap/packages/layer/official/TileLayer/TileLayer.vue";


//# sourceMappingURL=TileLayer.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/TileLayer/index.mjs



TileLayer_vue2_script.install = (app) => {
  app.component(TileLayer_vue2_script.name, TileLayer_vue2_script);
  return app;
};
const ElAmapLayerTile = TileLayer_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Traffic/Traffic.vue2.mjs



var Traffic_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerTraffic",
  mixins: [registerComponent],
  props: {
    autoRefresh: {
      type: Boolean,
      defult: true
    },
    // æ¯å¦èªå¨æ´æ°æ°æ®ï¼é»è®¤å¼å¯
    interval: {
      type: Number
    },
    // èªå¨æ´æ°æ°æ®çé´éæ¯«ç§æ°ï¼é»è®¤ 180ms
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    tileSize: {
      type: Number
    }
    // åçå¤§å°ï¼åå¼ï¼ 256ï¼è¡¨ç¤ºåçå¤§å°ä¸º256 256ï¼ 128ï¼è¡¨ç¤ºåçå¤§å°ä¸º128 128ï¼ 64ï¼è¡¨ç¤ºåçå¤§å°ä¸º64*64ãé»è®¤å¼ä¸º256
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.TileLayer.Traffic(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    stopFresh() {
      if (this.$amapComponent) {
        this.$amapComponent.stopFresh();
      }
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Traffic.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Traffic/Traffic.vue.mjs


Traffic_vue2_script.__file = "src/vue-amap/packages/layer/official/Traffic/Traffic.vue";


//# sourceMappingURL=Traffic.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/official/Traffic/index.mjs



Traffic_vue2_script.install = (app) => {
  app.component(Traffic_vue2_script.name, Traffic_vue2_script);
  return app;
};
const ElAmapLayerTraffic = Traffic_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/MapboxVectorTileLayer/MapboxVectorTileLayer.vue2.mjs



var MapboxVectorTileLayer_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerMapboxVectorTile",
  mixins: [registerComponent],
  props: {
    url: {
      type: String
    },
    // MVT æ°æ®çé¾æ¥å°å
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2,22]
    dataZooms: {
      type: Array
    },
    // ç¦çæ°æ®ç­çº§èå´ï¼è¶è¿èå´ä¼ä½¿ç¨æå¤§/æå°ç­çº§çæ°æ®ï¼é»è®¤ [2,18]
    opacity: {
      type: Number
    },
    // éæåº¦ï¼é»è®¤ 1
    styles: {
      type: Object
    }
    // æ ·å¼
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.MapboxVectorTileLayer"], () => {
          this.$amapComponent = new AMap.MapboxVectorTileLayer(options);
          this.$parentComponent.addLayer(this.$amapComponent);
          resolve();
        });
      });
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.removeLayer(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=MapboxVectorTileLayer.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/MapboxVectorTileLayer/MapboxVectorTileLayer.vue.mjs


MapboxVectorTileLayer_vue2_script.__file = "src/vue-amap/packages/layer/standard/MapboxVectorTileLayer/MapboxVectorTileLayer.vue";


//# sourceMappingURL=MapboxVectorTileLayer.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/MapboxVectorTileLayer/index.mjs



MapboxVectorTileLayer_vue2_script.install = (app) => {
  app.component(MapboxVectorTileLayer_vue2_script.name, MapboxVectorTileLayer_vue2_script);
  return app;
};
const ElAmapLayerMapboxVectorTile = MapboxVectorTileLayer_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/WMS/WMS.vue2.mjs



var WMS_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerWms",
  mixins: [registerComponent],
  props: {
    url: {
      type: String
    },
    // wmsæå¡çurlå°åï¼å¦' https://ahocevar.com/geoserver/wms '
    blend: {
      type: Boolean,
      default: false
    },
    // å°å¾çº§å«åæ¢æ¶ï¼ä¸åçº§å«çå¾çæ¯å¦è¿è¡æ··åï¼å¦å¾å±çå¾ååå®¹ä¸ºé¨åéæè¯·è®¾ç½®ä¸ºfalse
    params: {
      type: Object
    },
    // OGCæ åçWMSå°å¾æå¡çGetMapæ¥å£çåæ°ï¼åæ¬VERSIONãLAYERSãSTYLESãFORMATãTRANSPARENTç­
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    }
    // éæåº¦ï¼é»è®¤ 1
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.TileLayer.WMS(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=WMS.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/WMS/WMS.vue.mjs


WMS_vue2_script.__file = "src/vue-amap/packages/layer/standard/WMS/WMS.vue";


//# sourceMappingURL=WMS.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/WMS/index.mjs



WMS_vue2_script.install = (app) => {
  app.component(WMS_vue2_script.name, WMS_vue2_script);
  return app;
};
const ElAmapLayerWms = WMS_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/WMTS/WMTS.vue2.mjs



var WMTS_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerWmts",
  mixins: [registerComponent],
  props: {
    url: {
      type: String
    },
    // wmtsæå¡çurlå°åï¼å¦ï¼' https://services.arcgisonline.com/arcgis/rest/services/'+ 'Demographics/USA_Population_Density/MapServer/WMTS/'
    blend: {
      type: Boolean,
      default: false
    },
    // å°å¾çº§å«åæ¢æ¶ï¼ä¸åçº§å«çå¾çæ¯å¦è¿è¡æ··åï¼å¦å¾å±çå¾ååå®¹ä¸ºé¨åéæè¯·è®¾ç½®ä¸ºfalse
    params: {
      type: Object
    },
    // OGCæ åçWMSå°å¾æå¡çGetMapæ¥å£çåæ°ï¼åæ¬VERSIONãLAYERSãSTYLESãFORMATãTRANSPARENTç­
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    opacity: {
      type: Number
    }
    // éæåº¦ï¼é»è®¤ 1
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.TileLayer.WMTS(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=WMTS.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/WMTS/WMTS.vue.mjs


WMTS_vue2_script.__file = "src/vue-amap/packages/layer/standard/WMTS/WMTS.vue";


//# sourceMappingURL=WMTS.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/standard/WMTS/index.mjs



WMTS_vue2_script.install = (app) => {
  app.component(WMTS_vue2_script.name, WMTS_vue2_script);
  return app;
};
const ElAmapLayerWmts = WMTS_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/ElasticMarker/ElasticMarker.vue2.mjs



var ElasticMarker_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapElasticMarker",
  mixins: [registerComponent],
  props: {
    position: {
      type: [Array, Object],
      required: true
    },
    // ç¹æ è®°å¨å°å¾ä¸æ¾ç¤ºçä½ç½®
    title: {
      type: String
    },
    // é¼ æ æ»è¿ç¹æ è®°æ¶çæå­æç¤ºãä¸è®¾ç½®åé¼ æ æ»è¿ç¹æ æ æå­æç¤ºã
    offset: {
      type: [Array, Object]
    },
    // ç¹æ è®°æ¾ç¤ºä½ç½®åç§»éï¼é»è®¤å¼ä¸º [0,0] ãMarkeræå®positionåï¼é»è®¤ä»¥markerå·¦ä¸è§ä½ç½®ä¸ºåºåç¹ï¼è¥è®¾ç½®äºanchorï¼åä»¥anchorè®¾ç½®ä½ç½®ä¸ºåºåç¹ï¼ï¼å¯¹åæç»å®çpositionä½ç½®ï¼è¥éä½¿markeræå®ä½ç½®å¯¹åå¨positionå¤ï¼éæ ¹æ®markerçå°ºå¯¸è®¾ç½®ä¸å®çåç§»éã
    clickable: {
      type: Boolean,
      default: true
    },
    // ç¹æ è®°æ¯å¦å¯ç¹å»ï¼é»è®¤å¼: true
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®ç¹æ è®°æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤å¼ï¼false
    bubble: {
      type: Boolean,
      default: false
    },
    // äºä»¶æ¯å¦åæ³¡ï¼é»è®¤ä¸º false
    zooms: {
      type: Array
    },
    // ç¹æ è®°æ¾ç¤ºçå±çº§èå´ï¼è¶è¿èå´ä¸æ¾ç¤ºãé»è®¤å¼ï¼zooms: [2, 20]
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ ï¼é»è®¤å¼ï¼'pointer'
    topWhenClick: {
      type: Boolean,
      default: false
    },
    // é¼ æ ç¹å»æ¶markeræ¯å¦ç½®é¡¶ï¼é»è®¤false ï¼ä¸ç½®é¡¶
    zoomStyleMapping: {
      type: Object
    },
    // è¡¨ç¤ºå°å¾çº§å«ä¸stylesä¸­æ ·å¼çæ å°ï¼{14:0,15:0,16:1,17:1,}è¡¨ç¤º14å°15çº§ä½¿ç¨stylesä¸­çç¬¬0ä¸ªæ ·å¼ï¼16-17çº§ä½¿ç¨ç¬¬äºä¸ªæ ·å¼
    styles: {
      type: Array
    },
    // å¤ä¸ªä¸åæ ·å¼çæ°ç»
    extData: {
      type: Object,
      default: () => null
    }
  },
  emits: ["update:position"],
  data() {
    return {
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.ElasticMarker"], () => {
          this.$amapComponent = new AMap.ElasticMarker(options);
          this.$parentComponent.add(this.$amapComponent);
          this.bindModelEvents();
          resolve();
        });
      });
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitPosition();
      });
      this.$amapComponent.on("touchend", () => {
        this.emitPosition();
      });
    },
    emitPosition() {
      const position = this.$amapComponent.getPosition();
      this.$emit("update:position", position.toArray());
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=ElasticMarker.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/ElasticMarker/ElasticMarker.vue.mjs


ElasticMarker_vue2_script.__file = "src/vue-amap/packages/marker/ElasticMarker/ElasticMarker.vue";


//# sourceMappingURL=ElasticMarker.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/ElasticMarker/index.mjs



ElasticMarker_vue2_script.install = (app) => {
  app.component(ElasticMarker_vue2_script.name, ElasticMarker_vue2_script);
  return app;
};
const ElAmapElasticMarker = ElasticMarker_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/LabelMarker/LabelMarker.vue2.mjs



var LabelMarker_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLabelMarker",
  mixins: [registerComponent],
  props: {
    name: {
      type: String
    },
    // æ æ³¨åç§°ï¼ä½ä¸ºæ æ³¨æ è¯ï¼å¹¶éæç»å¨å°å¾ä¸æ¾ç¤ºçæå­åå®¹ï¼æ¾ç¤ºæå­åå®¹è¯·è®¾ç½® opts.text.content
    position: {
      type: [Array, Object],
      required: true
    },
    // æ æ³¨ä½ç½®
    zooms: {
      type: Array
    },
    // ç¹æ è®°æ¾ç¤ºçå±çº§èå´ï¼è¶è¿èå´ä¸æ¾ç¤ºãé»è®¤å¼ï¼zooms: [2, 20]
    opacity: {
      type: Number
    },
    // æ æ³¨éæåº¦ï¼é»è®¤å¼: 1
    rank: {
      type: Number
    },
    // é¿è®©ä¼åçº§ï¼è·åæ æ³¨çä¼åçº§ï¼è¯¥ä¼åçº§ç¨äº labelsLayer æ¯æé¿è®©æ¶ï¼rank å¼å¤§çæ æ³¨ä¼é¿è®©æ rank å¼ä½çæ æ³¨ãé»è®¤å¼ï¼1
    icon: {
      type: Object
    },
    // æ æ³¨å¾æ è®¾ç½®
    text: {
      type: Object
    },
    // æ æ³¨ææ¬è®¾ç½®
    extData: null
  },
  data() {
    return {
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.LabelMarker(options);
      this.$parentComponent.add(this.$amapComponent);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=LabelMarker.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/LabelMarker/LabelMarker.vue.mjs


LabelMarker_vue2_script.__file = "src/vue-amap/packages/marker/LabelMarker/LabelMarker.vue";


//# sourceMappingURL=LabelMarker.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/LabelMarker/index.mjs



LabelMarker_vue2_script.install = (app) => {
  app.component(LabelMarker_vue2_script.name, LabelMarker_vue2_script);
  return app;
};
const ElAmapLabelMarker = LabelMarker_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/Marker/Marker.vue2.mjs



var Marker_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapMarker",
  mixins: [registerComponent],
  props: {
    position: {
      type: [Array, Object],
      required: true
    },
    // ç¹æ è®°å¨å°å¾ä¸æ¾ç¤ºçä½ç½®
    icon: {
      type: [String, Object]
    },
    // å¨ç¹æ è®°ä¸­æ¾ç¤ºçå¾æ ãå¯ä»¥ä¼ ä¸ä¸ªå¾æ å°åï¼ä¹å¯ä»¥ä¼ Iconå¯¹è±¡ãæåæ³çcontentåå®¹è®¾ç½®æ¶ï¼æ­¤å±æ§æ æã
    content: {
      type: [String, typeof HTMLElement === "undefined" ? Object : HTMLElement]
    },
    // ç¹æ è®°æ¾ç¤ºåå®¹ãå¯ä»¥æ¯HTMLè¦ç´ å­ç¬¦ä¸²æèHTML DOMå¯¹è±¡ãcontentæææ¶ï¼iconå±æ§å°è¢«è¦çã
    title: {
      type: String
    },
    // é¼ æ æ»è¿ç¹æ è®°æ¶çæå­æç¤ºãä¸è®¾ç½®åé¼ æ æ»è¿ç¹æ æ æå­æç¤ºã
    offset: {
      type: [Array, Object]
    },
    // ç¹æ è®°æ¾ç¤ºä½ç½®åç§»éï¼é»è®¤å¼ä¸º [0,0] ãMarkeræå®positionåï¼é»è®¤ä»¥markerå·¦ä¸è§ä½ç½®ä¸ºåºåç¹ï¼è¥è®¾ç½®äºanchorï¼åä»¥anchorè®¾ç½®ä½ç½®ä¸ºåºåç¹ï¼ï¼å¯¹åæç»å®çpositionä½ç½®ï¼è¥éä½¿markeræå®ä½ç½®å¯¹åå¨positionå¤ï¼éæ ¹æ®markerçå°ºå¯¸è®¾ç½®ä¸å®çåç§»éã
    anchor: {
      type: [String, Array]
    },
    // è®¾ç½®ç¹æ è®°éç¹ï¼å¯éå¼ï¼'top-left','top-center','top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-center', 'bottom-right'
    angle: {
      type: Number
    },
    // ç¹æ è®°çæè½¬è§åº¦ï¼ï¼å¹¿æ³ç¨äºæ¹åè½¦è¾è¡é©¶æ¹åãé»è®¤å¼ï¼0
    clickable: {
      type: Boolean,
      default: true
    },
    // ç¹æ è®°æ¯å¦å¯ç¹å»ï¼é»è®¤å¼: true
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®ç¹æ è®°æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤å¼ï¼false
    bubble: {
      type: Boolean,
      default: false
    },
    // äºä»¶æ¯å¦åæ³¡ï¼é»è®¤ä¸º false
    zooms: {
      type: Array
    },
    // ç¹æ è®°æ¾ç¤ºçå±çº§èå´ï¼è¶è¿èå´ä¸æ¾ç¤ºãé»è®¤å¼ï¼zooms: [2, 20]
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ ï¼é»è®¤å¼ï¼'pointer'
    topWhenClick: {
      type: Boolean,
      default: false
    },
    // é¼ æ ç¹å»æ¶markeræ¯å¦ç½®é¡¶ï¼é»è®¤false ï¼ä¸ç½®é¡¶
    label: {
      type: Object
    },
    // æ·»å ææ¬æ æ³¨
    extData: null,
    moveOptions: {
      type: Object,
      default: () => null
    }
  },
  emits: ["update:position"],
  data() {
    return {
      withSlot: false,
      converters: {}
    };
  },
  /*updated() {
    if(this.withSlot && this.$amapComponent){
      this.$amapComponent.setContent(this.$refs.content);
    }
  },*/
  methods: {
    __initComponent(options) {
      if (this.$slots.default && this.$slots.default().length > 0) {
        this.withSlot = true;
        options.content = this.getSlotContent();
      }
      this.$amapComponent = new AMap.Marker(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      }
      if (this.withSlot) {
        const config = { attributes: true, childList: true, subtree: true };
        const observer = new MutationObserver(() => {
          this.$amapComponent.setContent(this.getSlotContent());
        });
        observer.observe(this.$refs.content, config);
        this.observer = observer;
      }
      this.bindModelEvents();
    },
    getSlotContent() {
      return this.$refs.content;
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitPosition();
      });
      this.$amapComponent.on("touchend", () => {
        this.emitPosition();
      });
    },
    emitPosition() {
      const position = this.$amapComponent.getPosition();
      this.$emit("update:position", position.toArray());
    },
    destroyComponent() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __position(position) {
      if (!this.moveOptions) {
        this.$amapComponent.setPosition(position);
        return;
      }
      if (this.$parentComponent) {
        this.$parentComponent.plugin("AMap.MoveAnimation", () => {
          this.$amapComponent.moveTo(position, this.moveOptions);
        });
      }
    }
  }
});


//# sourceMappingURL=Marker.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/Marker/Marker.vue3.mjs


const Marker_vue3_hoisted_1 = { style: { "display": "none" } };
const Marker_vue3_hoisted_2 = { ref: "content" };
function Marker_vue3_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)("div", Marker_vue3_hoisted_1, [
    (0,runtime_core_esm_bundler/* createElementVNode */.Lk)(
      "div",
      Marker_vue3_hoisted_2,
      [
        (0,runtime_core_esm_bundler/* renderSlot */.RG)(_ctx.$slots, "default")
      ],
      512
      /* NEED_PATCH */
    )
  ]);
}


//# sourceMappingURL=Marker.vue3.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/Marker/Marker.vue.mjs



Marker_vue2_script.render = Marker_vue3_render;
Marker_vue2_script.__file = "src/vue-amap/packages/marker/Marker/Marker.vue";


//# sourceMappingURL=Marker.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/Marker/index.mjs



Marker_vue2_script.install = (app) => {
  app.component(Marker_vue2_script.name, Marker_vue2_script);
  return app;
};
const ElAmapMarker = Marker_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/MarkerCluster/MarkerCluster.vue2.mjs



var MarkerCluster_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapMarkerCluster",
  mixins: [registerComponent],
  props: {
    points: {
      type: Array,
      required: true
    },
    // éè¦è¿è¡èåæ¾ç¤ºçç¹æ°æ®
    gridSize: {
      type: Number
    },
    // èåè®¡ç®æ¶ç½æ ¼çåç´ å¤§å°ï¼é»è®¤60
    maxZoom: {
      type: Number
    },
    // æå¤§çèåçº§å«ï¼å¤§äºè¯¥çº§å«å°±ä¸è¿è¡ç¸åºçèåãé»è®¤å¼ä¸º 18ï¼å³å°äº 18 çº§ççº§å«åè¿è¡èåï¼18 åä»¥ä¸çº§å«ä¸è¿è¡èå
    averageCenter: {
      type: Boolean,
      default: true
    },
    // èåç¹çå¾æ ä½ç½®æ¯å¦æ¯ææèååç¹çä¸­å¿ç¹ãé»è®¤ä¸º trueãæ°æ®ä¸­å¦æå«ææéå¼ï¼ä»¥æéé«çç¹ä¸ºä¸­å¿è¿è¡èå
    clusterByZoomChange: {
      type: Boolean,
      default: false
    },
    // å°å¾ç¼©æ¾è¿ç¨ä¸­æ¯å¦èåãé»è®¤å¼ falseã
    styles: {
      type: Array
    },
    // æå®èååçç¹æ è®°çå¾æ æ ·å¼ï¼å¯ç¼ºçï¼ç¼ºçæ¶ä¸ºé»è®¤æ ·å¼
    renderClusterMarker: {
      type: Function
    },
    // è¯¥æ¹æ³ç¨æ¥å®ç°èåç¹çèªå®ä¹ç»å¶ï¼ç±å¼åèèªå·±å®ç°ï¼API å°å¨ç»å¶æ¯ä¸ªèåç¹çæ¶åè°ç¨è¿ä¸ªæ¹æ³ï¼å¯ä»¥å®ç°èåç¹æ ·å¼ççµæ´»è®¾å®ï¼æå®äº renderClusterMarker å styles æ æã
    renderMarker: {
      type: Function
    }
    // è¯¥æ¹æ³ç¨æ¥å®ç°éèåç¹çèªå®ä¹ç»å¶ï¼ç±å¼åèèªå·±å®ç°ï¼API å°å¨ç»å¶æ¯ä¸ªéèåç¹çæ¶åè°ç¨è¿ä¸ªæ¹æ³
  },
  data() {
    return {
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.MarkerCluster"], () => {
          const points = options.points;
          delete options.points;
          this.$amapComponent = new AMap.MarkerCluster(this.$parentComponent, points, options);
          resolve();
        });
      });
    },
    destroyComponent() {
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __points(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setData(value);
      }
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=MarkerCluster.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/MarkerCluster/MarkerCluster.vue.mjs


MarkerCluster_vue2_script.__file = "src/vue-amap/packages/marker/MarkerCluster/MarkerCluster.vue";


//# sourceMappingURL=MarkerCluster.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/MarkerCluster/index.mjs



MarkerCluster_vue2_script.install = (app) => {
  app.component(MarkerCluster_vue2_script.name, MarkerCluster_vue2_script);
  return app;
};
const ElAmapMarkerCluster = MarkerCluster_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/MassMarks/MassMarks.vue2.mjs



var MassMarks_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapMassMarks",
  mixins: [registerComponent],
  props: {
    data: {
      type: Array,
      required: true
    },
    // æµ·éç¹æ°æ®åæ°
    zooms: {
      type: Array
    },
    // ç¹æ è®°æ¾ç¤ºçå±çº§èå´ï¼è¶è¿èå´ä¸æ¾ç¤ºã
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ ï¼é»è®¤å¼ï¼'pointer'
    styles: {
      type: [Array, Object]
    }
    // æ ·å¼
  },
  data() {
    return {
      propsRedirect: {
        styles: "style"
      },
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      const data = options.data;
      delete options.data;
      this.$amapComponent = new AMap.MassMarks(data, options);
      this.$amapComponent.setMap(this.$parentComponent);
    },
    destroyComponent() {
      this.$amapComponent.clear();
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=MassMarks.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/MassMarks/MassMarks.vue.mjs


MassMarks_vue2_script.__file = "src/vue-amap/packages/marker/MassMarks/MassMarks.vue";


//# sourceMappingURL=MassMarks.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/MassMarks/index.mjs



MassMarks_vue2_script.install = (app) => {
  app.component(MassMarks_vue2_script.name, MassMarks_vue2_script);
  return app;
};
const ElAmapMassMarks = MassMarks_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/Text/Text.vue2.mjs



var Text_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapText",
  mixins: [registerComponent],
  props: {
    position: {
      type: [Array, Object],
      required: true
    },
    // ç¹æ è®°å¨å°å¾ä¸æ¾ç¤ºçä½ç½®
    text: {
      type: String
    },
    // æ è®°æ¾ç¤ºçææ¬åå®¹
    title: {
      type: String
    },
    // é¼ æ æ»è¿ç¹æ è®°æ¶çæå­æç¤ºãä¸è®¾ç½®åé¼ æ æ»è¿ç¹æ æ æå­æç¤ºã
    offset: {
      type: [Array, Object]
    },
    // ç¹æ è®°æ¾ç¤ºä½ç½®åç§»éï¼é»è®¤å¼ä¸º [0,0] ãMarkeræå®positionåï¼é»è®¤ä»¥markerå·¦ä¸è§ä½ç½®ä¸ºåºåç¹ï¼è¥è®¾ç½®äºanchorï¼åä»¥anchorè®¾ç½®ä½ç½®ä¸ºåºåç¹ï¼ï¼å¯¹åæç»å®çpositionä½ç½®ï¼è¥éä½¿markeræå®ä½ç½®å¯¹åå¨positionå¤ï¼éæ ¹æ®markerçå°ºå¯¸è®¾ç½®ä¸å®çåç§»éã
    anchor: {
      type: [String, Array]
    },
    // è®¾ç½®ç¹æ è®°éç¹ï¼å¯éå¼ï¼'top-left','top-center','top-right', 'middle-left', 'center', 'middle-right', 'bottom-left', 'bottom-center', 'bottom-right'
    angle: {
      type: Number
    },
    // ç¹æ è®°çæè½¬è§åº¦ãé»è®¤å¼ï¼0 ãæ³¨ï¼angleå±æ§æ¯ä½¿ç¨CSS3æ¥å®ç°çï¼æ¯æIE9åä»¥ä¸çæ¬
    clickable: {
      type: Boolean,
      default: true
    },
    // ç¹æ è®°æ¯å¦å¯ç¹å»ï¼é»è®¤å¼: true
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®ç¹æ è®°æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤å¼ï¼false
    bubble: {
      type: Boolean,
      default: false
    },
    // äºä»¶æ¯å¦åæ³¡ï¼é»è®¤ä¸º false
    zooms: {
      type: Array
    },
    // ç¹æ è®°æ¾ç¤ºçå±çº§èå´ï¼è¶è¿èå´ä¸æ¾ç¤ºãé»è®¤å¼ï¼zooms: [2, 20]
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ ï¼é»è®¤å¼ï¼'pointer'
    topWhenClick: {
      type: Boolean,
      default: false
    },
    // é¼ æ ç¹å»æ¶markeræ¯å¦ç½®é¡¶ï¼é»è®¤false ï¼ä¸ç½®é¡¶
    textStyle: {
      type: Object
    },
    // è®¾ç½®ææ¬æ ·å¼ï¼Objectåcssæ ·å¼è¡¨ï¼å¦:{'background-color':'red'}
    extData: null
  },
  emits: ["update:position"],
  data() {
    return {
      propsRedirect: {
        textStyle: "style"
      },
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Text(options);
      this.$parentComponent.add(this.$amapComponent);
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitPosition();
      });
      this.$amapComponent.on("touchend", () => {
        this.emitPosition();
      });
    },
    emitPosition() {
      const position = this.$amapComponent.getPosition();
      this.$emit("update:position", position.toArray());
    },
    destroyComponent() {
      this.$amapComponent.setMap(null);
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Text.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/Text/Text.vue.mjs


Text_vue2_script.__file = "src/vue-amap/packages/marker/Text/Text.vue";


//# sourceMappingURL=Text.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/Text/index.mjs



Text_vue2_script.install = (app) => {
  app.component(Text_vue2_script.name, Text_vue2_script);
  return app;
};
const ElAmapText = Text_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/mixins/editor-component.mjs



var editorMixin = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  props: {
    editable: {
      type: Boolean,
      default: false
    },
    editOptions: {
      type: Object
    }
  },
  data() {
    return {};
  },
  methods: {
    setEditorEvents() {
      if (!this.$amapComponent.editor)
        return;
      const filters = ["addnode", "adjust", "removenode", "end", "move", "add"];
      const filterSet = {};
      Object.keys(this.$attrs).forEach((key) => {
        if (eventReg.test(key)) {
          const eventKey = convertEventToLowerCase(key);
          if (filters.indexOf(eventKey) !== -1)
            filterSet[eventKey] = this.$attrs[key];
        }
      });
      Object.keys(filterSet).forEach((key) => {
        eventHelper$1.addListener(this.$amapComponent.editor, key, filterSet[key]);
      });
    }
  }
});


//# sourceMappingURL=editor-component.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/BezierCurve/BezierCurve.vue2.mjs




var BezierCurve_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapBezierCurve",
  mixins: [registerComponent, editorMixin],
  props: {
    path: {
      type: Array,
      required: true
    },
    // è´çå°æ²çº¿çè·¯å¾ãæè¿°ä¸ºä¸ä¸ªäºç»´æ°ç»è§åå¦ä¸ï¼ç¬¬ä¸ä¸ªåç´ æ¯èµ·ç¹ï¼ ä¹åçåç´ åæ¶æè¿°æ§å¶ç¹åéç»ç¹ï¼ä¹åæ¯ä¸ªåç´ å¯ä»¥æ0ä¸ªå°2ä¸ªæ§å¶ç¹ æ§å¶ç¹å¨åï¼éç»ç¹å¨æå [ [lng,lat] ,//èµ·ç¹0 [lng,lat,lng,lat,lng,lat] ,//æ§å¶ç¹ãæ§å¶ç¹ãéç»ç¹2 [lng,lat,lng,lat] //æ§å¶ç¹ãéç»ç¹3 ] æè [ [ [lng,lat] ],//èµ·ç¹0 [ [lng,lat] , [lng,lat] ],//æ§å¶ç¹ãéç»ç¹1 [ [lng,lat] , [lng,lat] , [lng,lat] ],//æ§å¶ç¹ãæ§å¶ç¹ãéç»ç¹2 [ [lng,lat] , [lng,lat] ]//æ§å¶ç¹ãéç»ç¹3 ]
    bubble: {
      type: Boolean,
      default: false
    },
    // æ¯å¦å°è¦çç©çé¼ æ ætouchç­äºä»¶åæ³¡å°å°å¾ä¸
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ æ æ ·å¼ï¼èªå®ä¹cursorï¼IEä»æ¯æcur/ani/icoæ ¼å¼ï¼Operaä¸æ¯æèªå®ä¹cursor
    strokeColor: {
      type: String
    },
    // çº¿æ¡é¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ãé»è®¤å¼ä¸º#00D3FC
    strokeOpacity: {
      type: Number
    },
    // è½®å»çº¿éæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.9
    strokeWeight: {
      type: Number
    },
    // è½®å»çº¿å®½åº¦ãé»è®¤ 2
    borderWeight: {
      type: Number
    },
    // æè¾¹çº¿å®½åº¦
    isOutline: {
      type: Boolean,
      default: false
    },
    // æ¯å¦æ¾ç¤ºæè¾¹,é»è®¤false
    outlineColor: {
      type: String
    },
    // çº¿æ¡æè¾¹é¢è²ï¼æ­¤é¡¹ä»å¨isOutlineä¸ºtrueæ¶ææï¼é»è®¤ï¼#00B2D5
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®å¤è¾¹å½¢æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤ä¸ºfalse
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator: (value) => {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    // è½®å»çº¿æ ·å¼ï¼å®çº¿:solidï¼èçº¿:dashed
    strokeDasharray: {
      type: Array
    },
    // å¾åå½¢ç¶è½®å»çèçº¿åé´éçæ ·å¼ï¼æ­¤å±æ§å¨strokeStyle ä¸ºdashed æ¶ææï¼ æ­¤å±æ§å¨ie9+æµè§å¨ææ åå¼ï¼ å®çº¿ï¼ [0,0,0] èçº¿ï¼ [10,10] ï¼ [10,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿ ç¹ç»çº¿ï¼ [10,2,10] ï¼ [10,2,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å2ä¸ªåç´ çç©ºç½ + 10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿
    lineJoin: {
      type: String,
      validator: (value) => {
        return ["miter", "round", "bevel"].indexOf(value) !== -1;
      }
    },
    // æçº¿æç¹çç»å¶æ ·å¼ï¼é»è®¤å¼ä¸º'miter'å°è§ï¼å¶ä»å¯éå¼ï¼'round'åè§ã'bevel'æè§
    lineCap: {
      type: String,
      validator: (value) => {
        return ["butt", "round", "square"].indexOf(value) !== -1;
      }
    },
    // æçº¿ä¸¤ç«¯çº¿å¸½çç»å¶æ ·å¼ï¼é»è®¤å¼ä¸º'butt'æ å¤´ï¼å¶ä»å¯éå¼ï¼'round'åå¤´ã'square'æ¹å¤´
    geodesic: {
      type: Boolean,
      default: false
    },
    // æ¯å¦ç»å¶æå¤§å°çº¿ï¼é»è®¤false
    showDir: {
      type: Boolean,
      default: false
    }
    // æ¯å¦å»¶è·¯å¾æ¾ç¤ºç½è²æ¹åç®­å¤´,é»è®¤falseãå»ºè®®æçº¿å®½åº¦å¤§äº6æ¶ä½¿ç¨
  },
  emits: ["update:path"],
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.BezierCurve(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.BezierCurveEditor"], () => {
            this.$amapComponent.editor = new AMap.BezierCurveEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("removenode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      this.$emit("update:path", target.getPath());
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __borderWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ borderWeight: value });
      }
    },
    __isOutline(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ isOutline: value });
      }
    },
    __outlineColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ outlineColor: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __lineJoin(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ lineJoin: value });
      }
    },
    __lineCap(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ lineCap: value });
      }
    },
    __geodesic(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ geodesic: value });
      }
    },
    __showDir(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ showDir: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=BezierCurve.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/BezierCurve/BezierCurve.vue.mjs


BezierCurve_vue2_script.__file = "src/vue-amap/packages/vector/BezierCurve/BezierCurve.vue";


//# sourceMappingURL=BezierCurve.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/BezierCurve/index.mjs



BezierCurve_vue2_script.install = (app) => {
  app.component(BezierCurve_vue2_script.name, BezierCurve_vue2_script);
  return app;
};
const ElAmapBezierCurve = BezierCurve_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Circle/Circle.vue2.mjs




var Circle_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapCircle",
  mixins: [registerComponent, editorMixin],
  props: {
    center: {
      type: Array,
      required: true
    },
    // åå¿ä½ç½®
    radius: {
      type: Number,
      required: true
    },
    // ååå¾ï¼åä½:ç±³
    bubble: {
      type: Boolean,
      default: false
    },
    // æ¯å¦å°è¦çç©çé¼ æ ætouchç­äºä»¶åæ³¡å°å°å¾ä¸
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ æ æ ·å¼ï¼èªå®ä¹cursorï¼IEä»æ¯æcur/ani/icoæ ¼å¼ï¼Operaä¸æ¯æèªå®ä¹cursor
    strokeColor: {
      type: String
    },
    // çº¿æ¡é¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ãé»è®¤å¼ä¸º#00D3FC
    strokeOpacity: {
      type: Number
    },
    // è½®å»çº¿éæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.9
    strokeWeight: {
      type: Number
    },
    // è½®å»çº¿å®½åº¦ãé»è®¤ 2
    fillColor: {
      type: String
    },
    // å¤è¾¹å½¢å¡«åé¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ï¼å¦ï¼#00B2D5
    fillOpacity: {
      type: Number
    },
    // å¤è¾¹å½¢å¡«åéæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.5
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®å¤è¾¹å½¢æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤ä¸ºfalse
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator: (value) => {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    // è½®å»çº¿æ ·å¼ï¼å®çº¿:solidï¼èçº¿:dashed
    strokeDasharray: {
      type: Array
    }
    // å¾åå½¢ç¶è½®å»çèçº¿åé´éçæ ·å¼ï¼æ­¤å±æ§å¨strokeStyle ä¸ºdashed æ¶ææï¼ æ­¤å±æ§å¨ie9+æµè§å¨ææ åå¼ï¼ å®çº¿ï¼ [0,0,0] èçº¿ï¼ [10,10] ï¼ [10,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿ ç¹ç»çº¿ï¼ [10,2,10] ï¼ [10,2,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å2ä¸ªåç´ çç©ºç½ + 10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿
  },
  emits: ["update:center", "update:radius"],
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Circle(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.CircleEditor"], () => {
            this.$amapComponent.editor = new AMap.CircleEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("move", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      this.$emit("update:center", target.getCenter().toArray());
      this.$emit("update:radius", target.getRadius());
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __fillColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillColor: value });
      }
    },
    __fillOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillOpacity: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Circle.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Circle/Circle.vue.mjs


Circle_vue2_script.__file = "src/vue-amap/packages/vector/Circle/Circle.vue";


//# sourceMappingURL=Circle.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Circle/index.mjs



Circle_vue2_script.install = (app) => {
  app.component(Circle_vue2_script.name, Circle_vue2_script);
  return app;
};
const ElAmapCircle = Circle_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Ellipse/Ellipse.vue2.mjs




var Ellipse_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapEllipse",
  mixins: [registerComponent, editorMixin],
  props: {
    center: {
      type: Array,
      required: true
    },
    // åå¿ä½ç½®
    radius: {
      type: Array,
      required: true
    },
    // æ¤­åçåå¾ï¼ç¨2ä¸ªåç´ çæ°ç»è¡¨ç¤ºï¼åä½ï¼ç±³ å¦ï¼ radius: [1000, 2000] è¡¨ç¤ºæ¨ªååå¾æ¯1000ï¼çºµåçåå¾æ¯2000 é»è®¤å¼ï¼ [1000, 1000]v
    bubble: {
      type: Boolean,
      default: false
    },
    // æ¯å¦å°è¦çç©çé¼ æ ætouchç­äºä»¶åæ³¡å°å°å¾ä¸
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ æ æ ·å¼ï¼èªå®ä¹cursorï¼IEä»æ¯æcur/ani/icoæ ¼å¼ï¼Operaä¸æ¯æèªå®ä¹cursor
    strokeColor: {
      type: String
    },
    // çº¿æ¡é¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ãé»è®¤å¼ä¸º#00D3FC
    strokeOpacity: {
      type: Number
    },
    // è½®å»çº¿éæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.9
    strokeWeight: {
      type: Number
    },
    // è½®å»çº¿å®½åº¦ãé»è®¤ 2
    fillColor: {
      type: String
    },
    // å¤è¾¹å½¢å¡«åé¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ï¼å¦ï¼#00B2D5
    fillOpacity: {
      type: Number
    },
    // å¤è¾¹å½¢å¡«åéæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.5
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®å¤è¾¹å½¢æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤ä¸ºfalse
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator: (value) => {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    // è½®å»çº¿æ ·å¼ï¼å®çº¿:solidï¼èçº¿:dashed
    strokeDasharray: {
      type: Array
    }
    // å¾åå½¢ç¶è½®å»çèçº¿åé´éçæ ·å¼ï¼æ­¤å±æ§å¨strokeStyle ä¸ºdashed æ¶ææï¼ æ­¤å±æ§å¨ie9+æµè§å¨ææ åå¼ï¼ å®çº¿ï¼ [0,0,0] èçº¿ï¼ [10,10] ï¼ [10,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿ ç¹ç»çº¿ï¼ [10,2,10] ï¼ [10,2,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å2ä¸ªåç´ çç©ºç½ + 10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿
  },
  emits: ["update:center", "update:radius"],
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Ellipse(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.EllipseEditor"], () => {
            this.$amapComponent.editor = new AMap.EllipseEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("move", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      this.$emit("update:center", target.getCenter().toArray());
      this.$emit("update:radius", target.getRadius());
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __fillColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillColor: value });
      }
    },
    __fillOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillOpacity: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Ellipse.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Ellipse/Ellipse.vue.mjs


Ellipse_vue2_script.__file = "src/vue-amap/packages/vector/Ellipse/Ellipse.vue";


//# sourceMappingURL=Ellipse.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Ellipse/index.mjs



Ellipse_vue2_script.install = (app) => {
  app.component(Ellipse_vue2_script.name, Ellipse_vue2_script);
  return app;
};
const ElAmapEllipse = Ellipse_vue2_script;


//# sourceMappingURL=index.mjs.map

// EXTERNAL MODULE: ./node_modules/lodash-es/merge.js + 95 modules
var merge = __webpack_require__(2847);
;// ./node_modules/@vuemap/vue-amap/es/packages/vector/GeoJSON/GeoJSON.vue2.mjs




var GeoJSON_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapGeojson",
  mixins: [registerComponent],
  props: {
    geo: {
      type: Object,
      required: true
    },
    // è¦å è½½çæ åGeoJSONå¯¹è±¡
    markerOptions: {
      type: Object
    },
    // markerçé»è®¤æ ·å¼
    getMarker: {
      type: Function
    },
    // æå®ç¹è¦ç´ çç»å¶æ¹å¼ï¼ç¼ºçæ¶ä¸ºMarkerçé»è®¤æ ·å¼ãgeojsonä¸ºå½åè¦ç´ å¯¹åºçGeoJSONå¯¹è±¡ï¼lnglatsä¸ºå¯¹åºççº¿çè·¯å¾
    polylineOptions: {
      type: Object
    },
    // polylineçé»è®¤æ ·å¼
    getPolyline: {
      type: Function
    },
    // æå®çº¿è¦ç´ çç»å¶æ¹å¼ï¼ç¼ºçæ¶ä¸ºPolylineçé»è®¤æ ·å¼ãgeojsonä¸ºå½åè¦ç´ å¯¹åºçGeoJSONå¯¹è±¡ï¼lnglatsä¸ºå¯¹åºççº¿çè·¯å¾
    polygonOptions: {
      type: Object
    },
    // polygonçé»è®¤æ ·å¼
    getPolygon: {
      type: Function
    }
    // æå®é¢è¦ç´ çç»å¶æ¹å¼ï¼ç¼ºçæ¶ä¸ºPolygonçé»è®¤æ ·å¼ãgeojsonä¸ºå½åè¦ç´ å¯¹åºçGeoJSONå¯¹è±¡ï¼lnglatsä¸ºå¯¹åºççº¿çè·¯å¾
  },
  data() {
    return {
      propsRedirect: {
        geo: "geoJSON"
      },
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.GeoJSON"], () => {
          if (!options.getMarker) {
            options.getMarker = this.createMarker;
          }
          if (!options.getPolyline) {
            options.getPolyline = this.createPolyline;
          }
          if (!options.getPolygon) {
            options.getPolygon = this.createPolygon;
          }
          this.$amapComponent = new AMap.GeoJSON(options);
          this.$parentComponent.add(this.$amapComponent);
          resolve();
        });
      });
    },
    createMarker(geojson, lnglat) {
      let options = this.markerOptions || {};
      options = (0,merge/* default */.A)({}, options, geojson.properties);
      options.position = lnglat;
      return new AMap.Marker(options);
    },
    createPolyline(geojson, lnglat) {
      let options = this.polylineOptions || {};
      options = (0,merge/* default */.A)({}, options, geojson.properties);
      options.path = lnglat;
      return new AMap.Polyline(options);
    },
    createPolygon(geojson, lnglat) {
      let options = this.polygonOptions || {};
      options = (0,merge/* default */.A)({}, options, geojson.properties);
      options.path = lnglat;
      return new AMap.Polygon(options);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __geoJSON(value) {
      if (this.$amapComponent) {
        this.$amapComponent.importData(value);
      }
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=GeoJSON.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/GeoJSON/GeoJSON.vue.mjs


GeoJSON_vue2_script.__file = "src/vue-amap/packages/vector/GeoJSON/GeoJSON.vue";


//# sourceMappingURL=GeoJSON.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/GeoJSON/index.mjs



GeoJSON_vue2_script.install = (app) => {
  app.component(GeoJSON_vue2_script.name, GeoJSON_vue2_script);
  return app;
};
const ElAmapGeojson = GeoJSON_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Polygon/Polygon.vue2.mjs




var Polygon_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapPolygon",
  mixins: [registerComponent, editorMixin],
  props: {
    path: {
      type: Array,
      required: true
    },
    // å¤è¾¹å½¢è½®å»çº¿çèç¹åæ æ°ç»ã æ¯æ åä¸ªæ®éå¤è¾¹å½¢({Array })ï¼åä¸ªå¸¦å­å¤è¾¹å½¢({Array<Array >})ï¼å¤ä¸ªå¸¦å­å¤è¾¹å½¢({Array<Array<Array >>})
    bubble: {
      type: Boolean,
      default: false
    },
    // æ¯å¦å°è¦çç©çé¼ æ ætouchç­äºä»¶åæ³¡å°å°å¾ä¸
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ æ æ ·å¼ï¼èªå®ä¹cursorï¼IEä»æ¯æcur/ani/icoæ ¼å¼ï¼Operaä¸æ¯æèªå®ä¹cursor
    strokeColor: {
      type: String
    },
    // çº¿æ¡é¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ãé»è®¤å¼ä¸º#00D3FC
    strokeOpacity: {
      type: Number
    },
    // è½®å»çº¿éæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.9
    strokeWeight: {
      type: Number
    },
    // è½®å»çº¿å®½åº¦ãé»è®¤ 2
    fillColor: {
      type: String
    },
    // å¤è¾¹å½¢å¡«åé¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ï¼å¦ï¼#00B2D5
    fillOpacity: {
      type: Number
    },
    // å¤è¾¹å½¢å¡«åéæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.5
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®å¤è¾¹å½¢æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤ä¸ºfalse
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator: (value) => {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    // è½®å»çº¿æ ·å¼ï¼å®çº¿:solidï¼èçº¿:dashed
    strokeDasharray: {
      type: Array
    }
    // å¾åå½¢ç¶è½®å»çèçº¿åé´éçæ ·å¼ï¼æ­¤å±æ§å¨strokeStyle ä¸ºdashed æ¶ææï¼ æ­¤å±æ§å¨ie9+æµè§å¨ææ åå¼ï¼ å®çº¿ï¼ [0,0,0] èçº¿ï¼ [10,10] ï¼ [10,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿ ç¹ç»çº¿ï¼ [10,2,10] ï¼ [10,2,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å2ä¸ªåç´ çç©ºç½ + 10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿
  },
  emits: ["update:path"],
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Polygon(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.PolygonEditor"], () => {
            this.$amapComponent.editor = new AMap.PolygonEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("removenode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      const paths = target.getPath();
      const pathArray = paths.map(convertLnglat);
      this.$emit("update:path", pathArray);
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __fillColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillColor: value });
      }
    },
    __fillOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillOpacity: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Polygon.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Polygon/Polygon.vue.mjs


Polygon_vue2_script.__file = "src/vue-amap/packages/vector/Polygon/Polygon.vue";


//# sourceMappingURL=Polygon.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Polygon/index.mjs



Polygon_vue2_script.install = (app) => {
  app.component(Polygon_vue2_script.name, Polygon_vue2_script);
  return app;
};
const ElAmapPolygon = Polygon_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Polyline/Polyline.vue2.mjs




var Polyline_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapPolyline",
  mixins: [registerComponent, editorMixin],
  props: {
    path: {
      type: Array,
      required: true
    },
    // polyline è·¯å¾ï¼æ¯æ lineString å MultiLineString
    bubble: {
      type: Boolean,
      default: false
    },
    // æ¯å¦å°è¦çç©çé¼ æ ætouchç­äºä»¶åæ³¡å°å°å¾ä¸
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ æ æ ·å¼ï¼èªå®ä¹cursorï¼IEä»æ¯æcur/ani/icoæ ¼å¼ï¼Operaä¸æ¯æèªå®ä¹cursor
    strokeColor: {
      type: String
    },
    // çº¿æ¡é¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ãé»è®¤å¼ä¸º#00D3FC
    strokeOpacity: {
      type: Number
    },
    // è½®å»çº¿éæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.9
    strokeWeight: {
      type: Number
    },
    // è½®å»çº¿å®½åº¦ãé»è®¤ 2
    borderWeight: {
      type: Number
    },
    // æè¾¹çº¿å®½åº¦
    isOutline: {
      type: Boolean,
      default: false
    },
    // æ¯å¦æ¾ç¤ºæè¾¹,é»è®¤false
    outlineColor: {
      type: String
    },
    // çº¿æ¡æè¾¹é¢è²ï¼æ­¤é¡¹ä»å¨isOutlineä¸ºtrueæ¶ææï¼é»è®¤ï¼#00B2D5
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®å¤è¾¹å½¢æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤ä¸ºfalse
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator: (value) => {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    // è½®å»çº¿æ ·å¼ï¼å®çº¿:solidï¼èçº¿:dashed
    strokeDasharray: {
      type: Array
    },
    // å¾åå½¢ç¶è½®å»çèçº¿åé´éçæ ·å¼ï¼æ­¤å±æ§å¨strokeStyle ä¸ºdashed æ¶ææï¼ æ­¤å±æ§å¨ie9+æµè§å¨ææ åå¼ï¼ å®çº¿ï¼ [0,0,0] èçº¿ï¼ [10,10] ï¼ [10,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿ ç¹ç»çº¿ï¼ [10,2,10] ï¼ [10,2,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å2ä¸ªåç´ çç©ºç½ + 10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿
    lineJoin: {
      type: String,
      validator: (value) => {
        return ["miter", "round", "bevel"].indexOf(value) !== -1;
      }
    },
    // æçº¿æç¹çç»å¶æ ·å¼ï¼é»è®¤å¼ä¸º'miter'å°è§ï¼å¶ä»å¯éå¼ï¼'round'åè§ã'bevel'æè§
    lineCap: {
      type: String,
      validator: (value) => {
        return ["butt", "round", "square"].indexOf(value) !== -1;
      }
    },
    // æçº¿ä¸¤ç«¯çº¿å¸½çç»å¶æ ·å¼ï¼é»è®¤å¼ä¸º'butt'æ å¤´ï¼å¶ä»å¯éå¼ï¼'round'åå¤´ã'square'æ¹å¤´
    geodesic: {
      type: Boolean,
      default: false
    },
    // æ¯å¦ç»å¶æå¤§å°çº¿ï¼é»è®¤false
    showDir: {
      type: Boolean,
      default: false
    }
    // æ¯å¦å»¶è·¯å¾æ¾ç¤ºç½è²æ¹åç®­å¤´,é»è®¤falseãå»ºè®®æçº¿å®½åº¦å¤§äº6æ¶ä½¿ç¨
  },
  emits: ["update:path"],
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Polyline(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.PolylineEditor"], () => {
            this.$amapComponent.editor = new AMap.PolylineEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("removenode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      const paths = target.getPath();
      const pathArray = paths.map(convertLnglat);
      this.$emit("update:path", pathArray);
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __borderWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ borderWeight: value });
      }
    },
    __isOutline(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ isOutline: value });
      }
    },
    __outlineColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ outlineColor: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __lineJoin(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ lineJoin: value });
      }
    },
    __lineCap(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ lineCap: value });
      }
    },
    __geodesic(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ geodesic: value });
      }
    },
    __showDir(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ showDir: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Polyline.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Polyline/Polyline.vue.mjs


Polyline_vue2_script.__file = "src/vue-amap/packages/vector/Polyline/Polyline.vue";


//# sourceMappingURL=Polyline.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Polyline/index.mjs



Polyline_vue2_script.install = (app) => {
  app.component(Polyline_vue2_script.name, Polyline_vue2_script);
  return app;
};
const ElAmapPolyline = Polyline_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Rectangle/Rectangle.vue2.mjs




var Rectangle_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapRectangle",
  mixins: [registerComponent, editorMixin],
  props: {
    bounds: {
      type: Array,
      required: true
    },
    // ç©å½¢çèå´
    bubble: {
      type: Boolean,
      default: false
    },
    // æ¯å¦å°è¦çç©çé¼ æ ætouchç­äºä»¶åæ³¡å°å°å¾ä¸
    cursor: {
      type: String
    },
    // æå®é¼ æ æ¬åæ¶çé¼ æ æ ·å¼ï¼èªå®ä¹cursorï¼IEä»æ¯æcur/ani/icoæ ¼å¼ï¼Operaä¸æ¯æèªå®ä¹cursor
    strokeColor: {
      type: String
    },
    // çº¿æ¡é¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ãé»è®¤å¼ä¸º#00D3FC
    strokeOpacity: {
      type: Number
    },
    // è½®å»çº¿éæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.9
    strokeWeight: {
      type: Number
    },
    // è½®å»çº¿å®½åº¦ãé»è®¤ 2
    fillColor: {
      type: String
    },
    // å¤è¾¹å½¢å¡«åé¢è²ï¼ä½¿ç¨16è¿å¶é¢è²ä»£ç èµå¼ï¼å¦ï¼#00B2D5
    fillOpacity: {
      type: Number
    },
    // å¤è¾¹å½¢å¡«åéæåº¦ï¼åå¼èå´ [0,1] ï¼0è¡¨ç¤ºå®å¨éæï¼1è¡¨ç¤ºä¸éæãé»è®¤ä¸º0.5
    draggable: {
      type: Boolean,
      default: false
    },
    // è®¾ç½®å¤è¾¹å½¢æ¯å¦å¯ææ½ç§»å¨ï¼é»è®¤ä¸ºfalse
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator: (value) => {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    // è½®å»çº¿æ ·å¼ï¼å®çº¿:solidï¼èçº¿:dashed
    strokeDasharray: {
      type: Array
    }
    // å¾åå½¢ç¶è½®å»çèçº¿åé´éçæ ·å¼ï¼æ­¤å±æ§å¨strokeStyle ä¸ºdashed æ¶ææï¼ æ­¤å±æ§å¨ie9+æµè§å¨ææ åå¼ï¼ å®çº¿ï¼ [0,0,0] èçº¿ï¼ [10,10] ï¼ [10,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿ ç¹ç»çº¿ï¼ [10,2,10] ï¼ [10,2,10] è¡¨ç¤º10ä¸ªåç´ çå®çº¿å2ä¸ªåç´ çç©ºç½ + 10ä¸ªåç´ çå®çº¿å10ä¸ªåç´ çç©ºç½ ï¼å¦æ­¤åå¤ï¼ç»æçèçº¿
  },
  emits: ["update:bounds"],
  data() {
    return {
      converters: {
        bounds: (path) => {
          return new AMap.Bounds(toLngLat(path[0]), toLngLat(path[1]));
        }
      }
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Rectangle(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.RectangleEditor"], () => {
            this.$amapComponent.editor = new AMap.RectangleEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("move", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      const bounds = target.getBounds();
      const southWest = bounds.getSouthWest();
      const northEast = bounds.getNorthEast();
      const paths = [southWest.toArray(), northEast.toArray()];
      this.$emit("update:bounds", paths);
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __fillColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillColor: value });
      }
    },
    __fillOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillOpacity: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Rectangle.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Rectangle/Rectangle.vue.mjs


Rectangle_vue2_script.__file = "src/vue-amap/packages/vector/Rectangle/Rectangle.vue";


//# sourceMappingURL=Rectangle.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/vector/Rectangle/index.mjs



Rectangle_vue2_script.install = (app) => {
  app.component(Rectangle_vue2_script.name, Rectangle_vue2_script);
  return app;
};
const ElAmapRectangle = Rectangle_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Tiles3D/Tiles3D.vue2.mjs



var Tiles3D_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerTiles3d",
  mixins: [registerComponent],
  props: {
    url: {
      type: String,
      required: true
    },
    threeScriptUrl: {
      type: String,
      default: "//a.amap.com/jsapi_demos/static/data3d/lib/three.117.js"
    },
    threeGltfLoader: {
      type: String,
      default: "//a.amap.com/jsapi_demos/static/data3d/lib/GLTFLoader.117.min.js"
    },
    layerStyle: {
      type: Object
    }
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.3DTilesLayer"], () => {
          if (!window["THREE"]) {
            loadScript(options.threeScriptUrl, () => {
              loadScript(options.threeGltfLoader, () => {
                this.createLayer(options);
                resolve();
              });
            });
          } else {
            this.createLayer(options);
            resolve();
          }
        });
      });
    },
    destroyComponent() {
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    createLayer(options) {
      let layerStyle = {};
      if (options.layerStyle) {
        layerStyle = JSON.parse(JSON.stringify(options.layerStyle));
      }
      this.$amapComponent = new AMap["3DTilesLayer"]({
        map: this.$parentComponent,
        url: options.url,
        // 3d Tiles å¥å£æä»¶
        style: layerStyle
      });
      console.log(this.$amapComponent);
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Tiles3D.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Tiles3D/Tiles3D.vue.mjs


Tiles3D_vue2_script.__file = "src/vue-amap/packages/layer/data/Tiles3D/Tiles3D.vue";


//# sourceMappingURL=Tiles3D.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Tiles3D/index.mjs



Tiles3D_vue2_script.install = (app) => {
  app.component(Tiles3D_vue2_script.name, Tiles3D_vue2_script);
  return app;
};
const ElAmapLayerTiles3d = Tiles3D_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/Geolocation/Geolocation.vue2.mjs



var Geolocation_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapControlGeolocation",
  mixins: [registerComponent],
  props: {
    position: {
      type: String
    },
    //æ¬åä½ç½®ï¼é»è®¤ä¸º"RB"ï¼å³å³ä¸è§.'LT': å·¦ä¸è§, 'RT': å³ä¸è§, 'LB': å·¦ä¸è§, 'RB': å³ä¸è§
    offset: {
      type: Array
    },
    //ç¼©ç¥å¾è·ç¦»æ¬åä½ç½®çåç´ è·ç¦»ï¼å¦ [2,2]
    borderColor: {
      type: String
    },
    //æé®è¾¹æ¡é¢è²å¼ï¼åCSSï¼å¦'silver'
    borderRadius: {
      type: String
    },
    //æé®åè§è¾¹æ¡å¼ï¼åCSSï¼å¦'5px'
    buttonSize: {
      type: String
    },
    //ç®­å¤´æé®çåç´ å°ºå¯¸ï¼åCSSï¼å¦'12px'
    convert: {
      type: Boolean,
      default: true
    },
    //æ¯å¦å°å®ä½ç»æè½¬æ¢ä¸ºé«å¾·åæ 
    enableHighAccuracy: {
      type: Boolean,
      default: false
    },
    //è¿è¡æµè§å¨åçå®ä½çæ¶åæ¯å¦å°è¯è·åè¾é«ç²¾åº¦ï¼å¯è½å½±åå®ä½æçï¼é»è®¤ä¸ºfalse
    timeout: {
      type: Number
    },
    //å®ä½çè¶æ¶æ¶é´ï¼æ¯«ç§
    maximumAge: {
      type: Number
    },
    //æµè§å¨åçå®ä½çç¼å­æ¶é´ï¼æ¯«ç§
    showButton: {
      type: Boolean,
      default: true
    },
    //æ¯å¦æ¾ç¤ºå®ä½æé®ï¼é»è®¤ä¸ºtrue
    showCircle: {
      type: Boolean,
      default: true
    },
    //æ¯å¦æ¾ç¤ºå®ä½ç²¾åº¦åï¼é»è®¤ä¸ºtrue
    showMarker: {
      type: Boolean,
      default: true
    },
    //æ¯å¦æ¾ç¤ºå®ä½ç¹ï¼é»è®¤ä¸ºtrue
    markerOptions: {
      type: Object
    },
    //å®ä½ç¹çæ ·å¼
    circleOptions: {
      type: Object
    },
    //CircleOptions
    panToLocation: {
      type: Boolean,
      default: true
    },
    //å®ä½æååæ¯å¦èªå¨ç§»å¨å°ååºä½ç½®
    zoomToAccuracy: {
      type: Boolean,
      default: true
    },
    //å®ä½æååæ¯å¦èªå¨è°æ´çº§å«
    GeoLocationFirst: {
      type: Boolean,
      default: true
    },
    //ä¼åä½¿ç¨H5å®ä½ï¼é»è®¤false
    noIpLocate: {
      type: Number
    },
    //æ¯å¦ç¦ç¨IPç²¾ç¡®å®ä½ï¼é»è®¤ä¸º0ï¼0:é½ç¨ 1:ææºä¸ä¸ç¨ 2:PCä¸ä¸ç¨ 3:é½ä¸ç¨
    noGeoLocation: {
      type: Number
    },
    //æ¯å¦ç¦ç¨æµè§å¨åçå®ä½ï¼é»è®¤ä¸º0ï¼0:é½ç¨ 1:ææºä¸ä¸ç¨ 2:PCä¸ä¸ç¨ 3:é½ä¸ç¨
    useNative: {
      type: Boolean,
      default: false
    },
    //æ¯å¦ä¸é«å¾·å®ä½SDKè½åç»åï¼éè¦åæ¶ä½¿ç¨å®åçé«å¾·å®ä½sdkï¼å¦åæ æ
    getCityWhenFail: {
      type: Boolean,
      default: false
    },
    //å®ä½å¤±è´¥ä¹åæ¯å¦è¿ååºæ¬åå¸å®ä½ä¿¡æ¯
    needAddress: {
      type: Boolean,
      default: false
    },
    //æ¯å¦éè¦å°å®ä½ç»æè¿è¡éå°çç¼ç æä½
    extensions: {
      type: String,
      validator: (value) => {
        return ["base", "all"].indexOf(value) !== -1;
      }
    }
    //æ¯å¦éè¦è¯¦ç»çéå°çç¼ç ä¿¡æ¯ï¼é»è®¤ä¸º'base'åªè¿ååºæ¬ä¿¡æ¯ï¼å¯é'all'
  },
  emits: ["complete"],
  methods: {
    __initComponent(options) {
      return new Promise((resolve) => {
        this.$parentComponent.plugin(["AMap.Geolocation"], () => {
          this.$amapComponent = new AMap.Geolocation(options);
          this.$parentComponent.addControl(this.$amapComponent);
          this.$amapComponent.on("complete", (e) => {
            this.$emit("complete", e);
          });
          resolve();
        });
      });
    },
    destroyComponent() {
      if (this.$amapComponent && this.$parentComponent) {
        if (!this.parentInstance.isDestroy) {
          this.$parentComponent.removeControl(this.$amapComponent);
        }
        this.$amapComponent = null;
        this.$parentComponent = null;
      }
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Geolocation.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/Geolocation/Geolocation.vue.mjs


Geolocation_vue2_script.__file = "src/vue-amap/packages/control/Geolocation/Geolocation.vue";


//# sourceMappingURL=Geolocation.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/control/Geolocation/index.mjs



Geolocation_vue2_script.install = (app) => {
  app.component(Geolocation_vue2_script.name, Geolocation_vue2_script);
  return app;
};
const ElAmapControlGeolocation = Geolocation_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/CircleMarker/CircleMarker.vue2.mjs



var CircleMarker_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapCircleMarker",
  mixins: [registerComponent],
  props: {
    zIndex: {
      type: Number
    },
    center: {
      type: Array,
      required: true
    },
    bubble: {
      type: Boolean,
      default: false
    },
    cursor: {
      type: String
    },
    radius: {
      type: Number
    },
    strokeColor: {
      type: String
    },
    strokeOpacity: {
      type: Number
    },
    strokeWeight: {
      type: Number
    },
    fillColor: {
      type: String
    },
    fillOpacity: {
      type: Number
    },
    draggable: {
      type: Boolean,
      default: false
    },
    extData: {
      type: Object
    }
  },
  emits: ["update:center"],
  data() {
    return {
      converters: {},
      handlers: {}
    };
  },
  methods: {
    __initComponent(options) {
      this.$parentComponent = this.parentInstance.$amapComponent;
      this.$amapComponent = new AMap.CircleMarker(options);
      this.$parentComponent.add(this.$amapComponent);
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitPosition();
      });
      this.$amapComponent.on("touchend", () => {
        this.emitPosition();
      });
    },
    emitPosition() {
      const center = this.$amapComponent.getCenter();
      this.$emit("update:center", center.toArray());
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.remove(this.$amapComponent);
      }
      this.$amapComponent = null;
    },
    __strokeColor(value) {
      this.$amapComponent.setOptions({
        strokeColor: value
      });
    },
    __strokeOpacity(value) {
      this.$amapComponent.setOptions({
        strokeOpacity: value
      });
    },
    __strokeWeight(value) {
      this.$amapComponent.setOptions({
        strokeWeight: value
      });
    },
    __fillColor(value) {
      this.$amapComponent.setOptions({
        fillColor: value
      });
    },
    __fillOpacity(value) {
      this.$amapComponent.setOptions({
        fillOpacity: value
      });
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=CircleMarker.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/CircleMarker/CircleMarker.vue.mjs


CircleMarker_vue2_script.__file = "src/vue-amap/packages/marker/CircleMarker/CircleMarker.vue";


//# sourceMappingURL=CircleMarker.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/marker/CircleMarker/index.mjs



CircleMarker_vue2_script.install = (app) => {
  app.component(CircleMarker_vue2_script.name, CircleMarker_vue2_script);
  return app;
};
const ElAmapCircleMarker = CircleMarker_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Video/VideoLayer.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class VideoLayer {
  constructor(options, video) {
    __publicField(this, "canvas");
    __publicField(this, "context");
    __publicField(this, "video");
    __publicField(this, "layer");
    __publicField(this, "canPlay", false);
    __publicField(this, "frame", -1);
    const canvas = document.createElement("canvas");
    this.video = video;
    video.src = options.url;
    video.autoplay = true;
    video.muted = true;
    video.crossOrigin = "anonymous";
    video.loop = options.loop;
    const layerOptions = {
      ...options,
      canvas
    };
    this.canvas = canvas;
    this.context = canvas.getContext("2d");
    this.layer = new AMap.CanvasLayer(layerOptions);
    this.initVideoEvents();
    this.load();
  }
  getLayer() {
    return this.layer;
  }
  initVideoEvents() {
    var _a;
    (_a = this.video) == null ? void 0 : _a.addEventListener("canplaythrough", () => {
      var _a2, _b;
      if (this.canvas) {
        this.canvas.width = (_a2 = this.video) == null ? void 0 : _a2.videoWidth;
        this.canvas.height = (_b = this.video) == null ? void 0 : _b.videoHeight;
      }
      this.canPlay = true;
      this.play();
    });
  }
  load() {
    var _a;
    (_a = this.video) == null ? void 0 : _a.load();
  }
  play() {
    var _a;
    if (this.canPlay) {
      (_a = this.video) == null ? void 0 : _a.play();
      this.stopRender();
      this.render();
    }
  }
  pause() {
    var _a;
    this.stopRender();
    (_a = this.video) == null ? void 0 : _a.pause();
  }
  stopRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
    }
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.frame = window.requestAnimationFrame(() => {
      this.render();
    });
    if ((_a = this.video) == null ? void 0 : _a.paused) {
      (_b = this.video) == null ? void 0 : _b.play();
    } else {
      (_e = this.context) == null ? void 0 : _e.clearRect(0, 0, (_c = this.canvas) == null ? void 0 : _c.width, (_d = this.canvas) == null ? void 0 : _d.height);
      (_h = this.context) == null ? void 0 : _h.drawImage(this.video, 0, 0, (_f = this.canvas) == null ? void 0 : _f.width, (_g = this.canvas) == null ? void 0 : _g.height);
      this.layer.reFresh();
    }
  }
  destroy() {
    this.stopRender();
    if (this.video) {
      this.video.pause();
    }
    this.video = null;
  }
  setUrl(url) {
    this.stopRender();
    this.canPlay = false;
    if (this.video) {
      this.video.src = url;
      this.load();
    }
  }
  setZooms(zooms) {
    this.getLayer().setZoom(zooms);
  }
  setOpacity(opacity) {
    this.getLayer().setOpacity(opacity);
  }
  setBounds(bounds) {
    this.getLayer().setBounds(bounds);
  }
  setzIndex(zIndex) {
    this.getLayer().setzIndex(zIndex);
  }
  show() {
    this.getLayer().show();
  }
  hide() {
    this.getLayer().hide();
  }
}


//# sourceMappingURL=VideoLayer.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Video/Video.vue2.mjs




var Video_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerVideo",
  mixins: [registerComponent],
  props: {
    url: {
      required: true,
      type: String
    },
    // è§é¢å°å
    zooms: {
      type: Array
    },
    // æ¯æçç¼©æ¾çº§å«èå´ï¼é»è®¤èå´ [2-30]
    bounds: {
      type: [Array, Object]
    },
    // å¾ççèå´å¤§å°ç»çº¬åº¦ï¼å¦æä¼ éæ°å­æ°ç»ç±»å: [minlng,minlat,maxlng,maxlat] æ AMap.Bounds
    opacity: {
      type: Number
    }
    // éæåº¦ï¼é»è®¤ 1
  },
  data() {
    return {
      handlers: {}
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new VideoLayer(options, this.$refs.video);
      this.$parentComponent.addLayer(this.$amapComponent.getLayer());
    },
    destroyComponent() {
      this.$amapComponent.destroy();
      if (!this.parentInstance.isDestroy) {
        this.$parentComponent.removeLayer(this.$amapComponent);
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    $$play() {
      this.$amapComponent.play();
    },
    $$pause() {
      this.$amapComponent.pause();
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=Video.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Video/Video.vue3.mjs


const Video_vue3_hoisted_1 = {
  ref: "video",
  style: { "display": "none" },
  muted: ""
};
function Video_vue3_render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0,runtime_core_esm_bundler/* openBlock */.uX)(), (0,runtime_core_esm_bundler/* createElementBlock */.CE)(
    "video",
    Video_vue3_hoisted_1,
    null,
    512
    /* NEED_PATCH */
  );
}


//# sourceMappingURL=Video.vue3.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Video/Video.vue.mjs



Video_vue2_script.render = Video_vue3_render;
Video_vue2_script.__file = "src/vue-amap/packages/layer/data/Video/Video.vue";


//# sourceMappingURL=Video.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/Video/index.mjs



Video_vue2_script.install = (app) => {
  app.component(Video_vue2_script.name, Video_vue2_script);
  return app;
};
const ElAmapLayerVideo = Video_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/util/MouseTool/MouseTool.vue2.mjs



var MouseTool_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapMouseTool",
  mixins: [registerComponent],
  props: {
    type: {
      type: String,
      required: true,
      default: "marker",
      validator: (value) => {
        return ["marker", "circle", "rectangle", "polyline", "polygon", "measureArea", "rule", "rectZoomIn", "rectZoomOut"].includes(value);
      }
    },
    // ç±»å
    drawOptions: {
      type: Object,
      default: () => null
    },
    // ç»å¶å¾å±çå±æ§
    autoClear: {
      type: Boolean,
      default: true
    },
    // æ¯å¦ç»å¶ç»æåèªå¨æ¸ç©ºå¾å±
    showTooltip: {
      type: Boolean,
      default: true
    },
    // æ¯å¦æ¾ç¤ºæç¤ºä¿¡æ¯
    tooltipTextMap: {
      type: Object,
      default: () => null
    },
    // æç¤ºä¿¡æ¯çmap
    textOptions: {
      type: Object,
      default: () => null
    },
    drawCursor: {
      type: String,
      default: "crosshair"
    }
  },
  emits: ["draw"],
  data() {
    return {
      preMapCursor: "",
      tipTexts: {
        marker: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u70B9\u4F4D",
        circle: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u5706",
        rectangle: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62",
        polyline: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u6298\u7EBF\u7ED8\u5236",
        polygon: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u591A\u8FB9\u5F62\u7ED8\u5236",
        measureArea: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u7ED8\u5236\u5E76\u8BA1\u7B97\u9762\u79EF",
        rule: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53F3\u51FB\u5730\u56FE\u5B8C\u6210\u7ED8\u5236\u5E76\u8BA1\u7B97\u8DDD\u79BB",
        rectZoomIn: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62\uFF0C\u677E\u5F00\u5DE6\u952E\u653E\u5927\u5730\u56FE",
        rectZoomOut: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62\uFF0C\u677E\u5F00\u5DE6\u952E\u653E\u5927\u5730\u56FE"
      },
      isDrawing: true
    };
  },
  methods: {
    __initComponent() {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.MouseTool"], () => {
          if (this.tooltipTextMap) {
            Object.assign(this.tipTexts, this.tooltipTextMap);
          }
          this.$amapComponent = new AMap.MouseTool(this.$parentComponent);
          this.preMapCursor = this.$parentComponent.getDefaultCursor();
          this.createTooltip();
          this.__type();
          this.bindEvent();
          this.changeMapCursor();
          resolve();
        });
      });
    },
    __type() {
      if (!this.isDrawing) {
        return;
      }
      const type = this.type;
      if (this.$amapComponent[type]) {
        const options = this.drawOptions || {};
        this.$amapComponent[type](options);
        this.setText(this.tipTexts[type]);
      }
    },
    createTooltip() {
      if (this.showTooltip) {
        const textOptions = this.textOptions || {};
        textOptions.anchor = "top-left";
        textOptions.clickable = false;
        textOptions.bubble = true;
        textOptions.offset = [10, 10];
        this.$text = new AMap.Text(textOptions);
        this.$parentComponent.add(this.$text);
        this.$parentComponent.on("mousemove", this.getMousePosition);
      }
    },
    getMousePosition(e) {
      const lnglat = e.lnglat;
      this.$text.setPosition([lnglat.lng, lnglat.lat]);
    },
    setText(content) {
      if (this.$text) {
        this.$text.setText(content);
      }
    },
    bindEvent() {
      this.$amapComponent.on("draw", (e) => {
        const type = this.type;
        let emitData;
        if (type === "marker") {
          emitData = e.obj.getPosition().toArray();
        } else if (type === "circle") {
          emitData = {
            center: e.obj.getCenter().toArray(),
            radius: e.obj.getRadius()
          };
        } else if (type === "rectangle") {
          const bounds = e.obj.getBounds();
          const southWest = bounds.getSouthWest();
          const northEast = bounds.getNorthEast();
          emitData = [southWest.toArray(), northEast.toArray()];
        } else if (type === "polyline") {
          const path = e.obj.getPath();
          emitData = path.map((v) => v.toArray());
        } else if (type === "polygon") {
          const path = e.obj.getPath();
          emitData = path.map((v) => v.toArray());
        } else if (type === "measureArea") {
          const path = e.obj.getPath().map((v) => v.toArray());
          emitData = AMap.GeometryUtil.ringArea(path);
        } else if (type === "rule") {
          const path = e.obj.getPath().map((v) => v.toArray());
          emitData = AMap.GeometryUtil.distanceOfLine(path);
        } else if (type === "rectZoomIn") {
          emitData = true;
        } else if (type === "rectZoomOut") {
          emitData = true;
        }
        this.$emit("draw", emitData, e.obj);
        if (this.autoClear) {
          this.$$clear();
          this.__type();
        }
      });
    },
    _close(ifClear = true) {
      this.$amapComponent.close(ifClear);
    },
    $$close(ifClear = true) {
      this.isDrawing = false;
      if (this.$amapComponent) {
        this._close(ifClear);
        this.revertMapCursor();
        if (this.$text) {
          this.$text.hide();
        }
      }
    },
    $$open() {
      this.isDrawing = true;
      this.changeMapCursor();
      this.__type();
      if (this.$text) {
        this.$text.show();
      }
    },
    $$clear() {
      this._close(true);
    },
    changeMapCursor() {
      this.$parentComponent.setDefaultCursor(this.drawCursor);
    },
    revertMapCursor() {
      if (this.preMapCursor) {
        this.$parentComponent.setDefaultCursor(this.preMapCursor);
      }
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$amapComponent.close(true);
        this.revertMapCursor();
        if (this.$text) {
          this.$parentComponent.off("mousemove", this.getMousePosition);
          this.$parentComponent.remove(this.$text);
          this.$text = null;
        }
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=MouseTool.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/util/MouseTool/MouseTool.vue.mjs


MouseTool_vue2_script.__file = "src/vue-amap/packages/util/MouseTool/MouseTool.vue";


//# sourceMappingURL=MouseTool.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/util/MouseTool/index.mjs



MouseTool_vue2_script.install = (app) => {
  app.component(MouseTool_vue2_script.name, MouseTool_vue2_script);
  return app;
};
const ElAmapMouseTool = MouseTool_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/DistrictCluster/addProcess.mjs
if (typeof process !== "undefined" && "object" === "undefined") // removed by dead control flow
{}
//# sourceMappingURL=addProcess.mjs.map

;// ./node_modules/@vuemap/district-cluster/dist/index.mjs
class Y{constructor(){this._listeners={}}on(t,e,r){this._listeners[t]?this._listeners[t].push({callback:e,isOnce:r}):this._listeners[t]=[{callback:e,isOnce:r}]}off(t,e){if(!e)throw new Error("\u53D6\u6D88\u4E8B\u4EF6\u65F6\u9700\u8981\u4F20\u5165\u539F\u56DE\u8C03\u51FD\u6570");const r=this._listeners[t];if(r&&r.length>0){for(let i=0;i<r.length;i++)if(r[i].callback===e){r.splice(i,1);break}}}emit(t,...e){const r=this._listeners[t];if(r&&r.length>0)for(let n=0;n<r.length;n++){const s=r[n];s.callback.call(this,...e),s.isOnce&&(r.splice(n,1),n--)}const i=this._listeners["*"];if(i&&i.length>0)for(let n=0;n<i.length;n++){const s=i[n];s.callback.call(this,t,...e),s.isOnce&&(i.splice(n,1),n--)}}trigger(t,...e){this.emit(t,e)}}function dt(o,t,e){e===void 0&&(e={});var r={type:"Feature"};return(e.id===0||e.id)&&(r.id=e.id),e.bbox&&(r.bbox=e.bbox),r.properties=t||{},r.geometry=o,r}function H(o,t,e){e===void 0&&(e={});for(var r=0,i=o;r<i.length;r++){var n=i[r];if(n.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");for(var s=0;s<n[n.length-1].length;s++)if(n[n.length-1][s]!==n[0][s])throw new Error("First and last Position are not equivalent.")}var a={type:"Polygon",coordinates:o};return dt(a,t,e)}function Bt(o,t,e){e===void 0&&(e={});var r={type:"MultiPolygon",coordinates:o};return dt(r,t,e)}function ft(o){return o.type==="Feature"?o.geometry:o}/**
 * splaytree v3.1.1
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 *//*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function $t(o,t){var e={label:0,sent:function(){if(n[0]&1)throw n[1];return n[1]},trys:[],ops:[]},r,i,n,s;return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(h){return u([l,h])}}function u(l){if(r)throw new TypeError("Generator is already executing.");for(;e;)try{if(r=1,i&&(n=l[0]&2?i.return:l[0]?i.throw||((n=i.return)&&n.call(i),0):i.next)&&!(n=n.call(i,l[1])).done)return n;switch(i=0,n&&(l=[l[0]&2,n.value]),l[0]){case 0:case 1:n=l;break;case 4:return e.label++,{value:l[1],done:!1};case 5:e.label++,i=l[1],l=[0];continue;case 7:l=e.ops.pop(),e.trys.pop();continue;default:if(n=e.trys,!(n=n.length>0&&n[n.length-1])&&(l[0]===6||l[0]===2)){e=0;continue}if(l[0]===3&&(!n||l[1]>n[0]&&l[1]<n[3])){e.label=l[1];break}if(l[0]===6&&e.label<n[1]){e.label=n[1],n=l;break}if(n&&e.label<n[2]){e.label=n[2],e.ops.push(l);break}n[2]&&e.ops.pop(),e.trys.pop();continue}l=t.call(o,e)}catch(h){l=[6,h],i=0}finally{r=n=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}}var A=function(){function o(t,e){this.next=null,this.key=t,this.data=e,this.left=null,this.right=null}return o}();function zt(o,t){return o>t?1:o<t?-1:0}function P(o,t,e){for(var r=new A(null,null),i=r,n=r;;){var s=e(o,t.key);if(s<0){if(t.left===null)break;if(e(o,t.left.key)<0){var a=t.left;if(t.left=a.right,a.right=t,t=a,t.left===null)break}n.left=t,n=t,t=t.left}else if(s>0){if(t.right===null)break;if(e(o,t.right.key)>0){var a=t.right;if(t.right=a.left,a.left=t,t=a,t.right===null)break}i.right=t,i=t,t=t.right}else break}return i.right=t.left,n.left=t.right,t.left=r.right,t.right=r.left,t}function X(o,t,e,r){var i=new A(o,t);if(e===null)return i.left=i.right=null,i;e=P(o,e,r);var n=r(o,e.key);return n<0?(i.left=e.left,i.right=e,e.left=null):n>=0&&(i.right=e.right,i.left=e,e.right=null),i}function pt(o,t,e){var r=null,i=null;if(t){t=P(o,t,e);var n=e(t.key,o);n===0?(r=t.left,i=t.right):n<0?(i=t.right,t.right=null,r=t):(r=t.left,t.left=null,i=t)}return{left:r,right:i}}function Gt(o,t,e){return t===null?o:(o===null||(t=P(o.key,t,e),t.left=o),t)}function Q(o,t,e,r,i){if(o){r(""+t+(e?"\u2514\u2500\u2500 ":"\u251C\u2500\u2500 ")+i(o)+`
`);var n=t+(e?"    ":"\u2502   ");o.left&&Q(o.left,n,!1,r,i),o.right&&Q(o.right,n,!0,r,i)}}var J=function(){function o(t){t===void 0&&(t=zt),this._root=null,this._size=0,this._comparator=t}return o.prototype.insert=function(t,e){return this._size++,this._root=X(t,e,this._root,this._comparator)},o.prototype.add=function(t,e){var r=new A(t,e);this._root===null&&(r.left=r.right=null,this._size++,this._root=r);var i=this._comparator,n=P(t,this._root,i),s=i(t,n.key);return s===0?this._root=n:(s<0?(r.left=n.left,r.right=n,n.left=null):s>0&&(r.right=n.right,r.left=n,n.right=null),this._size++,this._root=r),this._root},o.prototype.remove=function(t){this._root=this._remove(t,this._root,this._comparator)},o.prototype._remove=function(t,e,r){var i;if(e===null)return null;e=P(t,e,r);var n=r(t,e.key);return n===0?(e.left===null?i=e.right:(i=P(t,e.left,r),i.right=e.right),this._size--,i):e},o.prototype.pop=function(){var t=this._root;if(t){for(;t.left;)t=t.left;return this._root=P(t.key,this._root,this._comparator),this._root=this._remove(t.key,this._root,this._comparator),{key:t.key,data:t.data}}return null},o.prototype.findStatic=function(t){for(var e=this._root,r=this._comparator;e;){var i=r(t,e.key);if(i===0)return e;i<0?e=e.left:e=e.right}return null},o.prototype.find=function(t){return this._root&&(this._root=P(t,this._root,this._comparator),this._comparator(t,this._root.key)!==0)?null:this._root},o.prototype.contains=function(t){for(var e=this._root,r=this._comparator;e;){var i=r(t,e.key);if(i===0)return!0;i<0?e=e.left:e=e.right}return!1},o.prototype.forEach=function(t,e){for(var r=this._root,i=[],n=!1;!n;)r!==null?(i.push(r),r=r.left):i.length!==0?(r=i.pop(),t.call(e,r),r=r.right):n=!0;return this},o.prototype.range=function(t,e,r,i){for(var n=[],s=this._comparator,a=this._root,u;n.length!==0||a;)if(a)n.push(a),a=a.left;else{if(a=n.pop(),u=s(a.key,e),u>0)break;if(s(a.key,t)>=0&&r.call(i,a))return this;a=a.right}return this},o.prototype.keys=function(){var t=[];return this.forEach(function(e){var r=e.key;return t.push(r)}),t},o.prototype.values=function(){var t=[];return this.forEach(function(e){var r=e.data;return t.push(r)}),t},o.prototype.min=function(){return this._root?this.minNode(this._root).key:null},o.prototype.max=function(){return this._root?this.maxNode(this._root).key:null},o.prototype.minNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.left;)t=t.left;return t},o.prototype.maxNode=function(t){if(t===void 0&&(t=this._root),t)for(;t.right;)t=t.right;return t},o.prototype.at=function(t){for(var e=this._root,r=!1,i=0,n=[];!r;)if(e)n.push(e),e=e.left;else if(n.length>0){if(e=n.pop(),i===t)return e;i++,e=e.right}else r=!0;return null},o.prototype.next=function(t){var e=this._root,r=null;if(t.right){for(r=t.right;r.left;)r=r.left;return r}for(var i=this._comparator;e;){var n=i(t.key,e.key);if(n===0)break;n<0?(r=e,e=e.left):e=e.right}return r},o.prototype.prev=function(t){var e=this._root,r=null;if(t.left!==null){for(r=t.left;r.right;)r=r.right;return r}for(var i=this._comparator;e;){var n=i(t.key,e.key);if(n===0)break;n<0?e=e.left:(r=e,e=e.right)}return r},o.prototype.clear=function(){return this._root=null,this._size=0,this},o.prototype.toList=function(){return Vt(this._root)},o.prototype.load=function(t,e,r){e===void 0&&(e=[]),r===void 0&&(r=!1);var i=t.length,n=this._comparator;if(r&&et(t,e,0,i-1,n),this._root===null)this._root=K(t,e,0,i),this._size=i;else{var s=qt(this.toList(),Zt(t,e),n);i=this._size+i,this._root=tt({head:s},0,i)}return this},o.prototype.isEmpty=function(){return this._root===null},Object.defineProperty(o.prototype,"size",{get:function(){return this._size},enumerable:!0,configurable:!0}),Object.defineProperty(o.prototype,"root",{get:function(){return this._root},enumerable:!0,configurable:!0}),o.prototype.toString=function(t){t===void 0&&(t=function(r){return String(r.key)});var e=[];return Q(this._root,"",!0,function(r){return e.push(r)},t),e.join("")},o.prototype.update=function(t,e,r){var i=this._comparator,n=pt(t,this._root,i),s=n.left,a=n.right;i(t,e)<0?a=X(e,r,a,i):s=X(e,r,s,i),this._root=Gt(s,a,i)},o.prototype.split=function(t){return pt(t,this._root,this._comparator)},o.prototype[Symbol.iterator]=function(){var t;return $t(this,function(e){switch(e.label){case 0:t=this.minNode(),e.label=1;case 1:return t?[4,t]:[3,3];case 2:return e.sent(),t=this.next(t),[3,1];case 3:return[2]}})},o}();function K(o,t,e,r){var i=r-e;if(i>0){var n=e+Math.floor(i/2),s=o[n],a=t[n],u=new A(s,a);return u.left=K(o,t,e,n),u.right=K(o,t,n+1,r),u}return null}function Zt(o,t){for(var e=new A(null,null),r=e,i=0;i<o.length;i++)r=r.next=new A(o[i],t[i]);return r.next=null,e.next}function Vt(o){for(var t=o,e=[],r=!1,i=new A(null,null),n=i;!r;)t?(e.push(t),t=t.left):e.length>0?(t=n=n.next=e.pop(),t=t.right):r=!0;return n.next=null,i.next}function tt(o,t,e){var r=e-t;if(r>0){var i=t+Math.floor(r/2),n=tt(o,t,i),s=o.head;return s.left=n,o.head=o.head.next,s.right=tt(o,i+1,e),s}return null}function qt(o,t,e){for(var r=new A(null,null),i=r,n=o,s=t;n!==null&&s!==null;)e(n.key,s.key)<0?(i.next=n,n=n.next):(i.next=s,s=s.next),i=i.next;return n!==null?i.next=n:s!==null&&(i.next=s),r.next}function et(o,t,e,r,i){if(!(e>=r)){for(var n=o[e+r>>1],s=e-1,a=r+1;;){do s++;while(i(o[s],n)<0);do a--;while(i(o[a],n)>0);if(s>=a)break;var u=o[s];o[s]=o[a],o[a]=u,u=t[s],t[s]=t[a],t[a]=u}et(o,t,e,a,i),et(o,t,a+1,r,i)}}function S(o,t){if(!(o instanceof t))throw new TypeError("Cannot call a class as a function")}function gt(o,t){for(var e=0;e<t.length;e++){var r=t[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(o,r.key,r)}}function b(o,t,e){return t&&gt(o.prototype,t),e&&gt(o,e),o}var z=function(t,e){return t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y},rt=function(t,e){if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;var r=t.ll.x<e.ll.x?e.ll.x:t.ll.x,i=t.ur.x<e.ur.x?t.ur.x:e.ur.x,n=t.ll.y<e.ll.y?e.ll.y:t.ll.y,s=t.ur.y<e.ur.y?t.ur.y:e.ur.y;return{ll:{x:r,y:n},ur:{x:i,y:s}}},N=Number.EPSILON;N===void 0&&(N=Math.pow(2,-52));var jt=N*N,it=function(t,e){if(-N<t&&t<N&&-N<e&&e<N)return 0;var r=t-e;return r*r<jt*t*e?0:t<e?-1:1},Ut=function(){function o(){S(this,o),this.reset()}return b(o,[{key:"reset",value:function(){this.xRounder=new yt,this.yRounder=new yt}},{key:"round",value:function(e,r){return{x:this.xRounder.round(e),y:this.yRounder.round(r)}}}]),o}(),yt=function(){function o(){S(this,o),this.tree=new J,this.round(0)}return b(o,[{key:"round",value:function(e){var r=this.tree.add(e),i=this.tree.prev(r);if(i!==null&&it(r.key,i.key)===0)return this.tree.remove(e),i.key;var n=this.tree.next(r);return n!==null&&it(r.key,n.key)===0?(this.tree.remove(e),n.key):e}}]),o}(),G=new Ut,Z=function(t,e){return t.x*e.y-t.y*e.x},vt=function(t,e){return t.x*e.x+t.y*e.y},_t=function(t,e,r){var i={x:e.x-t.x,y:e.y-t.y},n={x:r.x-t.x,y:r.y-t.y},s=Z(i,n);return it(s,0)},V=function(t){return Math.sqrt(vt(t,t))},Wt=function(t,e,r){var i={x:e.x-t.x,y:e.y-t.y},n={x:r.x-t.x,y:r.y-t.y};return Z(n,i)/V(n)/V(i)},Yt=function(t,e,r){var i={x:e.x-t.x,y:e.y-t.y},n={x:r.x-t.x,y:r.y-t.y};return vt(n,i)/V(n)/V(i)},mt=function(t,e,r){return e.y===0?null:{x:t.x+e.x/e.y*(r-t.y),y:r}},xt=function(t,e,r){return e.x===0?null:{x:r,y:t.y+e.y/e.x*(r-t.x)}},Ht=function(t,e,r,i){if(e.x===0)return xt(r,i,t.x);if(i.x===0)return xt(t,e,r.x);if(e.y===0)return mt(r,i,t.y);if(i.y===0)return mt(t,e,r.y);var n=Z(e,i);if(n==0)return null;var s={x:r.x-t.x,y:r.y-t.y},a=Z(s,e)/n,u=Z(s,i)/n,l=t.x+u*e.x,h=r.x+a*i.x,c=t.y+u*e.y,d=r.y+a*i.y,f=(l+h)/2,g=(c+d)/2;return{x:f,y:g}},I=function(){b(o,null,[{key:"compare",value:function(e,r){var i=o.comparePoints(e.point,r.point);return i!==0?i:(e.point!==r.point&&e.link(r),e.isLeft!==r.isLeft?e.isLeft?1:-1:q.compare(e.segment,r.segment))}},{key:"comparePoints",value:function(e,r){return e.x<r.x?-1:e.x>r.x?1:e.y<r.y?-1:e.y>r.y?1:0}}]);function o(t,e){S(this,o),t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}return b(o,[{key:"link",value:function(e){if(e.point===this.point)throw new Error("Tried to link already linked events");for(var r=e.point.events,i=0,n=r.length;i<n;i++){var s=r[i];this.point.events.push(s),s.point=this.point}this.checkForConsuming()}},{key:"checkForConsuming",value:function(){for(var e=this.point.events.length,r=0;r<e;r++){var i=this.point.events[r];if(i.segment.consumedBy===void 0)for(var n=r+1;n<e;n++){var s=this.point.events[n];s.consumedBy===void 0&&i.otherSE.point.events===s.otherSE.point.events&&i.segment.consume(s.segment)}}}},{key:"getAvailableLinkedEvents",value:function(){for(var e=[],r=0,i=this.point.events.length;r<i;r++){var n=this.point.events[r];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&e.push(n)}return e}},{key:"getLeftmostComparator",value:function(e){var r=this,i=new Map,n=function(a){var u=a.otherSE;i.set(a,{sine:Wt(r.point,e.point,u.point),cosine:Yt(r.point,e.point,u.point)})};return function(s,a){i.has(s)||n(s),i.has(a)||n(a);var u=i.get(s),l=u.sine,h=u.cosine,c=i.get(a),d=c.sine,f=c.cosine;return l>=0&&d>=0?h<f?1:h>f?-1:0:l<0&&d<0?h<f?-1:h>f?1:0:d<l?-1:d>l?1:0}}}]),o}(),Xt=0,q=function(){b(o,null,[{key:"compare",value:function(e,r){var i=e.leftSE.point.x,n=r.leftSE.point.x,s=e.rightSE.point.x,a=r.rightSE.point.x;if(a<i)return 1;if(s<n)return-1;var u=e.leftSE.point.y,l=r.leftSE.point.y,h=e.rightSE.point.y,c=r.rightSE.point.y;if(i<n){if(l<u&&l<h)return 1;if(l>u&&l>h)return-1;var d=e.comparePoint(r.leftSE.point);if(d<0)return 1;if(d>0)return-1;var f=r.comparePoint(e.rightSE.point);return f!==0?f:-1}if(i>n){if(u<l&&u<c)return-1;if(u>l&&u>c)return 1;var g=r.comparePoint(e.leftSE.point);if(g!==0)return g;var p=e.comparePoint(r.rightSE.point);return p<0?1:p>0?-1:1}if(u<l)return-1;if(u>l)return 1;if(s<a){var y=r.comparePoint(e.rightSE.point);if(y!==0)return y}if(s>a){var m=e.comparePoint(r.rightSE.point);if(m<0)return 1;if(m>0)return-1}if(s!==a){var x=h-u,w=s-i,_=c-l,k=a-n;if(x>w&&_<k)return 1;if(x<w&&_>k)return-1}return s>a?1:s<a||h<c?-1:h>c?1:e.id<r.id?-1:e.id>r.id?1:0}}]);function o(t,e,r,i){S(this,o),this.id=++Xt,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=r,this.windings=i}return b(o,[{key:"replaceRightSE",value:function(e){this.rightSE=e,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}},{key:"bbox",value:function(){var e=this.leftSE.point.y,r=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:e<r?e:r},ur:{x:this.rightSE.point.x,y:e>r?e:r}}}},{key:"vector",value:function(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}},{key:"isAnEndpoint",value:function(e){return e.x===this.leftSE.point.x&&e.y===this.leftSE.point.y||e.x===this.rightSE.point.x&&e.y===this.rightSE.point.y}},{key:"comparePoint",value:function(e){if(this.isAnEndpoint(e))return 0;var r=this.leftSE.point,i=this.rightSE.point,n=this.vector();if(r.x===i.x)return e.x===r.x?0:e.x<r.x?1:-1;var s=(e.y-r.y)/n.y,a=r.x+s*n.x;if(e.x===a)return 0;var u=(e.x-r.x)/n.x,l=r.y+u*n.y;return e.y===l?0:e.y<l?-1:1}},{key:"getIntersection",value:function(e){var r=this.bbox(),i=e.bbox(),n=rt(r,i);if(n===null)return null;var s=this.leftSE.point,a=this.rightSE.point,u=e.leftSE.point,l=e.rightSE.point,h=z(r,u)&&this.comparePoint(u)===0,c=z(i,s)&&e.comparePoint(s)===0,d=z(r,l)&&this.comparePoint(l)===0,f=z(i,a)&&e.comparePoint(a)===0;if(c&&h)return f&&!d?a:!f&&d?l:null;if(c)return d&&s.x===l.x&&s.y===l.y?null:s;if(h)return f&&a.x===u.x&&a.y===u.y?null:u;if(f&&d)return null;if(f)return a;if(d)return l;var g=Ht(s,this.vector(),u,e.vector());return g===null||!z(n,g)?null:G.round(g.x,g.y)}},{key:"split",value:function(e){var r=[],i=e.events!==void 0,n=new I(e,!0),s=new I(e,!1),a=this.rightSE;this.replaceRightSE(s),r.push(s),r.push(n);var u=new o(n,a,this.rings.slice(),this.windings.slice());return I.comparePoints(u.leftSE.point,u.rightSE.point)>0&&u.swapEvents(),I.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),i&&(n.checkForConsuming(),s.checkForConsuming()),r}},{key:"swapEvents",value:function(){var e=this.rightSE;this.rightSE=this.leftSE,this.leftSE=e,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(var r=0,i=this.windings.length;r<i;r++)this.windings[r]*=-1}},{key:"consume",value:function(e){for(var r=this,i=e;r.consumedBy;)r=r.consumedBy;for(;i.consumedBy;)i=i.consumedBy;var n=o.compare(r,i);if(n!==0){if(n>0){var s=r;r=i,i=s}if(r.prev===i){var a=r;r=i,i=a}for(var u=0,l=i.rings.length;u<l;u++){var h=i.rings[u],c=i.windings[u],d=r.rings.indexOf(h);d===-1?(r.rings.push(h),r.windings.push(c)):r.windings[d]+=c}i.rings=null,i.windings=null,i.consumedBy=r,i.leftSE.consumedBy=r.leftSE,i.rightSE.consumedBy=r.rightSE}}},{key:"prevInResult",value:function(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}},{key:"beforeState",value:function(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{var e=this.prev.consumedBy||this.prev;this._beforeState=e.afterState()}return this._beforeState}},{key:"afterState",value:function(){if(this._afterState!==void 0)return this._afterState;var e=this.beforeState();this._afterState={rings:e.rings.slice(0),windings:e.windings.slice(0),multiPolys:[]};for(var r=this._afterState.rings,i=this._afterState.windings,n=this._afterState.multiPolys,s=0,a=this.rings.length;s<a;s++){var u=this.rings[s],l=this.windings[s],h=r.indexOf(u);h===-1?(r.push(u),i.push(l)):i[h]+=l}for(var c=[],d=[],f=0,g=r.length;f<g;f++)if(i[f]!==0){var p=r[f],y=p.poly;if(d.indexOf(y)===-1)if(p.isExterior)c.push(y);else{d.indexOf(y)===-1&&d.push(y);var m=c.indexOf(p.poly);m!==-1&&c.splice(m,1)}}for(var x=0,w=c.length;x<w;x++){var _=c[x].multiPoly;n.indexOf(_)===-1&&n.push(_)}return this._afterState}},{key:"isInResult",value:function(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;var e=this.beforeState().multiPolys,r=this.afterState().multiPolys;switch(L.type){case"union":{var i=e.length===0,n=r.length===0;this._isInResult=i!==n;break}case"intersection":{var s,a;e.length<r.length?(s=e.length,a=r.length):(s=r.length,a=e.length),this._isInResult=a===L.numMultiPolys&&s<a;break}case"xor":{var u=Math.abs(e.length-r.length);this._isInResult=u%2===1;break}case"difference":{var l=function(c){return c.length===1&&c[0].isSubject};this._isInResult=l(e)!==l(r);break}default:throw new Error("Unrecognized operation type found ".concat(L.type))}return this._isInResult}}],[{key:"fromRing",value:function(e,r,i){var n,s,a,u=I.comparePoints(e,r);if(u<0)n=e,s=r,a=1;else if(u>0)n=r,s=e,a=-1;else throw new Error("Tried to create degenerate segment at [".concat(e.x,", ").concat(e.y,"]"));var l=new I(n,!0),h=new I(s,!1);return new o(l,h,[i],[a])}}]),o}(),bt=function(){function o(t,e,r){if(S(this,o),!Array.isArray(t)||t.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=r,this.segments=[],typeof t[0][0]!="number"||typeof t[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var i=G.round(t[0][0],t[0][1]);this.bbox={ll:{x:i.x,y:i.y},ur:{x:i.x,y:i.y}};for(var n=i,s=1,a=t.length;s<a;s++){if(typeof t[s][0]!="number"||typeof t[s][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");var u=G.round(t[s][0],t[s][1]);u.x===n.x&&u.y===n.y||(this.segments.push(q.fromRing(n,u,this)),u.x<this.bbox.ll.x&&(this.bbox.ll.x=u.x),u.y<this.bbox.ll.y&&(this.bbox.ll.y=u.y),u.x>this.bbox.ur.x&&(this.bbox.ur.x=u.x),u.y>this.bbox.ur.y&&(this.bbox.ur.y=u.y),n=u)}(i.x!==n.x||i.y!==n.y)&&this.segments.push(q.fromRing(n,i,this))}return b(o,[{key:"getSweepEvents",value:function(){for(var e=[],r=0,i=this.segments.length;r<i;r++){var n=this.segments[r];e.push(n.leftSE),e.push(n.rightSE)}return e}}]),o}(),Qt=function(){function o(t,e){if(S(this,o),!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new bt(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(var r=1,i=t.length;r<i;r++){var n=new bt(t[r],this,!1);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.interiorRings.push(n)}this.multiPoly=e}return b(o,[{key:"getSweepEvents",value:function(){for(var e=this.exteriorRing.getSweepEvents(),r=0,i=this.interiorRings.length;r<i;r++)for(var n=this.interiorRings[r].getSweepEvents(),s=0,a=n.length;s<a;s++)e.push(n[s]);return e}}]),o}(),wt=function(){function o(t,e){if(S(this,o),!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof t[0][0][0]=="number"&&(t=[t])}catch(s){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(var r=0,i=t.length;r<i;r++){var n=new Qt(t[r],this);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.polys.push(n)}this.isSubject=e}return b(o,[{key:"getSweepEvents",value:function(){for(var e=[],r=0,i=this.polys.length;r<i;r++)for(var n=this.polys[r].getSweepEvents(),s=0,a=n.length;s<a;s++)e.push(n[s]);return e}}]),o}(),Jt=function(){b(o,null,[{key:"factory",value:function(e){for(var r=[],i=0,n=e.length;i<n;i++){var s=e[i];if(!(!s.isInResult()||s.ringOut)){for(var a=null,u=s.leftSE,l=s.rightSE,h=[u],c=u.point,d=[];a=u,u=l,h.push(u),u.point!==c;)for(;;){var f=u.getAvailableLinkedEvents();if(f.length===0){var g=h[0].point,p=h[h.length-1].point;throw new Error("Unable to complete output ring starting at [".concat(g.x,",")+" ".concat(g.y,"]. Last matching segment found ends at")+" [".concat(p.x,", ").concat(p.y,"]."))}if(f.length===1){l=f[0].otherSE;break}for(var y=null,m=0,x=d.length;m<x;m++)if(d[m].point===u.point){y=m;break}if(y!==null){var w=d.splice(y)[0],_=h.splice(w.index);_.unshift(_[0].otherSE),r.push(new o(_.reverse()));continue}d.push({index:h.length,point:u.point});var k=u.getLeftmostComparator(a);l=f.sort(k)[0].otherSE;break}r.push(new o(h))}}return r}}]);function o(t){S(this,o),this.events=t;for(var e=0,r=t.length;e<r;e++)t[e].segment.ringOut=this;this.poly=null}return b(o,[{key:"getGeom",value:function(){for(var e=this.events[0].point,r=[e],i=1,n=this.events.length-1;i<n;i++){var s=this.events[i].point,a=this.events[i+1].point;_t(s,e,a)!==0&&(r.push(s),e=s)}if(r.length===1)return null;var u=r[0],l=r[1];_t(u,e,l)===0&&r.shift(),r.push(r[0]);for(var h=this.isExteriorRing()?1:-1,c=this.isExteriorRing()?0:r.length-1,d=this.isExteriorRing()?r.length:-1,f=[],g=c;g!=d;g+=h)f.push([r[g].x,r[g].y]);return f}},{key:"isExteriorRing",value:function(){if(this._isExteriorRing===void 0){var e=this.enclosingRing();this._isExteriorRing=e?!e.isExteriorRing():!0}return this._isExteriorRing}},{key:"enclosingRing",value:function(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}},{key:"_calcEnclosingRing",value:function(){for(var e=this.events[0],r=1,i=this.events.length;r<i;r++){var n=this.events[r];I.compare(e,n)>0&&(e=n)}for(var s=e.segment.prevInResult(),a=s?s.prevInResult():null;;){if(!s)return null;if(!a)return s.ringOut;if(a.ringOut!==s.ringOut)return a.ringOut.enclosingRing()!==s.ringOut?s.ringOut:s.ringOut.enclosingRing();s=a.prevInResult(),a=s?s.prevInResult():null}}}]),o}(),St=function(){function o(t){S(this,o),this.exteriorRing=t,t.poly=this,this.interiorRings=[]}return b(o,[{key:"addInterior",value:function(e){this.interiorRings.push(e),e.poly=this}},{key:"getGeom",value:function(){var e=[this.exteriorRing.getGeom()];if(e[0]===null)return null;for(var r=0,i=this.interiorRings.length;r<i;r++){var n=this.interiorRings[r].getGeom();n!==null&&e.push(n)}return e}}]),o}(),Kt=function(){function o(t){S(this,o),this.rings=t,this.polys=this._composePolys(t)}return b(o,[{key:"getGeom",value:function(){for(var e=[],r=0,i=this.polys.length;r<i;r++){var n=this.polys[r].getGeom();n!==null&&e.push(n)}return e}},{key:"_composePolys",value:function(e){for(var r=[],i=0,n=e.length;i<n;i++){var s=e[i];if(!s.poly)if(s.isExteriorRing())r.push(new St(s));else{var a=s.enclosingRing();a.poly||r.push(new St(a)),a.poly.addInterior(s)}}return r}}]),o}(),te=function(){function o(t){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:q.compare;S(this,o),this.queue=t,this.tree=new J(e),this.segments=[]}return b(o,[{key:"process",value:function(e){var r=e.segment,i=[];if(e.consumedBy)return e.isLeft?this.queue.remove(e.otherSE):this.tree.remove(r),i;var n=e.isLeft?this.tree.insert(r):this.tree.find(r);if(!n)throw new Error("Unable to find segment #".concat(r.id," ")+"[".concat(r.leftSE.point.x,", ").concat(r.leftSE.point.y,"] -> ")+"[".concat(r.rightSE.point.x,", ").concat(r.rightSE.point.y,"] ")+"in SweepLine tree. Please submit a bug report.");for(var s=n,a=n,u=void 0,l=void 0;u===void 0;)s=this.tree.prev(s),s===null?u=null:s.key.consumedBy===void 0&&(u=s.key);for(;l===void 0;)a=this.tree.next(a),a===null?l=null:a.key.consumedBy===void 0&&(l=a.key);if(e.isLeft){var h=null;if(u){var c=u.getIntersection(r);if(c!==null&&(r.isAnEndpoint(c)||(h=c),!u.isAnEndpoint(c)))for(var d=this._splitSafely(u,c),f=0,g=d.length;f<g;f++)i.push(d[f])}var p=null;if(l){var y=l.getIntersection(r);if(y!==null&&(r.isAnEndpoint(y)||(p=y),!l.isAnEndpoint(y)))for(var m=this._splitSafely(l,y),x=0,w=m.length;x<w;x++)i.push(m[x])}if(h!==null||p!==null){var _=null;if(h===null)_=p;else if(p===null)_=h;else{var k=I.comparePoints(h,p);_=k<=0?h:p}this.queue.remove(r.rightSE),i.push(r.rightSE);for(var D=r.split(_),M=0,R=D.length;M<R;M++)i.push(D[M])}i.length>0?(this.tree.remove(r),i.push(e)):(this.segments.push(r),r.prev=u)}else{if(u&&l){var E=u.getIntersection(l);if(E!==null){if(!u.isAnEndpoint(E))for(var T=this._splitSafely(u,E),F=0,U=T.length;F<U;F++)i.push(T[F]);if(!l.isAnEndpoint(E))for(var B=this._splitSafely(l,E),$=0,W=B.length;$<W;$++)i.push(B[$])}}this.tree.remove(r)}return i}},{key:"_splitSafely",value:function(e,r){this.tree.remove(e);var i=e.rightSE;this.queue.remove(i);var n=e.split(r);return n.push(i),e.consumedBy===void 0&&this.tree.insert(e),n}}]),o}(),Et=typeof process!="undefined"&&({"NODE_ENV":"production","VUE_APP_BASE_API":"/cl583636164","VUE_APP_BASE_API_URL":"http://localhost:8080","VUE_APP_BASR_API_PREFIX":"/cl583636164","BASE_URL":"./"}).POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,ee=typeof process!="undefined"&&({"NODE_ENV":"production","VUE_APP_BASE_API":"/cl583636164","VUE_APP_BASE_API_URL":"http://localhost:8080","VUE_APP_BASR_API_PREFIX":"/cl583636164","BASE_URL":"./"}).POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6,re=function(){function o(){S(this,o)}return b(o,[{key:"run",value:function(e,r,i){L.type=e,G.reset();for(var n=[new wt(r,!0)],s=0,a=i.length;s<a;s++)n.push(new wt(i[s],!1));if(L.numMultiPolys=n.length,L.type==="difference")for(var u=n[0],l=1;l<n.length;)rt(n[l].bbox,u.bbox)!==null?l++:n.splice(l,1);if(L.type==="intersection"){for(var h=0,c=n.length;h<c;h++)for(var d=n[h],f=h+1,g=n.length;f<g;f++)if(rt(d.bbox,n[f].bbox)===null)return[]}for(var p=new J(I.compare),y=0,m=n.length;y<m;y++)for(var x=n[y].getSweepEvents(),w=0,_=x.length;w<_;w++)if(p.insert(x[w]),p.size>Et)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");for(var k=new te(p),D=p.size,M=p.pop();M;){var R=M.key;if(p.size===D){var E=R.segment;throw new Error("Unable to pop() ".concat(R.isLeft?"left":"right"," SweepEvent ")+"[".concat(R.point.x,", ").concat(R.point.y,"] from segment #").concat(E.id," ")+"[".concat(E.leftSE.point.x,", ").concat(E.leftSE.point.y,"] -> ")+"[".concat(E.rightSE.point.x,", ").concat(E.rightSE.point.y,"] from queue. ")+"Please file a bug report.")}if(p.size>Et)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");if(k.segments.length>ee)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");for(var T=k.process(R),F=0,U=T.length;F<U;F++){var B=T[F];B.consumedBy===void 0&&p.insert(B)}D=p.size,M=p.pop()}G.reset();var $=Jt.factory(k.segments),W=new Kt($);return W.getGeom()}}]),o}(),L=new re,ie=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("union",t,r)},ne=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("intersection",t,r)},oe=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("xor",t,r)},se=function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];return L.run("difference",t,r)},ae={union:ie,intersection:ne,xor:oe,difference:se};function ue(o,t,e){e===void 0&&(e={});var r=ft(o),i=ft(t),n=ae.intersection(r.coordinates,i.coordinates);return n.length===0?null:n.length===1?H(n[0],e.properties):Bt(n,e.properties)}const v={mergeArray(o,t){if(t.length<5e4)o.push.apply(o,t);else for(let e=0,r=t.length;e<r;e+=1)o.push(t[e])},now:Date.now||function(){return new Date().getTime()},bind(o,t){return o.bind?o.bind(t):function(){return o.apply(t,arguments)}},forEach(o,t,e){if(o.forEach)return o.forEach(t,e);for(let r=0,i=o.length;r<i;r++)t.call(e,o[r],r)},map(o,t,e){if(o.map)return o.map(t,e);const r=[];for(let i=0,n=o.length;i<n;i++)r[i]=t.call(e,o[i],i);return r},merge(o,t){if(t.length<5e4)Array.prototype.push.apply(o,t);else for(let e=0,r=t.length;e<r;e+=1)o.push(t[e])},arrayIndexOf(o,t,e){if(o.indexOf)return o.indexOf(t,e);let r,i=o,n=i.length>>>0;if(n===0)return-1;const s=0|e;if(s>=n)return-1;for(r=Math.max(s>=0?s:n-Math.abs(s),0);r<n;){if(r in i&&i[r]===t)return r;r++}return-1},extend(o){return o||(o={}),this.extendObjs(o,Array.prototype.slice.call(arguments,1))},extendObjs(o,t){o||(o={});for(let e=0,r=t.length;e<r;e++){const i=t[e];if(i)for(const n in i)i.hasOwnProperty(n)&&(o[n]=i[n])}return o},debounce(o,t,e){let r,i,n,s,a,u=function(){const l=v.now()-s;l<t&&l>=0?r=setTimeout(u,t-l):(r=null,e||(a=o.apply(n,i),r||(n=i=null)))};return function(){n=this,i=arguments,s=v.now();const l=e&&!r;return r||(r=setTimeout(u,t)),l&&(a=o.apply(n,i),n=i=null),a}},throttle(o,t,e){let r,i,n,s=null,a=0;e||(e={});const u=function(){a=e.leading===!1?0:v.now(),s=null,n=o.apply(r,i),s||(r=i=null)};return function(){const l=v.now();a||e.leading!==!1||(a=l);const h=t-(l-a);return r=this,i=arguments,h<=0||h>t?(s&&(clearTimeout(s),s=null),a=l,n=o.apply(r,i),s||(r=i=null)):s||e.trailing===!1||(s=setTimeout(u,h)),n}},escapeHtml(o){const t={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"};return`${o}`.replace(/[&<>"']/g,function(e){return t[e]})}};var nt={BBRFLAG:{I:1,S:2},ADCODES:{COUNTRY:1e5}};function le(o){return o}function he(o){if(o==null)return le;var t,e,r=o.scale[0],i=o.scale[1],n=o.translate[0],s=o.translate[1];return function(a,u){u||(t=e=0);var l=2,h=a.length,c=new Array(h);for(c[0]=(t+=a[0])*r+n,c[1]=(e+=a[1])*i+s;l<h;)c[l]=a[l],++l;return c}}function ce(o,t){for(var e,r=o.length,i=r-t;i<--r;)e=o[i],o[i++]=o[r],o[r]=e}function de(o,t){return typeof t=="string"&&(t=o.objects[t]),t.type==="GeometryCollection"?{type:"FeatureCollection",features:t.geometries.map(function(e){return Lt(o,e)})}:Lt(o,t)}function Lt(o,t){var e=t.id,r=t.bbox,i=t.properties==null?{}:t.properties,n=fe(o,t);return e==null&&r==null?{type:"Feature",properties:i,geometry:n}:r==null?{type:"Feature",id:e,properties:i,geometry:n}:{type:"Feature",id:e,bbox:r,properties:i,geometry:n}}function fe(o,t){var e=he(o.transform),r=o.arcs;function i(h,c){c.length&&c.pop();for(var d=r[h<0?~h:h],f=0,g=d.length;f<g;++f)c.push(e(d[f],f));h<0&&ce(c,g)}function n(h){return e(h)}function s(h){for(var c=[],d=0,f=h.length;d<f;++d)i(h[d],c);return c.length<2&&c.push(c[0]),c}function a(h){for(var c=s(h);c.length<4;)c.push(c[0]);return c}function u(h){return h.map(a)}function l(h){var c=h.type,d;switch(c){case"GeometryCollection":return{type:c,geometries:h.geometries.map(l)};case"Point":d=n(h.coordinates);break;case"MultiPoint":d=h.coordinates.map(n);break;case"LineString":d=s(h.arcs);break;case"MultiLineString":d=h.arcs.map(s);break;case"Polygon":d=u(h.arcs);break;case"MultiPolygon":d=h.arcs.map(u);break;default:return null}return{type:c,coordinates:d}}return l(t)}function pe(o,t){let e,r,i,n,s=o;e=t[t.length-2];for(let a=0,u=t.length-1;a<u;a++){r=t[a];const l=s;s=[],i=l[l.length-1];for(let h=0,c=l.length;h<c;h++)n=l[h],ot(n,e,r)?(ot(i,e,r)||s.push(kt(e,r,i,n)),s.push(n)):ot(i,e,r)&&s.push(kt(e,r,i,n)),i=n;e=r}return s.length<3?[]:(s.push(s[0]),s)}function ge(o,t,e){const r=(e[1]-t[1])/(e[0]-t[0])*(o[0]-t[0])+t[1];return Math.abs(r-o[1])<1e-6&&o[0]>=t[0]&&o[0]<=e[0]}function ye(o,t){for(let e=0,r=t.length;e<r-1;e++)if(ge(o,t[e],t[e+1]))return!0;return!1}function ve(o,t){let e=!1;for(let r=o[0],i=o[1],n=0,s=t.length,a=s-1;n<s;a=n++){const u=t[n][0],l=t[n][1],h=t[a][0],c=t[a][1];l>i!=c>i&&r<(h-u)*(i-l)/(c-l)+u&&(e=!e)}return e}function _e(o,t,e){let r,i=t[0],n=t[1];const s=e[0]-i,a=e[1]-n,u=s*s+a*a;return u>0&&(r=((o[0]-i)*s+(o[1]-n)*a)/u,r>1?(i=e[0],n=e[1]):r>0&&(i+=s*r,n+=a*r)),[i,n]}function me(o,t,e){const r=_e(o,t,e),i=o[0]-r[0],n=o[1]-r[1];return i*i+n*n}function xe(o,t){let e=Number.MAX_VALUE;for(let r=0,i=t.length;r<i-1;r++){const n=me(o,t[r],t[r+1]);n<e&&(e=n)}return e}function ot(o,t,e){return(e[0]-t[0])*(o[1]-t[1])>(e[1]-t[1])*(o[0]-t[0])}function kt(o,t,e,r){const i=[o[0]-t[0],o[1]-t[1]],n=[e[0]-r[0],e[1]-r[1]],s=o[0]*t[1]-o[1]*t[0],a=e[0]*r[1]-e[1]*r[0],u=1/(i[0]*n[1]-i[1]*n[0]);return[(s*n[0]-a*i[0])*u,(s*n[1]-a*i[1])*u]}var j={sqClosestDistanceToPolygon:xe,pointOnPolygon:ye,pointInPolygon:ve,polygonClip:pe};const st=nt.BBRFLAG,at=[];function be(o,t){const e=[];for(let r=0,i=o.length;r<i;r++){const n=o[r].split("-");let s=n[0],a=n.length>1?n[1]:s;s=parseInt(s,t),a=parseInt(a,t);for(let u=s;u<=a;u++)e.push(u)}return e}function It(o,t,e){if(o[t])throw new Error(`Alreay exists:  ${o[t]}`);o[t]=e}function we(o){return at[o]||(at[o]=[st.I,o]),at[o]}function Se(o,t,e){if(o)for(let r=o.split(":"),i=parseInt(r[0],t),n=be(r[1].split(","),t),s=we(i),a=0,u=n.length;a<u;a++)It(e,n[a],s)}function Ee(o,t,e){if(o){const r=[];let i=o.split(":"),n=parseInt(i[0],t);const s=i[1].split(";");for(let a=0,u=s.length;a<u;a++){i=s[a].split(",");const l=[parseInt(i[0],t),0];i.length>1&&(l[1]=parseInt(i[1],t)),r.push(l)}It(e,n,[st.S,r])}}function At(o,t){if(!o)return null;const e=o.split(","),r=[];for(let i=0,n=e.length;i<n;i++){if(parseInt(e[i],t)<0)return null;r.push(parseInt(e[i],t))}return r}function Le(o,t){if(!o)return null;const e=o.split(";"),r=[];for(let i=0,n=e.length;i<n;i++)r.push(At(e[i],t));return r}function ke(o){let t,e;const r=o.r,i=[],n=o.idx.i.split("|");for(o.idx.i=null,t=0,e=n.length;t<e;t++)Se(n[t],r,i);n.length=0;const s=o.idx.s.split("|");for(o.idx.s=null,t=0,e=s.length;t<e;t++)Ee(s[t],r,i);s.length=0,o.idx=null,o.idxList=i,o.mxr&&(o.maxRect=At(o.mxr,r),o.mxr=null),o.mxsr&&(o.maxSubRect=Le(o.mxsr,r),o.mxsr=null)}function Ie(o,t,e){for(let r=o.geoData.sub.features,i=0,n=e.length;i<n;i++){const s=e[i],a=r[s[0]],u=a.geometry.coordinates[s[1]][0],l=j.polygonClip(u,t);!l||l.length<4?console.warn(`Cliped ring length werid: ${l}`):s[2]=l}return!0}function Ae(o,t,e){const r=o.bbIndex,i=r.s;(t<0||e<0||e>=r.h||t>=r.w)&&console.warn("Wrong x,y",t,e,r);const n=e*r.w+t,s=r.idxList[n];if(s[0]!==st.S)return!1;const a=s[1];if(a[0].length>2)return!1;const u=t*i+r.l,l=e*i+r.t;return Ie(o,[[u,l],[u+i,l],[u+i,l+i],[u,l+i],[u,l]],a),!0}var Pt={prepareGridFeatureClip:Ae,buildIdxList:ke};class C{constructor(t,e,r,i){this.x=t,this.y=e,this.width=r,this.height=i}static getBoundsItemToExpand(){return new C(Number.MAX_VALUE,Number.MAX_VALUE,-1,-1)}static boundsIntersect(t,e){return t.x<=e.x+e.width&&e.x<=t.x+t.width&&t.y<=e.y+e.height&&e.y<=t.y+t.height}isEmpty(){return this.width<0}expandByPoint(t,e){let r,i,n,s;this.isEmpty()?(r=n=t,i=s=e):(r=this.x,i=this.y,n=this.x+this.width,s=this.y+this.height,t<r?r=t:t>n&&(n=t),e<i?i=e:e>s&&(s=e)),this.x=r,this.y=i,this.width=n-r,this.height=s-i}}function Pe(o){const t={},e=o.objects;for(const r in e)t[r]=de(o,e[r]);return t}function Ne(o){for(let t=o.sub?o.sub.features:[],e=o.parent.properties,r=(e.acroutes||[]).concat([e.adcode]),i=0,n=t.length;i<n;i++)t[i].properties.subFeatureIndex=i,t[i].properties.acroutes=r}function Me(o){if(!o._isBuiled){Pt.buildIdxList(o.bbIndex),o.geoData=Pe(o.topo),o.geoData.sub&&Ne(o.geoData);const t=o.topo.bbox;o.bounds=new C(t[0],t[1],t[2]-t[0],t[3]-t[1]),o.topo=null,o._isBuiled=!0}return o}var Re={buildData:Me};const ut={},O=Math.PI/180,Nt=180/Math.PI,Fe=Math.PI/4,Mt=.5/Math.PI;function lt(o){return ut[o]||(ut[o]=256*Math.pow(2,o)),ut[o]}function Oe(o){let t=o[1],e=o[0]*O,r=t*O;return r=Math.log(Math.tan(Fe+r/2)),[e,r]}function Ce(o,t){t=t||1;const e=Mt,r=.5,i=-e,n=.5;return[t*(e*o[0]+r),t*(i*o[1]+n)]}function De(o){const t=o[0]*Nt,e=(2*Math.atan(Math.exp(o[1]))-Math.PI/2)*Nt;return[parseFloat(t.toFixed(6)),parseFloat(e.toFixed(6))]}function Te(o,t){const e=Mt,r=.5,i=-e,n=.5;return[(o[0]/t-r)/e,(o[1]/t-n)/i]}function Rt(o,t,e){const r=Ce(Oe(o),t);return e&&(r[0]=Math.round(r[0]),r[1]=Math.round(r[1])),r}function Be(o,t,e){return Rt(o,lt(t),e)}function $e(o,t){const e=lt(t),r=Te(o,e);return De(r)}function ze(o,t){const e=Math.cos,r=o[1]*O,i=o[0]*O,n=t[1]*O,s=t[0]*O,a=n-r,u=s-i,l=(1-e(a)+(1-e(u))*e(r)*e(n))/2;return 12756274*Math.asin(Math.sqrt(l))}var ht={haversineDistance:ze,getScale:lt,lngLatToPointByScale:Rt,pointToLngLat:$e,lngLatToPoint:Be};class ct{constructor(t,e,r){this.adcode=t,this._data=e,this._sqScaleFactor=e.scale*e.scale,this._opts=Object.assign({nearTolerance:2},r),this.setNearTolerance(this._opts.nearTolerance)}static getPropsOfFeature(t){return t&&t.properties?t.properties:null}static getAdcodeOfFeature(t){return t?t.properties.adcode:null}static doesFeatureHasChildren(t){return!!t&&t.properties.childrenNum>0}setNearTolerance(t){this._opts.nearTolerance=t,this._sqNearTolerance=t*t}getIdealZoom(){return this._data.idealZoom}_getEmptySubFeatureGroupItem(t){return{subFeatureIndex:t,subFeature:this.getSubFeatureByIndex(t),pointsIndexes:[],points:[]}}groupByPosition(t,e){let r,i,n={},s=null;for(r=0,i=t.length;r<i;r++){const u=this.getLocatedSubFeatureIndex(e.call(null,t[r],r));n[u]||(n[u]=this._getEmptySubFeatureGroupItem(u)),n[u].pointsIndexes.push(r),n[u].points.push(t[r]),u<0&&(s=n[u])}const a=[];if(this._data.geoData.sub)for(r=0,i=this._data.geoData.sub.features.length;r<i;r++)a.push(n[r]||this._getEmptySubFeatureGroupItem(r));return s&&a.push(s),n=null,a}getLocatedSubFeatureIndex(t){return this._getLocatedSubFeatureIndexByPixel(this.lngLatToPixel(t))}getSubFeatureByIndex(t){return t>=0?this.getSubFeatures()[t]:null}_getLocatedSubFeatureIndexByPixel(t){if(!this._data.geoData.sub)return-1;const e=this._data,r=e.bbIndex,i=t[0]-r.l,n=t[1]-r.t,s=Math.floor(n/r.s),a=Math.floor(i/r.s);if(a<0||s<0||s>=r.h||a>=r.w)return-1;const u=s*r.w+a,l=r.idxList[u];if(!l)return-1;const h=nt.BBRFLAG;switch(l[0]){case h.I:return l[1];case h.S:return Pt.prepareGridFeatureClip(e,a,s),this._calcLocatedFeatureIndexOfSList(t,l[1]);default:throw new Error(`Unknown BBRFLAG: ${l[0]}`)}}_calcNearestFeatureIndexOfSList(t,e){let r=[];this._data.geoData.sub&&(r=this._data.geoData.sub.features);let i={sq:Number.MAX_VALUE,idx:-1};for(let n=0,s=e.length;n<s;n++){const a=e[n],u=r[a[0]],l=a[2]||u.geometry.coordinates[a[1]][0],h=j.sqClosestDistanceToPolygon(t,l);h<i.sq&&(i.sq=h,i.idx=a[0])}return i.sq/this._sqScaleFactor<this._sqNearTolerance?i.idx:-1}_calcLocatedFeatureIndexOfSList(t,e){for(let r=this._data.geoData.sub.features,i=0,n=e.length;i<n;i++){const s=e[i],a=r[s[0]],u=s[2]||a.geometry.coordinates[s[1]][0];if(j.pointInPolygon(t,u)||j.pointOnPolygon(t,u))return s[0]}return this._calcNearestFeatureIndexOfSList(t,e)}pixelToLngLat(t,e){return ht.pointToLngLat([t,e],this._data.pz)}lngLatToPixel(t){t instanceof AMap.LngLat&&(t=[t.getLng(),t.getLat()]);const e=ht.lngLatToPoint(t,this._data.pz);return[Math.round(e[0]),Math.round(e[1])]}_convertRingCoordsToLngLats(t){const e=[];for(let r=0,i=t.length;r<i;r++)e[r]=this.pixelToLngLat(t[r][0],t[r][1]);return e}_convertPolygonCoordsToLngLats(t){const e=[];for(let r=0,i=t.length;r<i;r++)e[r]=this._convertRingCoordsToLngLats(t[r]);return e}_convertMultiPolygonCoordsToLngLats(t){const e=[];for(let r=0,i=t.length;r<i;r++)e[r]=this._convertPolygonCoordsToLngLats(t[r]);return e}_convertCoordsToLngLats(t,e){switch(t){case"MultiPolygon":return this._convertMultiPolygonCoordsToLngLats(e);default:throw new Error(`Unknown type ${t}`)}}_createLngLatFeature(t,e){const r=Object.assign({},t);return e&&Object.assign(r.properties,e),r.geometry=Object.assign({},r.geometry),r.geometry.coordinates=this._convertCoordsToLngLats(r.geometry.type,r.geometry.coordinates),r}getAdcode(){return this.getProps("adcode")}getName(){return this.getProps("name")}getChildrenNum(){return this.getProps("childrenNum")}getProps(t){const e=ct.getPropsOfFeature(this._data.geoData.parent);return e?t?e[t]:e:null}getParentFeature(){const t=this._data.geoData;return t.lngLatParent||(t.lngLatParent=this._createLngLatFeature(t.parent)),t.lngLatParent}getParentFeatureInPixel(){return this._data.geoData.parent}getSubFeatures(){const t=this._data.geoData;if(!t.sub)return[];if(!t.lngLatSubList){const e=[];for(let r=t.sub.features,i=0,n=r.length;i<n;i++)e[i]=this._createLngLatFeature(r[i]);t.lngLatSubList=e}return[].concat(t.lngLatSubList)}getSubFeaturesInPixel(){return this._data.geoData.sub?[].concat(this._data.geoData.sub.features):[]}getBounds(){const t=this._data;if(!t.lngLatBounds){const e=this._data.bounds;t.lngLatBounds=new AMap.Bounds(this.pixelToLngLat(e.x,e.y+e.height),this.pixelToLngLat(e.x+e.width,e.y))}return t.lngLatBounds}}class Ge extends Y{constructor(t){super(),this._opts=Object.assign({distDataLoc:"//webapi.amap.com/ui/1.1/ui/geo/DistrictExplorer/assets/d_v2"},t),this._areaNodesForLocating=null,this._areaNodeCache={},this._opts.preload&&this.loadMultiAreaNodes(this._opts.preload)}setAreaNodesForLocating(t){t?Array.isArray(t)||(t=[t]):t=[],this._areaNodesForLocating=t||[]}_loadJson(t,e){const r=this;return fetch(t,{headers:{Accept:"application/json"}}).then(i=>i.json()).then(i=>{e&&e.call(r,null,i)}).catch(i=>{if(!e)throw i;e(i)})}_getAreaNodeDataFileName(t){return`an_${t}.json`}_getAreaNodeDataSrc(t){return`${this._opts.distDataLoc}/${this._getAreaNodeDataFileName(t)}`}loadAreaTree(t){this._loadJson(`${this._opts.distDataLoc}/area_tree.json`,t)}loadCountryNode(t){this.loadAreaNode(nt.ADCODES.COUNTRY,t)}loadMultiAreaNodes(t,e){let r=[],i=!1,n;function s(a){return function(u,l){i||(n--,u?(e&&e(u),i=!0):(r[a]=l,n===0&&e&&e(null,r)))}}if(t&&t.length){const a=t.length;for(let u=0;u<a;u++)this.loadAreaNode(t[u],e?s(u):null)}else e&&e(null,[])}loadAreaNode(t,e,r,i){if(r=r||this,this._areaNodeCache[t]){if(e){const n=this._areaNodeCache[t];i?e.call(r,null,n,!0):setTimeout(function(){e.call(r,null,n)},0)}}else this._loadJson(this._getAreaNodeDataSrc(t),(n,s)=>{n?e&&e.call(r,n):(this._buildAreaNode(t,s),e&&e.call(r,null,this._areaNodeCache[t]))})}getLocalAreaNode(t){return this._areaNodeCache[t]||null}_buildAreaNode(t,e){if(!this._areaNodeCache[t]){if(!e)throw new Error(`Empty distData: ${t}`);const r=new ct(t,Re.buildData(e),this._opts);this._areaNodeCache[t]=r,this._areaNodesForLocating||(this._areaNodesForLocating=[r])}}clearAreaNodeCacheByAdcode(t){const e=this._areaNodeCache;return delete e[t],!0}destroy(){this._areaNodesForLocating=null,this._areaNodeCache=null,this._opts=null}}class Ze{constructor(t){this.isDistReady=!1,this.nodeMap={},this.waitFnList=[],this.singleDistExplorer=new Ge({}),this._opts=v.extend({topAdcodes:[1e5]},t),this._touchMap={},this.singleDistExplorer.loadAreaTree((e,r)=>{if(e)throw e;if(this.filterAreaTree(r),this.singleCountryNode=r,this.isDistReady=!0,this.waitFnList.length){for(let i=0,n=this.waitFnList.length;i<n;i++)this.waitFnList[i][0].call(this.waitFnList[i][1]);this.waitFnList.length=0}this.singleDistExplorer.loadMultiAreaNodes(this._opts.topAdcodes)})}pixelToLngLat(t,e,r){return ht.pointToLngLat([t,e],r)}getBounds(t){const e=t.bbounds;return new AMap.Bounds(this.pixelToLngLat(e.x,e.y+e.height,20),this.pixelToLngLat(e.x+e.width,e.y,20))}filterAreaTree(t){const e=[t];do{const r=e.pop();this.nodeMap[r.adcode]=r;const i=r.bbox;if(r.bbounds=new C(i[0],i[1],i[2],i[3]),r.bbox=this.getBounds(r),r.children)for(let n=r.children,s=0,a=n.length;s<a;s++)n[s].childIdx=s,e.push(n[s])}while(e.length)}isReady(){return this.isDistReady}getParentAdcode(t,e){if(!e){const r=this.getNodeByAdcode(t);if(!r)return console.warn(`Can not find node: ${t}`),null;e=r.acroutes}return e&&e.length?e[e.length-1]:null}getSubIdx(t){return this.getNodeByAdcode(t).childIdx}getChildrenNum(t){const e=this.getNodeByAdcode(t);return this.getChildrenNumOfNode(e)}getChildrenNumOfNode(t){return t.children?t.children.length:t.childrenNum||0}getNodeByAdcode(t){const e=this.nodeMap[t];if(!e){let r=this.singleDistExplorer.getLocalAreaNode(`${`${t}`.substr(0,4)}00`);if(r||(r=this.singleDistExplorer.getLocalAreaNode(`${`${t}`.substr(0,2)}0000`)),!r)return null;for(let i=r.getSubFeatures(),n=0,s=i.length;n<s;n++)if(i[n].properties.adcode===t)return i[n].properties}return e}getNodeChildren(t){const e=this.getNodeByAdcode(t);if(!e)return null;if(e.children)return e.children;if(e.childrenNum>=0){const r=this.singleDistExplorer.getLocalAreaNode(t);if(!r)return null;const i=[],n=r.getSubFeaturesInPixel();for(let s=0,a=n.length;s<a;s++)i.push(n[s].properties);return i}return null}getExplorer(){return this.singleDistExplorer}traverseCountry(t,e,r,i,n){this.traverseNode(this.singleCountryNode,t,e,r,i,n,[])}getNodeBoundsSize(t,e){const r=this.getPixelZoom(),i=Math.pow(2,r-e);return[t.bbounds.width/i,t.bbounds.height/i]}doesRingRingIntersect(t,e){const r=[t.getNorthWest().toArray(),t.getNorthEast().toArray(),t.getSouthEast().toArray(),t.getSouthWest().toArray(),t.getNorthWest().toArray()],i=[e.getNorthWest().toArray(),e.getNorthEast().toArray(),e.getSouthEast().toArray(),e.getSouthWest().toArray(),e.getNorthWest().toArray()];return!!ue(H([r]),H([i]))}traverseNode(t,e,r,i,n,s,a,u){if(!(a&&a.indexOf(t.adcode)>=0)){if(this.doesRingRingIntersect(e,t.bbox)){const l=t.children,h=l&&l.length>0;if(r>t.idealZoom&&h)for(let c=0,d=l.length;c<d;c++)this.traverseNode(l[c],e,r,i,null,s,a);else i.call(s,t)}n&&(u?(u.count++,u.count>=u.total&&n.call(s)):n.call(s))}}onReady(t,e,r){this.isDistReady?r?t.call(e):setTimeout(function(){t.call(e)},0):this.waitFnList.push([t,e])}getPixelZoom(){var t;return(t=this.singleCountryNode)===null||t===void 0?void 0:t.pz}loadAreaNode(t,e,r,i){this.singleDistExplorer.loadAreaNode(t,e,r,i)}isExcludedAdcode(t){const e=this._opts.excludedAdcodes;return e&&e.indexOf(t)>=0}traverseTopNodes(t,e,r,i,n){const s=this._opts.topAdcodes,a=this._opts.excludedAdcodes,u={total:s.length,count:0};for(let l=0,h=s.length;l<h;l++){const c=this.getNodeByAdcode(s[l]);if(!c)throw new Error(`Can not find adcode: ${s[l]}`);this.traverseNode(c,t,e,r,i,n,a,u)}}tryClearCache(t,e){if(!(e<0)){const r=[this.singleCountryNode],i=[],n=this._touchMap;do{const a=r.pop();a.children&&v.mergeArray(r,a.children);const u=n[a.adcode];u&&u!==t&&i.push(a.adcode)}while(r.length);i.sort(function(a,u){const l=n[a]-n[u];return l===0?a-u:l});const s=i.length-e;if(!(s<=0))for(let a=0;a<s;a++)this.singleDistExplorer.clearAreaNodeCacheByAdcode(i[a])&&this.touchAdcode(i[a],null)}}touchAdcode(t,e){this._touchMap[t]=e}destroy(){this.singleDistExplorer.destroy(),this._touchMap={},this.nodeMap={},this.singleDistExplorer=void 0,this._opts=void 0,this.waitFnList=[],this.singleCountryNode=void 0}}function Ve(o){return[o.x,o.y]}class qe{constructor(t){this._data=[],this._pointsMap={},this._opts=v.extend({topAdcode:1e5},t),this.clearData()}clearData(){this._data=[],this._pointsMap={}}setData(t){this.clearData(),this._data=t,this._updatePointsMap(this._opts.topAdcode,"all",t)}_updatePointsMap(t,e,r){let i=this._pointsMap[t];i||(i=this._pointsMap[t]={}),i[e]=r,i[`${e}_pack`]=this._buildPackItemsByAdcode(t,r)}getPointsByAdcode(t,e){return this._pointsMap[t]?this._pointsMap[t][e||"all"]:[]}getPackItemsByAdcode(t,e){return this._pointsMap[t]?this._pointsMap[t][`${e||"all"}_pack`]:[]}_buildPackItemsByAdcode(t,e){const r=this._opts.pointPacker,i=[];for(let n=0,s=e.length;n<s;n++)i[n]=r.call(this._opts.pointPackerThisArg,e[n]);return i}calcDistGroup(t,e,r,i){const n=this._opts.distMgr.getNodeByAdcode(t);let s=n.acroutes||[1e5];e&&n.acroutes&&(s=[].concat(s),s.push(t)),this._calcGroupWithRoutes(s,0,r,i)}_calcGroupWithRoutes(t,e,r,i){const n=()=>{e<t.length-1?this._calcGroupWithRoutes(t,e+1,r,i):r&&r.call(i)},s=t[e];if(this.getPointsByAdcode(s,"__done"))n.call(this);else{const a=this.getPointsByAdcode(s);if(!a)throw new Error(`Not points found:  ${s}`);this._opts.distMgr.getExplorer().loadAreaNode(s,(u,l)=>{this._groupByAreaNode(l,a),n.call(this)},this,!0)}}_groupByAreaNode(t,e){const r=t.groupByPosition(e,Ve),i=t.getAdcode()===this._opts.topAdcode,n=[];for(let s=0,a=r.length;s<a;s++){const u=r[s];u.subFeature?(this._updatePointsMap(u.subFeature.properties.adcode,"all",u.points),i&&v.mergeArray(n,u.points)):this._updatePointsMap(t.getAdcode(),"hanging",u.points)}i&&this._updatePointsMap(t.getAdcode(),"all",n),this._updatePointsMap(t.getAdcode(),"__done",!0)}destroy(){this.clearData(),this._opts=null}}var je=Object.defineProperty,Ue=Object.defineProperties,We=Object.getOwnPropertyDescriptors,Ft=Object.getOwnPropertySymbols,Ye=Object.prototype.hasOwnProperty,He=Object.prototype.propertyIsEnumerable,Ot=(o,t,e)=>t in o?je(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,Ct=(o,t)=>{for(var e in t||(t={}))Ye.call(t,e)&&Ot(o,e,t[e]);if(Ft)for(var e of Ft(t))He.call(t,e)&&Ot(o,e,t[e]);return o},Xe=(o,t)=>Ue(o,We(t));class Qe extends Y{constructor(t,e){super(),this.baseId=1,this._currentZoom=2,this._currentFeatures=[],this._loadLeft=0,this._polygonCache=[],this._markerCache=[],this._opts=v.extend({engine:"default",areaNodeCacheLimit:-1,minHeightToShowSubFeatures:630,minSiblingAvgHeightToShowSubFeatures:600,minSubAvgHeightToShowSubFeatures:300,zooms:[2,30],clusterMarkerEventSupport:!0,clusterMarkerClickToShowSub:!0,featureEventSupport:!0,featureClickToShowSub:!1,featureStyleByLevel:{country:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(49, 163, 84)",fillOpacity:.8},province:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(116, 196, 118)",fillOpacity:.7},city:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(161, 217, 155)",fillOpacity:.6},district:{strokeColor:"rgb(31, 119, 180)",strokeOpacity:.9,strokeWeight:2,fillColor:"rgb(199, 233, 192)",fillOpacity:.5}}},e),this._map=this._opts.map,this._createLayer(),this._ins=t,this._isRendering=!1,this._loadLeft=0,this._currentFeatures=[]}_createLayer(){this.markerGroup=new AMap.OverlayGroup,this._map.add(this.markerGroup),this.layer=new AMap.VectorLayer({zIndex:this._opts.zIndex||10,visible:this._opts.visible||!0}),this._map.addLayer(this.layer)}zoomToShowSubFeatures(t,e){const r=this.getMinZoomToShowSub(t);if(r>=3){const i=this._ins.getMap();i&&(e||(e=this._ins._distMgr.getNodeByAdcode(t).center),i.setZoomAndCenter(r,e))}}getPixelRatio(){return Math.min(2,Math.round(window.devicePixelRatio||1))}refreshViewState(){if(!this._ins._distMgr.isReady())return!1;const t=this._ins;if(!t.isReady())return!1;const e=t.getMap(),r=e.getBounds(),i=e.getSize(),n=e.getZoom(3),s=this._opts.zooms[1],a=Math.pow(2,s-n),u=r.getNorthWest(),l=e.lngLatToCoords([u.getLng(),u.getLat()]),h=new C(l[0],l[1],i.width*a,i.height*a);this._currentZoom=n,this._currentScaleFactor=a,this._currentViewBounds=h,this._currentViewBoundsInLngLat=r,this._currentPixelRatio=this.getPixelRatio()}renderViewport(){if(this.refreshViewState(),!this._currentViewBounds)return!1;this._currentRenderId=this.baseId++,this._loadLeft=0,this._currentFeatures=[],this._renderViewDist(this._currentRenderId),this._isRendering=!1}getCurrentRenderId(){return this._currentRenderId}isRenderIdStillValid(t){return t===this._currentRenderId}_renderViewDist(t){const e=[];if(this._currentZoom<this._opts.zooms[0]||this._currentZoom>this._opts.zooms[1]){this.isRenderIdStillValid(t)&&this._prepareFeatures(t,e);return}this._ins.getDistMgr().traverseTopNodes(this._currentViewBoundsInLngLat,this._currentZoom,r=>{e.push(r.adcode)},()=>{this.isRenderIdStillValid(t)&&this._prepareFeatures(t,e)},this)}getMinZoomToShowSub(t){const e=this._ins._distMgr.getNodeByAdcode(t);if(!e||!e.idealZoom)return-1;if(!e._minZoomToShowSub){const r=this._ins.getZooms();for(let i=r[0];i<=r[1];i++)if(this.shouldShowSubOnZoom(e,i)){e._minZoomToShowSub=i;break}}return e._minZoomToShowSub||-1}shouldShowSubOnZoom(t,e){if(!t.idealZoom)return!1;if(t._minZoomToShowSub&&e>=t._minZoomToShowSub)return!0;let r=this._ins._distMgr.getNodeBoundsSize(t,e);if(t.adcode===1e5&&r[1]>400)return!0;if(r[1]<this._opts.minHeightToShowSubFeatures)return!1;let i,n,s;if(t.children){const u=t.children;if(s=0,n=u.length,n){for(i=0;i<n;i++)r=this._ins._distMgr.getNodeBoundsSize(u[i],e),s+=r[1];if(s/n<this._opts.minSubAvgHeightToShowSubFeatures)return!1}}const a=this._ins._distMgr.getParentAdcode(t.adcode,t.acroutes);if(a){const u=this._ins._distMgr.getNodeByAdcode(a),l=u.children;if(l||console.error("No children bound",t,u),n=l.length,n>1){for(s=0,i=0;i<n;i++)l[i].adcode!==t.adcode&&(r=this._ins._distMgr.getNodeBoundsSize(l[i],e),s+=r[1]);if(s/(n-1)<this._opts.minSiblingAvgHeightToShowSubFeatures)return!1}}return!0}_shouldShowSub(t){return!(!t.children||!t.children.length)&&this.shouldShowSubOnZoom(t,this._currentZoom)}_prepareFeatures(t,e){const r=[],i=[];for(let n=0,s=e.length;n<s;n++){const a=this._ins._distMgr.getNodeByAdcode(e[n]);if(!a)throw new Error(`Can not find node: ${e[n]}`);this._shouldShowSub(a)?i.push(e[n]):r.push(e[n])}this._prepareSelfFeatures(t,r),this._prepareSubFeatures(t,i),this._checkLoadFinish(t)}_prepareSelfFeatures(t,e){let r;const i=this._currentZoom;for(let n=0,s=e.length;n<s;n++){const a=this._ins._distMgr.getNodeByAdcode(e[n]);if(r=null,a.acroutes){const u=this._ins._distMgr.getNodeByAdcode(a.acroutes[a.acroutes.length-1]);(!a.idealZoom||i<a.idealZoom-1||Math.abs(i-u.idealZoom)<=Math.abs(a.idealZoom-i))&&(r=u.adcode)}this._loadAndRenderSelf(t,r||e[n],e[n])}}_prepareSubFeatures(t,e){let r,i;for(r=0,i=e.length;r<i;r++)this._loadAndRenderSub(t,e[r])}_renderSelf(t,e,r){let i;if(e===r.getAdcode())i=r.getParentFeature();else{const n=r.getSubFeatures(),s=this._ins._distMgr.getSubIdx(e);if(i=n[s],!i){console.warn("Werid, can not find sub feature",r.getAdcode(),e);return}if(i.properties.adcode!==e){console.warn("Sub adcode not match!!",n,s);return}}this._ins.getDistCounter().calcDistGroup(e,!1,()=>{this.isRenderIdStillValid(t)&&this._prepRenderFeatureInPixel(t,i)},this)}_checkLoadFinish(t){if(this._loadLeft===0){const e=this;setTimeout(function(){e.isRenderIdStillValid(t)&&e._handleRenderFinish()},0)}}_renderSub(t,e){const r=e.getSubFeatures();this._ins.getDistCounter().calcDistGroup(e.getAdcode(),!0,()=>{if(this.isRenderIdStillValid(t))for(let i=0,n=r.length;i<n;i++)this._prepRenderFeatureInPixel(t,r[i])},this)}_handleRenderFinish(){this._tryFreeMemery(),this._renderAllFeature()}_renderAllFeature(){this._renderAllFeatureByDefault()}_renderAllFeatureByDefault(){var t,e;const r=[],i=[],n=[],s=[];for(let a=0;a<this._polygonCache.length;a++){const u=this._polygonCache[a],l=u.getExtData()._data.adcode;let h=!1;for(let c=0;c<this._currentFeatures.length;c++){const d=this._currentFeatures[c].feature.properties;if(l===d.adcode){h=!0,this._currentFeatures.splice(c,1);break}}h||(i.push(u),this._polygonCache.splice(a,1),s.push(this._markerCache[a]),this._markerCache.splice(a,1),a--)}this._currentFeatures.forEach(a=>{const u=this._createPolygonFeature(a.feature,a.dataItems);this._opts.featureEventSupport&&(u.on("click",v.bind(h=>{this.emit("featureClick",h,a.feature),this._opts.featureClickToShowSub&&this._ins.zoomToShowSubFeatures(a.feature.properties.adcode)},this)),u.on("mouseover",v.bind(h=>{this.emit("featureMouseover",h,a.feature)},this)),u.on("mouseout",v.bind(h=>{this.emit("featureMouseout",h,a.feature)},this)));const l=this._createClusterMarker(a.feature,a.dataItems);this._opts.clusterMarkerEventSupport&&l.on("click",v.bind(h=>{this.emit("clusterMarkerClick",h,Ct({adcode:a.feature.properties.adcode},a)),this._opts.clusterMarkerClickToShowSub&&this._ins.zoomToShowSubFeatures(a.feature.properties.adcode)},this)),r.push(u),n.push(l)}),this.layer.remove(i),(t=this.markerGroup)===null||t===void 0||t.removeOverlays(s),this.layer.add(r),this._polygonCache.push(...r),r.length=0,(e=this.markerGroup)===null||e===void 0||e.addOverlays(n),this._markerCache.push(...n),n.length=0}_tryFreeMemery(){this._ins.getDistMgr().tryClearCache(this._currentRenderId,this._opts.areaNodeCacheLimit)}_increaseLoadLeft(){this._loadLeft++}_decreaseLoadLeft(t){this._loadLeft--,this._loadLeft===0&&this._checkLoadFinish(t)}_loadAndRenderSelf(t,e,r){this._ins.getDistMgr().touchAdcode(e,t);const i=this._ins._distMgr.getExplorer(),n=i.getLocalAreaNode(e);n?this._renderSelf(t,r,n):(this._increaseLoadLeft(),i.loadAreaNode(e,(s,a)=>{this.isRenderIdStillValid(t)&&(s?console.error(s):this._renderSelf(t,r,a),this._decreaseLoadLeft(t))},this))}_loadAndRenderSub(t,e){this._ins.getDistMgr().touchAdcode(e,t);const r=this._ins._distMgr.getExplorer(),i=r.getLocalAreaNode(e);i?this._renderSub(t,i):(this._increaseLoadLeft(),r.loadAreaNode(e,(n,s)=>{this.isRenderIdStillValid(t)&&(n?console.error(n):this._renderSub(t,s),this._decreaseLoadLeft(t))},this))}_prepRenderFeatureInPixel(t,e){if(!this._ins.getDistMgr().isExcludedAdcode(e.properties.adcode)){const r=this._ins.getDistCounter().getPackItemsByAdcode(e.properties.adcode);this._currentFeatures.push({feature:e,dataItems:r})}}_createPolygonFeature(t,e){const r=Object.assign({},t.properties);if(r.dataItems=e,this._opts.renderPolygon){const n=this._opts.renderPolygon(t,e),s=n.getExtData()||{};return s._data=r,n.setExtData(s),n}const i=this._getFeatureStyleOptions(t,e)||{};return new AMap.Polygon(Xe(Ct({path:t.geometry.coordinates},i),{extData:{_data:r}}))}_createClusterMarker(t,e){const r=t.properties;if(r.dataItems=e,this._opts.renderClusterMarker){const h=this._opts.renderClusterMarker(t,e),c=h.getExtData()||{};return c._data=r,h.setExtData(c),h}const i={title:"amap-ui-district-cluster-marker-title",body:"amap-ui-district-cluster-marker-body",container:"amap-ui-district-cluster-marker"},n=document.createElement("div"),s=document.createElement("span");s.className=i.title;const a=document.createElement("span");a.className=i.body,n.appendChild(s),n.appendChild(a);const u=[],l=[i.container,`level_${r.level}`,`adcode_${r.adcode}`];if(r.acroutes)for(let h=r.acroutes,c=0,d=h.length;c<d;c++)l.push(`descendant_of_${h[c]}`),c===d-1&&l.push(`child_of_${h[c]}`),c>0&&u.push(this._ins._distMgr.getNodeByAdcode(h[c]).name);return n.className=l.join(" "),u.length>0?(u.push(r.name),n.setAttribute("title",u.join(">"))):n.removeAttribute("title"),s.innerHTML=v.escapeHtml(r.name),a.innerHTML=e.length,new AMap.Marker({topWhenClick:!0,offset:new AMap.Pixel(-20,-30),content:n,position:r.center,extData:{_data:r}})}_getFeatureStyleOptions(t,e){const r=this._opts.getFeatureStyle,i=this._opts.featureStyleByLevel[t.properties.level];if(!r)return i;const n=r.call(null,t,e);return n?v.extend({},this._opts.featureStyleByLevel[t.properties.level],n):i}renderLater(t){this._renderLaterId||(this._renderLaterId=setTimeout(()=>{this.render()},t||100))}isRendering(){return this._isRendering}render(){this._renderLaterId&&(clearTimeout(this._renderLaterId),this._renderLaterId=null),this._isRendering=!0,this._ins._distMgr.onReady(this.renderViewport,this,!0)}forceRender(){this._renderLaterId&&(clearTimeout(this._renderLaterId),this._renderLaterId=null),this._isRendering=!0,this.clear(),this._ins._distMgr.onReady(this.renderViewport,this,!0)}getOption(t){return this._opts[t]}getOptions(){return this._opts}show(){var t;this.layer.show(),(t=this.markerGroup)===null||t===void 0||t.show()}hide(){var t;this.layer.hide(),(t=this.markerGroup)===null||t===void 0||t.hide()}clear(){var t;this.layer.clear(),(t=this.markerGroup)===null||t===void 0||t.clearOverlays(),this._polygonCache=[],this._markerCache=[]}setzIndex(t){this.layer.setzIndex(t)}getZooms(){return this._opts.zooms}destroy(){this._map.removeLayer(this.layer),this._map.remove(this.markerGroup),this._currentFeatures=[],this.clear(),this.layer=null,this._map=null,this._ins=null}}class Je{constructor(t,e,r){this.x=t,this.y=e,this.idx=r}}var Ke=Object.defineProperty,tr=Object.defineProperties,er=Object.getOwnPropertyDescriptors,Dt=Object.getOwnPropertySymbols,rr=Object.prototype.hasOwnProperty,ir=Object.prototype.propertyIsEnumerable,Tt=(o,t,e)=>t in o?Ke(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,nr=(o,t)=>{for(var e in t||(t={}))rr.call(t,e)&&Tt(o,e,t[e]);if(Dt)for(var e of Dt(t))ir.call(t,e)&&Tt(o,e,t[e]);return o},or=(o,t)=>tr(o,er(t));class sr extends Y{constructor(t){super(),this._data={list:[],bounds:null,source:null},this._mouseEvent=v.bind(v.debounce(()=>{this.renderLater()},50),this),this.initCSS();const e={autoSetFitView:!0,topAdcodes:[1e5],visible:!0,excludedAdcodes:null,zIndex:10,renderOptions:{}};this._opts=v.extend({},e,t),this.map=t.map,this._distMgr=new Ze({topAdcodes:this._opts.topAdcodes,excludedAdcodes:this._opts.excludedAdcodes}),this._distCounter=new qe({distMgr:this._distMgr,pointPackerThisArg:this,pointPacker:r=>this._packDataItem(r)}),this.renderEngine=new Qe(this,or(nr({},t.renderOptions),{zIndex:this._opts.zIndex,visible:this._opts.visible,map:t.map})),this.renderEngine.on("*",(r,...i)=>{this.emit(r,...i)}),this._opts.data&&this.setData(this._opts.data),this.bindOrUnbindMapEvent()}bindOrUnbindMapEvent(t=!0){const e=t?"on":"off";this.map[e]("moveend",this._mouseEvent),this.map[e]("zoomend",this._mouseEvent),this.map[e]("resize",this._mouseEvent),this.map[e]("rotateend",this._mouseEvent),this.map[e]("dragend",this._mouseEvent)}initCSS(){const t="_amap_district_cluster_css";if(document.getElementById(t))return;const e=".amap-ui-district-cluster-container{cursor:default;-webkit-backface-visibility:hidden;-webkit-transform:translateZ(0) scale(1,1)}.amap-ui-district-cluster-container canvas{position:absolute}.amap-ui-district-cluster-container .amap-ui-hide{display:none!important}.amap-ui-district-cluster-container .overlay-title,.amap-ui-district-cluster-marker{color:#555;background-color:#fffeef;font-size:12px;white-space:nowrap;position:absolute}.amap-ui-district-cluster-container .overlay-title{padding:2px 6px;display:inline-block;z-index:99999;border:1px solid #7e7e7e;border-radius:2px}.amap-ui-district-cluster-container .overlay-title:after,.amap-ui-district-cluster-container .overlay-title:before{content:'';display:block;position:absolute;margin:auto;width:0;height:0;border:solid transparent;border-width:5px}.amap-ui-district-cluster-container .overlay-title.left{transform:translate(10px,-50%)}.amap-ui-district-cluster-container .overlay-title.left:before{top:5px}.amap-ui-district-cluster-container .overlay-title.left:after{left:-9px;top:5px;border-right-color:#fffeef}.amap-ui-district-cluster-container .overlay-title.left:before{left:-10px;border-right-color:#7e7e7e}.amap-ui-district-cluster-container .overlay-title.top{transform:translate(-50%,-130%)}.amap-ui-district-cluster-container .overlay-title.top:before{left:0;right:0}.amap-ui-district-cluster-container .overlay-title.top:after{bottom:-9px;left:0;right:0;border-top-color:#fffeef}.amap-ui-district-cluster-container .overlay-title.top:before{bottom:-10px;border-top-color:#7e7e7e}.amap-ui-district-cluster-marker{border:1px solid #8e8e8e;width:auto;height:22px;border-radius:5px 5px 5px 0;left:0;top:0}.amap-ui-district-cluster-marker:after,.amap-ui-district-cluster-marker:before{content:'';display:block;position:absolute;width:0;height:0;border:solid rgba(0,0,0,0);border-width:6px;left:13px}.amap-ui-district-cluster-marker:after{bottom:-12px;border-top-color:#fffeef}.amap-ui-district-cluster-marker:before{bottom:-13px;border-top-color:#8e8e8e}.amap-ui-district-cluster-marker span{vertical-align:middle;padding:3px 5px;display:inline-block;height:16px;line-height:16px}.amap-ui-district-cluster-marker-title{border-radius:5px 0 0 0}.amap-ui-district-cluster-marker-body{background-color:#dc3912;color:#fff;border-radius:0 5px 5px 0}.amap-ui-district-cluster-marker.level_country .amap-ui-district-cluster-marker-body{background-color:#36c}.amap-ui-district-cluster-marker.level_province .amap-ui-district-cluster-marker-body{background-color:#dc3912}.amap-ui-district-cluster-marker.level_city .amap-ui-district-cluster-marker-body{background-color:#909}.amap-ui-district-cluster-marker.level_district .amap-ui-district-cluster-marker-body{background-color:#d47}",r=document,i="appendChild",n="styleSheet",s=r.createElement("style");s.id=t,s.type="text/css",r.getElementsByTagName("head")[0][i](s),s[n]?s[n].cssText=e:s[i](r.createTextNode(e))}getMinZoomToShowSub(t){return this.renderEngine.getMinZoomToShowSub(t)}getAreaNodeProps(t){return this._distMgr.getNodeByAdcode(t)}getDistrictExplorer(){return this._distMgr.getExplorer()}getRender(){return this.renderEngine}zoomToShowSubFeatures(t,e){this.renderEngine.zoomToShowSubFeatures(t,e)}renderLater(t){this.renderEngine.renderLater(t)}render(){this.renderEngine.render()}forceRender(){this.renderEngine.forceRender()}getDistMgr(){return this._distMgr}_clearData(){this.trigger("willClearData"),this._data?this._data.list.length=0:this._data={list:[],bounds:null},this._data.source=null,this._data.bounds=null,this._data.kdTree=null,this._distCounter.clearData(),this.trigger("didClearData")}_buildDataItems(t){const e=this._opts,r=e.getPosition,i=this._data.list,n=this._data.bounds;for(let s=0,a=t.length;s<a;s++){let u=t[s],l=r.call(this,u,s);l&&(l.getLng&&(l=[l.getLng(),l.getLat()]),i[s]=new Je(l[0],l[1],s),n.expandByPoint(l[0],l[1]))}}getDataItemsByBounds(t){const e=this._data.kdTree;if(!e)return null;const r=t.getSouthWest(),i=t.getNorthEast(),n=this._data.list,s=e.range(r.getLng(),r.getLat(),i.getLng(),i.getLat()),a=[];for(let u=0,l=s.length;u<l;u++)a[u]=this._packDataItem(n[s[u]]);return a}_packDataItem(t){if(!t)return null;if(!t._packedItem){const e=t.idx,r=[t.x,t.y];t._packedItem={dataIndex:e,dataItem:this._data.source[e],position:r}}return t._packedItem}_buildData(t){this._clearData(),this.trigger("willBuildData",t),this._data.source=t,this._data.bounds=C.getBoundsItemToExpand(),this._buildDataItems(t),this._distCounter.setData(this._data.list),this.trigger("didBuildData",t)}setData(t){t||(t=[]),this._buildData(t),this.renderLater(10),t.length&&this._opts.autoSetFitView&&this.setFitView()}isReady(){return this._distMgr.isReady()&&!!this._data}setFitView(){const t=this._data.bounds,e=this.getMap(),r=new AMap.Bounds([t.x,t.y],[t.x+t.width,t.y+t.height]);e&&e.setBounds(r)}getDistCounter(){return this._distCounter}getMap(){return this._opts.map}getZooms(){return this.renderEngine.getZooms()}isHidden(){return!this._opts.visible}show(){return this._opts.visible=!0,this.getRender().show()}hide(){return this._opts.visible=!1,this.getRender().hide()}destroy(){this.bindOrUnbindMapEvent(!1),this.getRender().destroy(),this._distCounter.destroy(),this._distMgr.destroy(),this.renderEngine=null,this._data={list:[],bounds:null},this._distMgr=null,this.map=void 0,this._opts=void 0}getzIndex(){return this._opts.zIndex}setzIndex(t){this._opts.zIndex=t,this.getRender().setzIndex(t)}}
//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/DistrictCluster/DistrictCluster.vue2.mjs





var DistrictCluster_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerDistrictCluster",
  mixins: [registerComponent],
  props: {
    data: {
      required: true,
      type: Array
    },
    // æ°æ®æºæ°ç»ï¼æ¯ä¸ªåç´ å³ä¸ºç¹ç¸å³çä¿¡æ¯
    getPosition: {
      type: Function
    },
    // è¿åæ°æ®é¡¹ä¸­çç»çº¬åº¦ä¿¡æ¯
    autoSetFitView: {
      type: Boolean,
      default: true
    },
    // æ¯å¦å¨ç»å¶åèªå¨è°æ´å°å¾è§éä»¥éåå¨é¨ç¹ï¼é»è®¤true
    topAdcodes: {
      type: Array
    },
    // é¡¶å±åºåçadcodeåè¡¨
    excludedAdcodes: {
      type: Array
    },
    renderOptions: {
      type: Object
    }
    // ç»å¶çå¼æçåæ°
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      options.map = this.$parentComponent;
      this.$amapComponent = new sr(options);
    },
    destroyComponent() {
      this.$amapComponent.destroy();
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=DistrictCluster.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/DistrictCluster/DistrictCluster.vue.mjs


DistrictCluster_vue2_script.__file = "src/vue-amap/packages/layer/data/DistrictCluster/DistrictCluster.vue";


//# sourceMappingURL=DistrictCluster.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/DistrictCluster/index.mjs



DistrictCluster_vue2_script.install = (app) => {
  app.component(DistrictCluster_vue2_script.name, DistrictCluster_vue2_script);
  return app;
};
const ElAmapLayerDistrictCluster = DistrictCluster_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/amap-xyz-layer/dist/index.mjs
var hr={exports:{}};hr.exports=cr,hr.exports.default=cr;function cr(r,e,n){n=n||2;var t=e&&e.length,i=t?e[0]*n:r.length,a=Zr(r,0,i,n,!0),s=[];if(!a||a.next===a.prev)return s;var h,c,l,f,o,v,M;if(t&&(a=ln(r,e,a,n)),r.length>80*n){h=l=r[0],c=f=r[1];for(var p=n;p<i;p+=n)o=r[p],v=r[p+1],o<h&&(h=o),v<c&&(c=v),o>l&&(l=o),v>f&&(f=v);M=Math.max(l-h,f-c),M=M!==0?32767/M:0}return dist_nr(a,s,n,h,c,M,0),s}function Zr(r,e,n,t,i){var a,s;if(i===wr(r,e,n,t)>0)for(a=e;a<n;a+=t)s=Xr(a,r[a],r[a+1],s);else for(a=n-t;a>=e;a-=t)s=Xr(a,r[a],r[a+1],s);return s&&lr(s,s.next)&&(dist_ir(s),s=s.next),s}function dist_H(r,e){if(!r)return r;e||(e=r);var n=r,t;do if(t=!1,!n.steiner&&(lr(n,n.next)||k(n.prev,n,n.next)===0)){if(dist_ir(n),n=e=n.prev,n===n.next)break;t=!0}else n=n.next;while(t||n!==e);return e}function dist_nr(r,e,n,t,i,a,s){if(!!r){!s&&a&&pn(r,t,i,a);for(var h=r,c,l;r.prev!==r.next;){if(c=r.prev,l=r.next,a?sn(r,t,i,a):an(r)){e.push(c.i/n|0),e.push(r.i/n|0),e.push(l.i/n|0),dist_ir(r),r=l.next,h=l.next;continue}if(r=l,r===h){s?s===1?(r=hn(dist_H(r),e,n),dist_nr(r,e,n,t,i,a,2)):s===2&&cn(r,e,n,t,i,a):dist_nr(dist_H(r),e,n,t,i,a,1);break}}}}function an(r){var e=r.prev,n=r,t=r.next;if(k(e,n,t)>=0)return!1;for(var i=e.x,a=n.x,s=t.x,h=e.y,c=n.y,l=t.y,f=i<a?i<s?i:s:a<s?a:s,o=h<c?h<l?h:l:c<l?c:l,v=i>a?i>s?i:s:a>s?a:s,M=h>c?h>l?h:l:c>l?c:l,p=t.next;p!==e;){if(p.x>=f&&p.x<=v&&p.y>=o&&p.y<=M&&dist_j(i,h,a,c,s,l,p.x,p.y)&&k(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function sn(r,e,n,t){var i=r.prev,a=r,s=r.next;if(k(i,a,s)>=0)return!1;for(var h=i.x,c=a.x,l=s.x,f=i.y,o=a.y,v=s.y,M=h<c?h<l?h:l:c<l?c:l,p=f<o?f<v?f:v:o<v?o:v,x=h>c?h>l?h:l:c>l?c:l,y=f>o?f>v?f:v:o>v?o:v,g=Pr(M,p,e,n,t),R=Pr(x,y,e,n,t),m=r.prevZ,d=r.nextZ;m&&m.z>=g&&d&&d.z<=R;){if(m.x>=M&&m.x<=x&&m.y>=p&&m.y<=y&&m!==i&&m!==s&&dist_j(h,f,c,o,l,v,m.x,m.y)&&k(m.prev,m,m.next)>=0||(m=m.prevZ,d.x>=M&&d.x<=x&&d.y>=p&&d.y<=y&&d!==i&&d!==s&&dist_j(h,f,c,o,l,v,d.x,d.y)&&k(d.prev,d,d.next)>=0))return!1;d=d.nextZ}for(;m&&m.z>=g;){if(m.x>=M&&m.x<=x&&m.y>=p&&m.y<=y&&m!==i&&m!==s&&dist_j(h,f,c,o,l,v,m.x,m.y)&&k(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;d&&d.z<=R;){if(d.x>=M&&d.x<=x&&d.y>=p&&d.y<=y&&d!==i&&d!==s&&dist_j(h,f,c,o,l,v,d.x,d.y)&&k(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function hn(r,e,n){var t=r;do{var i=t.prev,a=t.next.next;!lr(i,a)&&Dr(i,t,t.next,a)&&dist_tr(i,a)&&dist_tr(a,i)&&(e.push(i.i/n|0),e.push(t.i/n|0),e.push(a.i/n|0),dist_ir(t),dist_ir(t.next),t=r=a),t=t.next}while(t!==r);return dist_H(t)}function cn(r,e,n,t,i,a){var s=r;do{for(var h=s.next.next;h!==s.prev;){if(s.i!==h.i&&mn(s,h)){var c=Vr(s,h);s=dist_H(s,s.next),c=dist_H(c,c.next),dist_nr(s,e,n,t,i,a,0),dist_nr(c,e,n,t,i,a,0);return}h=h.next}s=s.next}while(s!==r)}function ln(r,e,n,t){var i=[],a,s,h,c,l;for(a=0,s=e.length;a<s;a++)h=e[a]*t,c=a<s-1?e[a+1]*t:r.length,l=Zr(r,h,c,t,!1),l===l.next&&(l.steiner=!0),i.push(xn(l));for(i.sort(fn),a=0;a<i.length;a++)n=vn(i[a],n);return n}function fn(r,e){return r.x-e.x}function vn(r,e){var n=on(r,e);if(!n)return e;var t=Vr(n,r);return dist_H(t,t.next),dist_H(n,n.next)}function on(r,e){var n=e,t=r.x,i=r.y,a=-1/0,s;do{if(i<=n.y&&i>=n.next.y&&n.next.y!==n.y){var h=n.x+(i-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(h<=t&&h>a&&(a=h,s=n.x<n.next.x?n:n.next,h===t))return s}n=n.next}while(n!==e);if(!s)return null;var c=s,l=s.x,f=s.y,o=1/0,v;n=s;do t>=n.x&&n.x>=l&&t!==n.x&&dist_j(i<f?t:a,i,l,f,i<f?a:t,i,n.x,n.y)&&(v=Math.abs(i-n.y)/(t-n.x),dist_tr(n,r)&&(v<o||v===o&&(n.x>s.x||n.x===s.x&&Mn(s,n)))&&(s=n,o=v)),n=n.next;while(n!==c);return s}function Mn(r,e){return k(r.prev,r,e.prev)<0&&k(e.next,r,r.next)<0}function pn(r,e,n,t){var i=r;do i.z===0&&(i.z=Pr(i.x,i.y,e,n,t)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==r);i.prevZ.nextZ=null,i.prevZ=null,yn(i)}function yn(r){var e,n,t,i,a,s,h,c,l=1;do{for(n=r,r=null,a=null,s=0;n;){for(s++,t=n,h=0,e=0;e<l&&(h++,t=t.nextZ,!!t);e++);for(c=l;h>0||c>0&&t;)h!==0&&(c===0||!t||n.z<=t.z)?(i=n,n=n.nextZ,h--):(i=t,t=t.nextZ,c--),a?a.nextZ=i:r=i,i.prevZ=a,a=i;n=t}a.nextZ=null,l*=2}while(s>1);return r}function Pr(r,e,n,t,i){return r=(r-n)*i|0,e=(e-t)*i|0,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function xn(r){var e=r,n=r;do(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next;while(e!==r);return n}function dist_j(r,e,n,t,i,a,s,h){return(i-s)*(e-h)>=(r-s)*(a-h)&&(r-s)*(t-h)>=(n-s)*(e-h)&&(n-s)*(a-h)>=(i-s)*(t-h)}function mn(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!gn(r,e)&&(dist_tr(r,e)&&dist_tr(e,r)&&dn(r,e)&&(k(r.prev,r,e.prev)||k(r,e.prev,e))||lr(r,e)&&k(r.prev,r,r.next)>0&&k(e.prev,e,e.next)>0)}function k(r,e,n){return(e.y-r.y)*(n.x-e.x)-(e.x-r.x)*(n.y-e.y)}function lr(r,e){return r.x===e.x&&r.y===e.y}function Dr(r,e,n,t){var i=vr(k(r,e,n)),a=vr(k(r,e,t)),s=vr(k(n,t,r)),h=vr(k(n,t,e));return!!(i!==a&&s!==h||i===0&&fr(r,n,e)||a===0&&fr(r,t,e)||s===0&&fr(n,r,t)||h===0&&fr(n,e,t))}function fr(r,e,n){return e.x<=Math.max(r.x,n.x)&&e.x>=Math.min(r.x,n.x)&&e.y<=Math.max(r.y,n.y)&&e.y>=Math.min(r.y,n.y)}function vr(r){return r>0?1:r<0?-1:0}function gn(r,e){var n=r;do{if(n.i!==r.i&&n.next.i!==r.i&&n.i!==e.i&&n.next.i!==e.i&&Dr(n,n.next,r,e))return!0;n=n.next}while(n!==r);return!1}function dist_tr(r,e){return k(r.prev,r,r.next)<0?k(r,e,r.next)>=0&&k(r,r.prev,e)>=0:k(r,e,r.prev)<0||k(r,r.next,e)<0}function dn(r,e){var n=r,t=!1,i=(r.x+e.x)/2,a=(r.y+e.y)/2;do n.y>a!=n.next.y>a&&n.next.y!==n.y&&i<(n.next.x-n.x)*(a-n.y)/(n.next.y-n.y)+n.x&&(t=!t),n=n.next;while(n!==r);return t}function Vr(r,e){var n=new Lr(r.i,r.x,r.y),t=new Lr(e.i,e.x,e.y),i=r.next,a=e.prev;return r.next=e,e.prev=r,n.next=i,i.prev=n,t.next=n,n.prev=t,a.next=t,t.prev=a,t}function Xr(r,e,n,t){var i=new Lr(r,e,n);return t?(i.next=t.next,i.prev=t,t.next.prev=i,t.next=i):(i.prev=i,i.next=i),i}function dist_ir(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function Lr(r,e,n){this.i=r,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}cr.deviation=function(r,e,n,t){var i=e&&e.length,a=i?e[0]*n:r.length,s=Math.abs(wr(r,0,a,n));if(i)for(var h=0,c=e.length;h<c;h++){var l=e[h]*n,f=h<c-1?e[h+1]*n:r.length;s-=Math.abs(wr(r,l,f,n))}var o=0;for(h=0;h<t.length;h+=3){var v=t[h]*n,M=t[h+1]*n,p=t[h+2]*n;o+=Math.abs((r[v]-r[p])*(r[M+1]-r[v+1])-(r[v]-r[M])*(r[p+1]-r[v+1]))}return s===0&&o===0?0:Math.abs((o-s)/s)};function wr(r,e,n,t){for(var i=0,a=e,s=n-t;a<n;a+=t)i+=(r[s]-r[a])*(r[a+1]+r[s+1]),s=a;return i}cr.flatten=function(r){for(var e=r[0][0].length,n={vertices:[],holes:[],dimensions:e},t=0,i=0;i<r.length;i++){for(var a=0;a<r[i].length;a++)for(var s=0;s<e;s++)n.vertices.push(r[i][a][s]);i>0&&(t+=r[i-1].length,n.holes.push(t))}return n};const dist_I={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0};function un(r,{precision:e=dist_I.precision}={}){return r=Tn(r),"".concat(parseFloat(r.toPrecision(e)))}function $r(r){return Array.isArray(r)||ArrayBuffer.isView(r)&&!(r instanceof DataView)}function Ir(r,e,n){const t=dist_I.EPSILON;n&&(dist_I.EPSILON=n);try{if(r===e)return!0;if($r(r)&&$r(e)){if(r.length!==e.length)return!1;for(let i=0;i<r.length;++i)if(!Ir(r[i],e[i]))return!1;return!0}return r&&r.equals?r.equals(e):e&&e.equals?e.equals(r):typeof r=="number"&&typeof e=="number"?Math.abs(r-e)<=dist_I.EPSILON*Math.max(1,Math.abs(r),Math.abs(e)):!1}finally{dist_I.EPSILON=t}}function Tn(r){return Math.round(r/dist_I.EPSILON)*dist_I.EPSILON}function _n(r){function e(){var n=Reflect.construct(r,Array.from(arguments));return Object.setPrototypeOf(n,Object.getPrototypeOf(this)),n}return e.prototype=Object.create(r.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),Object.setPrototypeOf?Object.setPrototypeOf(e,r):e.__proto__=r,e}class En extends _n(Array){clone(){return new this.constructor().copy(this)}fromArray(e,n=0){for(let t=0;t<this.ELEMENTS;++t)this[t]=e[t+n];return this.check()}toArray(e=[],n=0){for(let t=0;t<this.ELEMENTS;++t)e[n+t]=this[t];return e}from(e){return Array.isArray(e)?this.copy(e):this.fromObject(e)}to(e){return e===this?this:$r(e)?this.toArray(e):this.toObject(e)}toTarget(e){return e?this.to(e):this}toFloat32Array(){return new Float32Array(this)}toString(){return this.formatString(dist_I)}formatString(e){let n="";for(let t=0;t<this.ELEMENTS;++t)n+=(t>0?", ":"")+un(this[t],e);return"".concat(e.printTypes?this.constructor.name:"","[").concat(n,"]")}equals(e){if(!e||this.length!==e.length)return!1;for(let n=0;n<this.ELEMENTS;++n)if(!Ir(this[n],e[n]))return!1;return!0}exactEquals(e){if(!e||this.length!==e.length)return!1;for(let n=0;n<this.ELEMENTS;++n)if(this[n]!==e[n])return!1;return!0}negate(){for(let e=0;e<this.ELEMENTS;++e)this[e]=-this[e];return this.check()}lerp(e,n,t){if(t===void 0)return this.lerp(this,e,n);for(let i=0;i<this.ELEMENTS;++i){const a=e[i];this[i]=a+t*(n[i]-a)}return this.check()}min(e){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(e[n],this[n]);return this.check()}max(e){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.max(e[n],this[n]);return this.check()}clamp(e,n){for(let t=0;t<this.ELEMENTS;++t)this[t]=Math.min(Math.max(this[t],e[t]),n[t]);return this.check()}add(...e){for(const n of e)for(let t=0;t<this.ELEMENTS;++t)this[t]+=n[t];return this.check()}subtract(...e){for(const n of e)for(let t=0;t<this.ELEMENTS;++t)this[t]-=n[t];return this.check()}scale(e){if(typeof e=="number")for(let n=0;n<this.ELEMENTS;++n)this[n]*=e;else for(let n=0;n<this.ELEMENTS&&n<e.length;++n)this[n]*=e[n];return this.check()}multiplyByScalar(e){for(let n=0;n<this.ELEMENTS;++n)this[n]*=e;return this.check()}check(){if(dist_I.debug&&!this.validate())throw new Error("math.gl: ".concat(this.constructor.name," some fields set to invalid numbers'"));return this}validate(){let e=this.length===this.ELEMENTS;for(let n=0;n<this.ELEMENTS;++n)e=e&&Number.isFinite(this[n]);return e}sub(e){return this.subtract(e)}setScalar(e){for(let n=0;n<this.ELEMENTS;++n)this[n]=e;return this.check()}addScalar(e){for(let n=0;n<this.ELEMENTS;++n)this[n]+=e;return this.check()}subScalar(e){return this.addScalar(-e)}multiplyScalar(e){for(let n=0;n<this.ELEMENTS;++n)this[n]*=e;return this.check()}divideScalar(e){return this.multiplyByScalar(1/e)}clampScalar(e,n){for(let t=0;t<this.ELEMENTS;++t)this[t]=Math.min(Math.max(this[t],e),n);return this.check()}get elements(){return this}}function Rn(r,e){if(r.length!==e)return!1;for(let n=0;n<r.length;++n)if(!Number.isFinite(r[n]))return!1;return!0}function On(r){if(!Number.isFinite(r))throw new Error("Invalid number ".concat(r));return r}function zr(r,e,n=""){if(dist_I.debug&&!Rn(r,e))throw new Error("math.gl: ".concat(n," some fields set to invalid numbers'"));return r}var E={},W={};Object.defineProperty(W,"__esModule",{value:!0}),W.setMatrixArrayType=Pn,W.toRadian=wn,W.equals=$n,W.RANDOM=W.ARRAY_TYPE=W.EPSILON=void 0;var Ur=1e-6;W.EPSILON=Ur;var Kr=typeof Float32Array!="undefined"?Float32Array:Array;W.ARRAY_TYPE=Kr;var An=Math.random;W.RANDOM=An;function Pn(r){W.ARRAY_TYPE=Kr=r}var Ln=Math.PI/180;function wn(r){return r*Ln}function $n(r,e){return Math.abs(r-e)<=Ur*Math.max(1,Math.abs(r),Math.abs(e))}Math.hypot||(Math.hypot=function(){for(var r=0,e=arguments.length;e--;)r+=arguments[e]*arguments[e];return Math.sqrt(r)});function dist_or(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?dist_or=function(n){return typeof n}:dist_or=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},dist_or(r)}Object.defineProperty(E,"__esModule",{value:!0}),E.create=Hr,E.clone=Cn,E.fromValues=Nn,E.copy=Fn,E.set=qn,E.add=Yn,E.subtract=Qr,E.multiply=Jr,E.divide=jr,E.ceil=kn,E.floor=bn,E.min=Wn,E.max=Bn,E.round=Zn,E.scale=Dn,E.scaleAndAdd=Vn,E.distance=dist_re,E.squaredDistance=dist_ee,E.length=dist_ne,E.squaredLength=dist_te,E.negate=Xn,E.inverse=In,E.normalize=Un,E.dot=Kn,E.cross=Gn,E.lerp=Hn,E.random=Qn,E.transformMat2=Jn,E.transformMat2d=jn,E.transformMat3=dist_rt;var zn=E.transformMat4=dist_et;E.rotate=dist_nt,E.angle=dist_tt,E.zero=dist_it,E.str=dist_at,E.exactEquals=dist_st,E.equals=dist_ht,E.forEach=E.sqrLen=E.sqrDist=E.dist=E.div=E.mul=E.sub=E.len=void 0;var dist_Q=Sn(W);function Gr(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,n=new WeakMap;return(Gr=function(i){return i?n:e})(r)}function Sn(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||dist_or(r)!=="object"&&typeof r!="function")return{default:r};var n=Gr(e);if(n&&n.has(r))return n.get(r);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(t,a,s):t[a]=r[a]}return t.default=r,n&&n.set(r,t),t}function Hr(){var r=new dist_Q.ARRAY_TYPE(2);return dist_Q.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0),r}function Cn(r){var e=new dist_Q.ARRAY_TYPE(2);return e[0]=r[0],e[1]=r[1],e}function Nn(r,e){var n=new dist_Q.ARRAY_TYPE(2);return n[0]=r,n[1]=e,n}function Fn(r,e){return r[0]=e[0],r[1]=e[1],r}function qn(r,e,n){return r[0]=e,r[1]=n,r}function Yn(r,e,n){return r[0]=e[0]+n[0],r[1]=e[1]+n[1],r}function Qr(r,e,n){return r[0]=e[0]-n[0],r[1]=e[1]-n[1],r}function Jr(r,e,n){return r[0]=e[0]*n[0],r[1]=e[1]*n[1],r}function jr(r,e,n){return r[0]=e[0]/n[0],r[1]=e[1]/n[1],r}function kn(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r}function bn(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r}function Wn(r,e,n){return r[0]=Math.min(e[0],n[0]),r[1]=Math.min(e[1],n[1]),r}function Bn(r,e,n){return r[0]=Math.max(e[0],n[0]),r[1]=Math.max(e[1],n[1]),r}function Zn(r,e){return r[0]=Math.round(e[0]),r[1]=Math.round(e[1]),r}function Dn(r,e,n){return r[0]=e[0]*n,r[1]=e[1]*n,r}function Vn(r,e,n,t){return r[0]=e[0]+n[0]*t,r[1]=e[1]+n[1]*t,r}function dist_re(r,e){var n=e[0]-r[0],t=e[1]-r[1];return Math.hypot(n,t)}function dist_ee(r,e){var n=e[0]-r[0],t=e[1]-r[1];return n*n+t*t}function dist_ne(r){var e=r[0],n=r[1];return Math.hypot(e,n)}function dist_te(r){var e=r[0],n=r[1];return e*e+n*n}function Xn(r,e){return r[0]=-e[0],r[1]=-e[1],r}function In(r,e){return r[0]=1/e[0],r[1]=1/e[1],r}function Un(r,e){var n=e[0],t=e[1],i=n*n+t*t;return i>0&&(i=1/Math.sqrt(i)),r[0]=e[0]*i,r[1]=e[1]*i,r}function Kn(r,e){return r[0]*e[0]+r[1]*e[1]}function Gn(r,e,n){var t=e[0]*n[1]-e[1]*n[0];return r[0]=r[1]=0,r[2]=t,r}function Hn(r,e,n,t){var i=e[0],a=e[1];return r[0]=i+t*(n[0]-i),r[1]=a+t*(n[1]-a),r}function Qn(r,e){e=e||1;var n=dist_Q.RANDOM()*2*Math.PI;return r[0]=Math.cos(n)*e,r[1]=Math.sin(n)*e,r}function Jn(r,e,n){var t=e[0],i=e[1];return r[0]=n[0]*t+n[2]*i,r[1]=n[1]*t+n[3]*i,r}function jn(r,e,n){var t=e[0],i=e[1];return r[0]=n[0]*t+n[2]*i+n[4],r[1]=n[1]*t+n[3]*i+n[5],r}function dist_rt(r,e,n){var t=e[0],i=e[1];return r[0]=n[0]*t+n[3]*i+n[6],r[1]=n[1]*t+n[4]*i+n[7],r}function dist_et(r,e,n){var t=e[0],i=e[1];return r[0]=n[0]*t+n[4]*i+n[12],r[1]=n[1]*t+n[5]*i+n[13],r}function dist_nt(r,e,n,t){var i=e[0]-n[0],a=e[1]-n[1],s=Math.sin(t),h=Math.cos(t);return r[0]=i*h-a*s+n[0],r[1]=i*s+a*h+n[1],r}function dist_tt(r,e){var n=r[0],t=r[1],i=e[0],a=e[1],s=Math.sqrt(n*n+t*t)*Math.sqrt(i*i+a*a),h=s&&(n*i+t*a)/s;return Math.acos(Math.min(Math.max(h,-1),1))}function dist_it(r){return r[0]=0,r[1]=0,r}function dist_at(r){return"vec2("+r[0]+", "+r[1]+")"}function dist_st(r,e){return r[0]===e[0]&&r[1]===e[1]}function dist_ht(r,e){var n=r[0],t=r[1],i=e[0],a=e[1];return Math.abs(n-i)<=dist_Q.EPSILON*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(t-a)<=dist_Q.EPSILON*Math.max(1,Math.abs(t),Math.abs(a))}var dist_ct=dist_ne;E.len=dist_ct;var dist_lt=Qr;E.sub=dist_lt;var dist_ft=Jr;E.mul=dist_ft;var dist_vt=jr;E.div=dist_vt;var dist_ot=dist_re;E.dist=dist_ot;var dist_Mt=dist_ee;E.sqrDist=dist_Mt;var dist_pt=dist_te;E.sqrLen=dist_pt;var dist_yt=function(){var r=Hr();return function(e,n,t,i,a,s){var h,c;for(n||(n=2),t||(t=0),i?c=Math.min(i*n+t,e.length):c=e.length,h=t;h<c;h+=n)r[0]=e[h],r[1]=e[h+1],a(r,r,s),e[h]=r[0],e[h+1]=r[1];return e}}();E.forEach=dist_yt;function dist_xt(r,e,n){const t=e[0],i=e[1],a=n[3]*t+n[7]*i||1;return r[0]=(n[0]*t+n[4]*i)/a,r[1]=(n[1]*t+n[5]*i)/a,r}function dist_mt(r,e,n){const t=e[0],i=e[1],a=e[2],s=n[3]*t+n[7]*i+n[11]*a||1;return r[0]=(n[0]*t+n[4]*i+n[8]*a)/s,r[1]=(n[1]*t+n[5]*i+n[9]*a)/s,r[2]=(n[2]*t+n[6]*i+n[10]*a)/s,r}var T={};function Mr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?Mr=function(n){return typeof n}:Mr=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Mr(r)}Object.defineProperty(T,"__esModule",{value:!0}),T.create=dist_ae,T.clone=dist_ut,T.length=dist_se,T.fromValues=dist_Tt,T.copy=dist_t,T.set=dist_Et,T.add=dist_Rt,T.subtract=dist_he,T.multiply=dist_ce,T.divide=dist_le,T.ceil=dist_Ot,T.floor=dist_At,T.min=dist_Pt,T.max=dist_Lt,T.round=dist_wt,T.scale=dist_$t,T.scaleAndAdd=dist_zt,T.distance=dist_fe,T.squaredDistance=dist_ve,T.squaredLength=dist_oe,T.negate=dist_St,T.inverse=dist_Ct,T.normalize=dist_Nt,T.dot=dist_Me,T.cross=dist_Ft,T.lerp=dist_qt,T.hermite=dist_Yt,T.bezier=dist_kt,T.random=dist_bt;var dist_gt=T.transformMat4=dist_Wt;T.transformMat3=dist_Bt,T.transformQuat=dist_Zt,T.rotateX=dist_Dt,T.rotateY=dist_Vt,T.rotateZ=dist_Xt,T.angle=dist_It,T.zero=dist_Ut,T.str=dist_Kt,T.exactEquals=dist_Gt,T.equals=dist_Ht,T.forEach=T.sqrLen=T.len=T.sqrDist=T.dist=T.div=T.mul=T.sub=void 0;var U=dist_dt(W);function dist_ie(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,n=new WeakMap;return(dist_ie=function(i){return i?n:e})(r)}function dist_dt(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||Mr(r)!=="object"&&typeof r!="function")return{default:r};var n=dist_ie(e);if(n&&n.has(r))return n.get(r);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(t,a,s):t[a]=r[a]}return t.default=r,n&&n.set(r,t),t}function dist_ae(){var r=new U.ARRAY_TYPE(3);return U.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function dist_ut(r){var e=new U.ARRAY_TYPE(3);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e}function dist_se(r){var e=r[0],n=r[1],t=r[2];return Math.hypot(e,n,t)}function dist_Tt(r,e,n){var t=new U.ARRAY_TYPE(3);return t[0]=r,t[1]=e,t[2]=n,t}function dist_t(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r}function dist_Et(r,e,n,t){return r[0]=e,r[1]=n,r[2]=t,r}function dist_Rt(r,e,n){return r[0]=e[0]+n[0],r[1]=e[1]+n[1],r[2]=e[2]+n[2],r}function dist_he(r,e,n){return r[0]=e[0]-n[0],r[1]=e[1]-n[1],r[2]=e[2]-n[2],r}function dist_ce(r,e,n){return r[0]=e[0]*n[0],r[1]=e[1]*n[1],r[2]=e[2]*n[2],r}function dist_le(r,e,n){return r[0]=e[0]/n[0],r[1]=e[1]/n[1],r[2]=e[2]/n[2],r}function dist_Ot(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r[2]=Math.ceil(e[2]),r}function dist_At(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r[2]=Math.floor(e[2]),r}function dist_Pt(r,e,n){return r[0]=Math.min(e[0],n[0]),r[1]=Math.min(e[1],n[1]),r[2]=Math.min(e[2],n[2]),r}function dist_Lt(r,e,n){return r[0]=Math.max(e[0],n[0]),r[1]=Math.max(e[1],n[1]),r[2]=Math.max(e[2],n[2]),r}function dist_wt(r,e){return r[0]=Math.round(e[0]),r[1]=Math.round(e[1]),r[2]=Math.round(e[2]),r}function dist_$t(r,e,n){return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r}function dist_zt(r,e,n,t){return r[0]=e[0]+n[0]*t,r[1]=e[1]+n[1]*t,r[2]=e[2]+n[2]*t,r}function dist_fe(r,e){var n=e[0]-r[0],t=e[1]-r[1],i=e[2]-r[2];return Math.hypot(n,t,i)}function dist_ve(r,e){var n=e[0]-r[0],t=e[1]-r[1],i=e[2]-r[2];return n*n+t*t+i*i}function dist_oe(r){var e=r[0],n=r[1],t=r[2];return e*e+n*n+t*t}function dist_St(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r}function dist_Ct(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r}function dist_Nt(r,e){var n=e[0],t=e[1],i=e[2],a=n*n+t*t+i*i;return a>0&&(a=1/Math.sqrt(a)),r[0]=e[0]*a,r[1]=e[1]*a,r[2]=e[2]*a,r}function dist_Me(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]}function dist_Ft(r,e,n){var t=e[0],i=e[1],a=e[2],s=n[0],h=n[1],c=n[2];return r[0]=i*c-a*h,r[1]=a*s-t*c,r[2]=t*h-i*s,r}function dist_qt(r,e,n,t){var i=e[0],a=e[1],s=e[2];return r[0]=i+t*(n[0]-i),r[1]=a+t*(n[1]-a),r[2]=s+t*(n[2]-s),r}function dist_Yt(r,e,n,t,i,a){var s=a*a,h=s*(2*a-3)+1,c=s*(a-2)+a,l=s*(a-1),f=s*(3-2*a);return r[0]=e[0]*h+n[0]*c+t[0]*l+i[0]*f,r[1]=e[1]*h+n[1]*c+t[1]*l+i[1]*f,r[2]=e[2]*h+n[2]*c+t[2]*l+i[2]*f,r}function dist_kt(r,e,n,t,i,a){var s=1-a,h=s*s,c=a*a,l=h*s,f=3*a*h,o=3*c*s,v=c*a;return r[0]=e[0]*l+n[0]*f+t[0]*o+i[0]*v,r[1]=e[1]*l+n[1]*f+t[1]*o+i[1]*v,r[2]=e[2]*l+n[2]*f+t[2]*o+i[2]*v,r}function dist_bt(r,e){e=e||1;var n=U.RANDOM()*2*Math.PI,t=U.RANDOM()*2-1,i=Math.sqrt(1-t*t)*e;return r[0]=Math.cos(n)*i,r[1]=Math.sin(n)*i,r[2]=t*e,r}function dist_Wt(r,e,n){var t=e[0],i=e[1],a=e[2],s=n[3]*t+n[7]*i+n[11]*a+n[15];return s=s||1,r[0]=(n[0]*t+n[4]*i+n[8]*a+n[12])/s,r[1]=(n[1]*t+n[5]*i+n[9]*a+n[13])/s,r[2]=(n[2]*t+n[6]*i+n[10]*a+n[14])/s,r}function dist_Bt(r,e,n){var t=e[0],i=e[1],a=e[2];return r[0]=t*n[0]+i*n[3]+a*n[6],r[1]=t*n[1]+i*n[4]+a*n[7],r[2]=t*n[2]+i*n[5]+a*n[8],r}function dist_Zt(r,e,n){var t=n[0],i=n[1],a=n[2],s=n[3],h=e[0],c=e[1],l=e[2],f=i*l-a*c,o=a*h-t*l,v=t*c-i*h,M=i*v-a*o,p=a*f-t*v,x=t*o-i*f,y=s*2;return f*=y,o*=y,v*=y,M*=2,p*=2,x*=2,r[0]=h+f+M,r[1]=c+o+p,r[2]=l+v+x,r}function dist_Dt(r,e,n,t){var i=[],a=[];return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],a[0]=i[0],a[1]=i[1]*Math.cos(t)-i[2]*Math.sin(t),a[2]=i[1]*Math.sin(t)+i[2]*Math.cos(t),r[0]=a[0]+n[0],r[1]=a[1]+n[1],r[2]=a[2]+n[2],r}function dist_Vt(r,e,n,t){var i=[],a=[];return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],a[0]=i[2]*Math.sin(t)+i[0]*Math.cos(t),a[1]=i[1],a[2]=i[2]*Math.cos(t)-i[0]*Math.sin(t),r[0]=a[0]+n[0],r[1]=a[1]+n[1],r[2]=a[2]+n[2],r}function dist_Xt(r,e,n,t){var i=[],a=[];return i[0]=e[0]-n[0],i[1]=e[1]-n[1],i[2]=e[2]-n[2],a[0]=i[0]*Math.cos(t)-i[1]*Math.sin(t),a[1]=i[0]*Math.sin(t)+i[1]*Math.cos(t),a[2]=i[2],r[0]=a[0]+n[0],r[1]=a[1]+n[1],r[2]=a[2]+n[2],r}function dist_It(r,e){var n=r[0],t=r[1],i=r[2],a=e[0],s=e[1],h=e[2],c=Math.sqrt(n*n+t*t+i*i),l=Math.sqrt(a*a+s*s+h*h),f=c*l,o=f&&dist_Me(r,e)/f;return Math.acos(Math.min(Math.max(o,-1),1))}function dist_Ut(r){return r[0]=0,r[1]=0,r[2]=0,r}function dist_Kt(r){return"vec3("+r[0]+", "+r[1]+", "+r[2]+")"}function dist_Gt(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]}function dist_Ht(r,e){var n=r[0],t=r[1],i=r[2],a=e[0],s=e[1],h=e[2];return Math.abs(n-a)<=U.EPSILON*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(t-s)<=U.EPSILON*Math.max(1,Math.abs(t),Math.abs(s))&&Math.abs(i-h)<=U.EPSILON*Math.max(1,Math.abs(i),Math.abs(h))}var dist_Qt=dist_he;T.sub=dist_Qt;var dist_Jt=dist_ce;T.mul=dist_Jt;var dist_jt=dist_le;T.div=dist_jt;var ri=dist_fe;T.dist=ri;var ei=dist_ve;T.sqrDist=ei;var ni=dist_se;T.len=ni;var ti=dist_oe;T.sqrLen=ti;var ii=function(){var r=dist_ae();return function(e,n,t,i,a,s){var h,c;for(n||(n=3),t||(t=0),i?c=Math.min(i*n+t,e.length):c=e.length,h=t;h<c;h+=n)r[0]=e[h],r[1]=e[h+1],r[2]=e[h+2],a(r,r,s),e[h]=r[0],e[h+1]=r[1],e[h+2]=r[2];return e}}();T.forEach=ii;class ai extends En{toString(){let e="[";if(dist_I.printRowMajor){e+="row-major:";for(let n=0;n<this.RANK;++n)for(let t=0;t<this.RANK;++t)e+=" ".concat(this[t*this.RANK+n])}else{e+="column-major:";for(let n=0;n<this.ELEMENTS;++n)e+=" ".concat(this[n])}return e+="]",e}getElementIndex(e,n){return n*this.RANK+e}getElement(e,n){return this[n*this.RANK+e]}setElement(e,n,t){return this[n*this.RANK+e]=On(t),this}getColumn(e,n=new Array(this.RANK).fill(-0)){const t=e*this.RANK;for(let i=0;i<this.RANK;++i)n[i]=this[t+i];return n}setColumn(e,n){const t=e*this.RANK;for(let i=0;i<this.RANK;++i)this[t+i]=n[i];return this}}var w={};function pr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?pr=function(n){return typeof n}:pr=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},pr(r)}Object.defineProperty(w,"__esModule",{value:!0}),w.create=hi,w.fromMat4=ci,w.clone=li,w.copy=fi,w.fromValues=vi,w.set=oi,w.identity=Mi,w.transpose=pi,w.invert=yi,w.adjoint=xi,w.determinant=mi,w.multiply=dist_ye,w.translate=gi,w.rotate=di,w.scale=ui,w.fromTranslation=Ti,w.fromRotation=_i,w.fromScaling=Ei,w.fromMat2d=Ri,w.fromQuat=Oi,w.normalFromMat4=Ai,w.projection=Pi,w.str=Li,w.frob=wi,w.add=$i,w.subtract=dist_xe,w.multiplyScalar=zi,w.multiplyScalarAndAdd=Si,w.exactEquals=Ci,w.equals=Ni,w.sub=w.mul=void 0;var B=si(W);function dist_pe(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,n=new WeakMap;return(dist_pe=function(i){return i?n:e})(r)}function si(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||pr(r)!=="object"&&typeof r!="function")return{default:r};var n=dist_pe(e);if(n&&n.has(r))return n.get(r);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(t,a,s):t[a]=r[a]}return t.default=r,n&&n.set(r,t),t}function hi(){var r=new B.ARRAY_TYPE(9);return B.ARRAY_TYPE!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[5]=0,r[6]=0,r[7]=0),r[0]=1,r[4]=1,r[8]=1,r}function ci(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[4],r[4]=e[5],r[5]=e[6],r[6]=e[8],r[7]=e[9],r[8]=e[10],r}function li(r){var e=new B.ARRAY_TYPE(9);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e}function fi(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r}function vi(r,e,n,t,i,a,s,h,c){var l=new B.ARRAY_TYPE(9);return l[0]=r,l[1]=e,l[2]=n,l[3]=t,l[4]=i,l[5]=a,l[6]=s,l[7]=h,l[8]=c,l}function oi(r,e,n,t,i,a,s,h,c,l){return r[0]=e,r[1]=n,r[2]=t,r[3]=i,r[4]=a,r[5]=s,r[6]=h,r[7]=c,r[8]=l,r}function Mi(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=1,r[5]=0,r[6]=0,r[7]=0,r[8]=1,r}function pi(r,e){if(r===e){var n=e[1],t=e[2],i=e[5];r[1]=e[3],r[2]=e[6],r[3]=n,r[5]=e[7],r[6]=t,r[7]=i}else r[0]=e[0],r[1]=e[3],r[2]=e[6],r[3]=e[1],r[4]=e[4],r[5]=e[7],r[6]=e[2],r[7]=e[5],r[8]=e[8];return r}function yi(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],o=f*s-h*l,v=-f*a+h*c,M=l*a-s*c,p=n*o+t*v+i*M;return p?(p=1/p,r[0]=o*p,r[1]=(-f*t+i*l)*p,r[2]=(h*t-i*s)*p,r[3]=v*p,r[4]=(f*n-i*c)*p,r[5]=(-h*n+i*a)*p,r[6]=M*p,r[7]=(-l*n+t*c)*p,r[8]=(s*n-t*a)*p,r):null}function xi(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8];return r[0]=s*f-h*l,r[1]=i*l-t*f,r[2]=t*h-i*s,r[3]=h*c-a*f,r[4]=n*f-i*c,r[5]=i*a-n*h,r[6]=a*l-s*c,r[7]=t*c-n*l,r[8]=n*s-t*a,r}function mi(r){var e=r[0],n=r[1],t=r[2],i=r[3],a=r[4],s=r[5],h=r[6],c=r[7],l=r[8];return e*(l*a-s*c)+n*(-l*i+s*h)+t*(c*i-a*h)}function dist_ye(r,e,n){var t=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],o=e[8],v=n[0],M=n[1],p=n[2],x=n[3],y=n[4],g=n[5],R=n[6],m=n[7],d=n[8];return r[0]=v*t+M*s+p*l,r[1]=v*i+M*h+p*f,r[2]=v*a+M*c+p*o,r[3]=x*t+y*s+g*l,r[4]=x*i+y*h+g*f,r[5]=x*a+y*c+g*o,r[6]=R*t+m*s+d*l,r[7]=R*i+m*h+d*f,r[8]=R*a+m*c+d*o,r}function gi(r,e,n){var t=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],o=e[8],v=n[0],M=n[1];return r[0]=t,r[1]=i,r[2]=a,r[3]=s,r[4]=h,r[5]=c,r[6]=v*t+M*s+l,r[7]=v*i+M*h+f,r[8]=v*a+M*c+o,r}function di(r,e,n){var t=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],o=e[8],v=Math.sin(n),M=Math.cos(n);return r[0]=M*t+v*s,r[1]=M*i+v*h,r[2]=M*a+v*c,r[3]=M*s-v*t,r[4]=M*h-v*i,r[5]=M*c-v*a,r[6]=l,r[7]=f,r[8]=o,r}function ui(r,e,n){var t=n[0],i=n[1];return r[0]=t*e[0],r[1]=t*e[1],r[2]=t*e[2],r[3]=i*e[3],r[4]=i*e[4],r[5]=i*e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r}function Ti(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=1,r[5]=0,r[6]=e[0],r[7]=e[1],r[8]=1,r}function _i(r,e){var n=Math.sin(e),t=Math.cos(e);return r[0]=t,r[1]=n,r[2]=0,r[3]=-n,r[4]=t,r[5]=0,r[6]=0,r[7]=0,r[8]=1,r}function Ei(r,e){return r[0]=e[0],r[1]=0,r[2]=0,r[3]=0,r[4]=e[1],r[5]=0,r[6]=0,r[7]=0,r[8]=1,r}function Ri(r,e){return r[0]=e[0],r[1]=e[1],r[2]=0,r[3]=e[2],r[4]=e[3],r[5]=0,r[6]=e[4],r[7]=e[5],r[8]=1,r}function Oi(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=n+n,h=t+t,c=i+i,l=n*s,f=t*s,o=t*h,v=i*s,M=i*h,p=i*c,x=a*s,y=a*h,g=a*c;return r[0]=1-o-p,r[3]=f-g,r[6]=v+y,r[1]=f+g,r[4]=1-l-p,r[7]=M-x,r[2]=v-y,r[5]=M+x,r[8]=1-l-o,r}function Ai(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],o=e[9],v=e[10],M=e[11],p=e[12],x=e[13],y=e[14],g=e[15],R=n*h-t*s,m=n*c-i*s,d=n*l-a*s,P=t*c-i*h,A=t*l-a*h,F=i*l-a*c,S=f*x-o*p,C=f*y-v*p,$=f*g-M*p,q=o*y-v*x,N=o*g-M*x,Y=v*g-M*y,L=R*Y-m*N+d*q+P*$-A*C+F*S;return L?(L=1/L,r[0]=(h*Y-c*N+l*q)*L,r[1]=(c*$-s*Y-l*C)*L,r[2]=(s*N-h*$+l*S)*L,r[3]=(i*N-t*Y-a*q)*L,r[4]=(n*Y-i*$+a*C)*L,r[5]=(t*$-n*N-a*S)*L,r[6]=(x*F-y*A+g*P)*L,r[7]=(y*d-p*F-g*m)*L,r[8]=(p*A-x*d+g*R)*L,r):null}function Pi(r,e,n){return r[0]=2/e,r[1]=0,r[2]=0,r[3]=0,r[4]=-2/n,r[5]=0,r[6]=-1,r[7]=1,r[8]=1,r}function Li(r){return"mat3("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+", "+r[4]+", "+r[5]+", "+r[6]+", "+r[7]+", "+r[8]+")"}function wi(r){return Math.hypot(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8])}function $i(r,e,n){return r[0]=e[0]+n[0],r[1]=e[1]+n[1],r[2]=e[2]+n[2],r[3]=e[3]+n[3],r[4]=e[4]+n[4],r[5]=e[5]+n[5],r[6]=e[6]+n[6],r[7]=e[7]+n[7],r[8]=e[8]+n[8],r}function dist_xe(r,e,n){return r[0]=e[0]-n[0],r[1]=e[1]-n[1],r[2]=e[2]-n[2],r[3]=e[3]-n[3],r[4]=e[4]-n[4],r[5]=e[5]-n[5],r[6]=e[6]-n[6],r[7]=e[7]-n[7],r[8]=e[8]-n[8],r}function zi(r,e,n){return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r[4]=e[4]*n,r[5]=e[5]*n,r[6]=e[6]*n,r[7]=e[7]*n,r[8]=e[8]*n,r}function Si(r,e,n,t){return r[0]=e[0]+n[0]*t,r[1]=e[1]+n[1]*t,r[2]=e[2]+n[2]*t,r[3]=e[3]+n[3]*t,r[4]=e[4]+n[4]*t,r[5]=e[5]+n[5]*t,r[6]=e[6]+n[6]*t,r[7]=e[7]+n[7]*t,r[8]=e[8]+n[8]*t,r}function Ci(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&r[5]===e[5]&&r[6]===e[6]&&r[7]===e[7]&&r[8]===e[8]}function Ni(r,e){var n=r[0],t=r[1],i=r[2],a=r[3],s=r[4],h=r[5],c=r[6],l=r[7],f=r[8],o=e[0],v=e[1],M=e[2],p=e[3],x=e[4],y=e[5],g=e[6],R=e[7],m=e[8];return Math.abs(n-o)<=B.EPSILON*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(t-v)<=B.EPSILON*Math.max(1,Math.abs(t),Math.abs(v))&&Math.abs(i-M)<=B.EPSILON*Math.max(1,Math.abs(i),Math.abs(M))&&Math.abs(a-p)<=B.EPSILON*Math.max(1,Math.abs(a),Math.abs(p))&&Math.abs(s-x)<=B.EPSILON*Math.max(1,Math.abs(s),Math.abs(x))&&Math.abs(h-y)<=B.EPSILON*Math.max(1,Math.abs(h),Math.abs(y))&&Math.abs(c-g)<=B.EPSILON*Math.max(1,Math.abs(c),Math.abs(g))&&Math.abs(l-R)<=B.EPSILON*Math.max(1,Math.abs(l),Math.abs(R))&&Math.abs(f-m)<=B.EPSILON*Math.max(1,Math.abs(f),Math.abs(m))}var Fi=dist_ye;w.mul=Fi;var qi=dist_xe;w.sub=qi;var dist_me;(function(r){r[r.COL0ROW0=0]="COL0ROW0",r[r.COL0ROW1=1]="COL0ROW1",r[r.COL0ROW2=2]="COL0ROW2",r[r.COL1ROW0=3]="COL1ROW0",r[r.COL1ROW1=4]="COL1ROW1",r[r.COL1ROW2=5]="COL1ROW2",r[r.COL2ROW0=6]="COL2ROW0",r[r.COL2ROW1=7]="COL2ROW1",r[r.COL2ROW2=8]="COL2ROW2"})(dist_me||(dist_me={})),Object.freeze([1,0,0,0,1,0,0,0,1]);var _={};function yr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?yr=function(n){return typeof n}:yr=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},yr(r)}Object.defineProperty(_,"__esModule",{value:!0}),_.create=Hi,_.clone=Qi,_.copy=Ji,_.fromValues=ji,_.set=r1,_.identity=dist_ue;var Yi=_.transpose=e1,ki=_.invert=n1;_.adjoint=t1;var bi=_.determinant=i1,dist_ge=_.multiply=dist_Te,Wi=_.translate=a1,Bi=_.scale=s1,Zi=_.rotate=h1,Di=_.rotateX=c1,Vi=_.rotateY=l1,Xi=_.rotateZ=f1;_.fromTranslation=v1,_.fromScaling=o1,_.fromRotation=M1,_.fromXRotation=p1,_.fromYRotation=y1,_.fromZRotation=x1,_.fromRotationTranslation=dist_e,_.fromQuat2=m1,_.getTranslation=g1,_.getScaling=dist_Ee,_.getRotation=d1,_.fromRotationTranslationScale=u1,_.fromRotationTranslationScaleOrigin=T1;var Ii=_.fromQuat=_1,Ui=_.frustum=E1;_.perspectiveNO=dist_Re,_.perspectiveZO=O1,_.perspectiveFromFieldOfView=A1,_.orthoNO=dist_Ae,_.orthoZO=L1;var Ki=_.lookAt=w1;_.targetTo=$1,_.str=z1,_.frob=S1,_.add=C1,_.subtract=dist_Le,_.multiplyScalar=N1,_.multiplyScalarAndAdd=F1,_.exactEquals=q1,_.equals=Y1,_.sub=_.mul=dist_Pe=_.ortho=dist_Oe=_.perspective=void 0;var dist_z=Gi(W);function dist_de(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,n=new WeakMap;return(dist_de=function(i){return i?n:e})(r)}function Gi(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||yr(r)!=="object"&&typeof r!="function")return{default:r};var n=dist_de(e);if(n&&n.has(r))return n.get(r);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(t,a,s):t[a]=r[a]}return t.default=r,n&&n.set(r,t),t}function Hi(){var r=new dist_z.ARRAY_TYPE(16);return dist_z.ARRAY_TYPE!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=0,r[12]=0,r[13]=0,r[14]=0),r[0]=1,r[5]=1,r[10]=1,r[15]=1,r}function Qi(r){var e=new dist_z.ARRAY_TYPE(16);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e[9]=r[9],e[10]=r[10],e[11]=r[11],e[12]=r[12],e[13]=r[13],e[14]=r[14],e[15]=r[15],e}function Ji(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function ji(r,e,n,t,i,a,s,h,c,l,f,o,v,M,p,x){var y=new dist_z.ARRAY_TYPE(16);return y[0]=r,y[1]=e,y[2]=n,y[3]=t,y[4]=i,y[5]=a,y[6]=s,y[7]=h,y[8]=c,y[9]=l,y[10]=f,y[11]=o,y[12]=v,y[13]=M,y[14]=p,y[15]=x,y}function r1(r,e,n,t,i,a,s,h,c,l,f,o,v,M,p,x,y){return r[0]=e,r[1]=n,r[2]=t,r[3]=i,r[4]=a,r[5]=s,r[6]=h,r[7]=c,r[8]=l,r[9]=f,r[10]=o,r[11]=v,r[12]=M,r[13]=p,r[14]=x,r[15]=y,r}function dist_ue(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function e1(r,e){if(r===e){var n=e[1],t=e[2],i=e[3],a=e[6],s=e[7],h=e[11];r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=n,r[6]=e[9],r[7]=e[13],r[8]=t,r[9]=a,r[11]=e[14],r[12]=i,r[13]=s,r[14]=h}else r[0]=e[0],r[1]=e[4],r[2]=e[8],r[3]=e[12],r[4]=e[1],r[5]=e[5],r[6]=e[9],r[7]=e[13],r[8]=e[2],r[9]=e[6],r[10]=e[10],r[11]=e[14],r[12]=e[3],r[13]=e[7],r[14]=e[11],r[15]=e[15];return r}function n1(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],o=e[9],v=e[10],M=e[11],p=e[12],x=e[13],y=e[14],g=e[15],R=n*h-t*s,m=n*c-i*s,d=n*l-a*s,P=t*c-i*h,A=t*l-a*h,F=i*l-a*c,S=f*x-o*p,C=f*y-v*p,$=f*g-M*p,q=o*y-v*x,N=o*g-M*x,Y=v*g-M*y,L=R*Y-m*N+d*q+P*$-A*C+F*S;return L?(L=1/L,r[0]=(h*Y-c*N+l*q)*L,r[1]=(i*N-t*Y-a*q)*L,r[2]=(x*F-y*A+g*P)*L,r[3]=(v*A-o*F-M*P)*L,r[4]=(c*$-s*Y-l*C)*L,r[5]=(n*Y-i*$+a*C)*L,r[6]=(y*d-p*F-g*m)*L,r[7]=(f*F-v*d+M*m)*L,r[8]=(s*N-h*$+l*S)*L,r[9]=(t*$-n*N-a*S)*L,r[10]=(p*A-x*d+g*R)*L,r[11]=(o*d-f*A-M*R)*L,r[12]=(h*C-s*q-c*S)*L,r[13]=(n*q-t*C+i*S)*L,r[14]=(x*m-p*P-y*R)*L,r[15]=(f*P-o*m+v*R)*L,r):null}function t1(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=e[4],h=e[5],c=e[6],l=e[7],f=e[8],o=e[9],v=e[10],M=e[11],p=e[12],x=e[13],y=e[14],g=e[15];return r[0]=h*(v*g-M*y)-o*(c*g-l*y)+x*(c*M-l*v),r[1]=-(t*(v*g-M*y)-o*(i*g-a*y)+x*(i*M-a*v)),r[2]=t*(c*g-l*y)-h*(i*g-a*y)+x*(i*l-a*c),r[3]=-(t*(c*M-l*v)-h*(i*M-a*v)+o*(i*l-a*c)),r[4]=-(s*(v*g-M*y)-f*(c*g-l*y)+p*(c*M-l*v)),r[5]=n*(v*g-M*y)-f*(i*g-a*y)+p*(i*M-a*v),r[6]=-(n*(c*g-l*y)-s*(i*g-a*y)+p*(i*l-a*c)),r[7]=n*(c*M-l*v)-s*(i*M-a*v)+f*(i*l-a*c),r[8]=s*(o*g-M*x)-f*(h*g-l*x)+p*(h*M-l*o),r[9]=-(n*(o*g-M*x)-f*(t*g-a*x)+p*(t*M-a*o)),r[10]=n*(h*g-l*x)-s*(t*g-a*x)+p*(t*l-a*h),r[11]=-(n*(h*M-l*o)-s*(t*M-a*o)+f*(t*l-a*h)),r[12]=-(s*(o*y-v*x)-f*(h*y-c*x)+p*(h*v-c*o)),r[13]=n*(o*y-v*x)-f*(t*y-i*x)+p*(t*v-i*o),r[14]=-(n*(h*y-c*x)-s*(t*y-i*x)+p*(t*c-i*h)),r[15]=n*(h*v-c*o)-s*(t*v-i*o)+f*(t*c-i*h),r}function i1(r){var e=r[0],n=r[1],t=r[2],i=r[3],a=r[4],s=r[5],h=r[6],c=r[7],l=r[8],f=r[9],o=r[10],v=r[11],M=r[12],p=r[13],x=r[14],y=r[15],g=e*s-n*a,R=e*h-t*a,m=e*c-i*a,d=n*h-t*s,P=n*c-i*s,A=t*c-i*h,F=l*p-f*M,S=l*x-o*M,C=l*y-v*M,$=f*x-o*p,q=f*y-v*p,N=o*y-v*x;return g*N-R*q+m*$+d*C-P*S+A*F}function dist_Te(r,e,n){var t=e[0],i=e[1],a=e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],o=e[8],v=e[9],M=e[10],p=e[11],x=e[12],y=e[13],g=e[14],R=e[15],m=n[0],d=n[1],P=n[2],A=n[3];return r[0]=m*t+d*h+P*o+A*x,r[1]=m*i+d*c+P*v+A*y,r[2]=m*a+d*l+P*M+A*g,r[3]=m*s+d*f+P*p+A*R,m=n[4],d=n[5],P=n[6],A=n[7],r[4]=m*t+d*h+P*o+A*x,r[5]=m*i+d*c+P*v+A*y,r[6]=m*a+d*l+P*M+A*g,r[7]=m*s+d*f+P*p+A*R,m=n[8],d=n[9],P=n[10],A=n[11],r[8]=m*t+d*h+P*o+A*x,r[9]=m*i+d*c+P*v+A*y,r[10]=m*a+d*l+P*M+A*g,r[11]=m*s+d*f+P*p+A*R,m=n[12],d=n[13],P=n[14],A=n[15],r[12]=m*t+d*h+P*o+A*x,r[13]=m*i+d*c+P*v+A*y,r[14]=m*a+d*l+P*M+A*g,r[15]=m*s+d*f+P*p+A*R,r}function a1(r,e,n){var t=n[0],i=n[1],a=n[2],s,h,c,l,f,o,v,M,p,x,y,g;return e===r?(r[12]=e[0]*t+e[4]*i+e[8]*a+e[12],r[13]=e[1]*t+e[5]*i+e[9]*a+e[13],r[14]=e[2]*t+e[6]*i+e[10]*a+e[14],r[15]=e[3]*t+e[7]*i+e[11]*a+e[15]):(s=e[0],h=e[1],c=e[2],l=e[3],f=e[4],o=e[5],v=e[6],M=e[7],p=e[8],x=e[9],y=e[10],g=e[11],r[0]=s,r[1]=h,r[2]=c,r[3]=l,r[4]=f,r[5]=o,r[6]=v,r[7]=M,r[8]=p,r[9]=x,r[10]=y,r[11]=g,r[12]=s*t+f*i+p*a+e[12],r[13]=h*t+o*i+x*a+e[13],r[14]=c*t+v*i+y*a+e[14],r[15]=l*t+M*i+g*a+e[15]),r}function s1(r,e,n){var t=n[0],i=n[1],a=n[2];return r[0]=e[0]*t,r[1]=e[1]*t,r[2]=e[2]*t,r[3]=e[3]*t,r[4]=e[4]*i,r[5]=e[5]*i,r[6]=e[6]*i,r[7]=e[7]*i,r[8]=e[8]*a,r[9]=e[9]*a,r[10]=e[10]*a,r[11]=e[11]*a,r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15],r}function h1(r,e,n,t){var i=t[0],a=t[1],s=t[2],h=Math.hypot(i,a,s),c,l,f,o,v,M,p,x,y,g,R,m,d,P,A,F,S,C,$,q,N,Y,L,X;return h<dist_z.EPSILON?null:(h=1/h,i*=h,a*=h,s*=h,c=Math.sin(n),l=Math.cos(n),f=1-l,o=e[0],v=e[1],M=e[2],p=e[3],x=e[4],y=e[5],g=e[6],R=e[7],m=e[8],d=e[9],P=e[10],A=e[11],F=i*i*f+l,S=a*i*f+s*c,C=s*i*f-a*c,$=i*a*f-s*c,q=a*a*f+l,N=s*a*f+i*c,Y=i*s*f+a*c,L=a*s*f-i*c,X=s*s*f+l,r[0]=o*F+x*S+m*C,r[1]=v*F+y*S+d*C,r[2]=M*F+g*S+P*C,r[3]=p*F+R*S+A*C,r[4]=o*$+x*q+m*N,r[5]=v*$+y*q+d*N,r[6]=M*$+g*q+P*N,r[7]=p*$+R*q+A*N,r[8]=o*Y+x*L+m*X,r[9]=v*Y+y*L+d*X,r[10]=M*Y+g*L+P*X,r[11]=p*Y+R*L+A*X,e!==r&&(r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r)}function c1(r,e,n){var t=Math.sin(n),i=Math.cos(n),a=e[4],s=e[5],h=e[6],c=e[7],l=e[8],f=e[9],o=e[10],v=e[11];return e!==r&&(r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[4]=a*i+l*t,r[5]=s*i+f*t,r[6]=h*i+o*t,r[7]=c*i+v*t,r[8]=l*i-a*t,r[9]=f*i-s*t,r[10]=o*i-h*t,r[11]=v*i-c*t,r}function l1(r,e,n){var t=Math.sin(n),i=Math.cos(n),a=e[0],s=e[1],h=e[2],c=e[3],l=e[8],f=e[9],o=e[10],v=e[11];return e!==r&&(r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i-l*t,r[1]=s*i-f*t,r[2]=h*i-o*t,r[3]=c*i-v*t,r[8]=a*t+l*i,r[9]=s*t+f*i,r[10]=h*t+o*i,r[11]=c*t+v*i,r}function f1(r,e,n){var t=Math.sin(n),i=Math.cos(n),a=e[0],s=e[1],h=e[2],c=e[3],l=e[4],f=e[5],o=e[6],v=e[7];return e!==r&&(r[8]=e[8],r[9]=e[9],r[10]=e[10],r[11]=e[11],r[12]=e[12],r[13]=e[13],r[14]=e[14],r[15]=e[15]),r[0]=a*i+l*t,r[1]=s*i+f*t,r[2]=h*i+o*t,r[3]=c*i+v*t,r[4]=l*i-a*t,r[5]=f*i-s*t,r[6]=o*i-h*t,r[7]=v*i-c*t,r}function v1(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=e[0],r[13]=e[1],r[14]=e[2],r[15]=1,r}function o1(r,e){return r[0]=e[0],r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=e[1],r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=e[2],r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function M1(r,e,n){var t=n[0],i=n[1],a=n[2],s=Math.hypot(t,i,a),h,c,l;return s<dist_z.EPSILON?null:(s=1/s,t*=s,i*=s,a*=s,h=Math.sin(e),c=Math.cos(e),l=1-c,r[0]=t*t*l+c,r[1]=i*t*l+a*h,r[2]=a*t*l-i*h,r[3]=0,r[4]=t*i*l-a*h,r[5]=i*i*l+c,r[6]=a*i*l+t*h,r[7]=0,r[8]=t*a*l+i*h,r[9]=i*a*l-t*h,r[10]=a*a*l+c,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r)}function p1(r,e){var n=Math.sin(e),t=Math.cos(e);return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=t,r[6]=n,r[7]=0,r[8]=0,r[9]=-n,r[10]=t,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function y1(r,e){var n=Math.sin(e),t=Math.cos(e);return r[0]=t,r[1]=0,r[2]=-n,r[3]=0,r[4]=0,r[5]=1,r[6]=0,r[7]=0,r[8]=n,r[9]=0,r[10]=t,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function x1(r,e){var n=Math.sin(e),t=Math.cos(e);return r[0]=t,r[1]=n,r[2]=0,r[3]=0,r[4]=-n,r[5]=t,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=1,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function dist_e(r,e,n){var t=e[0],i=e[1],a=e[2],s=e[3],h=t+t,c=i+i,l=a+a,f=t*h,o=t*c,v=t*l,M=i*c,p=i*l,x=a*l,y=s*h,g=s*c,R=s*l;return r[0]=1-(M+x),r[1]=o+R,r[2]=v-g,r[3]=0,r[4]=o-R,r[5]=1-(f+x),r[6]=p+y,r[7]=0,r[8]=v+g,r[9]=p-y,r[10]=1-(f+M),r[11]=0,r[12]=n[0],r[13]=n[1],r[14]=n[2],r[15]=1,r}function m1(r,e){var n=new dist_z.ARRAY_TYPE(3),t=-e[0],i=-e[1],a=-e[2],s=e[3],h=e[4],c=e[5],l=e[6],f=e[7],o=t*t+i*i+a*a+s*s;return o>0?(n[0]=(h*s+f*t+c*a-l*i)*2/o,n[1]=(c*s+f*i+l*t-h*a)*2/o,n[2]=(l*s+f*a+h*i-c*t)*2/o):(n[0]=(h*s+f*t+c*a-l*i)*2,n[1]=(c*s+f*i+l*t-h*a)*2,n[2]=(l*s+f*a+h*i-c*t)*2),dist_e(r,e,n),r}function g1(r,e){return r[0]=e[12],r[1]=e[13],r[2]=e[14],r}function dist_Ee(r,e){var n=e[0],t=e[1],i=e[2],a=e[4],s=e[5],h=e[6],c=e[8],l=e[9],f=e[10];return r[0]=Math.hypot(n,t,i),r[1]=Math.hypot(a,s,h),r[2]=Math.hypot(c,l,f),r}function d1(r,e){var n=new dist_z.ARRAY_TYPE(3);dist_Ee(n,e);var t=1/n[0],i=1/n[1],a=1/n[2],s=e[0]*t,h=e[1]*i,c=e[2]*a,l=e[4]*t,f=e[5]*i,o=e[6]*a,v=e[8]*t,M=e[9]*i,p=e[10]*a,x=s+f+p,y=0;return x>0?(y=Math.sqrt(x+1)*2,r[3]=.25*y,r[0]=(o-M)/y,r[1]=(v-c)/y,r[2]=(h-l)/y):s>f&&s>p?(y=Math.sqrt(1+s-f-p)*2,r[3]=(o-M)/y,r[0]=.25*y,r[1]=(h+l)/y,r[2]=(v+c)/y):f>p?(y=Math.sqrt(1+f-s-p)*2,r[3]=(v-c)/y,r[0]=(h+l)/y,r[1]=.25*y,r[2]=(o+M)/y):(y=Math.sqrt(1+p-s-f)*2,r[3]=(h-l)/y,r[0]=(v+c)/y,r[1]=(o+M)/y,r[2]=.25*y),r}function u1(r,e,n,t){var i=e[0],a=e[1],s=e[2],h=e[3],c=i+i,l=a+a,f=s+s,o=i*c,v=i*l,M=i*f,p=a*l,x=a*f,y=s*f,g=h*c,R=h*l,m=h*f,d=t[0],P=t[1],A=t[2];return r[0]=(1-(p+y))*d,r[1]=(v+m)*d,r[2]=(M-R)*d,r[3]=0,r[4]=(v-m)*P,r[5]=(1-(o+y))*P,r[6]=(x+g)*P,r[7]=0,r[8]=(M+R)*A,r[9]=(x-g)*A,r[10]=(1-(o+p))*A,r[11]=0,r[12]=n[0],r[13]=n[1],r[14]=n[2],r[15]=1,r}function T1(r,e,n,t,i){var a=e[0],s=e[1],h=e[2],c=e[3],l=a+a,f=s+s,o=h+h,v=a*l,M=a*f,p=a*o,x=s*f,y=s*o,g=h*o,R=c*l,m=c*f,d=c*o,P=t[0],A=t[1],F=t[2],S=i[0],C=i[1],$=i[2],q=(1-(x+g))*P,N=(M+d)*P,Y=(p-m)*P,L=(M-d)*A,X=(1-(v+g))*A,rr=(y+R)*A,er=(p+m)*F,Wr=(y-R)*F,Br=(1-(v+x))*F;return r[0]=q,r[1]=N,r[2]=Y,r[3]=0,r[4]=L,r[5]=X,r[6]=rr,r[7]=0,r[8]=er,r[9]=Wr,r[10]=Br,r[11]=0,r[12]=n[0]+S-(q*S+L*C+er*$),r[13]=n[1]+C-(N*S+X*C+Wr*$),r[14]=n[2]+$-(Y*S+rr*C+Br*$),r[15]=1,r}function _1(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=n+n,h=t+t,c=i+i,l=n*s,f=t*s,o=t*h,v=i*s,M=i*h,p=i*c,x=a*s,y=a*h,g=a*c;return r[0]=1-o-p,r[1]=f+g,r[2]=v-y,r[3]=0,r[4]=f-g,r[5]=1-l-p,r[6]=M+x,r[7]=0,r[8]=v+y,r[9]=M-x,r[10]=1-l-o,r[11]=0,r[12]=0,r[13]=0,r[14]=0,r[15]=1,r}function E1(r,e,n,t,i,a,s){var h=1/(n-e),c=1/(i-t),l=1/(a-s);return r[0]=a*2*h,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a*2*c,r[6]=0,r[7]=0,r[8]=(n+e)*h,r[9]=(i+t)*c,r[10]=(s+a)*l,r[11]=-1,r[12]=0,r[13]=0,r[14]=s*a*2*l,r[15]=0,r}function dist_Re(r,e,n,t,i){var a=1/Math.tan(e/2),s;return r[0]=a/n,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i!=null&&i!==1/0?(s=1/(t-i),r[10]=(i+t)*s,r[14]=2*i*t*s):(r[10]=-1,r[14]=-2*t),r}var R1=dist_Re,dist_Oe=_.perspective=R1;function O1(r,e,n,t,i){var a=1/Math.tan(e/2),s;return r[0]=a/n,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=a,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[11]=-1,r[12]=0,r[13]=0,r[15]=0,i!=null&&i!==1/0?(s=1/(t-i),r[10]=i*s,r[14]=i*t*s):(r[10]=-1,r[14]=-t),r}function A1(r,e,n,t){var i=Math.tan(e.upDegrees*Math.PI/180),a=Math.tan(e.downDegrees*Math.PI/180),s=Math.tan(e.leftDegrees*Math.PI/180),h=Math.tan(e.rightDegrees*Math.PI/180),c=2/(s+h),l=2/(i+a);return r[0]=c,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=l,r[6]=0,r[7]=0,r[8]=-((s-h)*c*.5),r[9]=(i-a)*l*.5,r[10]=t/(n-t),r[11]=-1,r[12]=0,r[13]=0,r[14]=t*n/(n-t),r[15]=0,r}function dist_Ae(r,e,n,t,i,a,s){var h=1/(e-n),c=1/(t-i),l=1/(a-s);return r[0]=-2*h,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=-2*c,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=2*l,r[11]=0,r[12]=(e+n)*h,r[13]=(i+t)*c,r[14]=(s+a)*l,r[15]=1,r}var P1=dist_Ae,dist_Pe=_.ortho=P1;function L1(r,e,n,t,i,a,s){var h=1/(e-n),c=1/(t-i),l=1/(a-s);return r[0]=-2*h,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=-2*c,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=l,r[11]=0,r[12]=(e+n)*h,r[13]=(i+t)*c,r[14]=a*l,r[15]=1,r}function w1(r,e,n,t){var i,a,s,h,c,l,f,o,v,M,p=e[0],x=e[1],y=e[2],g=t[0],R=t[1],m=t[2],d=n[0],P=n[1],A=n[2];return Math.abs(p-d)<dist_z.EPSILON&&Math.abs(x-P)<dist_z.EPSILON&&Math.abs(y-A)<dist_z.EPSILON?dist_ue(r):(f=p-d,o=x-P,v=y-A,M=1/Math.hypot(f,o,v),f*=M,o*=M,v*=M,i=R*v-m*o,a=m*f-g*v,s=g*o-R*f,M=Math.hypot(i,a,s),M?(M=1/M,i*=M,a*=M,s*=M):(i=0,a=0,s=0),h=o*s-v*a,c=v*i-f*s,l=f*a-o*i,M=Math.hypot(h,c,l),M?(M=1/M,h*=M,c*=M,l*=M):(h=0,c=0,l=0),r[0]=i,r[1]=h,r[2]=f,r[3]=0,r[4]=a,r[5]=c,r[6]=o,r[7]=0,r[8]=s,r[9]=l,r[10]=v,r[11]=0,r[12]=-(i*p+a*x+s*y),r[13]=-(h*p+c*x+l*y),r[14]=-(f*p+o*x+v*y),r[15]=1,r)}function $1(r,e,n,t){var i=e[0],a=e[1],s=e[2],h=t[0],c=t[1],l=t[2],f=i-n[0],o=a-n[1],v=s-n[2],M=f*f+o*o+v*v;M>0&&(M=1/Math.sqrt(M),f*=M,o*=M,v*=M);var p=c*v-l*o,x=l*f-h*v,y=h*o-c*f;return M=p*p+x*x+y*y,M>0&&(M=1/Math.sqrt(M),p*=M,x*=M,y*=M),r[0]=p,r[1]=x,r[2]=y,r[3]=0,r[4]=o*y-v*x,r[5]=v*p-f*y,r[6]=f*x-o*p,r[7]=0,r[8]=f,r[9]=o,r[10]=v,r[11]=0,r[12]=i,r[13]=a,r[14]=s,r[15]=1,r}function z1(r){return"mat4("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+", "+r[4]+", "+r[5]+", "+r[6]+", "+r[7]+", "+r[8]+", "+r[9]+", "+r[10]+", "+r[11]+", "+r[12]+", "+r[13]+", "+r[14]+", "+r[15]+")"}function S1(r){return Math.hypot(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11],r[12],r[13],r[14],r[15])}function C1(r,e,n){return r[0]=e[0]+n[0],r[1]=e[1]+n[1],r[2]=e[2]+n[2],r[3]=e[3]+n[3],r[4]=e[4]+n[4],r[5]=e[5]+n[5],r[6]=e[6]+n[6],r[7]=e[7]+n[7],r[8]=e[8]+n[8],r[9]=e[9]+n[9],r[10]=e[10]+n[10],r[11]=e[11]+n[11],r[12]=e[12]+n[12],r[13]=e[13]+n[13],r[14]=e[14]+n[14],r[15]=e[15]+n[15],r}function dist_Le(r,e,n){return r[0]=e[0]-n[0],r[1]=e[1]-n[1],r[2]=e[2]-n[2],r[3]=e[3]-n[3],r[4]=e[4]-n[4],r[5]=e[5]-n[5],r[6]=e[6]-n[6],r[7]=e[7]-n[7],r[8]=e[8]-n[8],r[9]=e[9]-n[9],r[10]=e[10]-n[10],r[11]=e[11]-n[11],r[12]=e[12]-n[12],r[13]=e[13]-n[13],r[14]=e[14]-n[14],r[15]=e[15]-n[15],r}function N1(r,e,n){return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r[4]=e[4]*n,r[5]=e[5]*n,r[6]=e[6]*n,r[7]=e[7]*n,r[8]=e[8]*n,r[9]=e[9]*n,r[10]=e[10]*n,r[11]=e[11]*n,r[12]=e[12]*n,r[13]=e[13]*n,r[14]=e[14]*n,r[15]=e[15]*n,r}function F1(r,e,n,t){return r[0]=e[0]+n[0]*t,r[1]=e[1]+n[1]*t,r[2]=e[2]+n[2]*t,r[3]=e[3]+n[3]*t,r[4]=e[4]+n[4]*t,r[5]=e[5]+n[5]*t,r[6]=e[6]+n[6]*t,r[7]=e[7]+n[7]*t,r[8]=e[8]+n[8]*t,r[9]=e[9]+n[9]*t,r[10]=e[10]+n[10]*t,r[11]=e[11]+n[11]*t,r[12]=e[12]+n[12]*t,r[13]=e[13]+n[13]*t,r[14]=e[14]+n[14]*t,r[15]=e[15]+n[15]*t,r}function q1(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&r[5]===e[5]&&r[6]===e[6]&&r[7]===e[7]&&r[8]===e[8]&&r[9]===e[9]&&r[10]===e[10]&&r[11]===e[11]&&r[12]===e[12]&&r[13]===e[13]&&r[14]===e[14]&&r[15]===e[15]}function Y1(r,e){var n=r[0],t=r[1],i=r[2],a=r[3],s=r[4],h=r[5],c=r[6],l=r[7],f=r[8],o=r[9],v=r[10],M=r[11],p=r[12],x=r[13],y=r[14],g=r[15],R=e[0],m=e[1],d=e[2],P=e[3],A=e[4],F=e[5],S=e[6],C=e[7],$=e[8],q=e[9],N=e[10],Y=e[11],L=e[12],X=e[13],rr=e[14],er=e[15];return Math.abs(n-R)<=dist_z.EPSILON*Math.max(1,Math.abs(n),Math.abs(R))&&Math.abs(t-m)<=dist_z.EPSILON*Math.max(1,Math.abs(t),Math.abs(m))&&Math.abs(i-d)<=dist_z.EPSILON*Math.max(1,Math.abs(i),Math.abs(d))&&Math.abs(a-P)<=dist_z.EPSILON*Math.max(1,Math.abs(a),Math.abs(P))&&Math.abs(s-A)<=dist_z.EPSILON*Math.max(1,Math.abs(s),Math.abs(A))&&Math.abs(h-F)<=dist_z.EPSILON*Math.max(1,Math.abs(h),Math.abs(F))&&Math.abs(c-S)<=dist_z.EPSILON*Math.max(1,Math.abs(c),Math.abs(S))&&Math.abs(l-C)<=dist_z.EPSILON*Math.max(1,Math.abs(l),Math.abs(C))&&Math.abs(f-$)<=dist_z.EPSILON*Math.max(1,Math.abs(f),Math.abs($))&&Math.abs(o-q)<=dist_z.EPSILON*Math.max(1,Math.abs(o),Math.abs(q))&&Math.abs(v-N)<=dist_z.EPSILON*Math.max(1,Math.abs(v),Math.abs(N))&&Math.abs(M-Y)<=dist_z.EPSILON*Math.max(1,Math.abs(M),Math.abs(Y))&&Math.abs(p-L)<=dist_z.EPSILON*Math.max(1,Math.abs(p),Math.abs(L))&&Math.abs(x-X)<=dist_z.EPSILON*Math.max(1,Math.abs(x),Math.abs(X))&&Math.abs(y-rr)<=dist_z.EPSILON*Math.max(1,Math.abs(y),Math.abs(rr))&&Math.abs(g-er)<=dist_z.EPSILON*Math.max(1,Math.abs(g),Math.abs(er))}var k1=dist_Te;_.mul=k1;var b1=dist_Le;_.sub=b1;var dist_O={};function xr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?xr=function(n){return typeof n}:xr=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},xr(r)}Object.defineProperty(dist_O,"__esModule",{value:!0}),dist_O.create=dist_$e,dist_O.clone=Z1,dist_O.fromValues=D1,dist_O.copy=V1,dist_O.set=X1,dist_O.add=I1,dist_O.subtract=dist_ze,dist_O.multiply=dist_Se,dist_O.divide=dist_Ce,dist_O.ceil=U1,dist_O.floor=K1,dist_O.min=G1,dist_O.max=H1,dist_O.round=Q1,dist_O.scale=J1,dist_O.scaleAndAdd=j1,dist_O.distance=dist_Ne,dist_O.squaredDistance=dist_Fe,dist_O.length=dist_qe,dist_O.squaredLength=dist_Ye,dist_O.negate=ra,dist_O.inverse=ea,dist_O.normalize=na,dist_O.dot=ta,dist_O.cross=ia,dist_O.lerp=sa,dist_O.random=ha;var W1=dist_O.transformMat4=ca;dist_O.transformQuat=la,dist_O.zero=fa,dist_O.str=va,dist_O.exactEquals=oa,dist_O.equals=Ma,dist_O.forEach=dist_O.sqrLen=dist_O.len=dist_O.sqrDist=dist_O.dist=dist_O.div=dist_O.mul=dist_O.sub=void 0;var D=B1(W);function dist_we(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,n=new WeakMap;return(dist_we=function(i){return i?n:e})(r)}function B1(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||xr(r)!=="object"&&typeof r!="function")return{default:r};var n=dist_we(e);if(n&&n.has(r))return n.get(r);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(t,a,s):t[a]=r[a]}return t.default=r,n&&n.set(r,t),t}function dist_$e(){var r=new D.ARRAY_TYPE(4);return D.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r}function Z1(r){var e=new D.ARRAY_TYPE(4);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e}function D1(r,e,n,t){var i=new D.ARRAY_TYPE(4);return i[0]=r,i[1]=e,i[2]=n,i[3]=t,i}function V1(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r}function X1(r,e,n,t,i){return r[0]=e,r[1]=n,r[2]=t,r[3]=i,r}function I1(r,e,n){return r[0]=e[0]+n[0],r[1]=e[1]+n[1],r[2]=e[2]+n[2],r[3]=e[3]+n[3],r}function dist_ze(r,e,n){return r[0]=e[0]-n[0],r[1]=e[1]-n[1],r[2]=e[2]-n[2],r[3]=e[3]-n[3],r}function dist_Se(r,e,n){return r[0]=e[0]*n[0],r[1]=e[1]*n[1],r[2]=e[2]*n[2],r[3]=e[3]*n[3],r}function dist_Ce(r,e,n){return r[0]=e[0]/n[0],r[1]=e[1]/n[1],r[2]=e[2]/n[2],r[3]=e[3]/n[3],r}function U1(r,e){return r[0]=Math.ceil(e[0]),r[1]=Math.ceil(e[1]),r[2]=Math.ceil(e[2]),r[3]=Math.ceil(e[3]),r}function K1(r,e){return r[0]=Math.floor(e[0]),r[1]=Math.floor(e[1]),r[2]=Math.floor(e[2]),r[3]=Math.floor(e[3]),r}function G1(r,e,n){return r[0]=Math.min(e[0],n[0]),r[1]=Math.min(e[1],n[1]),r[2]=Math.min(e[2],n[2]),r[3]=Math.min(e[3],n[3]),r}function H1(r,e,n){return r[0]=Math.max(e[0],n[0]),r[1]=Math.max(e[1],n[1]),r[2]=Math.max(e[2],n[2]),r[3]=Math.max(e[3],n[3]),r}function Q1(r,e){return r[0]=Math.round(e[0]),r[1]=Math.round(e[1]),r[2]=Math.round(e[2]),r[3]=Math.round(e[3]),r}function J1(r,e,n){return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r}function j1(r,e,n,t){return r[0]=e[0]+n[0]*t,r[1]=e[1]+n[1]*t,r[2]=e[2]+n[2]*t,r[3]=e[3]+n[3]*t,r}function dist_Ne(r,e){var n=e[0]-r[0],t=e[1]-r[1],i=e[2]-r[2],a=e[3]-r[3];return Math.hypot(n,t,i,a)}function dist_Fe(r,e){var n=e[0]-r[0],t=e[1]-r[1],i=e[2]-r[2],a=e[3]-r[3];return n*n+t*t+i*i+a*a}function dist_qe(r){var e=r[0],n=r[1],t=r[2],i=r[3];return Math.hypot(e,n,t,i)}function dist_Ye(r){var e=r[0],n=r[1],t=r[2],i=r[3];return e*e+n*n+t*t+i*i}function ra(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r[3]=-e[3],r}function ea(r,e){return r[0]=1/e[0],r[1]=1/e[1],r[2]=1/e[2],r[3]=1/e[3],r}function na(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=n*n+t*t+i*i+a*a;return s>0&&(s=1/Math.sqrt(s)),r[0]=n*s,r[1]=t*s,r[2]=i*s,r[3]=a*s,r}function ta(r,e){return r[0]*e[0]+r[1]*e[1]+r[2]*e[2]+r[3]*e[3]}function ia(r,e,n,t){var i=n[0]*t[1]-n[1]*t[0],a=n[0]*t[2]-n[2]*t[0],s=n[0]*t[3]-n[3]*t[0],h=n[1]*t[2]-n[2]*t[1],c=n[1]*t[3]-n[3]*t[1],l=n[2]*t[3]-n[3]*t[2],f=e[0],o=e[1],v=e[2],M=e[3];return r[0]=o*l-v*c+M*h,r[1]=-(f*l)+v*s-M*a,r[2]=f*c-o*s+M*i,r[3]=-(f*h)+o*a-v*i,r}function sa(r,e,n,t){var i=e[0],a=e[1],s=e[2],h=e[3];return r[0]=i+t*(n[0]-i),r[1]=a+t*(n[1]-a),r[2]=s+t*(n[2]-s),r[3]=h+t*(n[3]-h),r}function ha(r,e){e=e||1;var n,t,i,a,s,h;do n=D.RANDOM()*2-1,t=D.RANDOM()*2-1,s=n*n+t*t;while(s>=1);do i=D.RANDOM()*2-1,a=D.RANDOM()*2-1,h=i*i+a*a;while(h>=1);var c=Math.sqrt((1-s)/h);return r[0]=e*n,r[1]=e*t,r[2]=e*i*c,r[3]=e*a*c,r}function ca(r,e,n){var t=e[0],i=e[1],a=e[2],s=e[3];return r[0]=n[0]*t+n[4]*i+n[8]*a+n[12]*s,r[1]=n[1]*t+n[5]*i+n[9]*a+n[13]*s,r[2]=n[2]*t+n[6]*i+n[10]*a+n[14]*s,r[3]=n[3]*t+n[7]*i+n[11]*a+n[15]*s,r}function la(r,e,n){var t=e[0],i=e[1],a=e[2],s=n[0],h=n[1],c=n[2],l=n[3],f=l*t+h*a-c*i,o=l*i+c*t-s*a,v=l*a+s*i-h*t,M=-s*t-h*i-c*a;return r[0]=f*l+M*-s+o*-c-v*-h,r[1]=o*l+M*-h+v*-s-f*-c,r[2]=v*l+M*-c+f*-h-o*-s,r[3]=e[3],r}function fa(r){return r[0]=0,r[1]=0,r[2]=0,r[3]=0,r}function va(r){return"vec4("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+")"}function oa(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]}function Ma(r,e){var n=r[0],t=r[1],i=r[2],a=r[3],s=e[0],h=e[1],c=e[2],l=e[3];return Math.abs(n-s)<=D.EPSILON*Math.max(1,Math.abs(n),Math.abs(s))&&Math.abs(t-h)<=D.EPSILON*Math.max(1,Math.abs(t),Math.abs(h))&&Math.abs(i-c)<=D.EPSILON*Math.max(1,Math.abs(i),Math.abs(c))&&Math.abs(a-l)<=D.EPSILON*Math.max(1,Math.abs(a),Math.abs(l))}var pa=dist_ze;dist_O.sub=pa;var ya=dist_Se;dist_O.mul=ya;var xa=dist_Ce;dist_O.div=xa;var ma=dist_Ne;dist_O.dist=ma;var ga=dist_Fe;dist_O.sqrDist=ga;var da=dist_qe;dist_O.len=da;var ua=dist_Ye;dist_O.sqrLen=ua;var Ta=function(){var r=dist_$e();return function(e,n,t,i,a,s){var h,c;for(n||(n=4),t||(t=0),i?c=Math.min(i*n+t,e.length):c=e.length,h=t;h<c;h+=n)r[0]=e[h],r[1]=e[h+1],r[2]=e[h+2],r[3]=e[h+3],a(r,r,s),e[h]=r[0],e[h+1]=r[1],e[h+2]=r[2],e[h+3]=r[3];return e}}();dist_O.forEach=Ta;var Sr;(function(r){r[r.COL0ROW0=0]="COL0ROW0",r[r.COL0ROW1=1]="COL0ROW1",r[r.COL0ROW2=2]="COL0ROW2",r[r.COL0ROW3=3]="COL0ROW3",r[r.COL1ROW0=4]="COL1ROW0",r[r.COL1ROW1=5]="COL1ROW1",r[r.COL1ROW2=6]="COL1ROW2",r[r.COL1ROW3=7]="COL1ROW3",r[r.COL2ROW0=8]="COL2ROW0",r[r.COL2ROW1=9]="COL2ROW1",r[r.COL2ROW2=10]="COL2ROW2",r[r.COL2ROW3=11]="COL2ROW3",r[r.COL3ROW0=12]="COL3ROW0",r[r.COL3ROW1=13]="COL3ROW1",r[r.COL3ROW2=14]="COL3ROW2",r[r.COL3ROW3=15]="COL3ROW3"})(Sr||(Sr={}));const _a=45*Math.PI/180,Ea=1,Cr=.1,Nr=500,Ra=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);class ar extends ai{static get IDENTITY(){return Aa()}static get ZERO(){return Oa()}get ELEMENTS(){return 16}get RANK(){return 4}get INDICES(){return Sr}constructor(e){super(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),arguments.length===1&&Array.isArray(e)?this.copy(e):this.identity()}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this[4]=e[4],this[5]=e[5],this[6]=e[6],this[7]=e[7],this[8]=e[8],this[9]=e[9],this[10]=e[10],this[11]=e[11],this[12]=e[12],this[13]=e[13],this[14]=e[14],this[15]=e[15],this.check()}set(e,n,t,i,a,s,h,c,l,f,o,v,M,p,x,y){return this[0]=e,this[1]=n,this[2]=t,this[3]=i,this[4]=a,this[5]=s,this[6]=h,this[7]=c,this[8]=l,this[9]=f,this[10]=o,this[11]=v,this[12]=M,this[13]=p,this[14]=x,this[15]=y,this.check()}setRowMajor(e,n,t,i,a,s,h,c,l,f,o,v,M,p,x,y){return this[0]=e,this[1]=a,this[2]=l,this[3]=M,this[4]=n,this[5]=s,this[6]=f,this[7]=p,this[8]=t,this[9]=h,this[10]=o,this[11]=x,this[12]=i,this[13]=c,this[14]=v,this[15]=y,this.check()}toRowMajor(e){return e[0]=this[0],e[1]=this[4],e[2]=this[8],e[3]=this[12],e[4]=this[1],e[5]=this[5],e[6]=this[9],e[7]=this[13],e[8]=this[2],e[9]=this[6],e[10]=this[10],e[11]=this[14],e[12]=this[3],e[13]=this[7],e[14]=this[11],e[15]=this[15],e}identity(){return this.copy(Ra)}fromObject(e){return this.check()}fromQuaternion(e){return Ii(this,e),this.check()}frustum(e){const{left:n,right:t,bottom:i,top:a,near:s=Cr,far:h=Nr}=e;return h===1/0?Pa(this,n,t,i,a,s):Ui(this,n,t,i,a,s,h),this.check()}lookAt(e){const{eye:n,center:t=[0,0,0],up:i=[0,1,0]}=e;return Ki(this,n,t,i),this.check()}ortho(e){const{left:n,right:t,bottom:i,top:a,near:s=Cr,far:h=Nr}=e;return dist_Pe(this,n,t,i,a,s,h),this.check()}orthographic(e){const{fovy:n=_a,aspect:t=Ea,focalDistance:i=1,near:a=Cr,far:s=Nr}=e;dist_ke(n);const h=n/2,c=i*Math.tan(h),l=c*t;return this.ortho({left:-l,right:l,bottom:-c,top:c,near:a,far:s})}perspective(e){const{fovy:n=45*Math.PI/180,aspect:t=1,near:i=.1,far:a=500}=e;return dist_ke(n),dist_Oe(this,n,t,i,a),this.check()}determinant(){return bi(this)}getScale(e=[-0,-0,-0]){return e[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),e[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),e[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),e}getTranslation(e=[-0,-0,-0]){return e[0]=this[12],e[1]=this[13],e[2]=this[14],e}getRotation(e,n){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],n=n||[-0,-0,-0];const t=this.getScale(n),i=1/t[0],a=1/t[1],s=1/t[2];return e[0]=this[0]*i,e[1]=this[1]*a,e[2]=this[2]*s,e[3]=0,e[4]=this[4]*i,e[5]=this[5]*a,e[6]=this[6]*s,e[7]=0,e[8]=this[8]*i,e[9]=this[9]*a,e[10]=this[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}getRotationMatrix3(e,n){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0],n=n||[-0,-0,-0];const t=this.getScale(n),i=1/t[0],a=1/t[1],s=1/t[2];return e[0]=this[0]*i,e[1]=this[1]*a,e[2]=this[2]*s,e[3]=this[4]*i,e[4]=this[5]*a,e[5]=this[6]*s,e[6]=this[8]*i,e[7]=this[9]*a,e[8]=this[10]*s,e}transpose(){return Yi(this,this),this.check()}invert(){return ki(this,this),this.check()}multiplyLeft(e){return dist_ge(this,e,this),this.check()}multiplyRight(e){return dist_ge(this,this,e),this.check()}rotateX(e){return Di(this,this,e),this.check()}rotateY(e){return Vi(this,this,e),this.check()}rotateZ(e){return Xi(this,this,e),this.check()}rotateXYZ(e){return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2])}rotateAxis(e,n){return Zi(this,this,e,n),this.check()}scale(e){return Bi(this,this,Array.isArray(e)?e:[e,e,e]),this.check()}translate(e){return Wi(this,this,e),this.check()}transform(e,n){return e.length===4?(n=W1(n||[-0,-0,-0,-0],e,this),zr(n,4),n):this.transformAsPoint(e,n)}transformAsPoint(e,n){const{length:t}=e;let i;switch(t){case 2:i=zn(n||[-0,-0],e,this);break;case 3:i=dist_gt(n||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return zr(i,e.length),i}transformAsVector(e,n){let t;switch(e.length){case 2:t=dist_xt(n||[-0,-0],e,this);break;case 3:t=dist_mt(n||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return zr(t,e.length),t}transformPoint(e,n){return this.transformAsPoint(e,n)}transformVector(e,n){return this.transformAsPoint(e,n)}transformDirection(e,n){return this.transformAsVector(e,n)}makeRotationX(e){return this.identity().rotateX(e)}makeTranslation(e,n,t){return this.identity().translate([e,n,t])}}let mr,gr;function Oa(){return mr||(mr=new ar([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Object.freeze(mr)),mr}function Aa(){return gr||(gr=new ar,Object.freeze(gr)),gr}function dist_ke(r){if(r>Math.PI*2)throw Error("expected radians")}function Pa(r,e,n,t,i,a){const s=2*a/(n-e),h=2*a/(i-t),c=(n+e)/(n-e),l=(i+t)/(i-t),f=-1,o=-1,v=-2*a;return r[0]=s,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=h,r[6]=0,r[7]=0,r[8]=c,r[9]=l,r[10]=f,r[11]=o,r[12]=0,r[13]=0,r[14]=v,r[15]=0,r}var u={};function dr(r){return typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?dr=function(n){return typeof n}:dr=function(n){return n&&typeof Symbol=="function"&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},dr(r)}Object.defineProperty(u,"__esModule",{value:!0}),u.create=Fr,u.identity=wa,u.setAxisAngle=dist_We,u.getAxisAngle=$a,u.getAngle=za,u.multiply=dist_Be,u.rotateX=Sa,u.rotateY=Ca,u.rotateZ=Na,u.calculateW=Fa,u.exp=dist_Ze,u.ln=dist_De,u.pow=qa,u.slerp=Tr,u.random=Ya,u.invert=ka,u.conjugate=ba,u.fromMat3=dist_Ve,u.fromEuler=Wa,u.str=Ba,u.setAxes=u.sqlerp=u.rotationTo=u.equals=u.exactEquals=u.normalize=u.sqrLen=u.squaredLength=u.len=u.length=u.lerp=u.dot=u.scale=u.mul=u.add=u.set=u.copy=u.fromValues=u.clone=void 0;var dist_J=ur(W),La=ur(w),dist_K=ur(T),dist_Z=ur(dist_O);function dist_be(r){if(typeof WeakMap!="function")return null;var e=new WeakMap,n=new WeakMap;return(dist_be=function(i){return i?n:e})(r)}function ur(r,e){if(!e&&r&&r.__esModule)return r;if(r===null||dr(r)!=="object"&&typeof r!="function")return{default:r};var n=dist_be(e);if(n&&n.has(r))return n.get(r);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if(a!=="default"&&Object.prototype.hasOwnProperty.call(r,a)){var s=i?Object.getOwnPropertyDescriptor(r,a):null;s&&(s.get||s.set)?Object.defineProperty(t,a,s):t[a]=r[a]}return t.default=r,n&&n.set(r,t),t}function Fr(){var r=new dist_J.ARRAY_TYPE(4);return dist_J.ARRAY_TYPE!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r[3]=1,r}function wa(r){return r[0]=0,r[1]=0,r[2]=0,r[3]=1,r}function dist_We(r,e,n){n=n*.5;var t=Math.sin(n);return r[0]=t*e[0],r[1]=t*e[1],r[2]=t*e[2],r[3]=Math.cos(n),r}function $a(r,e){var n=Math.acos(e[3])*2,t=Math.sin(n/2);return t>dist_J.EPSILON?(r[0]=e[0]/t,r[1]=e[1]/t,r[2]=e[2]/t):(r[0]=1,r[1]=0,r[2]=0),n}function za(r,e){var n=dist_Ie(r,e);return Math.acos(2*n*n-1)}function dist_Be(r,e,n){var t=e[0],i=e[1],a=e[2],s=e[3],h=n[0],c=n[1],l=n[2],f=n[3];return r[0]=t*f+s*h+i*l-a*c,r[1]=i*f+s*c+a*h-t*l,r[2]=a*f+s*l+t*c-i*h,r[3]=s*f-t*h-i*c-a*l,r}function Sa(r,e,n){n*=.5;var t=e[0],i=e[1],a=e[2],s=e[3],h=Math.sin(n),c=Math.cos(n);return r[0]=t*c+s*h,r[1]=i*c+a*h,r[2]=a*c-i*h,r[3]=s*c-t*h,r}function Ca(r,e,n){n*=.5;var t=e[0],i=e[1],a=e[2],s=e[3],h=Math.sin(n),c=Math.cos(n);return r[0]=t*c-a*h,r[1]=i*c+s*h,r[2]=a*c+t*h,r[3]=s*c-i*h,r}function Na(r,e,n){n*=.5;var t=e[0],i=e[1],a=e[2],s=e[3],h=Math.sin(n),c=Math.cos(n);return r[0]=t*c+i*h,r[1]=i*c-t*h,r[2]=a*c+s*h,r[3]=s*c-a*h,r}function Fa(r,e){var n=e[0],t=e[1],i=e[2];return r[0]=n,r[1]=t,r[2]=i,r[3]=Math.sqrt(Math.abs(1-n*n-t*t-i*i)),r}function dist_Ze(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=Math.sqrt(n*n+t*t+i*i),h=Math.exp(a),c=s>0?h*Math.sin(s)/s:0;return r[0]=n*c,r[1]=t*c,r[2]=i*c,r[3]=h*Math.cos(s),r}function dist_De(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=Math.sqrt(n*n+t*t+i*i),h=s>0?Math.atan2(s,a)/s:0;return r[0]=n*h,r[1]=t*h,r[2]=i*h,r[3]=.5*Math.log(n*n+t*t+i*i+a*a),r}function qa(r,e,n){return dist_De(r,e),dist_Xe(r,r,n),dist_Ze(r,r),r}function Tr(r,e,n,t){var i=e[0],a=e[1],s=e[2],h=e[3],c=n[0],l=n[1],f=n[2],o=n[3],v,M,p,x,y;return M=i*c+a*l+s*f+h*o,M<0&&(M=-M,c=-c,l=-l,f=-f,o=-o),1-M>dist_J.EPSILON?(v=Math.acos(M),p=Math.sin(v),x=Math.sin((1-t)*v)/p,y=Math.sin(t*v)/p):(x=1-t,y=t),r[0]=x*i+y*c,r[1]=x*a+y*l,r[2]=x*s+y*f,r[3]=x*h+y*o,r}function Ya(r){var e=dist_J.RANDOM(),n=dist_J.RANDOM(),t=dist_J.RANDOM(),i=Math.sqrt(1-e),a=Math.sqrt(e);return r[0]=i*Math.sin(2*Math.PI*n),r[1]=i*Math.cos(2*Math.PI*n),r[2]=a*Math.sin(2*Math.PI*t),r[3]=a*Math.cos(2*Math.PI*t),r}function ka(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],s=n*n+t*t+i*i+a*a,h=s?1/s:0;return r[0]=-n*h,r[1]=-t*h,r[2]=-i*h,r[3]=a*h,r}function ba(r,e){return r[0]=-e[0],r[1]=-e[1],r[2]=-e[2],r[3]=e[3],r}function dist_Ve(r,e){var n=e[0]+e[4]+e[8],t;if(n>0)t=Math.sqrt(n+1),r[3]=.5*t,t=.5/t,r[0]=(e[5]-e[7])*t,r[1]=(e[6]-e[2])*t,r[2]=(e[1]-e[3])*t;else{var i=0;e[4]>e[0]&&(i=1),e[8]>e[i*3+i]&&(i=2);var a=(i+1)%3,s=(i+2)%3;t=Math.sqrt(e[i*3+i]-e[a*3+a]-e[s*3+s]+1),r[i]=.5*t,t=.5/t,r[3]=(e[a*3+s]-e[s*3+a])*t,r[a]=(e[a*3+i]+e[i*3+a])*t,r[s]=(e[s*3+i]+e[i*3+s])*t}return r}function Wa(r,e,n,t){var i=.5*Math.PI/180;e*=i,n*=i,t*=i;var a=Math.sin(e),s=Math.cos(e),h=Math.sin(n),c=Math.cos(n),l=Math.sin(t),f=Math.cos(t);return r[0]=a*c*f-s*h*l,r[1]=s*h*f+a*c*l,r[2]=s*c*l-a*h*f,r[3]=s*c*f+a*h*l,r}function Ba(r){return"quat("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+")"}var Za=dist_Z.clone;u.clone=Za;var Da=dist_Z.fromValues;u.fromValues=Da;var Va=dist_Z.copy;u.copy=Va;var Xa=dist_Z.set;u.set=Xa;var Ia=dist_Z.add;u.add=Ia;var Ua=dist_Be;u.mul=Ua;var dist_Xe=dist_Z.scale;u.scale=dist_Xe;var dist_Ie=dist_Z.dot;u.dot=dist_Ie;var Ka=dist_Z.lerp;u.lerp=Ka;var dist_Ue=dist_Z.length;u.length=dist_Ue;var Ga=dist_Ue;u.len=Ga;var dist_Ke=dist_Z.squaredLength;u.squaredLength=dist_Ke;var Ha=dist_Ke;u.sqrLen=Ha;var qr=dist_Z.normalize;u.normalize=qr;var Qa=dist_Z.exactEquals;u.exactEquals=Qa;var Ja=dist_Z.equals;u.equals=Ja;var ja=function(){var r=dist_K.create(),e=dist_K.fromValues(1,0,0),n=dist_K.fromValues(0,1,0);return function(t,i,a){var s=dist_K.dot(i,a);return s<-.999999?(dist_K.cross(r,e,i),dist_K.len(r)<1e-6&&dist_K.cross(r,n,i),dist_K.normalize(r,r),dist_We(t,r,Math.PI),t):s>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(dist_K.cross(r,i,a),t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=1+s,qr(t,t))}}();u.rotationTo=ja;var r0=function(){var r=Fr(),e=Fr();return function(n,t,i,a,s,h){return Tr(r,t,s,h),Tr(e,i,a,h),Tr(n,r,e,2*h*(1-h)),n}}();u.sqlerp=r0;var e0=function(){var r=La.create();return function(e,n,t,i){return r[0]=t[0],r[3]=t[1],r[6]=t[2],r[1]=i[0],r[4]=i[1],r[7]=i[2],r[2]=-n[0],r[5]=-n[1],r[8]=-n[2],qr(e,dist_Ve(e,r))}}();u.setAxes=e0;var dist_Ge;(function(r){r[r.ZYX=0]="ZYX",r[r.YXZ=1]="YXZ",r[r.XZY=2]="XZY",r[r.ZXY=3]="ZXY",r[r.YZX=4]="YZX",r[r.XYZ=5]="XYZ"})(dist_Ge||(dist_Ge={}));const dist_b=3.141592653589793,_r=6378245,Er=.006693421622965943,Rr=dist_b*3e3/180;function dist_sr(r,e,n){const t=dist_b/180*e,i=Math.pow(2,n),a=Math.floor((r+180)/360*i),s=Math.floor((1-Math.asinh(Math.tan(t))/dist_b)/2*i);return[a,s]}function dist_He(r,e,n){const t=Math.pow(2,n),i=r/t*360-180,a=Math.atan(Math.sinh(dist_b*(1-2*e/t)))*180/dist_b;return[i,a]}function n0(r,e){let n=dist_je(r-105,e-35),t=rn(r-105,e-35);const i=e/180*dist_b;let a=Math.sin(i);a=1-Er*a*a;const s=Math.sqrt(a);n=n*180/(_r*(1-Er)/(a*s)*dist_b),t=t*180/(_r/s*Math.cos(i)*dist_b);const h=e+n;return{lng:r+t,lat:h}}function dist_Qe(r,e){const n=i0(r,e),t=r*2-n.lng,i=e*2-n.lat;return{lng:t,lat:i}}function dist_Je(r,e){const n=Math.sqrt(r*r+e*e)+2e-5*Math.sin(e*Rr),t=Math.atan2(e,r)+3e-6*Math.cos(r*Rr),i=n*Math.cos(t)+.0065,a=n*Math.sin(t)+.006;return{lng:i,lat:a}}function t0(r,e){const n=r-.0065,t=e-.006,i=Math.sqrt(n*n+t*t)-2e-5*Math.sin(t*Rr),a=Math.atan2(t,n)-3e-6*Math.cos(n*Rr),s=i*Math.cos(a),h=i*Math.sin(a);return{lng:s,lat:h}}function i0(r,e){let n=dist_je(r-105,e-35),t=rn(r-105,e-35);const i=e/180*dist_b;let a=Math.sin(i);a=1-Er*a*a;const s=Math.sqrt(a);n=n*180/(_r*(1-Er)/(a*s)*dist_b),t=t*180/(_r/s*Math.cos(i)*dist_b);const h=e+n;return{lng:r+t,lat:h}}function dist_je(r,e){let n=-100+2*r+3*e+.2*e*e+.1*r*e+.2*Math.sqrt(Math.abs(r));return n+=(20*Math.sin(6*r*dist_b)+20*Math.sin(2*r*dist_b))*2/3,n+=(20*Math.sin(e*dist_b)+40*Math.sin(e/3*dist_b))*2/3,n+=(160*Math.sin(e/12*dist_b)+320*Math.sin(e*dist_b/30))*2/3,n}function rn(r,e){let n=300+r+2*e+.1*r*r+.1*r*e+.1*Math.sqrt(Math.abs(r));return n+=(20*Math.sin(6*r*dist_b)+20*Math.sin(2*r*dist_b))*2/3,n+=(20*Math.sin(r*dist_b)+40*Math.sin(r/3*dist_b))*2/3,n+=(150*Math.sin(r/12*dist_b)+300*Math.sin(r/30*dist_b))*2/3,n}function en(r,e){for(var n in e)e.hasOwnProperty(n)&&(r[n]=e[n]);return r}function a0(r,e){for(var n in e)r[n]=e[n]}function nn(r){return typeof r=="string"}var tn=void 0,Or=null;function dist_V(r,e){isNaN(r)&&(r=Ib(r),r=isNaN(r)?0:r),nn(r)&&(r=parseFloat(r)),isNaN(e)&&(e=Ib(e),e=isNaN(e)?0:e),nn(e)&&(e=parseFloat(e)),this.lng=r,this.lat=e}dist_V.TL=function(r){return r&&180>=r.lng&&-180<=r.lng&&74>=r.lat&&-74<=r.lat},dist_V.prototype.lb=function(r){return r&&this.lat==r.lat&&this.lng==r.lng};function Ar(r,e){this.x=r||0,this.y=e||0,this.x=this.x,this.y=this.y}Ar.prototype.lb=function(r){return r&&r.x==this.x&&r.y==this.y};function Yr(){}Yr.prototype.nh=function(){aa("lngLatToPoint\u65B9\u6CD5\u672A\u5B9E\u73B0")},Yr.prototype.wi=function(){aa("pointToLngLat\u65B9\u6CD5\u672A\u5B9E\u73B0")};function dist_G(){}dist_G.prototype=new Yr,en(dist_G,{$O:637099681e-2,lG:[1289059486e-2,836237787e-2,5591021,348198983e-2,167804312e-2,0],Au:[75,60,45,30,15,0],fP:[[1410526172116255e-23,898305509648872e-20,-1.9939833816331,200.9824383106796,-187.2403703815547,91.6087516669843,-23.38765649603339,2.57121317296198,-.03801003308653,173379812e-1],[-7435856389565537e-24,8983055097726239e-21,-.78625201886289,96.32687599759846,-1.85204757529826,-59.36935905485877,47.40033549296737,-16.50741931063887,2.28786674699375,1026014486e-2],[-3030883460898826e-23,898305509983578e-20,.30071316287616,59.74293618442277,7.357984074871,-25.38371002664745,13.45380521110908,-3.29883767235584,.32710905363475,685681737e-2],[-1981981304930552e-23,8983055099779535e-21,.03278182852591,40.31678527705744,.65659298677277,-4.44255534477492,.85341911805263,.12923347998204,-.04625736007561,448277706e-2],[309191371068437e-23,8983055096812155e-21,6995724062e-14,23.10934304144901,-.00023663490511,-.6321817810242,-.00663494467273,.03430082397953,-.00466043876332,25551644e-1],[2890871144776878e-24,8983055095805407e-21,-3068298e-14,7.47137025468032,-353937994e-14,-.02145144861037,-1234426596e-14,.00010322952773,-323890364e-14,826088.5]],iG:[[-.0015702102444,111320.7020616939,0x60e374c3105a3,-0x24bb4115e2e164,0x5cc55543bb0ae8,-0x7ce070193f3784,0x5e7ca61ddf8150,-0x261a578d8b24d0,0x665d60f3742ca,82.5],[.0008277824516172526,111320.7020463578,6477955746671607e-7,-4082003173641316e-6,1077490566351142e-5,-1517187553151559e-5,1205306533862167e-5,-5124939663577472e-6,9133119359512032e-7,67.5],[.00337398766765,111320.7020202162,4481351045890365e-9,-2339375119931662e-8,7968221547186455e-8,-1159649932797253e-7,9723671115602145e-8,-4366194633752821e-8,8477230501135234e-9,52.5],[.00220636496208,111320.7020209128,51751.86112841131,3796837749470245e-9,992013.7397791013,-122195221711287e-8,1340652697009075e-9,-620943.6990984312,144416.9293806241,37.5],[-.0003441963504368392,111320.7020576856,278.2353980772752,2485758690035394e-9,6070.750963243378,54821.18345352118,9540.606633304236,-2710.55326746645,1405.483844121726,22.5],[-.0003218135878613132,111320.7020701615,.00369383431289,823725.6402795718,.46104986909093,2351.343141331292,1.58060784298199,8.77738589078284,.37238884252424,7.45]],Z1:function(i,e){if(!i||!e)return 0;var n,t,i=this.Fb(i);return i?(n=this.Tk(i.lng),t=this.Tk(i.lat),e=this.Fb(e),e?this.Pe(n,this.Tk(e.lng),t,this.Tk(e.lat)):0):0},Vo:function(r,e){return!r||!e?0:(r.lng=this.JD(r.lng,-180,180),r.lat=this.ND(r.lat,-74,74),e.lng=this.JD(e.lng,-180,180),e.lat=this.ND(e.lat,-74,74),this.Pe(this.Tk(r.lng),this.Tk(e.lng),this.Tk(r.lat),this.Tk(e.lat)))},Fb:function(r){if(r===Or||r===tn)return new dist_V(0,0);var e,n;e=new dist_V(Math.abs(r.lng),Math.abs(r.lat));for(var t=0;t<this.lG.length;t++)if(e.lat>=this.lG[t]){n=this.fP[t];break}return r=this.gK(r,n),r=new dist_V(r.lng.toFixed(6),r.lat.toFixed(6))},Eb:function(r){if(r===Or||r===tn||180<r.lng||-180>r.lng||90<r.lat||-90>r.lat)return new dist_V(0,0);var e,n;r.lng=this.JD(r.lng,-180,180),r.lat=this.ND(r.lat,-74,74),e=new dist_V(r.lng,r.lat);for(var t=0;t<this.Au.length;t++)if(e.lat>=this.Au[t]){n=this.iG[t];break}if(!n){for(t=0;t<this.Au.length;t++)if(e.lat<=-this.Au[t]){n=this.iG[t];break}}return r=this.gK(r,n),r=new dist_V(r.lng.toFixed(2),r.lat.toFixed(2))},gK:function(r,e){if(r&&e){var n=e[0]+e[1]*Math.abs(r.lng),t=Math.abs(r.lat)/e[9],t=e[2]+e[3]*t+e[4]*t*t+e[5]*t*t*t+e[6]*t*t*t*t+e[7]*t*t*t*t*t+e[8]*t*t*t*t*t*t,n=n*(0>r.lng?-1:1),t=t*(0>r.lat?-1:1);return new dist_V(n,t)}},Pe:function(r,e,n,t){return this.$O*Math.acos(Math.sin(n)*Math.sin(t)+Math.cos(n)*Math.cos(t)*Math.cos(e-r))},Tk:function(r){return Math.PI*r/180},Z3:function(r){return 180*r/Math.PI},ND:function(r,e,n){return e!=Or&&(r=Math.max(r,e)),n!=Or&&(r=Math.min(r,n)),r},JD:function(r,e,n){for(;r>n;)r-=n-e;for(;r<e;)r+=n-e;return r}}),en(dist_G.prototype,{Jm:function(r){return dist_G.Eb(r)},nh:function(r){return r=dist_G.Eb(r),new Ar(r.lng,r.lat)},qh:function(r){return dist_G.Fb(r)},wi:function(r){return r=new dist_V(r.x,r.y),dist_G.Fb(r)},fc:function(r,e,n,t,i){if(r)return r=this.Jm(r,i),e=this.Lc(e),new Ar(Math.round((r.lng-n.lng)/e+t.width/2),Math.round((n.lat-r.lat)/e+t.height/2))},zb:function(r,e,n,t,i){if(r)return e=this.Lc(e),this.qh(new dist_V(n.lng+e*(r.x-t.width/2),n.lat-e*(r.y-t.height/2)),i)},Lc:function(r){return Math.pow(2,18-r)}});var kr=dist_G.prototype;a0(kr,{lngLatToPoint:kr.nh,pointToLngLat:kr.wi});let br={Point:dist_V,Pixel:Ar,MercatorProjection:dist_G};class s0{constructor(e,n){this.projection=new br.MercatorProjection,this.levelMax=e,this.levelMin=n}_getRetain(e){return Math.pow(2,e-18)}getResolution(e,n){return Math.pow(2,18-n)*Math.cos(e)}lnglatToPoint(e,n){let t=new br.Point(e,n),i=this.projection.lngLatToPoint(t);return{pointX:i.x,pointY:i.y}}pointToLnglat(e,n){let t=new br.Pixel(e,n),i=this.projection.pointToLngLat(t);return{lng:i.lng,lat:i.lat}}_lngToTileX(e,n){let t=this.lnglatToPoint(e,0);return Math.floor(t.pointX*this._getRetain(n)/256)}_latToTileY(e,n){let t=this.lnglatToPoint(0,e);return Math.floor(t.pointY*this._getRetain(n)/256)}lnglatToTile(e,n,t){let i=this._lngToTileX(e,t),a=this._latToTileY(n,t);return[i,a]}_lngToPixelX(e,n){let t=this._lngToTileX(e,n),i=this.lnglatToPoint(e,0);return Math.floor(i.pointX*this._getRetain(n)-t*256)}_latToPixelY(e,n){let t=this._latToTileY(e,n),i=this.lnglatToPoint(0,e);return Math.floor(i.pointY*this._getRetain(n)-t*256)}lnglatToPixel(e,n,t){let i=this._lngToPixelX(e,t),a=this._latToPixelY(n,t);return{pixelX:i,pixelY:a}}_pixelXToLng(e,n,t){let i=(n*256+e)/this._getRetain(t);return this.pointToLnglat(i,0).lng}_pixelYToLat(e,n,t){let i=(n*256+e)/this._getRetain(t);return this.pointToLnglat(0,i).lat}pixelToLnglat(e,n,t,i,a){let s=(t*256+e)/this._getRetain(a),h=(i*256+n)/this._getRetain(a),c=this.pointToLnglat(s,h);return[c.lng,c.lat]}}Object.freeze=function(r){return r};var h0=/\{ *([\w_-]+) *\}/g;function c0(r,e){return r.replace(h0,function(n,t){let i=e[t];if(i===void 0)throw new Error(`No value provided for variable ${n}`);return typeof i=="function"&&(i=i(e)),i})}class l0{constructor(e,n){if(this.program=null,this.showTiles=[],this.isReadRender=!1,this.isLayerShow=!1,this.tileCache=[],this.gridCache={},this.transformBaidu=new s0,this.maskCache=[],this._projectionMatrix=new ar,this._viewMatrix4=new ar,this._mvpMatrix4=new ar,this.isOrtho=!1,!e)throw new Error("\u8BF7\u4F20\u5165\u5730\u56FE\u5B9E\u4F8B");this.validate(n),this.map=e,this.center=e.getCenter().toArray(),this.options=Object.assign(this.getDefaultGlLayerOptions(),n),this.customCoords=e.customCoords,this.customCoords.lngLatsToCoords([this.center]),this.layer=new AMap.GLCustomLayer({zooms:this.options.zooms,opacity:this.options.opacity,visible:this.options.visible,zIndex:this.options.zIndex,init:t=>{this.gl=t;const i="uniform mat4 u_ProjectionMatrix;uniform mat4 u_ViewMatrix4;uniform mat4 u_MvpMatrix4;uniform bool u_isOrtho;attribute vec2 a_pos;attribute vec2 a_TextCoord;varying vec2 v_TextCoord;void main() {   if(u_isOrtho){     gl_Position = u_MvpMatrix4 * vec4(a_pos,0.0, 1.0);   }else{     gl_Position = u_ProjectionMatrix * u_ViewMatrix4 * vec4(a_pos,0.0, 1.0);   }   v_TextCoord = a_TextCoord;}",a="precision mediump float;uniform sampler2D u_Sampler; varying vec2 v_TextCoord; void main() {   gl_FragColor = texture2D(u_Sampler, v_TextCoord);}",s=t.createShader(t.VERTEX_SHADER);t.shaderSource(s,i),t.compileShader(s);const h=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(h,a),t.compileShader(h),this.program=t.createProgram(),t.attachShader(this.program,s),t.attachShader(this.program,h),t.linkProgram(this.program),this.a_Pos=t.getAttribLocation(this.program,"a_pos"),this.a_TextCoord=t.getAttribLocation(this.program,"a_TextCoord");const c="uniform mat4 u_ProjectionMatrix;uniform mat4 u_ViewMatrix4;uniform mat4 u_MvpMatrix4;uniform bool u_isOrtho;attribute vec2 a_pos;void main() {   if(u_isOrtho){     gl_Position = u_MvpMatrix4 * vec4(a_pos,0.0, 1.0);   }else{     gl_Position = u_ProjectionMatrix * u_ViewMatrix4 * vec4(a_pos,0.0, 1.0);   }}",l="void main() {    gl_FragColor = vec4(0.0, 1.0, 0.0, 0.0);}",f=t.createShader(t.VERTEX_SHADER);t.shaderSource(f,c),t.compileShader(f);const o=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(o,l),t.compileShader(o),this.maskProgram=t.createProgram(),t.attachShader(this.maskProgram,f),t.attachShader(this.maskProgram,o),t.linkProgram(this.maskProgram),this.mask_Pos=t.getAttribLocation(this.maskProgram,"a_pos"),this.options.visible&&(this.isLayerShow=!0),this.mapCallback=()=>{this.isLayerShow&&this.update()},e.on("dragging",this.mapCallback),e.on("moveend",this.mapCallback),e.on("zoomchange",this.mapCallback),e.on("rotatechange",this.mapCallback),this._createMask(this.options.mask),this.update()},render:t=>{if(!this.isReadRender)return;const i=this.options.zooms;if(!(this.map.getZoom()<i[0]||this.map.getZoom()>i[1])){if(this.customCoords.setCenter(this.center),e.getView().type==="3D"){this.isOrtho=!1;const{near:a,far:s,fov:h,up:c,lookAt:l,position:f}=this.customCoords.getCameraParams();this._viewMatrix4.lookAt({eye:f,center:l,up:c}).translate([0,0,this.options.altitude]),this._projectionMatrix.perspective({fovy:h*Math.PI/180,far:s,near:a,aspect:t.drawingBufferWidth/t.drawingBufferHeight})}else{this.isOrtho=!0;const a=this.customCoords.getMVPMatrix();this._mvpMatrix4.copy(a)}this.maskCache.length>0?(t.clearStencil(0),t.clear(t.STENCIL_BUFFER_BIT),t.enable(t.STENCIL_TEST),t.stencilFunc(t.ALWAYS,1,255),t.stencilOp(t.KEEP,t.KEEP,t.REPLACE),this._renderMask(t),t.stencilFunc(t.EQUAL,1,255),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.disable(t.DEPTH_TEST),this._renderTile(t),t.enable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST)):this._renderTile(t)}}}),e.add(this.layer)}_renderMask(e){if(this.maskCache.length){this.customCoords.setCenter(this.center),e.useProgram(this.maskProgram),this.setVertex(e,this.maskProgram);for(const n of this.maskCache)e.bindBuffer(e.ARRAY_BUFFER,n.vertexBuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n.indexBuffer),e.vertexAttribPointer(this.mask_Pos,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(this.mask_Pos),e.drawElements(e.TRIANGLES,n.deviationLength,e.UNSIGNED_INT,0)}}_renderTile(e){var n,t,i,a,s,h;this.customCoords.setCenter(this.center),e.useProgram(this.program),this.setVertex(e,this.program);for(const c of this.showTiles){if(!c.isLoad)continue;e.bindTexture(e.TEXTURE_2D,c.texture),e.activeTexture(e.TEXTURE0),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.MIRRORED_REPEAT);const l=e.getUniformLocation(this.program,"u_Sampler");e.uniform1i(l,0),e.bindBuffer(e.ARRAY_BUFFER,c.buffer),e.vertexAttribPointer(this.a_Pos,(n=c.PosParam)===null||n===void 0?void 0:n.size,e.FLOAT,!1,(t=c.PosParam)===null||t===void 0?void 0:t.stride,(i=c.PosParam)===null||i===void 0?void 0:i.offset),e.vertexAttribPointer(this.a_TextCoord,(a=c.TextCoordParam)===null||a===void 0?void 0:a.size,e.FLOAT,!1,(s=c.TextCoordParam)===null||s===void 0?void 0:s.stride,(h=c.TextCoordParam)===null||h===void 0?void 0:h.offset),e.enableVertexAttribArray(this.a_Pos),e.enableVertexAttribArray(this.a_TextCoord),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.drawArrays(e.TRIANGLE_STRIP,0,4)}}validate(e){if(!e.url)throw new Error("\u8BF7\u4F20\u5165url");if(e.url.includes("{s}")&&(!e.subdomains||e.subdomains.length===0))throw new Error("\u8BF7\u4F20\u5165subdomains")}getDefaultGlLayerOptions(){return{url:"",zooms:[2,18],opacity:1,visible:!0,zIndex:120,proj:"gcj02",tileType:"xyz",debug:!1,cacheSize:512,tileMaxZoom:18,altitude:0}}_createMask(e){if(!e||e.length===0){this.maskCache=[];return}const n=this.getMaskDeep(e);if(n<2||n>4){console.warn("mask\u6570\u636E\u683C\u5F0F\u4E0D\u6B63\u786E");return}n===2?e=[[e]]:n===3&&(e=[e]);for(let t of e){t=this._convertMaskLnglatToCoords(t);const i=hr.exports.flatten(t),a=hr.exports(i.vertices,i.holes,i.dimensions),s=this.gl,h=new Float32Array(i.vertices),c=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,c),s.bufferData(s.ARRAY_BUFFER,h,s.STATIC_DRAW),s.bindBuffer(s.ARRAY_BUFFER,null);const l=s.createBuffer();s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,l),s.bufferData(s.ELEMENT_ARRAY_BUFFER,new Uint32Array(a),s.STATIC_DRAW),s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,null),this.maskCache.push({FSIZE:h.BYTES_PER_ELEMENT,vertexBuffer:c,indexBuffer:l,deviationLength:a.length})}}getMaskDeep(e,n=1){return e.length?typeof e[0]=="number"?n:this.getMaskDeep(e[0],n+1):-1}_convertMaskLnglatToCoords(e){return!e||e.length===0?e:typeof e[0]=="number"?this._convertLnglatToCoords([e[0],e[1]]):e.map(n=>this._convertMaskLnglatToCoords(n))}_convertLnglatToCoords(e){return this.customCoords.setCenter(this.center),this.customCoords.lngLatsToCoords([e])[0]}update(){if(!this.gl)return;this.isReadRender=!1;const e=this.gl,n=this.map,t=n.getCenter();let i=Math.ceil(n.getZoom());i>this.options.tileMaxZoom&&(i=this.options.tileMaxZoom);const a=n.getBounds();let s,h,c,l;if(this.options.tileType==="xyz"?(c=a.getNorthWest().toArray(),l=a.getSouthEast().toArray()):(c=a.getSouthWest().toArray(),l=a.getNorthEast().toArray()),this.options.proj==="wgs84"){const v=dist_Qe(...c),M=dist_Qe(...l);s=dist_sr(v.lng,v.lat,i),h=dist_sr(M.lng,M.lat,i)}else if(this.options.proj==="bd09"){const v=dist_Je(...c),M=dist_Je(...l);s=this.transformBaidu.lnglatToTile(v.lng,v.lat,i),h=this.transformBaidu.lnglatToTile(M.lng,M.lat,i)}else s=dist_sr(c[0],c[1],i),h=dist_sr(l[0],l[1],i);const f=[];for(let v=s[0];v<=h[0];v++)for(let M=s[1];M<=h[1];M++){const p={x:v,y:M,z:i};f.push(p),this.addGridCache(p,0,0),v===h[0]&&this.addGridCache(p,1,0),M===h[1]&&this.addGridCache(p,0,1),v===h[0]&&M===h[1]&&this.addGridCache(p,1,1)}let o;this.options.tileType==="xyz"?o=dist_sr(t.getLng(),t.getLat(),i):o=this.transformBaidu.lnglatToTile(t.getLng(),t.getLat(),i),f.sort((v,M)=>this.tileDistance(v,o)-this.tileDistance(M,o)),this._cancelOutViewImage(f),this._clearShowTile();for(const v of f){const M=this.createTileKey(v),p=this.getTileCache(M);if(p)!p.isLoad&&p.image&&p.imageCanceled&&(p.image.src=p.url,p.imageCanceled=!1),this.showTiles.push(p);else{const x=this.createTile(e,v);this.showTiles.push(x),this.pushTileCache(x)}}this.showTiles.length>0&&this.showTiles.unshift(this.showTiles[0]),this.isReadRender=!0}_cancelOutViewImage(e){this.tileCache.forEach(n=>{e.findIndex(t=>this.createTileKey(t)===n.xyzKey)===-1&&!n.isLoad&&n.image&&(n.image.src="",n.imageCanceled=!0)})}getTileCache(e){return this.tileCache.find(n=>n.xyzKey===e)}pushTileCache(e){const n=this.options.cacheSize;n>0&&this.tileCache.length>=n&&(this.showTiles.findIndex(t=>t.xyzKey===this.tileCache[0].xyzKey)<0&&this._destroyTile(this.tileCache[0]),this.tileCache.splice(0,1)),this.tileCache.push(e)}addGridCache(e,n,t){const i=this.createTileKey(e.x+n,e.y+t,e.z);if(!this.gridCache[i])if(this.options.proj==="wgs84"){const a=n0(...dist_He(e.x+n,e.y+t,e.z)),s=this._convertLnglatToCoords([a.lng,a.lat]);this.gridCache[i]={lng:s[0],lat:s[1]}}else if(this.options.tileType==="bd09"){const a=t0(...this.transformBaidu.pixelToLnglat(0,0,e.x+n,e.y+t,e.z)),s=this._convertLnglatToCoords([a.lng,a.lat]);this.gridCache[i]={lng:s[0],lat:s[1]}}else{const a=this._convertLnglatToCoords(dist_He(e.x+n,e.y+t,e.z));this.gridCache[i]={lng:a[0],lat:a[1]}}}tileDistance(e,n){return Math.sqrt(Math.pow(e.x-n[0],2)+Math.pow(e.y-n[1],2))}createTileKey(e,n,t){return e instanceof Object?`${e.z}/${e.x}/${e.y}`:`${t}/${e}/${n}`}deepFormatTileNumber(e,n){return e>=0&&e<n?e:(e>0&&e>=n?e=e-n:e<0&&(e=e+n),this.deepFormatTileNumber(e,n))}createTile(e,n){let t=Math.ceil(this.map.getZoom());t>this.options.tileMaxZoom&&(t=this.options.tileMaxZoom);const i=Math.pow(2,t);let a=n.x,s=n.y;a=this.deepFormatTileNumber(a,i),s=this.deepFormatTileNumber(s,i);const h={x:a,y:s,z:n.z};this.options.subdomains&&(h.s=this.options.subdomains[Math.abs(n.x+n.y)%this.options.subdomains.length]);const c=c0(this.options.url,h),l={xyz:n,xyzKey:this.createTileKey(n),isLoad:!1,url:c,imageCanceled:!1};let f,o,v,M;this.options.tileType==="xyz"?(f=this.gridCache[this.createTileKey(n)],o=this.gridCache[this.createTileKey(n.x+1,n.y,n.z)],v=this.gridCache[this.createTileKey(n.x,n.y+1,n.z)],M=this.gridCache[this.createTileKey(n.x+1,n.y+1,n.z)]):(f=this.gridCache[this.createTileKey(n.x,n.y+1,n.z)],o=this.gridCache[this.createTileKey(n.x+1,n.y+1,n.z)],v=this.gridCache[this.createTileKey(n)],M=this.gridCache[this.createTileKey(n.x+1,n.y,n.z)]);const p=new Float32Array([f.lng,f.lat,0,1,v.lng,v.lat,0,0,o.lng,o.lat,1,1,M.lng,M.lat,1,0]),x=p.BYTES_PER_ELEMENT,y=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,y),e.bufferData(e.ARRAY_BUFFER,p,e.STATIC_DRAW),l.buffer=y,l.PosParam={size:2,stride:x*4,offset:0},l.TextCoordParam={size:2,stride:x*4,offset:x*2};const g=new Image(256,256);return g.onload=()=>{if(l.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,l.texture),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,1),this.options.debug){const R=document.createElement("canvas");R.width=256,R.height=256;const m=R.getContext("2d");m.drawImage(g,0,0),m.font="15px Verdana",m.fillStyle="#ff0000",m.strokeStyle="#FF0000",m.strokeRect(0,0,256,256),m.fillText(`(${[n.x,n.y,n.z].join(",")})`,10,30),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,R)}else e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,g);l.isLoad=!0,this.showTiles.findIndex(R=>R===l)>=0&&this.map.render()},g.crossOrigin="anonymous",g.src=c,l.image=g,l}setVertex(e,n){e.uniformMatrix4fv(e.getUniformLocation(n,"u_ProjectionMatrix"),!1,this._projectionMatrix.toArray()),e.uniformMatrix4fv(e.getUniformLocation(n,"u_ViewMatrix4"),!1,this._viewMatrix4.toArray()),e.uniformMatrix4fv(e.getUniformLocation(n,"u_MvpMatrix4"),!1,this._mvpMatrix4.toArray()),e.uniform1f(e.getUniformLocation(n,"u_isOrtho"),this.isOrtho)}show(){this.isLayerShow=!0,this.update(),this.layer.show()}hide(){this.isLayerShow=!1,this.layer.hide()}getzIndex(){return this.layer.getzIndex()}setzIndex(e){this.options.zIndex=e,this.layer.setzIndex(e)}getOpacity(){return this.layer.getOpacity()}setOpacity(e){this.options.opacity=e,this.layer.setOpacity(e)}getZooms(){return this.layer.getZooms()}setZooms(e){this.options.zooms=e,this.layer.setZooms(e)}setMask(e){this._destroyMaskCache(),this._createMask(e),this.options.mask=e,this.map.render()}getMask(){return this.options.mask}getMap(){return this.map}_destroyMaskCache(){this.maskCache.forEach(e=>{this.gl.deleteBuffer(e.vertexBuffer),this.gl.deleteBuffer(e.indexBuffer)}),this.maskCache=[]}_destroyTile(e){e.buffer&&this.gl.deleteBuffer(e.buffer),e.texture&&this.gl.deleteTexture(e.texture)}_clearAllCacheTile(){this.tileCache.forEach(e=>{this._destroyTile(e)}),this.tileCache=[]}_clearShowTile(){this.showTiles.forEach(e=>{this.tileCache.findIndex(n=>n.xyzKey===e.xyzKey)<0&&this._destroyTile(e)}),this.showTiles=[]}destroy(){this.isLayerShow=!1,this.map.remove(this.layer),this.map.off("dragging",this.mapCallback),this.map.off("moveend",this.mapCallback),this.map.off("zoomchange",this.mapCallback),this.map.off("rotatechange",this.mapCallback),this._destroyMaskCache(),this._clearShowTile(),this._clearAllCacheTile(),this.gridCache={},this.transformBaidu=null,this.mapCallback=null,this.gl.deleteProgram(this.program),this.gl.deleteProgram(this.maskProgram),this.program=null,this.maskProgram=null,this.options=void 0,this.customCoords=void 0,this.center=void 0,this.layer=null,this.gl=null,this.map=null}}
//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/CustomXyz/CustomXyz.vue2.mjs




var CustomXyz_vue2_script = (0,runtime_core_esm_bundler/* defineComponent */.pM)({
  name: "ElAmapLayerCustomXyz",
  mixins: [registerComponent],
  props: {
    url: {
      required: true,
      type: String
    },
    // ç¦çå°åï¼æ¯æ {s} {x} {y} {z}ï¼ç¤ºä¾ï¼http://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}
    subdomains: {
      type: Array
    },
    // å­ååæ°ç»ï¼å½urlä¸­è®¾ç½®{s}åï¼è¯¥å±æ§å¿å¡«
    tileType: {
      type: String,
      default: "xyz",
      validator: (value) => {
        return ["xyz", "bd09"].indexOf(value) !== -1;
      }
    },
    // ç¦çåå²ç±»åï¼é»è®¤æ¯xyzï¼xyzä»£è¡¨ç¦çæ¯ç¼å·æ¯ä»å·¦ä¸è§å¼å§ï¼ç¾åº¦ç¦çæ¯ç±ä¸­é´å¼å§ï¼æä»¥éè¦åºåæ®éç¦çè¿æ¯ç¾åº¦
    proj: {
      type: String,
      default: "gcj02",
      validator: (value) => {
        return ["wgs84", "gcj02", "bd09"].indexOf(value) !== -1;
      }
    },
    // ç¦çä½¿ç¨çåæ ç³»ï¼é»è®¤æ¯gcj02
    zooms: {
      type: Object
    },
    // å¾å±ç¼©æ¾ç­çº§èå´ï¼é»è®¤ [2, 18]
    opacity: {
      type: Number
    },
    // å¾å±éæåº¦ï¼é»è®¤ä¸º 1
    zIndex: {
      type: Number,
      default: 120
    },
    mask: {
      type: Array
    },
    cacheSize: {
      type: Number,
      default: 512
    },
    debug: {
      type: Boolean,
      default: false
    },
    tileMaxZoom: {
      type: Number
    },
    altitude: {
      type: Number
    }
  },
  data() {
    return {};
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new l0(this.$parentComponent, options);
    },
    destroyComponent() {
      this.$amapComponent.destroy();
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});


//# sourceMappingURL=CustomXyz.vue2.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/CustomXyz/CustomXyz.vue.mjs


CustomXyz_vue2_script.__file = "src/vue-amap/packages/layer/data/CustomXyz/CustomXyz.vue";


//# sourceMappingURL=CustomXyz.vue.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/packages/layer/data/CustomXyz/index.mjs



CustomXyz_vue2_script.install = (app) => {
  app.component(CustomXyz_vue2_script.name, CustomXyz_vue2_script);
  return app;
};
const ElAmapLayerCustomXyz = CustomXyz_vue2_script;


//# sourceMappingURL=index.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/component.mjs
















































var Components = [
  ElAmap,
  ElAmapControlControlBar,
  ElAmapControlHawkEye,
  ElAmapControlMapType,
  ElAmapControlScale,
  ElAmapControlToolBar,
  ElAmapSearchBox,
  ElAmapInfoWindow,
  ElAmapLayerCanvas,
  ElAmapLayerCustom,
  ElAmapLayerFlexible,
  ElAmapLayerGlCustom,
  ElAmapLayerHeatMap,
  ElAmapLayerImage,
  ElAmapLayerLabels,
  ElAmapLayerVector,
  ElAmapLayerBuildings,
  ElAmapLayerDefault,
  ElAmapLayerDistrict,
  ElAmapLayerIndoorMap,
  ElAmapLayerRoadNet,
  ElAmapLayerSatellite,
  ElAmapLayerTile,
  ElAmapLayerTraffic,
  ElAmapLayerMapboxVectorTile,
  ElAmapLayerWms,
  ElAmapLayerWmts,
  ElAmapElasticMarker,
  ElAmapLabelMarker,
  ElAmapMarker,
  ElAmapMarkerCluster,
  ElAmapMassMarks,
  ElAmapText,
  ElAmapBezierCurve,
  ElAmapCircle,
  ElAmapEllipse,
  ElAmapGeojson,
  ElAmapPolygon,
  ElAmapPolyline,
  ElAmapRectangle,
  ElAmapLayerTiles3d,
  ElAmapControlGeolocation,
  ElAmapCircleMarker,
  ElAmapLayerVideo,
  ElAmapMouseTool,
  ElAmapLayerDistrictCluster,
  ElAmapLayerCustomXyz
];


//# sourceMappingURL=component.mjs.map

;// ./node_modules/@vuemap/vue-amap/es/defaults.mjs



var installer = makeInstaller([...Components]);


//# sourceMappingURL=defaults.mjs.map


/***/ }),

/***/ 8756:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseTransition: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pR; },
/* harmony export */   BaseTransitionPropsValidators: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.QP; },
/* harmony export */   Comment: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Mw; },
/* harmony export */   DeprecationTypes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.aT; },
/* harmony export */   EffectScope: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.yC; },
/* harmony export */   ErrorCodes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.tG; },
/* harmony export */   ErrorTypeStrings: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ZQ; },
/* harmony export */   Fragment: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.FK; },
/* harmony export */   KeepAlive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.PR; },
/* harmony export */   ReactiveEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.X2; },
/* harmony export */   Static: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.jC; },
/* harmony export */   Suspense: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.tY; },
/* harmony export */   Teleport: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Im; },
/* harmony export */   Text: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EY; },
/* harmony export */   TrackOpTypes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Ul; },
/* harmony export */   Transition: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.eB; },
/* harmony export */   TransitionGroup: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.F; },
/* harmony export */   TriggerOpTypes: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.PP; },
/* harmony export */   VueElement: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Vy; },
/* harmony export */   assertNumber: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.U4; },
/* harmony export */   callWithAsyncErrorHandling: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.qL; },
/* harmony export */   callWithErrorHandling: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.gh; },
/* harmony export */   camelize: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.PT; },
/* harmony export */   capitalize: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ZH; },
/* harmony export */   cloneVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.E3; },
/* harmony export */   compatUtils: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Y5; },
/* harmony export */   compile: function() { return /* binding */ compile; },
/* harmony export */   computed: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.EW; },
/* harmony export */   createApp: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Ef; },
/* harmony export */   createBlock: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Wv; },
/* harmony export */   createCommentVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Q3; },
/* harmony export */   createElementBlock: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.CE; },
/* harmony export */   createElementVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Lk; },
/* harmony export */   createHydrationRenderer: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ci; },
/* harmony export */   createPropsRestProxy: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.bn; },
/* harmony export */   createRenderer: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.K9; },
/* harmony export */   createSSRApp: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.m1; },
/* harmony export */   createSlots: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.eX; },
/* harmony export */   createStaticVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fv; },
/* harmony export */   createTextVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.eW; },
/* harmony export */   createVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.bF; },
/* harmony export */   customRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.rY; },
/* harmony export */   defineAsyncComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.$V; },
/* harmony export */   defineComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pM; },
/* harmony export */   defineCustomElement: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Xq; },
/* harmony export */   defineEmits: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.qP; },
/* harmony export */   defineExpose: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.wk; },
/* harmony export */   defineModel: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.NP; },
/* harmony export */   defineOptions: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.GM; },
/* harmony export */   defineProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Yj; },
/* harmony export */   defineSSRCustomElement: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Po; },
/* harmony export */   defineSlots: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Lu; },
/* harmony export */   devtools: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.lt; },
/* harmony export */   effect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.QZ; },
/* harmony export */   effectScope: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.uY; },
/* harmony export */   getCurrentInstance: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nI; },
/* harmony export */   getCurrentScope: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.o5; },
/* harmony export */   getCurrentWatcher: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Yv; },
/* harmony export */   getTransitionRawChildren: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Df; },
/* harmony export */   guardReactiveProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Ng; },
/* harmony export */   h: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.h; },
/* harmony export */   handleError: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.H4; },
/* harmony export */   hasInjectionContext: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.PS; },
/* harmony export */   hydrate: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Qv; },
/* harmony export */   hydrateOnIdle: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.rU; },
/* harmony export */   hydrateOnInteraction: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Tq; },
/* harmony export */   hydrateOnMediaQuery: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.dA; },
/* harmony export */   hydrateOnVisible: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Pn; },
/* harmony export */   initCustomFormatter: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.y$; },
/* harmony export */   initDirectivesForSSR: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Ib; },
/* harmony export */   inject: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.WQ; },
/* harmony export */   isMemoSame: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Bs; },
/* harmony export */   isProxy: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ju; },
/* harmony export */   isReactive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.g8; },
/* harmony export */   isReadonly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Tm; },
/* harmony export */   isRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.i9; },
/* harmony export */   isRuntimeOnly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.wX; },
/* harmony export */   isShallow: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.fE; },
/* harmony export */   isVNode: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.vv; },
/* harmony export */   markRaw: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.IG; },
/* harmony export */   mergeDefaults: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.HF; },
/* harmony export */   mergeModels: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.zz; },
/* harmony export */   mergeProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.v6; },
/* harmony export */   nextTick: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.dY; },
/* harmony export */   normalizeClass: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.C4; },
/* harmony export */   normalizeProps: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__._B; },
/* harmony export */   normalizeStyle: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Tr; },
/* harmony export */   onActivated: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.n; },
/* harmony export */   onBeforeMount: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KC; },
/* harmony export */   onBeforeUnmount: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.xo; },
/* harmony export */   onBeforeUpdate: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Ic; },
/* harmony export */   onDeactivated: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Y4; },
/* harmony export */   onErrorCaptured: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.qG; },
/* harmony export */   onMounted: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.sV; },
/* harmony export */   onRenderTracked: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.qR; },
/* harmony export */   onRenderTriggered: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.bj; },
/* harmony export */   onScopeDispose: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.jr; },
/* harmony export */   onServerPrefetch: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.SS; },
/* harmony export */   onUnmounted: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hi; },
/* harmony export */   onUpdated: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.$u; },
/* harmony export */   onWatcherCleanup: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ch; },
/* harmony export */   openBlock: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.uX; },
/* harmony export */   popScopeId: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.jt; },
/* harmony export */   provide: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Gt; },
/* harmony export */   proxyRefs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Pr; },
/* harmony export */   pushScopeId: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Qi; },
/* harmony export */   queuePostFlushCb: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Dl; },
/* harmony export */   reactive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Kh; },
/* harmony export */   readonly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.tB; },
/* harmony export */   ref: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KR; },
/* harmony export */   registerRuntimeCompiler: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.tC; },
/* harmony export */   render: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.XX; },
/* harmony export */   renderList: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.pI; },
/* harmony export */   renderSlot: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.RG; },
/* harmony export */   resolveComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.g2; },
/* harmony export */   resolveDirective: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.gN; },
/* harmony export */   resolveDynamicComponent: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.$y; },
/* harmony export */   resolveFilter: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.LJ; },
/* harmony export */   resolveTransitionHooks: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.OW; },
/* harmony export */   setBlockTracking: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Vq; },
/* harmony export */   setDevtoolsHook: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.iD; },
/* harmony export */   setTransitionHooks: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.MZ; },
/* harmony export */   shallowReactive: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Gc; },
/* harmony export */   shallowReadonly: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nD; },
/* harmony export */   shallowRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.IJ; },
/* harmony export */   ssrContextKey: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Fw; },
/* harmony export */   ssrUtils: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Gw; },
/* harmony export */   stop: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ds; },
/* harmony export */   toDisplayString: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.v_; },
/* harmony export */   toHandlerKey: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Kf; },
/* harmony export */   toHandlers: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Tb; },
/* harmony export */   toRaw: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.ux; },
/* harmony export */   toRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.lW; },
/* harmony export */   toRefs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.QW; },
/* harmony export */   toValue: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.BA; },
/* harmony export */   transformVNodeArgs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.gW; },
/* harmony export */   triggerRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.mu; },
/* harmony export */   unref: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.R1; },
/* harmony export */   useAttrs: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.OA; },
/* harmony export */   useCssModule: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.D; },
/* harmony export */   useCssVars: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.$9; },
/* harmony export */   useHost: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.KT; },
/* harmony export */   useId: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Bi; },
/* harmony export */   useModel: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.fn; },
/* harmony export */   useSSRContext: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.LM; },
/* harmony export */   useShadowRoot: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__._U; },
/* harmony export */   useSlots: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Ht; },
/* harmony export */   useTemplateRef: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.rk; },
/* harmony export */   useTransitionState: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Gy; },
/* harmony export */   vModelCheckbox: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.lH; },
/* harmony export */   vModelDynamic: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.hp; },
/* harmony export */   vModelRadio: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.XL; },
/* harmony export */   vModelSelect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.u1; },
/* harmony export */   vModelText: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.Jo; },
/* harmony export */   vShow: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.aG; },
/* harmony export */   version: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.rE; },
/* harmony export */   warn: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.R8; },
/* harmony export */   watch: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.wB; },
/* harmony export */   watchEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.nT; },
/* harmony export */   watchPostEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.p9; },
/* harmony export */   watchSyncEffect: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.U_; },
/* harmony export */   withAsyncContext: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.E; },
/* harmony export */   withCtx: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.k6; },
/* harmony export */   withDefaults: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.rO; },
/* harmony export */   withDirectives: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.bo; },
/* harmony export */   withKeys: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.jR; },
/* harmony export */   withMemo: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.bU; },
/* harmony export */   withModifiers: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.D$; },
/* harmony export */   withScopeId: function() { return /* reexport safe */ _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__.YY; }
/* harmony export */ });
/* harmony import */ var _vue_runtime_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3751);
/**
* vue v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/



function initDev() {
  {
    initCustomFormatter();
  }
}

if (false) // removed by dead control flow
{}
const compile = () => {
  if (false) // removed by dead control flow
{}
};




/***/ }),

/***/ 8890:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(6492);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 8892:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  RC: function() { return /* reexport */ Swiper; },
  qr: function() { return /* reexport */ SwiperSlide; }
});

// UNUSED EXPORTS: useSwiper, useSwiperSlide

// EXTERNAL MODULE: ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
var reactivity_esm_bundler = __webpack_require__(953);
// EXTERNAL MODULE: ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
var runtime_core_esm_bundler = __webpack_require__(641);
// EXTERNAL MODULE: ./node_modules/swiper/swiper.esm.js + 91 modules
var swiper_esm = __webpack_require__(9025);
;// ./node_modules/swiper/components-shared/utils.js
function isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function extend(target, src) {
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params = {}) {
  return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
}
function needsPagination(params = {}) {
  return params.pagination && typeof params.pagination.el === 'undefined';
}
function needsScrollbar(params = {}) {
  return params.scrollbar && typeof params.scrollbar.el === 'undefined';
}
function uniqueClasses(classNames = '') {
  const classes = classNames.split(' ').map(c => c.trim()).filter(c => !!c);
  const unique = [];
  classes.forEach(c => {
    if (unique.indexOf(c) < 0) unique.push(c);
  });
  return unique.join(' ');
}
function attrToProp(attrName = '') {
  return attrName.replace(/-[a-z]/g, l => l.toUpperCase().replace('-', ''));
}
function wrapperClass(className = '') {
  if (!className) return 'swiper-wrapper';
  if (!className.includes('swiper-wrapper')) return `swiper-wrapper ${className}`;
  return className;
}

;// ./node_modules/swiper/components-shared/params-list.js
/* underscore in name -> watch for changes */
const paramsList = ['eventsPrefix', 'injectStyles', 'injectStylesUrls', 'modules', 'init', '_direction', 'oneWayMovement', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', '_spaceBetween', '_slidesPerView', 'maxBackfaceHiddenSlides', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_loop', 'loopedSlides', 'loopPreventsSliding', '_rewind', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideActiveClass', 'slideVisibleClass', 'slideNextClass', 'slidePrevClass', 'wrapperClass', 'lazyPreloaderClass', 'lazyPreloadPrevNext', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren',
// modules
'a11y', '_autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom', 'control'];

;// ./node_modules/swiper/components-shared/get-params.js



function getParams(obj = {}, splitEvents = true) {
  const params = {
    on: {}
  };
  const events = {};
  const passedParams = {};
  extend(params, swiper_esm/* default */.Ay.defaults);
  extend(params, swiper_esm/* default */.Ay.extendedDefaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map(key => key.replace(/_/, ''));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach(key => {
    if (typeof obj[key] === 'undefined') return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend(params[key], obj[key]);
        extend(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
      if (splitEvents) {
        events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ['navigation', 'pagination', 'scrollbar'].forEach(key => {
    if (params[key] === true) params[key] = {};
    if (params[key] === false) delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events
  };
}

;// ./node_modules/swiper/components-shared/mount-swiper.js

function mountSwiper({
  el,
  nextEl,
  prevEl,
  paginationEl,
  scrollbarEl,
  swiper
}, swiperParams) {
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper.init(el);
}

;// ./node_modules/swiper/components-shared/get-changed-params.js


function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys = [];
  if (!oldParams) return keys;
  const addKey = key => {
    if (keys.indexOf(key) < 0) keys.push(key);
  };
  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');
    if (oldChildren.length !== children.length) addKey('children');
  }
  const watchParams = paramsList.filter(key => key[0] === '_').map(key => key.replace(/_/, ''));
  watchParams.forEach(key => {
    if (key in swiperParams && key in oldParams) {
      if (isObject(swiperParams[key]) && isObject(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach(newKey => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach(oldKey => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys;
}

;// ./node_modules/swiper/vue/get-children.js
function getChildren(originalSlots, slidesRef, oldSlidesRef) {
  if (originalSlots === void 0) {
    originalSlots = {};
  }
  const slides = [];
  const slots = {
    'container-start': [],
    'container-end': [],
    'wrapper-start': [],
    'wrapper-end': []
  };
  const getSlidesFromElements = (els, slotName) => {
    if (!Array.isArray(els)) {
      return;
    }
    els.forEach(vnode => {
      const isFragment = typeof vnode.type === 'symbol';
      if (slotName === 'default') slotName = 'container-end';
      if (isFragment && vnode.children) {
        getSlidesFromElements(vnode.children, slotName);
      } else if (vnode.type && (vnode.type.name === 'SwiperSlide' || vnode.type.name === 'AsyncComponentWrapper')) {
        slides.push(vnode);
      } else if (slots[slotName]) {
        slots[slotName].push(vnode);
      }
    });
  };
  Object.keys(originalSlots).forEach(slotName => {
    if (typeof originalSlots[slotName] !== 'function') return;
    const els = originalSlots[slotName]();
    getSlidesFromElements(els, slotName);
  });
  oldSlidesRef.value = slidesRef.value;
  slidesRef.value = slides;
  return {
    slides,
    slots
  };
}

;// ./node_modules/swiper/components-shared/update-swiper.js

function updateSwiper({
  swiper,
  slides,
  passedParams,
  changedParams,
  nextEl,
  prevEl,
  scrollbarEl,
  paginationEl
}) {
  const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction' && key !== 'wrapperClass');
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  let loopNeedDestroy;
  let loopNeedEnable;
  let loopNeedReloop;
  if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = mod => {
    if (!swiper[mod]) return;
    swiper[mod].destroy();
    if (mod === 'navigation') {
      if (swiper.isElement) {
        swiper[mod].prevEl.remove();
        swiper[mod].nextEl.remove();
      }
      currentParams[mod].prevEl = undefined;
      currentParams[mod].nextEl = undefined;
      swiper[mod].prevEl = undefined;
      swiper[mod].nextEl = undefined;
    } else {
      if (swiper.isElement) {
        swiper[mod].el.remove();
      }
      currentParams[mod].el = undefined;
      swiper[mod].el = undefined;
    }
  };
  if (changedParams.includes('loop') && swiper.isElement) {
    if (currentParams.loop && !passedParams.loop) {
      loopNeedDestroy = true;
    } else if (!currentParams.loop && passedParams.loop) {
      loopNeedEnable = true;
    } else {
      loopNeedReloop = true;
    }
  }
  updateParams.forEach(key => {
    if (isObject(currentParams[key]) && isObject(passedParams[key])) {
      extend(currentParams[key], passedParams[key]);
      if ((key === 'navigation' || key === 'pagination' || key === 'scrollbar') && 'enabled' in passedParams[key] && !passedParams[key].enabled) {
        destroyModule(key);
      }
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  }
  if (changedParams.includes('children') && slides && currentParams.loop) {
    loopNeedReloop = true;
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized) thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (swiper.isElement && (!paginationEl || typeof paginationEl === 'string')) {
      paginationEl = document.createElement('div');
      paginationEl.classList.add('swiper-pagination');
      swiper.el.shadowEl.appendChild(paginationEl);
    }
    if (paginationEl) currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === 'string')) {
      scrollbarEl = document.createElement('div');
      scrollbarEl.classList.add('swiper-scrollbar');
      swiper.el.shadowEl.appendChild(scrollbarEl);
    }
    if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (swiper.isElement) {
      if (!nextEl || typeof nextEl === 'string') {
        nextEl = document.createElement('div');
        nextEl.classList.add('swiper-button-next');
        swiper.el.shadowEl.appendChild(nextEl);
      }
      if (!prevEl || typeof prevEl === 'string') {
        prevEl = document.createElement('div');
        prevEl.classList.add('swiper-button-prev');
        swiper.el.shadowEl.appendChild(prevEl);
      }
    }
    if (nextEl) currentParams.navigation.nextEl = nextEl;
    if (prevEl) currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes('allowSlideNext')) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes('allowSlidePrev')) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes('direction')) {
    swiper.changeDirection(passedParams.direction, false);
  }
  if (loopNeedDestroy || loopNeedReloop) {
    swiper.loopDestroy();
  }
  if (loopNeedEnable || loopNeedReloop) {
    swiper.loopCreate();
  }
  swiper.update();
}

;// ./node_modules/swiper/vue/virtual.js

function renderVirtual(swiperRef, slides, virtualData) {
  if (!virtualData) return null;
  const getSlideIndex = index => {
    let slideIndex = index;
    if (index < 0) {
      slideIndex = slides.length + index;
    } else if (slideIndex >= slides.length) {
      // eslint-disable-next-line
      slideIndex = slideIndex - slides.length;
    }
    return slideIndex;
  };
  const style = swiperRef.value.isHorizontal() ? {
    [swiperRef.value.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  const {
    from,
    to
  } = virtualData;
  const loopFrom = swiperRef.value.params.loop ? -slides.length : 0;
  const loopTo = swiperRef.value.params.loop ? slides.length * 2 : slides.length;
  const slidesToRender = [];
  for (let i = loopFrom; i < loopTo; i += 1) {
    if (i >= from && i <= to) {
      slidesToRender.push(slides[getSlideIndex(i)]);
    }
  }
  return slidesToRender.map(slide => {
    if (!slide.props) slide.props = {};
    if (!slide.props.style) slide.props.style = {};
    slide.props.swiperRef = swiperRef;
    slide.props.style = style;
    return (0,runtime_core_esm_bundler.h)(slide.type, {
      ...slide.props
    }, slide.children);
  });
}

;// ./node_modules/swiper/components-shared/update-on-virtual-data.js
const updateOnVirtualData = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
  swiper.updateSlides();
  swiper.updateProgress();
  swiper.updateSlidesClasses();
  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
    swiper.parallax.setTranslate();
  }
};
;// ./node_modules/swiper/vue/swiper.js










const Swiper = {
  name: 'Swiper',
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    wrapperTag: {
      type: String,
      default: 'div'
    },
    modules: {
      type: Array,
      default: undefined
    },
    init: {
      type: Boolean,
      default: undefined
    },
    direction: {
      type: String,
      default: undefined
    },
    oneWayMovement: {
      type: Boolean,
      default: undefined
    },
    touchEventsTarget: {
      type: String,
      default: undefined
    },
    initialSlide: {
      type: Number,
      default: undefined
    },
    speed: {
      type: Number,
      default: undefined
    },
    cssMode: {
      type: Boolean,
      default: undefined
    },
    updateOnWindowResize: {
      type: Boolean,
      default: undefined
    },
    resizeObserver: {
      type: Boolean,
      default: undefined
    },
    nested: {
      type: Boolean,
      default: undefined
    },
    focusableElements: {
      type: String,
      default: undefined
    },
    width: {
      type: Number,
      default: undefined
    },
    height: {
      type: Number,
      default: undefined
    },
    preventInteractionOnTransition: {
      type: Boolean,
      default: undefined
    },
    userAgent: {
      type: String,
      default: undefined
    },
    url: {
      type: String,
      default: undefined
    },
    edgeSwipeDetection: {
      type: [Boolean, String],
      default: undefined
    },
    edgeSwipeThreshold: {
      type: Number,
      default: undefined
    },
    autoHeight: {
      type: Boolean,
      default: undefined
    },
    setWrapperSize: {
      type: Boolean,
      default: undefined
    },
    virtualTranslate: {
      type: Boolean,
      default: undefined
    },
    effect: {
      type: String,
      default: undefined
    },
    breakpoints: {
      type: Object,
      default: undefined
    },
    spaceBetween: {
      type: [Number, String],
      default: undefined
    },
    slidesPerView: {
      type: [Number, String],
      default: undefined
    },
    maxBackfaceHiddenSlides: {
      type: Number,
      default: undefined
    },
    slidesPerGroup: {
      type: Number,
      default: undefined
    },
    slidesPerGroupSkip: {
      type: Number,
      default: undefined
    },
    slidesPerGroupAuto: {
      type: Boolean,
      default: undefined
    },
    centeredSlides: {
      type: Boolean,
      default: undefined
    },
    centeredSlidesBounds: {
      type: Boolean,
      default: undefined
    },
    slidesOffsetBefore: {
      type: Number,
      default: undefined
    },
    slidesOffsetAfter: {
      type: Number,
      default: undefined
    },
    normalizeSlideIndex: {
      type: Boolean,
      default: undefined
    },
    centerInsufficientSlides: {
      type: Boolean,
      default: undefined
    },
    watchOverflow: {
      type: Boolean,
      default: undefined
    },
    roundLengths: {
      type: Boolean,
      default: undefined
    },
    touchRatio: {
      type: Number,
      default: undefined
    },
    touchAngle: {
      type: Number,
      default: undefined
    },
    simulateTouch: {
      type: Boolean,
      default: undefined
    },
    shortSwipes: {
      type: Boolean,
      default: undefined
    },
    longSwipes: {
      type: Boolean,
      default: undefined
    },
    longSwipesRatio: {
      type: Number,
      default: undefined
    },
    longSwipesMs: {
      type: Number,
      default: undefined
    },
    followFinger: {
      type: Boolean,
      default: undefined
    },
    allowTouchMove: {
      type: Boolean,
      default: undefined
    },
    threshold: {
      type: Number,
      default: undefined
    },
    touchMoveStopPropagation: {
      type: Boolean,
      default: undefined
    },
    touchStartPreventDefault: {
      type: Boolean,
      default: undefined
    },
    touchStartForcePreventDefault: {
      type: Boolean,
      default: undefined
    },
    touchReleaseOnEdges: {
      type: Boolean,
      default: undefined
    },
    uniqueNavElements: {
      type: Boolean,
      default: undefined
    },
    resistance: {
      type: Boolean,
      default: undefined
    },
    resistanceRatio: {
      type: Number,
      default: undefined
    },
    watchSlidesProgress: {
      type: Boolean,
      default: undefined
    },
    grabCursor: {
      type: Boolean,
      default: undefined
    },
    preventClicks: {
      type: Boolean,
      default: undefined
    },
    preventClicksPropagation: {
      type: Boolean,
      default: undefined
    },
    slideToClickedSlide: {
      type: Boolean,
      default: undefined
    },
    loop: {
      type: Boolean,
      default: undefined
    },
    loopedSlides: {
      type: Number,
      default: undefined
    },
    loopPreventsSliding: {
      type: Boolean,
      default: undefined
    },
    rewind: {
      type: Boolean,
      default: undefined
    },
    allowSlidePrev: {
      type: Boolean,
      default: undefined
    },
    allowSlideNext: {
      type: Boolean,
      default: undefined
    },
    swipeHandler: {
      type: Boolean,
      default: undefined
    },
    noSwiping: {
      type: Boolean,
      default: undefined
    },
    noSwipingClass: {
      type: String,
      default: undefined
    },
    noSwipingSelector: {
      type: String,
      default: undefined
    },
    passiveListeners: {
      type: Boolean,
      default: undefined
    },
    containerModifierClass: {
      type: String,
      default: undefined
    },
    slideClass: {
      type: String,
      default: undefined
    },
    slideActiveClass: {
      type: String,
      default: undefined
    },
    slideVisibleClass: {
      type: String,
      default: undefined
    },
    slideNextClass: {
      type: String,
      default: undefined
    },
    slidePrevClass: {
      type: String,
      default: undefined
    },
    wrapperClass: {
      type: String,
      default: undefined
    },
    lazyPreloaderClass: {
      type: String,
      default: undefined
    },
    lazyPreloadPrevNext: {
      type: Number,
      default: undefined
    },
    runCallbacksOnInit: {
      type: Boolean,
      default: undefined
    },
    observer: {
      type: Boolean,
      default: undefined
    },
    observeParents: {
      type: Boolean,
      default: undefined
    },
    observeSlideChildren: {
      type: Boolean,
      default: undefined
    },
    a11y: {
      type: [Boolean, Object],
      default: undefined
    },
    autoplay: {
      type: [Boolean, Object],
      default: undefined
    },
    controller: {
      type: Object,
      default: undefined
    },
    coverflowEffect: {
      type: Object,
      default: undefined
    },
    cubeEffect: {
      type: Object,
      default: undefined
    },
    fadeEffect: {
      type: Object,
      default: undefined
    },
    flipEffect: {
      type: Object,
      default: undefined
    },
    creativeEffect: {
      type: Object,
      default: undefined
    },
    cardsEffect: {
      type: Object,
      default: undefined
    },
    hashNavigation: {
      type: [Boolean, Object],
      default: undefined
    },
    history: {
      type: [Boolean, Object],
      default: undefined
    },
    keyboard: {
      type: [Boolean, Object],
      default: undefined
    },
    mousewheel: {
      type: [Boolean, Object],
      default: undefined
    },
    navigation: {
      type: [Boolean, Object],
      default: undefined
    },
    pagination: {
      type: [Boolean, Object],
      default: undefined
    },
    parallax: {
      type: [Boolean, Object],
      default: undefined
    },
    scrollbar: {
      type: [Boolean, Object],
      default: undefined
    },
    thumbs: {
      type: Object,
      default: undefined
    },
    virtual: {
      type: [Boolean, Object],
      default: undefined
    },
    zoom: {
      type: [Boolean, Object],
      default: undefined
    },
    grid: {
      type: [Object],
      default: undefined
    },
    freeMode: {
      type: [Boolean, Object],
      default: undefined
    },
    enabled: {
      type: Boolean,
      default: undefined
    }
  },
  emits: ['_beforeBreakpoint', '_containerClasses', '_slideClass', '_slideClasses', '_swiper', '_freeModeNoMomentumRelease', 'activeIndexChange', 'afterInit', 'autoplay', 'autoplayStart', 'autoplayStop', 'autoplayPause', 'autoplayResume', 'autoplayTimeLeft', 'beforeDestroy', 'beforeInit', 'beforeLoopFix', 'beforeResize', 'beforeSlideChangeStart', 'beforeTransitionStart', 'breakpoint', 'changeDirection', 'click', 'disable', 'doubleTap', 'doubleClick', 'destroy', 'enable', 'fromEdge', 'hashChange', 'hashSet', 'init', 'keyPress', 'lock', 'loopFix', 'momentumBounce', 'navigationHide', 'navigationShow', 'navigationPrev', 'navigationNext', 'observerUpdate', 'orientationchange', 'paginationHide', 'paginationRender', 'paginationShow', 'paginationUpdate', 'progress', 'reachBeginning', 'reachEnd', 'realIndexChange', 'resize', 'scroll', 'scrollbarDragEnd', 'scrollbarDragMove', 'scrollbarDragStart', 'setTransition', 'setTranslate', 'slideChange', 'slideChangeTransitionEnd', 'slideChangeTransitionStart', 'slideNextTransitionEnd', 'slideNextTransitionStart', 'slidePrevTransitionEnd', 'slidePrevTransitionStart', 'slideResetTransitionStart', 'slideResetTransitionEnd', 'sliderMove', 'sliderFirstMove', 'slidesLengthChange', 'slidesGridLengthChange', 'snapGridLengthChange', 'snapIndexChange', 'swiper', 'tap', 'toEdge', 'touchEnd', 'touchMove', 'touchMoveOpposite', 'touchStart', 'transitionEnd', 'transitionStart', 'unlock', 'update', 'virtualUpdate', 'zoomChange'],
  setup(props, _ref) {
    let {
      slots: originalSlots,
      emit
    } = _ref;
    const {
      tag: Tag,
      wrapperTag: WrapperTag
    } = props;
    const containerClasses = (0,reactivity_esm_bundler/* ref */.KR)('swiper');
    const virtualData = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const breakpointChanged = (0,reactivity_esm_bundler/* ref */.KR)(false);
    const initializedRef = (0,reactivity_esm_bundler/* ref */.KR)(false);
    const swiperElRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const swiperRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const oldPassedParamsRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const slidesRef = {
      value: []
    };
    const oldSlidesRef = {
      value: []
    };
    const nextElRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const prevElRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const paginationElRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const scrollbarElRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const {
      params: swiperParams,
      passedParams
    } = getParams(props, false);
    getChildren(originalSlots, slidesRef, oldSlidesRef);
    oldPassedParamsRef.value = passedParams;
    oldSlidesRef.value = slidesRef.value;
    const onBeforeBreakpoint = () => {
      getChildren(originalSlots, slidesRef, oldSlidesRef);
      breakpointChanged.value = true;
    };
    swiperParams.onAny = function (event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      emit(event, ...args);
    };
    Object.assign(swiperParams.on, {
      _beforeBreakpoint: onBeforeBreakpoint,
      _containerClasses(swiper, classes) {
        containerClasses.value = classes;
      }
    });

    // init Swiper
    const passParams = {
      ...swiperParams
    };
    delete passParams.wrapperClass;
    swiperRef.value = new swiper_esm/* default */.Ay(passParams);
    if (swiperRef.value.virtual && swiperRef.value.params.virtual.enabled) {
      swiperRef.value.virtual.slides = slidesRef.value;
      const extendWith = {
        cache: false,
        slides: slidesRef.value,
        renderExternal: data => {
          virtualData.value = data;
        },
        renderExternalUpdate: false
      };
      extend(swiperRef.value.params.virtual, extendWith);
      extend(swiperRef.value.originalParams.virtual, extendWith);
    }
    (0,runtime_core_esm_bundler/* onUpdated */.$u)(() => {
      // set initialized flag
      if (!initializedRef.value && swiperRef.value) {
        swiperRef.value.emitSlidesClasses();
        initializedRef.value = true;
      }
      // watch for params change
      const {
        passedParams: newPassedParams
      } = getParams(props, false);
      const changedParams = getChangedParams(newPassedParams, oldPassedParamsRef.value, slidesRef.value, oldSlidesRef.value, c => c.props && c.props.key);
      oldPassedParamsRef.value = newPassedParams;
      if ((changedParams.length || breakpointChanged.value) && swiperRef.value && !swiperRef.value.destroyed) {
        updateSwiper({
          swiper: swiperRef.value,
          slides: slidesRef.value,
          passedParams: newPassedParams,
          changedParams,
          nextEl: nextElRef.value,
          prevEl: prevElRef.value,
          scrollbarEl: scrollbarElRef.value,
          paginationEl: paginationElRef.value
        });
      }
      breakpointChanged.value = false;
    });
    (0,runtime_core_esm_bundler/* provide */.Gt)('swiper', swiperRef);

    // update on virtual update
    (0,runtime_core_esm_bundler/* watch */.wB)(virtualData, () => {
      (0,runtime_core_esm_bundler/* nextTick */.dY)(() => {
        updateOnVirtualData(swiperRef.value);
      });
    });

    // mount swiper
    (0,runtime_core_esm_bundler/* onMounted */.sV)(() => {
      if (!swiperElRef.value) return;
      mountSwiper({
        el: swiperElRef.value,
        nextEl: nextElRef.value,
        prevEl: prevElRef.value,
        paginationEl: paginationElRef.value,
        scrollbarEl: scrollbarElRef.value,
        swiper: swiperRef.value
      }, swiperParams);
      emit('swiper', swiperRef.value);
    });
    (0,runtime_core_esm_bundler/* onBeforeUnmount */.xo)(() => {
      if (swiperRef.value && !swiperRef.value.destroyed) {
        swiperRef.value.destroy(true, false);
      }
    });

    // bypass swiper instance to slides
    function renderSlides(slides) {
      if (swiperParams.virtual) {
        return renderVirtual(swiperRef, slides, virtualData.value);
      }
      slides.forEach((slide, index) => {
        if (!slide.props) slide.props = {};
        slide.props.swiperRef = swiperRef;
        slide.props.swiperSlideIndex = index;
      });
      return slides;
    }
    return () => {
      const {
        slides,
        slots
      } = getChildren(originalSlots, slidesRef, oldSlidesRef);
      return (0,runtime_core_esm_bundler.h)(Tag, {
        ref: swiperElRef,
        class: uniqueClasses(containerClasses.value)
      }, [slots['container-start'], (0,runtime_core_esm_bundler.h)(WrapperTag, {
        class: wrapperClass(swiperParams.wrapperClass)
      }, [slots['wrapper-start'], renderSlides(slides), slots['wrapper-end']]), needsNavigation(props) && [(0,runtime_core_esm_bundler.h)('div', {
        ref: prevElRef,
        class: 'swiper-button-prev'
      }), (0,runtime_core_esm_bundler.h)('div', {
        ref: nextElRef,
        class: 'swiper-button-next'
      })], needsScrollbar(props) && (0,runtime_core_esm_bundler.h)('div', {
        ref: scrollbarElRef,
        class: 'swiper-scrollbar'
      }), needsPagination(props) && (0,runtime_core_esm_bundler.h)('div', {
        ref: paginationElRef,
        class: 'swiper-pagination'
      }), slots['container-end']]);
    };
  }
};

;// ./node_modules/swiper/vue/swiper-slide.js


const SwiperSlide = {
  name: 'SwiperSlide',
  props: {
    tag: {
      type: String,
      default: 'div'
    },
    swiperRef: {
      type: Object,
      required: false
    },
    swiperSlideIndex: {
      type: Number,
      default: undefined,
      required: false
    },
    zoom: {
      type: Boolean,
      default: undefined,
      required: false
    },
    lazy: {
      type: Boolean,
      default: false,
      required: false
    },
    virtualIndex: {
      type: [String, Number],
      default: undefined
    }
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    let eventAttached = false;
    const {
      swiperRef
    } = props;
    const slideElRef = (0,reactivity_esm_bundler/* ref */.KR)(null);
    const slideClasses = (0,reactivity_esm_bundler/* ref */.KR)('swiper-slide');
    const lazyLoaded = (0,reactivity_esm_bundler/* ref */.KR)(false);
    function updateClasses(swiper, el, classNames) {
      if (el === slideElRef.value) {
        slideClasses.value = classNames;
      }
    }
    (0,runtime_core_esm_bundler/* onMounted */.sV)(() => {
      if (!swiperRef || !swiperRef.value) return;
      swiperRef.value.on('_slideClass', updateClasses);
      eventAttached = true;
    });
    (0,runtime_core_esm_bundler/* onBeforeUpdate */.Ic)(() => {
      if (eventAttached || !swiperRef || !swiperRef.value) return;
      swiperRef.value.on('_slideClass', updateClasses);
      eventAttached = true;
    });
    (0,runtime_core_esm_bundler/* onUpdated */.$u)(() => {
      if (!slideElRef.value || !swiperRef || !swiperRef.value) return;
      if (typeof props.swiperSlideIndex !== 'undefined') {
        slideElRef.value.swiperSlideIndex = props.swiperSlideIndex;
      }
      if (swiperRef.value.destroyed) {
        if (slideClasses.value !== 'swiper-slide') {
          slideClasses.value = 'swiper-slide';
        }
      }
    });
    (0,runtime_core_esm_bundler/* onBeforeUnmount */.xo)(() => {
      if (!swiperRef || !swiperRef.value) return;
      swiperRef.value.off('_slideClass', updateClasses);
    });
    const slideData = (0,runtime_core_esm_bundler/* computed */.EW)(() => ({
      isActive: slideClasses.value.indexOf('swiper-slide-active') >= 0,
      isVisible: slideClasses.value.indexOf('swiper-slide-visible') >= 0,
      isPrev: slideClasses.value.indexOf('swiper-slide-prev') >= 0,
      isNext: slideClasses.value.indexOf('swiper-slide-next') >= 0
    }));
    (0,runtime_core_esm_bundler/* provide */.Gt)('swiperSlide', slideData);
    const onLoad = () => {
      lazyLoaded.value = true;
    };
    return () => {
      return (0,runtime_core_esm_bundler.h)(props.tag, {
        class: uniqueClasses(`${slideClasses.value}`),
        ref: slideElRef,
        'data-swiper-slide-index': typeof props.virtualIndex === 'undefined' && swiperRef && swiperRef.value && swiperRef.value.params.loop ? props.swiperSlideIndex : props.virtualIndex,
        onLoadCapture: onLoad
      }, props.zoom ? (0,runtime_core_esm_bundler.h)('div', {
        class: 'swiper-zoom-container',
        'data-swiper-zoom': typeof props.zoom === 'number' ? props.zoom : undefined
      }, [slots.default && slots.default(slideData.value), props.lazy && !lazyLoaded.value && (0,runtime_core_esm_bundler.h)('div', {
        class: 'swiper-lazy-preloader'
      })]) : [slots.default && slots.default(slideData.value), props.lazy && !lazyLoaded.value && (0,runtime_core_esm_bundler.h)('div', {
        class: 'swiper-lazy-preloader'
      })]);
    };
  }
};

;// ./node_modules/swiper/vue/swiper-vue.js
/**
 * Swiper Vue 9.4.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2023 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: June 13, 2023
 */






/***/ }),

/***/ 8916:
/***/ (function(__unused_webpack_module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 9025:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Ij: function() { return /* reexport */ Autoplay; },
  t9: function() { return /* reexport */ EffectCoverflow; },
  $j: function() { return /* reexport */ EffectCreative; },
  hw: function() { return /* reexport */ EffectCube; },
  _R: function() { return /* reexport */ EffectFade; },
  n: function() { return /* reexport */ EffectFlip; },
  U1: function() { return /* reexport */ freeMode; },
  xA: function() { return /* reexport */ Grid; },
  Vx: function() { return /* reexport */ Navigation; },
  dK: function() { return /* reexport */ Pagination; },
  Ze: function() { return /* reexport */ Scrollbar; },
  Ay: function() { return /* reexport */ core; }
});

// UNUSED EXPORTS: A11y, Controller, EffectCards, HashNavigation, History, Keyboard, Manipulation, Mousewheel, Parallax, Swiper, Thumbs, Virtual, Zoom

;// ./node_modules/swiper/node_modules/ssr-window/ssr-window.esm.js
/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function ssr_window_esm_isObject(obj) {
    return (obj !== null &&
        typeof obj === 'object' &&
        'constructor' in obj &&
        obj.constructor === Object);
}
function extend(target = {}, src = {}) {
    Object.keys(src).forEach((key) => {
        if (typeof target[key] === 'undefined')
            target[key] = src[key];
        else if (ssr_window_esm_isObject(src[key]) &&
            ssr_window_esm_isObject(target[key]) &&
            Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}

const ssrDocument = {
    body: {},
    addEventListener() { },
    removeEventListener() { },
    activeElement: {
        blur() { },
        nodeName: '',
    },
    querySelector() {
        return null;
    },
    querySelectorAll() {
        return [];
    },
    getElementById() {
        return null;
    },
    createEvent() {
        return {
            initEvent() { },
        };
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() { },
            getElementsByTagName() {
                return [];
            },
        };
    },
    createElementNS() {
        return {};
    },
    importNode() {
        return null;
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
};
function ssr_window_esm_getDocument() {
    const doc = typeof document !== 'undefined' ? document : {};
    extend(doc, ssrDocument);
    return doc;
}

const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: '',
    },
    location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
    },
    history: {
        replaceState() { },
        pushState() { },
        go() { },
        back() { },
    },
    CustomEvent: function CustomEvent() {
        return this;
    },
    addEventListener() { },
    removeEventListener() { },
    getComputedStyle() {
        return {
            getPropertyValue() {
                return '';
            },
        };
    },
    Image() { },
    Date() { },
    screen: {},
    setTimeout() { },
    clearTimeout() { },
    matchMedia() {
        return {};
    },
    requestAnimationFrame(callback) {
        if (typeof setTimeout === 'undefined') {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame(id) {
        if (typeof setTimeout === 'undefined') {
            return;
        }
        clearTimeout(id);
    },
};
function ssr_window_esm_getWindow() {
    const win = typeof window !== 'undefined' ? window : {};
    extend(win, ssrWindow);
    return win;
}



;// ./node_modules/swiper/shared/utils.js

function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {
      // no getter for object
    }
    try {
      delete object[key];
    } catch (e) {
      // something got wrong
    }
  });
}
function utils_nextTick(callback, delay = 0) {
  return setTimeout(callback, delay);
}
function utils_now() {
  return Date.now();
}
function utils_getComputedStyle(el) {
  const window = ssr_window_esm_getWindow();
  let style;
  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function utils_getTranslate(el, axis = 'x') {
  const window = ssr_window_esm_getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = utils_getComputedStyle(el, null);
  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    }
    // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case
    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function utils_isObject(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function utils_extend(...args) {
  const to = Object(args[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  for (let i = 1; i < args.length; i += 1) {
    const nextSource = args[i];
    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function utils_setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll({
  swiper,
  targetPosition,
  side
}) {
  const window = ssr_window_esm_getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';
  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };
  animate();
}
function utils_getSlideTransformEl(slideEl) {
  return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowEl && slideEl.shadowEl.querySelector('.swiper-slide-transform') || slideEl;
}
function findElementsInElements(elements = [], selector = '') {
  const found = [];
  elements.forEach(el => {
    found.push(...el.querySelectorAll(selector));
  });
  return found;
}
function utils_elementChildren(element, selector = '') {
  return [...element.children].filter(el => el.matches(selector));
}
function utils_createElement(tag, classes = []) {
  const el = document.createElement(tag);
  el.classList.add(...(Array.isArray(classes) ? classes : [classes]));
  return el;
}
function utils_elementOffset(el) {
  const window = ssr_window_esm_getWindow();
  const document = ssr_window_esm_getDocument();
  const box = el.getBoundingClientRect();
  const body = document.body;
  const clientTop = el.clientTop || body.clientTop || 0;
  const clientLeft = el.clientLeft || body.clientLeft || 0;
  const scrollTop = el === window ? window.scrollY : el.scrollTop;
  const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
  return {
    top: box.top + scrollTop - clientTop,
    left: box.left + scrollLeft - clientLeft
  };
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if (prev.matches(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if (next.matches(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window = ssr_window_esm_getWindow();
  return window.getComputedStyle(el, null).getPropertyValue(prop);
}
function utils_elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
function utils_elementParents(el, selector) {
  const parents = []; // eslint-disable-line
  let parent = el.parentElement; // eslint-disable-line
  while (parent) {
    if (selector) {
      if (parent.matches(selector)) parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function utils_elementTransitionEnd(el, callback) {
  function fireCallBack(e) {
    if (e.target !== el) return;
    callback.call(el, e);
    el.removeEventListener('transitionend', fireCallBack);
  }
  if (callback) {
    el.addEventListener('transitionend', fireCallBack);
  }
}
function elementOuterSize(el, size, includeMargins) {
  const window = ssr_window_esm_getWindow();
  if (includeMargins) {
    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
  }
  return el.offsetWidth;
}

;// ./node_modules/swiper/shared/get-support.js

let support;
function calcSupport() {
  const window = ssr_window_esm_getWindow();
  const document = ssr_window_esm_getDocument();
  return {
    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

;// ./node_modules/swiper/shared/get-device.js


let deviceCached;
function calcDevice({
  userAgent
} = {}) {
  const support = getSupport();
  const window = ssr_window_esm_getWindow();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }

  // Export object
  return device;
}
function getDevice(overrides = {}) {
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}

;// ./node_modules/swiper/shared/get-browser.js

let browser;
function calcBrowser() {
  const window = ssr_window_esm_getWindow();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  if (isSafari()) {
    const ua = String(window.navigator.userAgent);
    if (ua.includes('Version/')) {
      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  return {
    isSafari: needPerspectiveFix || isSafari(),
    needPerspectiveFix,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

;// ./node_modules/swiper/core/modules/resize/resize.js

function Resize({
  swiper,
  on,
  emit
}) {
  const window = ssr_window_esm_getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(({
          contentBoxSize,
          contentRect,
          target
        }) => {
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };
  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }
    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}
;// ./node_modules/swiper/core/modules/observer/observer.js


function Observer({
  swiper,
  extendParams,
  on,
  emit
}) {
  const observers = [];
  const window = ssr_window_esm_getWindow();
  const attach = (target, options = {}) => {
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = utils_elementParents(swiper.el);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    // Observe container
    attach(swiper.el, {
      childList: swiper.params.observeSlideChildren
    });

    // Observe wrapper
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}
;// ./node_modules/swiper/core/events-emitter.js
/* eslint-disable no-underscore-dangle */

/* harmony default export */ var events_emitter = ({
  on(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    function onceHandler(...args) {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit(...args) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
});
;// ./node_modules/swiper/core/update/updateSize.js

function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }

  // Subtract paddings
  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}
;// ./node_modules/swiper/core/update/updateSlides.js

function updateSlides() {
  const swiper = this;
  function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    }
    // prettier-ignore
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;

  // reset margins
  slides.forEach(slideEl => {
    if (rtl) {
      slideEl.style.marginLeft = '';
    } else {
      slideEl.style.marginRight = '';
    }
    slideEl.style.marginBottom = '';
    slideEl.style.marginTop = '';
  });

  // reset cssMode offsets
  if (params.centeredSlides && params.cssMode) {
    utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
    utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slidesLength);
  }

  // Calc slides
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide;
    if (slides[i]) slide = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
    }
    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[getDirectionLabel('width')] = ``;
      }
      const slideStyles = getComputedStyle(slide);
      const currentTransform = slide.style.transform;
      const currentWebKitTransform = slide.style.webkitTransform;
      if (currentTransform) {
        slide.style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach(slideEl => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(snap => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    utils_setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}
;// ./node_modules/swiper/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}
;// ./node_modules/swiper/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  // eslint-disable-next-line
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}
;// ./node_modules/swiper/core/update/updateSlidesProgress.js
function updateSlidesProgress(translate = this && this.translate || 0) {
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.forEach(slideEl => {
    slideEl.classList.remove(params.slideVisibleClass);
  });
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
      slides[i].classList.add(params.slideVisibleClass);
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}
;// ./node_modules/swiper/core/update/updateProgress.js
function updateProgress(translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}
;// ./node_modules/swiper/core/update/updateSlidesClasses.js

function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const getFilteredSlide = selector => {
    return utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  slides.forEach(slideEl => {
    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
  });
  let activeSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    activeSlide = slides[activeIndex];
  }
  if (activeSlide) {
    // Active classes
    activeSlide.classList.add(params.slideActiveClass);

    // Next Slide
    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    if (params.loop && !nextSlide) {
      nextSlide = slides[0];
    }
    if (nextSlide) {
      nextSlide.classList.add(params.slideNextClass);
    }
    // Prev Slide
    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    if (params.loop && !prevSlide === 0) {
      prevSlide = slides[slides.length - 1];
    }
    if (prevSlide) {
      prevSlide.classList.add(params.slidePrevClass);
    }
  }
  swiper.emitSlidesClasses();
}
;// ./node_modules/swiper/shared/process-lazy-preloader.js
const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute('loading');
};
const preload = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};
;// ./node_modules/swiper/core/update/updateActiveIndex.js

function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== 'undefined') {
      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = aIndex => {
    let realIndex = aIndex - swiper.virtual.slidesBefore;
    if (realIndex < 0) {
      realIndex = swiper.virtual.slides.length + realIndex;
    }
    if (realIndex >= swiper.virtual.slides.length) {
      realIndex -= swiper.virtual.slides.length;
    }
    return realIndex;
  };
  if (typeof activeIndex === 'undefined') {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.realIndex = getVirtualRealIndex(activeIndex);
    }
    return;
  }
  // Get real index
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (swiper.slides[activeIndex]) {
    realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}
;// ./node_modules/swiper/core/update/updateClickedSlide.js
function updateClickedSlide(e) {
  const swiper = this;
  const params = swiper.params;
  const slide = e.closest(`.${params.slideClass}, swiper-slide`);
  let slideFound = false;
  let slideIndex;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
;// ./node_modules/swiper/core/update/index.js









/* harmony default export */ var update = ({
  updateSize: updateSize,
  updateSlides: updateSlides,
  updateAutoHeight: updateAutoHeight,
  updateSlidesOffset: updateSlidesOffset,
  updateSlidesProgress: updateSlidesProgress,
  updateProgress: updateProgress,
  updateSlidesClasses: updateSlidesClasses,
  updateActiveIndex: updateActiveIndex,
  updateClickedSlide: updateClickedSlide
});
;// ./node_modules/swiper/core/translate/getTranslate.js

function getSwiperTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  let currentTranslate = utils_getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
;// ./node_modules/swiper/core/translate/setTranslate.js
function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}
;// ./node_modules/swiper/core/translate/minTranslate.js
function minTranslate() {
  return -this.snapGrid[0];
}
;// ./node_modules/swiper/core/translate/maxTranslate.js
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
;// ./node_modules/swiper/core/translate/translateTo.js

function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
;// ./node_modules/swiper/core/translate/index.js





/* harmony default export */ var translate = ({
  getTranslate: getSwiperTranslate,
  setTranslate: setTranslate,
  minTranslate: minTranslate,
  maxTranslate: maxTranslate,
  translateTo: translateTo
});
;// ./node_modules/swiper/core/transition/setTransition.js
function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
  }
  swiper.emit('setTransition', duration, byController);
}
;// ./node_modules/swiper/core/transition/transitionEmit.js
function transitionEmit({
  swiper,
  runCallbacks,
  direction,
  step
}) {
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}
;// ./node_modules/swiper/core/transition/transitionStart.js

function transitionStart(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}
;// ./node_modules/swiper/core/transition/transitionEnd.js

function transitionEnd(runCallbacks = true, direction) {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}
;// ./node_modules/swiper/core/transition/index.js



/* harmony default export */ var transition = ({
  setTransition: setTransition,
  transitionStart: transitionStart,
  transitionEnd: transitionEnd
});
;// ./node_modules/swiper/core/slide/slideTo.js

function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
  if (typeof index === 'string') {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate = -snapGrid[snapIndex];
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  // Update progress
  swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

  // Update Index
  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}
;// ./node_modules/swiper/core/slide/slideToLoop.js
function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
  if (typeof index === 'string') {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      // eslint-disable-next-line
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      newIndex = swiper.getSlideIndexByData(newIndex);
    }
  }
  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
;// ./node_modules/swiper/core/slide/slideNext.js
/* eslint no-unused-vars: "off" */
function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled) return swiper;
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'next'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
;// ./node_modules/swiper/core/slide/slidePrev.js
/* eslint no-unused-vars: "off" */
function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled) return swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'prev'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
;// ./node_modules/swiper/core/slide/slideReset.js
/* eslint no-unused-vars: "off" */
function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
  const swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
;// ./node_modules/swiper/core/slide/slideToClosest.js
/* eslint no-unused-vars: "off" */
function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
  const swiper = this;
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}
;// ./node_modules/swiper/core/slide/slideToClickedSlide.js

function slideToClickedSlide() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        utils_nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      utils_nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
;// ./node_modules/swiper/core/slide/index.js







/* harmony default export */ var slide = ({
  slideTo: slideTo,
  slideToLoop: slideToLoop,
  slideNext: slideNext,
  slidePrev: slidePrev,
  slideReset: slideReset,
  slideToClosest: slideToClosest,
  slideToClickedSlide: slideToClickedSlide
});
;// ./node_modules/swiper/core/loop/loopCreate.js

function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  slides.forEach((el, index) => {
    el.setAttribute('data-swiper-slide-index', index);
  });
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? undefined : 'next'
  });
}
;// ./node_modules/swiper/core/loop/loopFix.js
function loopFix({
  slideRealIndex,
  slideTo = true,
  direction,
  setTranslate,
  activeSlideIndex,
  byController,
  byMousewheel
} = {}) {
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit('beforeLoopFix');
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
    return;
  }
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
  let loopedSlides = params.loopedSlides || slidesPerView;
  if (loopedSlides % params.slidesPerGroup !== 0) {
    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
  }
  swiper.loopedSlides = loopedSlides;
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === 'undefined') {
    activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === 'next' || !direction;
  const isPrev = direction === 'prev' || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  // prepend last slides before start
  if (activeSlideIndex < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
      const index = i - Math.floor(i / slides.length) * slides.length;
      prependSlidesIndexes.push(slides.length - index - 1);
    }
  } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {
    slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / slides.length) * slides.length;
      appendSlidesIndexes.push(index);
    }
  }
  if (isPrev) {
    prependSlidesIndexes.forEach(index => {
      swiper.slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(swiper.slides[index]);
      swiper.slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach(index => {
      swiper.slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(swiper.slides[index]);
      swiper.slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === 'auto') {
    swiper.updateSlides();
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
          if (setTranslate) {
            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
          }
        }
      } else {
        if (setTranslate) {
          swiper.slideToLoop(slideRealIndex, 0, false, true);
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate) {
            swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;
          }
        }
      } else {
        swiper.slideToLoop(slideRealIndex, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      slideTo: false,
      direction,
      setTranslate,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach(c => {
        if (!c.destroyed && c.params.loop) c.loopFix(loopParams);
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix(loopParams);
    }
  }
  swiper.emit('loopFix');
}
;// ./node_modules/swiper/core/loop/loopDestroy.js
function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach(slideEl => {
    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach(slideEl => {
    slideEl.removeAttribute('data-swiper-slide-index');
  });
  newSlidesOrder.forEach(slideEl => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}
;// ./node_modules/swiper/core/loop/index.js



/* harmony default export */ var loop = ({
  loopCreate: loopCreate,
  loopFix: loopFix,
  loopDestroy: loopDestroy
});
;// ./node_modules/swiper/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
;// ./node_modules/swiper/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}
;// ./node_modules/swiper/core/grab-cursor/index.js


/* harmony default export */ var grab_cursor = ({
  setGrabCursor: setGrabCursor,
  unsetGrabCursor: unsetGrabCursor
});
;// ./node_modules/swiper/core/events/onTouchStart.js



// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
function closestElement(selector, base = this) {
  function __closestFrom(el) {
    if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function onTouchStart(event) {
  const swiper = this;
  const document = ssr_window_esm_getDocument();
  const window = ssr_window_esm_getWindow();
  const data = swiper.touchEventsData;
  data.evCache.push(event);
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let targetEl = e.target;
  if (params.touchEventsTarget === 'wrapper') {
    if (!swiper.wrapperEl.contains(targetEl)) return;
  }
  if ('which' in e && e.which === 3) return;
  if ('button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;

  // change target el for shadow root component
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  // eslint-disable-next-line
  const eventPath = event.composedPath ? event.composedPath() : event.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);

  // use closestElement for shadow root element to get the actual closest for nested shadow root element
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = utils_now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === 'SELECT') {
      data.isTouched = false;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {
    document.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit('touchStart', e);
}
;// ./node_modules/swiper/core/events/onTouchMove.js


function onTouchMove(event) {
  const document = ssr_window_esm_getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
  if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
  const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        prevX: swiper.touches.currentX,
        prevY: swiper.touches.currentY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = utils_now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document.activeElement) {
    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
  const isLoop = swiper.params.loop && !params.cssMode;
  if (!data.isMoved) {
    if (isLoop) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent('transitionend', {
        bubbles: true,
        cancelable: true
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  let loopFixed;
  if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {
    // need another loop fix
    swiper.loopFix({
      direction: swiper.swipeDirection,
      setTranslate: true
    });
    loopFixed = true;
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {
      swiper.loopFix({
        direction: 'prev',
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: 'next',
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }

  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}
;// ./node_modules/swiper/core/events/onTouchEnd.js

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);
  if (pointerIndex >= 0) {
    data.evCache.splice(pointerIndex, 1);
  }
  if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {
    const proceed = event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = utils_now();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = utils_now();
  utils_nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }

  // Find current slide
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
;// ./node_modules/swiper/core/events/onResize.js
function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
;// ./node_modules/swiper/core/events/onClick.js
function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}
;// ./node_modules/swiper/core/events/onScroll.js
function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}
;// ./node_modules/swiper/core/events/onLoad.js

function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}
;// ./node_modules/swiper/core/events/index.js








let dummyEventAttached = false;
function dummyEventListener() {}
const events = (swiper, method) => {
  const document = ssr_window_esm_getDocument();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method;

  // Touch Events
  el[domMethod]('pointerdown', swiper.onTouchStart, {
    passive: false
  });
  document[domMethod]('pointermove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('pointerup', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointercancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerout', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerleave', swiper.onTouchEnd, {
    passive: true
  });

  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }

  // Images loader
  el[domMethod]('load', swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const document = ssr_window_esm_getDocument();
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  if (!dummyEventAttached) {
    document.addEventListener('touchstart', dummyEventListener);
    dummyEventAttached = true;
  }
  events(swiper, 'on');
}
function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}
/* harmony default export */ var core_events = ({
  attachEvents,
  detachEvents
});
;// ./node_modules/swiper/core/breakpoints/setBreakpoint.js

const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }

  // Toggle navigation, pagination, scrollbar
  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
    if (typeof breakpointParams[prop] === 'undefined') return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  utils_extend(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);
  if (needsReLoop && initialized) {
    swiper.loopDestroy();
    swiper.loopCreate(realIndex);
    swiper.updateSlides();
  }
  swiper.emit('breakpoint', breakpointParams);
}
;// ./node_modules/swiper/core/breakpoints/getBreakpoint.js

function getBreakpoint(breakpoints, base = 'window', containerEl) {
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = ssr_window_esm_getWindow();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];
    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}
;// ./node_modules/swiper/core/breakpoints/index.js


/* harmony default export */ var breakpoints = ({
  setBreakpoint: setBreakpoint,
  getBreakpoint: getBreakpoint
});
;// ./node_modules/swiper/core/classes/addClasses.js
function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  // prettier-ignore
  const suffixes = prepareClasses(['initialized', params.direction, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }, {
    'watch-progress': params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}
;// ./node_modules/swiper/core/classes/removeClasses.js
function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}
;// ./node_modules/swiper/core/classes/index.js


/* harmony default export */ var classes = ({
  addClasses: addClasses,
  removeClasses: removeClasses
});
;// ./node_modules/swiper/core/check-overflow/index.js
function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}
/* harmony default export */ var check_overflow = ({
  checkOverflow
});
;// ./node_modules/swiper/core/defaults.js
/* harmony default export */ var defaults = ({
  init: true,
  direction: 'horizontal',
  oneWayMovement: false,
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopedSlides: null,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideActiveClass: 'swiper-slide-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideNextClass: 'swiper-slide-next',
  slidePrevClass: 'swiper-slide-prev',
  wrapperClass: 'swiper-wrapper',
  lazyPreloaderClass: 'swiper-lazy-preloader',
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
});
;// ./node_modules/swiper/core/moduleExtendParams.js

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj = {}) {
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== 'object' || moduleParams === null) {
      utils_extend(allModulesParams, obj);
      return;
    }
    if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
      params[moduleParamName] = {
        auto: true
      };
    }
    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      utils_extend(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    utils_extend(allModulesParams, obj);
  };
}
;// ./node_modules/swiper/core/core.js
/* eslint no-param-reassign: "off" */





















const prototypes = {
  eventsEmitter: events_emitter,
  update: update,
  translate: translate,
  transition: transition,
  slide: slide,
  loop: loop,
  grabCursor: grab_cursor,
  events: core_events,
  breakpoints: breakpoints,
  checkOverflow: check_overflow,
  classes: classes
};
const extendedDefaults = {};
class Swiper {
  constructor(...args) {
    let el;
    let params;
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = utils_extend({}, params);
    if (el && !params.el) params.el = el;
    const document = ssr_window_esm_getDocument();
    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document.querySelectorAll(params.el).forEach(containerEl => {
        const newParams = utils_extend({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      // eslint-disable-next-line no-constructor-return
      return swipers;
    }

    // Swiper Instance
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });

    // Extend defaults with modules params
    const swiperParams = utils_extend({}, defaults, allModulesParams);

    // Extend defaults with passed params
    swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = utils_extend({}, swiper.params);
    swiper.passedParams = utils_extend({}, params);

    // add event listeners
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }

    // Extend Swiper
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        // Returns 0 unless `translate` is > 2**23
        // Should be subtracted from css values to prevent overflow
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        startMoving: undefined,
        evCache: []
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper');

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    // eslint-disable-next-line no-constructor-return
    return swiper;
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = utils_elementIndex(slides[0]);
    return utils_elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit('enable');
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit('disable');
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return '';
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }
  slidesPerViewDynamic(view = 'current', exact = false) {
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }
  changeDirection(newDirection, needUpdate = true) {
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;

    // Find el
    let el = element || swiper.params.el;
    if (typeof el === 'string') {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.shadowEl) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        // Children needs to return slot items
        return res;
      }
      return utils_elementChildren(el, getWrapperSelector())[0];
    };
    // Find Wrapper
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = utils_createElement('div', swiper.params.wrapperClass);
      el.append(wrapperEl);
      utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement ? el : wrapperEl,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    // Slide To Initial Slide
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Attach events
    swiper.attachEvents();
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener('load', e => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);

    // Init Flag
    swiper.initialized = true;
    preload(swiper);

    // Emit
    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }
  destroy(deleteInstance = true, cleanStyles = true) {
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }
    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      el.removeAttribute('style');
      wrapperEl.removeAttribute('style');
      if (slides && slides.length) {
        slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute('style');
          slideEl.removeAttribute('data-swiper-slide-index');
        });
      }
    }
    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper.el.swiper = null;
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    utils_extend(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
}
Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([Resize, Observer]);
/* harmony default export */ var core = (Swiper);
;// ./node_modules/swiper/modules/virtual/virtual.js


function Virtual({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    virtual: {
      enabled: false,
      slides: [],
      cache: true,
      renderSlide: null,
      renderExternal: null,
      renderExternalUpdate: true,
      addSlidesBefore: 0,
      addSlidesAfter: 0
    }
  });
  let cssModeTimeout;
  const document = getDocument();
  swiper.virtual = {
    cache: {},
    from: undefined,
    to: undefined,
    slides: [],
    offset: 0,
    slidesGrid: []
  };
  const tempDOM = document.createElement('div');
  function renderSlide(slide, index) {
    const params = swiper.params.virtual;
    if (params.cache && swiper.virtual.cache[index]) {
      return swiper.virtual.cache[index];
    }
    // eslint-disable-next-line
    let slideEl;
    if (params.renderSlide) {
      slideEl = params.renderSlide.call(swiper, slide, index);
      if (typeof slideEl === 'string') {
        tempDOM.innerHTML = slideEl;
        slideEl = tempDOM.children[0];
      }
    } else if (swiper.isElement) {
      slideEl = createElement('swiper-slide');
    } else {
      slideEl = createElement('div', swiper.params.slideClass);
    }
    slideEl.setAttribute('data-swiper-slide-index', index);
    if (!params.renderSlide) {
      slideEl.innerHTML = slide;
    }
    if (params.cache) swiper.virtual.cache[index] = slideEl;
    return slideEl;
  }
  function update(force) {
    const {
      slidesPerView,
      slidesPerGroup,
      centeredSlides,
      loop: isLoop
    } = swiper.params;
    const {
      addSlidesBefore,
      addSlidesAfter
    } = swiper.params.virtual;
    const {
      from: previousFrom,
      to: previousTo,
      slides,
      slidesGrid: previousSlidesGrid,
      offset: previousOffset
    } = swiper.virtual;
    if (!swiper.params.cssMode) {
      swiper.updateActiveIndex();
    }
    const activeIndex = swiper.activeIndex || 0;
    let offsetProp;
    if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';
    let slidesAfter;
    let slidesBefore;
    if (centeredSlides) {
      slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
    } else {
      slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
      slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
    }
    let from = activeIndex - slidesBefore;
    let to = activeIndex + slidesAfter;
    if (!isLoop) {
      from = Math.max(from, 0);
      to = Math.min(to, slides.length - 1);
    }
    let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
    if (isLoop && activeIndex >= slidesBefore) {
      from -= slidesBefore;
      if (!centeredSlides) offset += swiper.slidesGrid[0];
    } else if (isLoop && activeIndex < slidesBefore) {
      from = -slidesBefore;
      if (centeredSlides) offset += swiper.slidesGrid[0];
    }
    Object.assign(swiper.virtual, {
      from,
      to,
      offset,
      slidesGrid: swiper.slidesGrid,
      slidesBefore,
      slidesAfter
    });
    function onRendered() {
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();
      emit('virtualUpdate');
    }
    if (previousFrom === from && previousTo === to && !force) {
      if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
        swiper.slides.forEach(slideEl => {
          slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
        });
      }
      swiper.updateProgress();
      emit('virtualUpdate');
      return;
    }
    if (swiper.params.virtual.renderExternal) {
      swiper.params.virtual.renderExternal.call(swiper, {
        offset,
        from,
        to,
        slides: function getSlides() {
          const slidesToRender = [];
          for (let i = from; i <= to; i += 1) {
            slidesToRender.push(slides[i]);
          }
          return slidesToRender;
        }()
      });
      if (swiper.params.virtual.renderExternalUpdate) {
        onRendered();
      } else {
        emit('virtualUpdate');
      }
      return;
    }
    const prependIndexes = [];
    const appendIndexes = [];
    const getSlideIndex = index => {
      let slideIndex = index;
      if (index < 0) {
        slideIndex = slides.length + index;
      } else if (slideIndex >= slides.length) {
        // eslint-disable-next-line
        slideIndex = slideIndex - slides.length;
      }
      return slideIndex;
    };
    if (force) {
      swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach(slideEl => {
        slideEl.remove();
      });
    } else {
      for (let i = previousFrom; i <= previousTo; i += 1) {
        if (i < from || i > to) {
          const slideIndex = getSlideIndex(i);
          swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`).forEach(slideEl => {
            slideEl.remove();
          });
        }
      }
    }
    const loopFrom = isLoop ? -slides.length : 0;
    const loopTo = isLoop ? slides.length * 2 : slides.length;
    for (let i = loopFrom; i < loopTo; i += 1) {
      if (i >= from && i <= to) {
        const slideIndex = getSlideIndex(i);
        if (typeof previousTo === 'undefined' || force) {
          appendIndexes.push(slideIndex);
        } else {
          if (i > previousTo) appendIndexes.push(slideIndex);
          if (i < previousFrom) prependIndexes.push(slideIndex);
        }
      }
    }
    appendIndexes.forEach(index => {
      swiper.slidesEl.append(renderSlide(slides[index], index));
    });
    if (isLoop) {
      for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
        const index = prependIndexes[i];
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      }
    } else {
      prependIndexes.sort((a, b) => b - a);
      prependIndexes.forEach(index => {
        swiper.slidesEl.prepend(renderSlide(slides[index], index));
      });
    }
    elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {
      slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
    });
    onRendered();
  }
  function appendSlide(slides) {
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.push(slides[i]);
      }
    } else {
      swiper.virtual.slides.push(slides);
    }
    update(true);
  }
  function prependSlide(slides) {
    const activeIndex = swiper.activeIndex;
    let newActiveIndex = activeIndex + 1;
    let numberOfNewSlides = 1;
    if (Array.isArray(slides)) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
      numberOfNewSlides = slides.length;
    } else {
      swiper.virtual.slides.unshift(slides);
    }
    if (swiper.params.virtual.cache) {
      const cache = swiper.virtual.cache;
      const newCache = {};
      Object.keys(cache).forEach(cachedIndex => {
        const cachedEl = cache[cachedIndex];
        const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');
        if (cachedElIndex) {
          cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);
        }
        newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
      });
      swiper.virtual.cache = newCache;
    }
    update(true);
    swiper.slideTo(newActiveIndex, 0);
  }
  function removeSlide(slidesIndexes) {
    if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
    let activeIndex = swiper.activeIndex;
    if (Array.isArray(slidesIndexes)) {
      for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
        swiper.virtual.slides.splice(slidesIndexes[i], 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes[i]];
        }
        if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
    } else {
      swiper.virtual.slides.splice(slidesIndexes, 1);
      if (swiper.params.virtual.cache) {
        delete swiper.virtual.cache[slidesIndexes];
      }
      if (slidesIndexes < activeIndex) activeIndex -= 1;
      activeIndex = Math.max(activeIndex, 0);
    }
    update(true);
    swiper.slideTo(activeIndex, 0);
  }
  function removeAllSlides() {
    swiper.virtual.slides = [];
    if (swiper.params.virtual.cache) {
      swiper.virtual.cache = {};
    }
    update(true);
    swiper.slideTo(0, 0);
  }
  on('beforeInit', () => {
    if (!swiper.params.virtual.enabled) return;
    let domSlidesAssigned;
    if (typeof swiper.passedParams.virtual.slides === 'undefined') {
      const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));
      if (slides && slides.length) {
        swiper.virtual.slides = [...slides];
        domSlidesAssigned = true;
        slides.forEach((slideEl, slideIndex) => {
          slideEl.setAttribute('data-swiper-slide-index', slideIndex);
          swiper.virtual.cache[slideIndex] = slideEl;
          slideEl.remove();
        });
      }
    }
    if (!domSlidesAssigned) {
      swiper.virtual.slides = swiper.params.virtual.slides;
    }
    swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
    if (!swiper.params.initialSlide) {
      update();
    }
  });
  on('setTranslate', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode && !swiper._immediateVirtual) {
      clearTimeout(cssModeTimeout);
      cssModeTimeout = setTimeout(() => {
        update();
      }, 100);
    } else {
      update();
    }
  });
  on('init update resize', () => {
    if (!swiper.params.virtual.enabled) return;
    if (swiper.params.cssMode) {
      setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);
    }
  });
  Object.assign(swiper.virtual, {
    appendSlide,
    prependSlide,
    removeSlide,
    removeAllSlides,
    update
  });
}
;// ./node_modules/swiper/modules/keyboard/keyboard.js
/* eslint-disable consistent-return */


function Keyboard({
  swiper,
  extendParams,
  on,
  emit
}) {
  const document = getDocument();
  const window = getWindow();
  swiper.keyboard = {
    enabled: false
  };
  extendParams({
    keyboard: {
      enabled: false,
      onlyInViewport: true,
      pageUpDown: true
    }
  });
  function handle(event) {
    if (!swiper.enabled) return;
    const {
      rtlTranslate: rtl
    } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    const kc = e.keyCode || e.charCode;
    const pageUpDown = swiper.params.keyboard.pageUpDown;
    const isPageUp = pageUpDown && kc === 33;
    const isPageDown = pageUpDown && kc === 34;
    const isArrowLeft = kc === 37;
    const isArrowRight = kc === 39;
    const isArrowUp = kc === 38;
    const isArrowDown = kc === 40;
    // Directions locks
    if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
      return false;
    }
    if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
      return false;
    }
    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
      return undefined;
    }
    if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
      return undefined;
    }
    if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
      let inView = false;
      // Check that swiper should be inside of visible area of window
      if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
        return undefined;
      }
      const el = swiper.el;
      const swiperWidth = el.clientWidth;
      const swiperHeight = el.clientHeight;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const swiperOffset = elementOffset(el);
      if (rtl) swiperOffset.left -= el.scrollLeft;
      const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];
      for (let i = 0; i < swiperCoord.length; i += 1) {
        const point = swiperCoord[i];
        if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
          inView = true;
        }
      }
      if (!inView) return undefined;
    }
    if (swiper.isHorizontal()) {
      if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
      if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
    } else {
      if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      if (isPageDown || isArrowDown) swiper.slideNext();
      if (isPageUp || isArrowUp) swiper.slidePrev();
    }
    emit('keyPress', kc);
    return undefined;
  }
  function enable() {
    if (swiper.keyboard.enabled) return;
    document.addEventListener('keydown', handle);
    swiper.keyboard.enabled = true;
  }
  function disable() {
    if (!swiper.keyboard.enabled) return;
    document.removeEventListener('keydown', handle);
    swiper.keyboard.enabled = false;
  }
  on('init', () => {
    if (swiper.params.keyboard.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    if (swiper.keyboard.enabled) {
      disable();
    }
  });
  Object.assign(swiper.keyboard, {
    enable,
    disable
  });
}
;// ./node_modules/swiper/modules/mousewheel/mousewheel.js
/* eslint-disable consistent-return */


function Mousewheel({
  swiper,
  extendParams,
  on,
  emit
}) {
  const window = getWindow();
  extendParams({
    mousewheel: {
      enabled: false,
      releaseOnEdges: false,
      invert: false,
      forceToAxis: false,
      sensitivity: 1,
      eventsTarget: 'container',
      thresholdDelta: null,
      thresholdTime: null,
      noMousewheelClass: 'swiper-no-mousewheel'
    }
  });
  swiper.mousewheel = {
    enabled: false
  };
  let timeout;
  let lastScrollTime = now();
  let lastEventBeforeSnap;
  const recentWheelEvents = [];
  function normalize(e) {
    // Reasonable defaults
    const PIXEL_STEP = 10;
    const LINE_HEIGHT = 40;
    const PAGE_HEIGHT = 800;
    let sX = 0;
    let sY = 0; // spinX, spinY
    let pX = 0;
    let pY = 0; // pixelX, pixelY

    // Legacy
    if ('detail' in e) {
      sY = e.detail;
    }
    if ('wheelDelta' in e) {
      sY = -e.wheelDelta / 120;
    }
    if ('wheelDeltaY' in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ('wheelDeltaX' in e) {
      sX = -e.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ('deltaY' in e) {
      pY = e.deltaY;
    }
    if ('deltaX' in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      // if user scrolls with shift he wants horizontal scroll
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  }
  function handleMouseEnter() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = true;
  }
  function handleMouseLeave() {
    if (!swiper.enabled) return;
    swiper.mouseEntered = false;
  }
  function animateSlider(newEvent) {
    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
      // Prevent if delta of wheel scroll delta is below configured threshold
      return false;
    }
    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
      // Prevent if time between scrolls is below configured threshold
      return false;
    }

    // If the movement is NOT big enough and
    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
    //   Don't go any further (avoid insignificant scroll movement).
    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
      // Return false as a default
      return true;
    }
    // If user is scrolling towards the end:
    //   If the slider hasn't hit the latest slide or
    //   if the slider is a loop and
    //   if the slider isn't moving right now:
    //     Go to next slide and
    //     emit a scroll event.
    // Else (the user is scrolling towards the beginning) and
    // if the slider hasn't hit the first slide or
    // if the slider is a loop and
    // if the slider isn't moving right now:
    //   Go to prev slide and
    //   emit a scroll event.
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        emit('scroll', newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      emit('scroll', newEvent.raw);
    }
    // If you got here is because an animation has been triggered so store the current time
    lastScrollTime = new window.Date().getTime();
    // Return false as a default
    return false;
  }
  function releaseScroll(newEvent) {
    const params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      // Return true to animate scroll on edges
      return true;
    }
    return false;
  }
  function handle(event) {
    let e = event;
    let disableParentSwiper = true;
    if (!swiper.enabled) return;

    // Ignore event if the target or its parents have the swiper-no-mousewheel class
    if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
    const params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e.preventDefault();
    }
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    const targetElContainsTarget = targetEl && targetEl.contains(e.target);
    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
    if (e.originalEvent) e = e.originalEvent; // jquery fix
    let delta = 0;
    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
    const data = normalize(e);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;
      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;
    } else {
      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
    }
    if (delta === 0) return true;
    if (params.invert) delta = -delta;

    // Get the scroll positions
    let positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();

    // When loop is true:
    //     the disableParentSwiper will be true.
    // When loop is false:
    //     if the scroll positions is not on edge,
    //     then the disableParentSwiper will be true.
    //     if the scroll on edge positions,
    //     then the disableParentSwiper will be false.
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
      // Register the new event in a variable which stores the relevant data
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event
      };

      // Keep the most recent events
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift(); // only store the last N events
      }

      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
      recentWheelEvents.push(newEvent);

      // If there is at least one previous recorded event:
      //   If direction has changed or
      //   if the scroll is quicker than the previous one:
      //     Animate the slider.
      // Else (this is the first time the wheel is moved):
      //     Animate the slider.
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          animateSlider(newEvent);
        }
      } else {
        animateSlider(newEvent);
      }

      // If it's time to release the scroll:
      //   Return now so you don't hit the preventDefault.
      if (releaseScroll(newEvent)) {
        return true;
      }
    } else {
      // Freemode or scrollContainer:

      // If we recently snapped after a momentum scroll, then ignore wheel events
      // to give time for the deceleration to finish. Stop ignoring after 500 msecs
      // or if it's a new scroll (larger delta or inverse sign as last event before
      // an end-of-momentum snap).
      const newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        lastEventBeforeSnap = undefined;
        let position = swiper.getTranslate() + delta * params.sensitivity;
        const wasBeginning = swiper.isBeginning;
        const wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate()) position = swiper.minTranslate();
        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.loop) {
          swiper.loopFix({
            direction: newEvent.direction < 0 ? 'next' : 'prev',
            byMousewheel: true
          });
        }
        if (swiper.params.freeMode.sticky) {
          // When wheel scrolling starts with sticky (aka snap) enabled, then detect
          // the end of a momentum scroll by storing recent (N=15?) wheel events.
          // 1. do all N events have decreasing or same (absolute value) delta?
          // 2. did all N events arrive in the last M (M=500?) msecs?
          // 3. does the earliest event have an (absolute value) delta that's
          //    at least P (P=1?) larger than the most recent event's delta?
          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
          // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
          // Snap immediately and ignore remaining wheel events in this scroll.
          // See comment above for "remaining wheel events in this scroll" determination.
          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
          clearTimeout(timeout);
          timeout = undefined;
          if (recentWheelEvents.length >= 15) {
            recentWheelEvents.shift(); // only store the last N events
          }

          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          const firstEvent = recentWheelEvents[0];
          recentWheelEvents.push(newEvent);
          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
            recentWheelEvents.splice(0);
          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
            // We're at the end of the deceleration of a momentum scroll, so there's no need
            // to wait for more events. Snap ASAP on the next tick.
            // Also, because there's some remaining momentum we'll bias the snap in the
            // direction of the ongoing scroll because it's better UX for the scroll to snap
            // in the same direction as the scroll instead of reversing to snap.  Therefore,
            // if it's already scrolled more than 20% in the current direction, keep going.
            const snapToThreshold = delta > 0 ? 0.8 : 0.2;
            lastEventBeforeSnap = newEvent;
            recentWheelEvents.splice(0);
            timeout = nextTick(() => {
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 0); // no delay; move on next tick
          }

          if (!timeout) {
            // if we get here, then we haven't detected the end of a momentum scroll, so
            // we'll consider a scroll "complete" when there haven't been any wheel events
            // for 500ms.
            timeout = nextTick(() => {
              const snapToThreshold = 0.5;
              lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
            }, 500);
          }
        }

        // Emit event
        if (!ignoreWheelEvents) emit('scroll', e);

        // Stop autoplay
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
        // Return page scroll on edge positions
        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
      }
    }
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    return false;
  }
  function events(method) {
    let targetEl = swiper.el;
    if (swiper.params.mousewheel.eventsTarget !== 'container') {
      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
    }
    targetEl[method]('mouseenter', handleMouseEnter);
    targetEl[method]('mouseleave', handleMouseLeave);
    targetEl[method]('wheel', handle);
  }
  function enable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener('wheel', handle);
      return true;
    }
    if (swiper.mousewheel.enabled) return false;
    events('addEventListener');
    swiper.mousewheel.enabled = true;
    return true;
  }
  function disable() {
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event, handle);
      return true;
    }
    if (!swiper.mousewheel.enabled) return false;
    events('removeEventListener');
    swiper.mousewheel.enabled = false;
    return true;
  }
  on('init', () => {
    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
      disable();
    }
    if (swiper.params.mousewheel.enabled) enable();
  });
  on('destroy', () => {
    if (swiper.params.cssMode) {
      enable();
    }
    if (swiper.mousewheel.enabled) disable();
  });
  Object.assign(swiper.mousewheel, {
    enable,
    disable
  });
}
;// ./node_modules/swiper/shared/create-element-if-not-defined.js

function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
  if (swiper.params.createElements) {
    Object.keys(checkProps).forEach(key => {
      if (!params[key] && params.auto === true) {
        let element = utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
        if (!element) {
          element = utils_createElement('div', checkProps[key]);
          element.className = checkProps[key];
          swiper.el.append(element);
        }
        params[key] = element;
        originalParams[key] = element;
      }
    });
  }
  return params;
}
;// ./node_modules/swiper/modules/navigation/navigation.js

function Navigation({
  swiper,
  extendParams,
  on,
  emit
}) {
  extendParams({
    navigation: {
      nextEl: null,
      prevEl: null,
      hideOnClick: false,
      disabledClass: 'swiper-button-disabled',
      hiddenClass: 'swiper-button-hidden',
      lockClass: 'swiper-button-lock',
      navigationDisabledClass: 'swiper-navigation-disabled'
    }
  });
  swiper.navigation = {
    nextEl: null,
    prevEl: null
  };
  const makeElementsArray = el => {
    if (!Array.isArray(el)) el = [el].filter(e => !!e);
    return el;
  };
  function getEl(el) {
    let res;
    if (el && typeof el === 'string' && swiper.isElement) {
      res = swiper.el.shadowRoot.querySelector(el);
      if (res) return res;
    }
    if (el) {
      if (typeof el === 'string') res = [...document.querySelectorAll(el)];
      if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
        res = swiper.el.querySelector(el);
      }
    }
    if (el && !res) return el;
    // if (Array.isArray(res) && res.length === 1) res = res[0];
    return res;
  }
  function toggleEl(el, disabled) {
    const params = swiper.params.navigation;
    el = makeElementsArray(el);
    el.forEach(subEl => {
      if (subEl) {
        subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));
        if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;
        if (swiper.params.watchOverflow && swiper.enabled) {
          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
        }
      }
    });
  }
  function update() {
    // Update Navigation Buttons
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (swiper.params.loop) {
      toggleEl(prevEl, false);
      toggleEl(nextEl, false);
      return;
    }
    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
  }
  function onPrevClick(e) {
    e.preventDefault();
    if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slidePrev();
    emit('navigationPrev');
  }
  function onNextClick(e) {
    e.preventDefault();
    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
    swiper.slideNext();
    emit('navigationNext');
  }
  function init() {
    const params = swiper.params.navigation;
    swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
      nextEl: 'swiper-button-next',
      prevEl: 'swiper-button-prev'
    });
    if (!(params.nextEl || params.prevEl)) return;
    let nextEl = getEl(params.nextEl);
    let prevEl = getEl(params.prevEl);
    Object.assign(swiper.navigation, {
      nextEl,
      prevEl
    });
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const initButton = (el, dir) => {
      if (el) {
        el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      }
      if (!swiper.enabled && el) {
        el.classList.add(...params.lockClass.split(' '));
      }
    };
    nextEl.forEach(el => initButton(el, 'next'));
    prevEl.forEach(el => initButton(el, 'prev'));
  }
  function destroy() {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const destroyButton = (el, dir) => {
      el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);
      el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));
    };
    nextEl.forEach(el => destroyButton(el, 'next'));
    prevEl.forEach(el => destroyButton(el, 'prev'));
  }
  on('init', () => {
    if (swiper.params.navigation.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      update();
    }
  });
  on('toEdge fromEdge lock unlock', () => {
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass));
  });
  on('click', (_s, e) => {
    let {
      nextEl,
      prevEl
    } = swiper.navigation;
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    const targetEl = e.target;
    if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
      if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
      let isHidden;
      if (nextEl.length) {
        isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      } else if (prevEl.length) {
        isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
      }
      if (isHidden === true) {
        emit('navigationShow');
      } else {
        emit('navigationHide');
      }
      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));
    init();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));
    destroy();
  };
  Object.assign(swiper.navigation, {
    enable,
    disable,
    update,
    init,
    destroy
  });
}
;// ./node_modules/swiper/shared/classes-to-selector.js
function classes_to_selector_classesToSelector(classes = '') {
  return `.${classes.trim().replace(/([\.:!+\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.')}`;
}
;// ./node_modules/swiper/modules/pagination/pagination.js



function Pagination({
  swiper,
  extendParams,
  on,
  emit
}) {
  const pfx = 'swiper-pagination';
  extendParams({
    pagination: {
      el: null,
      bulletElement: 'span',
      clickable: false,
      hideOnClick: false,
      renderBullet: null,
      renderProgressbar: null,
      renderFraction: null,
      renderCustom: null,
      progressbarOpposite: false,
      type: 'bullets',
      // 'bullets' or 'progressbar' or 'fraction' or 'custom'
      dynamicBullets: false,
      dynamicMainBullets: 1,
      formatFractionCurrent: number => number,
      formatFractionTotal: number => number,
      bulletClass: `${pfx}-bullet`,
      bulletActiveClass: `${pfx}-bullet-active`,
      modifierClass: `${pfx}-`,
      currentClass: `${pfx}-current`,
      totalClass: `${pfx}-total`,
      hiddenClass: `${pfx}-hidden`,
      progressbarFillClass: `${pfx}-progressbar-fill`,
      progressbarOppositeClass: `${pfx}-progressbar-opposite`,
      clickableClass: `${pfx}-clickable`,
      lockClass: `${pfx}-lock`,
      horizontalClass: `${pfx}-horizontal`,
      verticalClass: `${pfx}-vertical`,
      paginationDisabledClass: `${pfx}-disabled`
    }
  });
  swiper.pagination = {
    el: null,
    bullets: []
  };
  let bulletSize;
  let dynamicBulletIndex = 0;
  const makeElementsArray = el => {
    if (!Array.isArray(el)) el = [el].filter(e => !!e);
    return el;
  };
  function isPaginationDisabled() {
    return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
  }
  function setSideBullets(bulletEl, position) {
    const {
      bulletActiveClass
    } = swiper.params.pagination;
    if (!bulletEl) return;
    bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
    if (bulletEl) {
      bulletEl.classList.add(`${bulletActiveClass}-${position}`);
      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];
      if (bulletEl) {
        bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
      }
    }
  }
  function onBulletClick(e) {
    const bulletEl = e.target.closest(classes_to_selector_classesToSelector(swiper.params.pagination.bulletClass));
    if (!bulletEl) {
      return;
    }
    e.preventDefault();
    const index = utils_elementIndex(bulletEl) * swiper.params.slidesPerGroup;
    if (swiper.params.loop) {
      if (swiper.realIndex === index) return;
      const newSlideIndex = swiper.getSlideIndexByData(index);
      const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);
      if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {
        swiper.loopFix({
          direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',
          activeSlideIndex: newSlideIndex,
          slideTo: false
        });
      }
      swiper.slideToLoop(index);
    } else {
      swiper.slideTo(index);
    }
  }
  function update() {
    // Render || Update Pagination bullets/items
    const rtl = swiper.rtl;
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    // Current/Total
    let current;
    let previousIndex;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
    if (swiper.params.loop) {
      previousIndex = swiper.previousRealIndex || 0;
      current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
    } else if (typeof swiper.snapIndex !== 'undefined') {
      current = swiper.snapIndex;
      previousIndex = swiper.previousSnapIndex;
    } else {
      previousIndex = swiper.previousIndex || 0;
      current = swiper.activeIndex || 0;
    }
    // Types
    if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
      const bullets = swiper.pagination.bullets;
      let firstIndex;
      let lastIndex;
      let midIndex;
      if (params.dynamicBullets) {
        bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);
        el.forEach(subEl => {
          subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
        });
        if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {
          dynamicBulletIndex += current - (previousIndex || 0);
          if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
            dynamicBulletIndex = params.dynamicMainBullets - 1;
          } else if (dynamicBulletIndex < 0) {
            dynamicBulletIndex = 0;
          }
        }
        firstIndex = Math.max(current - dynamicBulletIndex, 0);
        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
        midIndex = (lastIndex + firstIndex) / 2;
      }
      bullets.forEach(bulletEl => {
        const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();
        bulletEl.classList.remove(...classesToRemove);
      });
      if (el.length > 1) {
        bullets.forEach(bullet => {
          const bulletIndex = utils_elementIndex(bullet);
          if (bulletIndex === current) {
            bullet.classList.add(...params.bulletActiveClass.split(' '));
          } else if (swiper.isElement) {
            bullet.setAttribute('part', 'bullet');
          }
          if (params.dynamicBullets) {
            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
              bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
            if (bulletIndex === firstIndex) {
              setSideBullets(bullet, 'prev');
            }
            if (bulletIndex === lastIndex) {
              setSideBullets(bullet, 'next');
            }
          }
        });
      } else {
        const bullet = bullets[current];
        if (bullet) {
          bullet.classList.add(...params.bulletActiveClass.split(' '));
        }
        if (swiper.isElement) {
          bullets.forEach((bulletEl, bulletIndex) => {
            bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');
          });
        }
        if (params.dynamicBullets) {
          const firstDisplayedBullet = bullets[firstIndex];
          const lastDisplayedBullet = bullets[lastIndex];
          for (let i = firstIndex; i <= lastIndex; i += 1) {
            if (bullets[i]) {
              bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));
            }
          }
          setSideBullets(firstDisplayedBullet, 'prev');
          setSideBullets(lastDisplayedBullet, 'next');
        }
      }
      if (params.dynamicBullets) {
        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
        const offsetProp = rtl ? 'right' : 'left';
        bullets.forEach(bullet => {
          bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;
        });
      }
    }
    el.forEach((subEl, subElIndex) => {
      if (params.type === 'fraction') {
        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.currentClass)).forEach(fractionEl => {
          fractionEl.textContent = params.formatFractionCurrent(current + 1);
        });
        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.totalClass)).forEach(totalEl => {
          totalEl.textContent = params.formatFractionTotal(total);
        });
      }
      if (params.type === 'progressbar') {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        subEl.querySelectorAll(classes_to_selector_classesToSelector(params.progressbarFillClass)).forEach(progressEl => {
          progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
          progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
        });
      }
      if (params.type === 'custom' && params.renderCustom) {
        subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
        if (subElIndex === 0) emit('paginationRender', subEl);
      } else {
        if (subElIndex === 0) emit('paginationRender', subEl);
        emit('paginationUpdate', subEl);
      }
      if (swiper.params.watchOverflow && swiper.enabled) {
        subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);
      }
    });
  }
  function render() {
    // Render Container
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
    let el = swiper.pagination.el;
    el = makeElementsArray(el);
    let paginationHTML = '';
    if (params.type === 'bullets') {
      let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
        numberOfBullets = slidesLength;
      }
      for (let i = 0; i < numberOfBullets; i += 1) {
        if (params.renderBullet) {
          paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
        } else {
          // prettier-ignore
          paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
        }
      }
    }
    if (params.type === 'fraction') {
      if (params.renderFraction) {
        paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
      } else {
        paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
      }
    }
    if (params.type === 'progressbar') {
      if (params.renderProgressbar) {
        paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
      } else {
        paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
      }
    }
    swiper.pagination.bullets = [];
    el.forEach(subEl => {
      if (params.type !== 'custom') {
        subEl.innerHTML = paginationHTML || '';
      }
      if (params.type === 'bullets') {
        swiper.pagination.bullets.push(...subEl.querySelectorAll(classes_to_selector_classesToSelector(params.bulletClass)));
      }
    });
    if (params.type !== 'custom') {
      emit('paginationRender', el[0]);
    }
  }
  function init() {
    swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
      el: 'swiper-pagination'
    });
    const params = swiper.params.pagination;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.shadowRoot.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = [...document.querySelectorAll(params.el)];
    }
    if (!el) {
      el = params.el;
    }
    if (!el || el.length === 0) return;
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {
      el = [...swiper.el.querySelectorAll(params.el)];
      // check if it belongs to another nested Swiper
      if (el.length > 1) {
        el = el.filter(subEl => {
          if (utils_elementParents(subEl, '.swiper')[0] !== swiper.el) return false;
          return true;
        })[0];
      }
    }
    if (Array.isArray(el) && el.length === 1) el = el[0];
    Object.assign(swiper.pagination, {
      el
    });
    el = makeElementsArray(el);
    el.forEach(subEl => {
      if (params.type === 'bullets' && params.clickable) {
        subEl.classList.add(params.clickableClass);
      }
      subEl.classList.add(params.modifierClass + params.type);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
      if (params.type === 'bullets' && params.dynamicBullets) {
        subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
        dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === 'progressbar' && params.progressbarOpposite) {
        subEl.classList.add(params.progressbarOppositeClass);
      }
      if (params.clickable) {
        subEl.addEventListener('click', onBulletClick);
      }
      if (!swiper.enabled) {
        subEl.classList.add(params.lockClass);
      }
    });
  }
  function destroy() {
    const params = swiper.params.pagination;
    if (isPaginationDisabled()) return;
    let el = swiper.pagination.el;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => {
        subEl.classList.remove(params.hiddenClass);
        subEl.classList.remove(params.modifierClass + params.type);
        subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        if (params.clickable) {
          subEl.removeEventListener('click', onBulletClick);
        }
      });
    }
    if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));
  }
  on('changeDirection', () => {
    if (!swiper.pagination || !swiper.pagination.el) return;
    const params = swiper.params.pagination;
    let {
      el
    } = swiper.pagination;
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.classList.remove(params.horizontalClass, params.verticalClass);
      subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    });
  });
  on('init', () => {
    if (swiper.params.pagination.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      render();
      update();
    }
  });
  on('activeIndexChange', () => {
    if (typeof swiper.snapIndex === 'undefined') {
      update();
    }
  });
  on('snapIndexChange', () => {
    update();
  });
  on('snapGridLengthChange', () => {
    render();
    update();
  });
  on('destroy', () => {
    destroy();
  });
  on('enable disable', () => {
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));
    }
  });
  on('lock unlock', () => {
    update();
  });
  on('click', (_s, e) => {
    const targetEl = e.target;
    let {
      el
    } = swiper.pagination;
    if (!Array.isArray(el)) el = [el].filter(element => !!element);
    if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
      if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
      const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
      if (isHidden === true) {
        emit('paginationShow');
      } else {
        emit('paginationHide');
      }
      el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));
    }
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
    }
    init();
    render();
    update();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
    let {
      el
    } = swiper.pagination;
    if (el) {
      el = makeElementsArray(el);
      el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
    }
    destroy();
  };
  Object.assign(swiper.pagination, {
    enable,
    disable,
    render,
    update,
    init,
    destroy
  });
}
;// ./node_modules/swiper/modules/scrollbar/scrollbar.js



function Scrollbar({
  swiper,
  extendParams,
  on,
  emit
}) {
  const document = ssr_window_esm_getDocument();
  let isTouched = false;
  let timeout = null;
  let dragTimeout = null;
  let dragStartPos;
  let dragSize;
  let trackSize;
  let divider;
  extendParams({
    scrollbar: {
      el: null,
      dragSize: 'auto',
      hide: false,
      draggable: false,
      snapOnRelease: true,
      lockClass: 'swiper-scrollbar-lock',
      dragClass: 'swiper-scrollbar-drag',
      scrollbarDisabledClass: 'swiper-scrollbar-disabled',
      horizontalClass: `swiper-scrollbar-horizontal`,
      verticalClass: `swiper-scrollbar-vertical`
    }
  });
  swiper.scrollbar = {
    el: null,
    dragEl: null
  };
  function setTranslate() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    const params = swiper.params.scrollbar;
    const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
    let newSize = dragSize;
    let newPos = (trackSize - dragSize) * progress;
    if (rtl) {
      newPos = -newPos;
      if (newPos > 0) {
        newSize = dragSize - newPos;
        newPos = 0;
      } else if (-newPos + dragSize > trackSize) {
        newSize = trackSize + newPos;
      }
    } else if (newPos < 0) {
      newSize = dragSize + newPos;
      newPos = 0;
    } else if (newPos + dragSize > trackSize) {
      newSize = trackSize - newPos;
    }
    if (swiper.isHorizontal()) {
      dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
      dragEl.style.width = `${newSize}px`;
    } else {
      dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
      dragEl.style.height = `${newSize}px`;
    }
    if (params.hide) {
      clearTimeout(timeout);
      el.style.opacity = 1;
      timeout = setTimeout(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
  }
  function setTransition(duration) {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
  }
  function updateSize() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    const {
      scrollbar
    } = swiper;
    const {
      dragEl,
      el
    } = scrollbar;
    dragEl.style.width = '';
    dragEl.style.height = '';
    trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
    divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
    if (swiper.params.scrollbar.dragSize === 'auto') {
      dragSize = trackSize * divider;
    } else {
      dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
    }
    if (swiper.isHorizontal()) {
      dragEl.style.width = `${dragSize}px`;
    } else {
      dragEl.style.height = `${dragSize}px`;
    }
    if (divider >= 1) {
      el.style.display = 'none';
    } else {
      el.style.display = '';
    }
    if (swiper.params.scrollbar.hide) {
      el.style.opacity = 0;
    }
    if (swiper.params.watchOverflow && swiper.enabled) {
      scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);
    }
  }
  function getPointerPosition(e) {
    return swiper.isHorizontal() ? e.clientX : e.clientY;
  }
  function setDragPosition(e) {
    const {
      scrollbar,
      rtlTranslate: rtl
    } = swiper;
    const {
      el
    } = scrollbar;
    let positionRatio;
    positionRatio = (getPointerPosition(e) - utils_elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
    if (rtl) {
      positionRatio = 1 - positionRatio;
    }
    const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
    swiper.updateProgress(position);
    swiper.setTranslate(position);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  function onDragStart(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    isTouched = true;
    dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
    e.preventDefault();
    e.stopPropagation();
    wrapperEl.style.transitionDuration = '100ms';
    dragEl.style.transitionDuration = '100ms';
    setDragPosition(e);
    clearTimeout(dragTimeout);
    el.style.transitionDuration = '0ms';
    if (params.hide) {
      el.style.opacity = 1;
    }
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = 'none';
    }
    emit('scrollbarDragStart', e);
  }
  function onDragMove(e) {
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el,
      dragEl
    } = scrollbar;
    if (!isTouched) return;
    if (e.preventDefault) e.preventDefault();else e.returnValue = false;
    setDragPosition(e);
    wrapperEl.style.transitionDuration = '0ms';
    el.style.transitionDuration = '0ms';
    dragEl.style.transitionDuration = '0ms';
    emit('scrollbarDragMove', e);
  }
  function onDragEnd(e) {
    const params = swiper.params.scrollbar;
    const {
      scrollbar,
      wrapperEl
    } = swiper;
    const {
      el
    } = scrollbar;
    if (!isTouched) return;
    isTouched = false;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style['scroll-snap-type'] = '';
      wrapperEl.style.transitionDuration = '';
    }
    if (params.hide) {
      clearTimeout(dragTimeout);
      dragTimeout = utils_nextTick(() => {
        el.style.opacity = 0;
        el.style.transitionDuration = '400ms';
      }, 1000);
    }
    emit('scrollbarDragEnd', e);
    if (params.snapOnRelease) {
      swiper.slideToClosest();
    }
  }
  function events(method) {
    const {
      scrollbar,
      params
    } = swiper;
    const el = scrollbar.el;
    if (!el) return;
    const target = el;
    const activeListener = params.passiveListeners ? {
      passive: false,
      capture: false
    } : false;
    const passiveListener = params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    if (!target) return;
    const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
    target[eventMethod]('pointerdown', onDragStart, activeListener);
    document[eventMethod]('pointermove', onDragMove, activeListener);
    document[eventMethod]('pointerup', onDragEnd, passiveListener);
  }
  function enableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('on');
  }
  function disableDraggable() {
    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
    events('off');
  }
  function init() {
    const {
      scrollbar,
      el: swiperEl
    } = swiper;
    swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
      el: 'swiper-scrollbar'
    });
    const params = swiper.params.scrollbar;
    if (!params.el) return;
    let el;
    if (typeof params.el === 'string' && swiper.isElement) {
      el = swiper.el.shadowRoot.querySelector(params.el);
    }
    if (!el && typeof params.el === 'string') {
      el = document.querySelectorAll(params.el);
    } else if (!el) {
      el = params.el;
    }
    if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
      el = swiperEl.querySelector(params.el);
    }
    if (el.length > 0) el = el[0];
    el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    let dragEl;
    if (el) {
      dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);
      if (!dragEl) {
        dragEl = utils_createElement('div', swiper.params.scrollbar.dragClass);
        el.append(dragEl);
      }
    }
    Object.assign(scrollbar, {
      el,
      dragEl
    });
    if (params.draggable) {
      enableDraggable();
    }
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
    }
  }
  function destroy() {
    const params = swiper.params.scrollbar;
    const el = swiper.scrollbar.el;
    if (el) {
      el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
    }
    disableDraggable();
  }
  on('init', () => {
    if (swiper.params.scrollbar.enabled === false) {
      // eslint-disable-next-line
      disable();
    } else {
      init();
      updateSize();
      setTranslate();
    }
  });
  on('update resize observerUpdate lock unlock', () => {
    updateSize();
  });
  on('setTranslate', () => {
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    setTransition(duration);
  });
  on('enable disable', () => {
    const {
      el
    } = swiper.scrollbar;
    if (el) {
      el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);
    }
  });
  on('destroy', () => {
    destroy();
  });
  const enable = () => {
    swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);
    }
    init();
    updateSize();
    setTranslate();
  };
  const disable = () => {
    swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
    if (swiper.scrollbar.el) {
      swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);
    }
    destroy();
  };
  Object.assign(swiper.scrollbar, {
    enable,
    disable,
    updateSize,
    setTranslate,
    init,
    destroy
  });
}
;// ./node_modules/swiper/modules/parallax/parallax.js

function Parallax({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    parallax: {
      enabled: false
    }
  });
  const setTransform = (el, progress) => {
    const {
      rtl
    } = swiper;
    const rtlFactor = rtl ? -1 : 1;
    const p = el.getAttribute('data-swiper-parallax') || '0';
    let x = el.getAttribute('data-swiper-parallax-x');
    let y = el.getAttribute('data-swiper-parallax-y');
    const scale = el.getAttribute('data-swiper-parallax-scale');
    const opacity = el.getAttribute('data-swiper-parallax-opacity');
    const rotate = el.getAttribute('data-swiper-parallax-rotate');
    if (x || y) {
      x = x || '0';
      y = y || '0';
    } else if (swiper.isHorizontal()) {
      x = p;
      y = '0';
    } else {
      y = p;
      x = '0';
    }
    if (x.indexOf('%') >= 0) {
      x = `${parseInt(x, 10) * progress * rtlFactor}%`;
    } else {
      x = `${x * progress * rtlFactor}px`;
    }
    if (y.indexOf('%') >= 0) {
      y = `${parseInt(y, 10) * progress}%`;
    } else {
      y = `${y * progress}px`;
    }
    if (typeof opacity !== 'undefined' && opacity !== null) {
      const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
      el.style.opacity = currentOpacity;
    }
    let transform = `translate3d(${x}, ${y}, 0px)`;
    if (typeof scale !== 'undefined' && scale !== null) {
      const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
      transform += ` scale(${currentScale})`;
    }
    if (rotate && typeof rotate !== 'undefined' && rotate !== null) {
      const currentRotate = rotate * progress * -1;
      transform += ` rotate(${currentRotate}deg)`;
    }
    el.style.transform = transform;
  };
  const setTranslate = () => {
    const {
      el,
      slides,
      progress,
      snapGrid
    } = swiper;
    elementChildren(el, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(subEl => {
      setTransform(subEl, progress);
    });
    slides.forEach((slideEl, slideIndex) => {
      let slideProgress = slideEl.progress;
      if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
        slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
      }
      slideProgress = Math.min(Math.max(slideProgress, -1), 1);
      slideEl.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]').forEach(subEl => {
        setTransform(subEl, slideProgress);
      });
    });
  };
  const setTransition = (duration = swiper.params.speed) => {
    const {
      el
    } = swiper;
    el.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(parallaxEl => {
      let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;
      if (duration === 0) parallaxDuration = 0;
      parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
    });
  };
  on('beforeInit', () => {
    if (!swiper.params.parallax.enabled) return;
    swiper.params.watchSlidesProgress = true;
    swiper.originalParams.watchSlidesProgress = true;
  });
  on('init', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTranslate', () => {
    if (!swiper.params.parallax.enabled) return;
    setTranslate();
  });
  on('setTransition', (_swiper, duration) => {
    if (!swiper.params.parallax.enabled) return;
    setTransition(duration);
  });
}
;// ./node_modules/swiper/modules/zoom/zoom.js


function Zoom({
  swiper,
  extendParams,
  on,
  emit
}) {
  const window = getWindow();
  extendParams({
    zoom: {
      enabled: false,
      maxRatio: 3,
      minRatio: 1,
      toggle: true,
      containerClass: 'swiper-zoom-container',
      zoomedSlideClass: 'swiper-slide-zoomed'
    }
  });
  swiper.zoom = {
    enabled: false
  };
  let currentScale = 1;
  let isScaling = false;
  let fakeGestureTouched;
  let fakeGestureMoved;
  const evCache = [];
  const gesture = {
    originX: 0,
    originY: 0,
    slideEl: undefined,
    slideWidth: undefined,
    slideHeight: undefined,
    imageEl: undefined,
    imageWrapEl: undefined,
    maxRatio: 3
  };
  const image = {
    isTouched: undefined,
    isMoved: undefined,
    currentX: undefined,
    currentY: undefined,
    minX: undefined,
    minY: undefined,
    maxX: undefined,
    maxY: undefined,
    width: undefined,
    height: undefined,
    startX: undefined,
    startY: undefined,
    touchesStart: {},
    touchesCurrent: {}
  };
  const velocity = {
    x: undefined,
    y: undefined,
    prevPositionX: undefined,
    prevPositionY: undefined,
    prevTime: undefined
  };
  let scale = 1;
  Object.defineProperty(swiper.zoom, 'scale', {
    get() {
      return scale;
    },
    set(value) {
      if (scale !== value) {
        const imageEl = gesture.imageEl;
        const slideEl = gesture.slideEl;
        emit('zoomChange', value, imageEl, slideEl);
      }
      scale = value;
    }
  });
  function getDistanceBetweenTouches() {
    if (evCache.length < 2) return 1;
    const x1 = evCache[0].pageX;
    const y1 = evCache[0].pageY;
    const x2 = evCache[1].pageX;
    const y2 = evCache[1].pageY;
    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    return distance;
  }
  function getScaleOrigin() {
    if (evCache.length < 2) return {
      x: null,
      y: null
    };
    const box = gesture.imageEl.getBoundingClientRect();
    return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];
  }
  function getSlideSelector() {
    return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  }
  function eventWithinSlide(e) {
    const slideSelector = getSlideSelector();
    if (e.target.matches(slideSelector)) return true;
    if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;
    return false;
  }
  function eventWithinZoomContainer(e) {
    const selector = `.${swiper.params.zoom.containerClass}`;
    if (e.target.matches(selector)) return true;
    if ([...swiper.el.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;
    return false;
  }

  // Events
  function onGestureStart(e) {
    if (e.pointerType === 'mouse') {
      evCache.splice(0, evCache.length);
    }
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    evCache.push(e);
    if (evCache.length < 2) {
      return;
    }
    fakeGestureTouched = true;
    gesture.scaleStart = getDistanceBetweenTouches();
    if (!gesture.slideEl) {
      gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
      if (!gesture.imageWrapEl) {
        gesture.imageEl = undefined;
        return;
      }
      gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
    }
    if (gesture.imageEl) {
      const [originX, originY] = getScaleOrigin();
      gesture.originX = originX;
      gesture.originY = originY;
      gesture.imageEl.style.transitionDuration = '0ms';
    }
    isScaling = true;
  }
  function onGestureChange(e) {
    if (!eventWithinSlide(e)) return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache[pointerIndex] = e;
    if (evCache.length < 2) {
      return;
    }
    fakeGestureMoved = true;
    gesture.scaleMove = getDistanceBetweenTouches();
    if (!gesture.imageEl) {
      return;
    }
    zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
    if (zoom.scale > gesture.maxRatio) {
      zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
    }
    if (zoom.scale < params.minRatio) {
      zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
    }
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function onGestureEnd(e) {
    if (!eventWithinSlide(e)) return;
    if (e.pointerType === 'mouse' && e.type === 'pointerout') return;
    const params = swiper.params.zoom;
    const zoom = swiper.zoom;
    const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);
    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
    if (!fakeGestureTouched || !fakeGestureMoved) {
      return;
    }
    fakeGestureTouched = false;
    fakeGestureMoved = false;
    if (!gesture.imageEl) return;
    zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    currentScale = zoom.scale;
    isScaling = false;
    if (zoom.scale > 1 && gesture.slideEl) {
      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    } else if (zoom.scale <= 1 && gesture.slideEl) {
      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    }
    if (zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
      gesture.slideEl = undefined;
    }
  }
  function onTouchStart(e) {
    const device = swiper.device;
    if (!gesture.imageEl) return;
    if (image.isTouched) return;
    if (device.android && e.cancelable) e.preventDefault();
    image.isTouched = true;
    const event = evCache.length > 0 ? evCache[0] : e;
    image.touchesStart.x = event.pageX;
    image.touchesStart.y = event.pageY;
  }
  function onTouchMove(e) {
    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;
    const zoom = swiper.zoom;
    if (!gesture.imageEl) return;
    if (!image.isTouched || !gesture.slideEl) return;
    if (!image.isMoved) {
      image.width = gesture.imageEl.offsetWidth;
      image.height = gesture.imageEl.offsetHeight;
      image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;
      image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;
      gesture.slideWidth = gesture.slideEl.offsetWidth;
      gesture.slideHeight = gesture.slideEl.offsetHeight;
      gesture.imageWrapEl.style.transitionDuration = '0ms';
    }
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
    image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
    const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
    if (touchesDiff > 5) {
      swiper.allowClick = false;
    }
    if (!image.isMoved && !isScaling) {
      if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
        image.isTouched = false;
        return;
      }
      if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
        image.isTouched = false;
        return;
      }
    }
    if (e.cancelable) {
      e.preventDefault();
    }
    e.stopPropagation();
    image.isMoved = true;
    const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
    const {
      originX,
      originY
    } = gesture;
    image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
    image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
    if (image.currentX < image.minX) {
      image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
    }
    if (image.currentX > image.maxX) {
      image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
    }
    if (image.currentY < image.minY) {
      image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
    }
    if (image.currentY > image.maxY) {
      image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
    }

    // Velocity
    if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
    if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
    if (!velocity.prevTime) velocity.prevTime = Date.now();
    velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
    velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
    velocity.prevPositionX = image.touchesCurrent.x;
    velocity.prevPositionY = image.touchesCurrent.y;
    velocity.prevTime = Date.now();
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTouchEnd() {
    const zoom = swiper.zoom;
    if (!gesture.imageEl) return;
    if (!image.isTouched || !image.isMoved) {
      image.isTouched = false;
      image.isMoved = false;
      return;
    }
    image.isTouched = false;
    image.isMoved = false;
    let momentumDurationX = 300;
    let momentumDurationY = 300;
    const momentumDistanceX = velocity.x * momentumDurationX;
    const newPositionX = image.currentX + momentumDistanceX;
    const momentumDistanceY = velocity.y * momentumDurationY;
    const newPositionY = image.currentY + momentumDistanceY;

    // Fix duration
    if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
    if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
    const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
    image.currentX = newPositionX;
    image.currentY = newPositionY;
    // Define if we need image drag
    const scaledWidth = image.width * zoom.scale;
    const scaledHeight = image.height * zoom.scale;
    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
    image.maxX = -image.minX;
    image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
    image.maxY = -image.minY;
    image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
    image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
  }
  function onTransitionEnd() {
    const zoom = swiper.zoom;
    if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
      if (gesture.imageEl) {
        gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
      }
      if (gesture.imageWrapEl) {
        gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
      }
      gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
      zoom.scale = 1;
      currentScale = 1;
      gesture.slideEl = undefined;
      gesture.imageEl = undefined;
      gesture.imageWrapEl = undefined;
      gesture.originX = 0;
      gesture.originY = 0;
    }
  }
  function zoomIn(e) {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (e && e.target) {
        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
      }
      if (!gesture.slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
        } else {
          gesture.slideEl = swiper.slides[swiper.activeIndex];
        }
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.touchAction = 'none';
    }
    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
    let touchX;
    let touchY;
    let offsetX;
    let offsetY;
    let diffX;
    let diffY;
    let translateX;
    let translateY;
    let imageWidth;
    let imageHeight;
    let scaledWidth;
    let scaledHeight;
    let translateMinX;
    let translateMinY;
    let translateMaxX;
    let translateMaxY;
    let slideWidth;
    let slideHeight;
    if (typeof image.touchesStart.x === 'undefined' && e) {
      touchX = e.pageX;
      touchY = e.pageY;
    } else {
      touchX = image.touchesStart.x;
      touchY = image.touchesStart.y;
    }
    const forceZoomRatio = typeof e === 'number' ? e : null;
    if (currentScale === 1 && forceZoomRatio) {
      touchX = undefined;
      touchY = undefined;
    }
    zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
    currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;
    if (e && !(currentScale === 1 && forceZoomRatio)) {
      slideWidth = gesture.slideEl.offsetWidth;
      slideHeight = gesture.slideEl.offsetHeight;
      offsetX = elementOffset(gesture.slideEl).left + window.scrollX;
      offsetY = elementOffset(gesture.slideEl).top + window.scrollY;
      diffX = offsetX + slideWidth / 2 - touchX;
      diffY = offsetY + slideHeight / 2 - touchY;
      imageWidth = gesture.imageEl.offsetWidth;
      imageHeight = gesture.imageEl.offsetHeight;
      scaledWidth = imageWidth * zoom.scale;
      scaledHeight = imageHeight * zoom.scale;
      translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
      translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
      translateMaxX = -translateMinX;
      translateMaxY = -translateMinY;
      translateX = diffX * zoom.scale;
      translateY = diffY * zoom.scale;
      if (translateX < translateMinX) {
        translateX = translateMinX;
      }
      if (translateX > translateMaxX) {
        translateX = translateMaxX;
      }
      if (translateY < translateMinY) {
        translateY = translateMinY;
      }
      if (translateY > translateMaxY) {
        translateY = translateMaxY;
      }
    } else {
      translateX = 0;
      translateY = 0;
    }
    if (forceZoomRatio && zoom.scale === 1) {
      gesture.originX = 0;
      gesture.originY = 0;
    }
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
  }
  function zoomOut() {
    const zoom = swiper.zoom;
    const params = swiper.params.zoom;
    if (!gesture.slideEl) {
      if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
        gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
      } else {
        gesture.slideEl = swiper.slides[swiper.activeIndex];
      }
      let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
      if (imageEl) {
        imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];
      }
      gesture.imageEl = imageEl;
      if (imageEl) {
        gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
      } else {
        gesture.imageWrapEl = undefined;
      }
    }
    if (!gesture.imageEl || !gesture.imageWrapEl) return;
    if (swiper.params.cssMode) {
      swiper.wrapperEl.style.overflow = '';
      swiper.wrapperEl.style.touchAction = '';
    }
    zoom.scale = 1;
    currentScale = 1;
    gesture.imageWrapEl.style.transitionDuration = '300ms';
    gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';
    gesture.imageEl.style.transitionDuration = '300ms';
    gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';
    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
    gesture.slideEl = undefined;
    gesture.originX = 0;
    gesture.originY = 0;
  }

  // Toggle Zoom
  function zoomToggle(e) {
    const zoom = swiper.zoom;
    if (zoom.scale && zoom.scale !== 1) {
      // Zoom Out
      zoomOut();
    } else {
      // Zoom In
      zoomIn(e);
    }
  }
  function getListeners() {
    const passiveListener = swiper.params.passiveListeners ? {
      passive: true,
      capture: false
    } : false;
    const activeListenerWithCapture = swiper.params.passiveListeners ? {
      passive: false,
      capture: true
    } : true;
    return {
      passiveListener,
      activeListenerWithCapture
    };
  }

  // Attach/Detach Events
  function enable() {
    const zoom = swiper.zoom;
    if (zoom.enabled) return;
    zoom.enabled = true;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  function disable() {
    const zoom = swiper.zoom;
    if (!zoom.enabled) return;
    zoom.enabled = false;
    const {
      passiveListener,
      activeListenerWithCapture
    } = getListeners();

    // Scale image
    swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);
    swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);
    ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {
      swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
    });

    // Move image
    swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);
  }
  on('init', () => {
    if (swiper.params.zoom.enabled) {
      enable();
    }
  });
  on('destroy', () => {
    disable();
  });
  on('touchStart', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchStart(e);
  });
  on('touchEnd', (_s, e) => {
    if (!swiper.zoom.enabled) return;
    onTouchEnd(e);
  });
  on('doubleTap', (_s, e) => {
    if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
      zoomToggle(e);
    }
  });
  on('transitionEnd', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
      onTransitionEnd();
    }
  });
  on('slideChange', () => {
    if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
      onTransitionEnd();
    }
  });
  Object.assign(swiper.zoom, {
    enable,
    disable,
    in: zoomIn,
    out: zoomOut,
    toggle: zoomToggle
  });
}
;// ./node_modules/swiper/modules/controller/controller.js
/* eslint no-bitwise: ["error", { "allow": [">>"] }] */

function Controller({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    controller: {
      control: undefined,
      inverse: false,
      by: 'slide' // or 'container'
    }
  });

  swiper.controller = {
    control: undefined
  };
  function LinearSpline(x, y) {
    const binarySearch = function search() {
      let maxIndex;
      let minIndex;
      let guess;
      return (array, val) => {
        minIndex = -1;
        maxIndex = array.length;
        while (maxIndex - minIndex > 1) {
          guess = maxIndex + minIndex >> 1;
          if (array[guess] <= val) {
            minIndex = guess;
          } else {
            maxIndex = guess;
          }
        }
        return maxIndex;
      };
    }();
    this.x = x;
    this.y = y;
    this.lastIndex = x.length - 1;
    // Given an x value (x2), return the expected y2 value:
    // (x1,y1) is the known point before given value,
    // (x3,y3) is the known point after given value.
    let i1;
    let i3;
    this.interpolate = function interpolate(x2) {
      if (!x2) return 0;

      // Get the indexes of x1 and x3 (the array indexes before and after given x2):
      i3 = binarySearch(this.x, x2);
      i1 = i3 - 1;

      // We have our indexes i1 & i3, so we can calculate already:
      // y2 := ((x2âx1) Ã (y3ây1)) Ã· (x3âx1) + y1
      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
    };
    return this;
  }
  function getInterpolateFunction(c) {
    swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
  }
  function setTranslate(_t, byController) {
    const controlled = swiper.controller.control;
    let multiplier;
    let controlledTranslate;
    const Swiper = swiper.constructor;
    function setControlledTranslate(c) {
      if (c.destroyed) return;

      // this will create an Interpolate function based on the snapGrids
      // x is the Grid of the scrolled scroller and y will be the controlled scroller
      // it makes sense to create this only once and recall it for the interpolation
      // the function does a lot of value caching for performance
      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
      if (swiper.params.controller.by === 'slide') {
        getInterpolateFunction(c);
        // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
        // but it did not work out
        controlledTranslate = -swiper.controller.spline.interpolate(-translate);
      }
      if (!controlledTranslate || swiper.params.controller.by === 'container') {
        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
        if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
          multiplier = 1;
        }
        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
      }
      if (swiper.params.controller.inverse) {
        controlledTranslate = c.maxTranslate() - controlledTranslate;
      }
      c.updateProgress(controlledTranslate);
      c.setTranslate(controlledTranslate, swiper);
      c.updateActiveIndex();
      c.updateSlidesClasses();
    }
    if (Array.isArray(controlled)) {
      for (let i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTranslate(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTranslate(controlled);
    }
  }
  function setTransition(duration, byController) {
    const Swiper = swiper.constructor;
    const controlled = swiper.controller.control;
    let i;
    function setControlledTransition(c) {
      if (c.destroyed) return;
      c.setTransition(duration, swiper);
      if (duration !== 0) {
        c.transitionStart();
        if (c.params.autoHeight) {
          nextTick(() => {
            c.updateAutoHeight();
          });
        }
        elementTransitionEnd(c.wrapperEl, () => {
          if (!controlled) return;
          c.transitionEnd();
        });
      }
    }
    if (Array.isArray(controlled)) {
      for (i = 0; i < controlled.length; i += 1) {
        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
          setControlledTransition(controlled[i]);
        }
      }
    } else if (controlled instanceof Swiper && byController !== controlled) {
      setControlledTransition(controlled);
    }
  }
  function removeSpline() {
    if (!swiper.controller.control) return;
    if (swiper.controller.spline) {
      swiper.controller.spline = undefined;
      delete swiper.controller.spline;
    }
  }
  on('beforeInit', () => {
    if (typeof window !== 'undefined' && (
    // eslint-disable-line
    typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {
      const controlElement = document.querySelector(swiper.params.controller.control);
      if (controlElement && controlElement.swiper) {
        swiper.controller.control = controlElement.swiper;
      } else if (controlElement) {
        const onControllerSwiper = e => {
          swiper.controller.control = e.detail[0];
          swiper.update();
          controlElement.removeEventListener('init', onControllerSwiper);
        };
        controlElement.addEventListener('init', onControllerSwiper);
      }
      return;
    }
    swiper.controller.control = swiper.params.controller.control;
  });
  on('update', () => {
    removeSpline();
  });
  on('resize', () => {
    removeSpline();
  });
  on('observerUpdate', () => {
    removeSpline();
  });
  on('setTranslate', (_s, translate, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTranslate(translate, byController);
  });
  on('setTransition', (_s, duration, byController) => {
    if (!swiper.controller.control || swiper.controller.control.destroyed) return;
    swiper.controller.setTransition(duration, byController);
  });
  Object.assign(swiper.controller, {
    setTranslate,
    setTransition
  });
}
;// ./node_modules/swiper/modules/a11y/a11y.js


function A11y({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    a11y: {
      enabled: true,
      notificationClass: 'swiper-notification',
      prevSlideMessage: 'Previous slide',
      nextSlideMessage: 'Next slide',
      firstSlideMessage: 'This is the first slide',
      lastSlideMessage: 'This is the last slide',
      paginationBulletMessage: 'Go to slide {{index}}',
      slideLabelMessage: '{{index}} / {{slidesLength}}',
      containerMessage: null,
      containerRoleDescriptionMessage: null,
      itemRoleDescriptionMessage: null,
      slideRole: 'group',
      id: null
    }
  });
  swiper.a11y = {
    clicked: false
  };
  let liveRegion = null;
  function notify(message) {
    const notification = liveRegion;
    if (notification.length === 0) return;
    notification.innerHTML = '';
    notification.innerHTML = message;
  }
  const makeElementsArray = el => {
    if (!Array.isArray(el)) el = [el].filter(e => !!e);
    return el;
  };
  function getRandomNumber(size = 16) {
    const randomChar = () => Math.round(16 * Math.random()).toString(16);
    return 'x'.repeat(size).replace(/x/g, randomChar);
  }
  function makeElFocusable(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '0');
    });
  }
  function makeElNotFocusable(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('tabIndex', '-1');
    });
  }
  function addElRole(el, role) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('role', role);
    });
  }
  function addElRoleDescription(el, description) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-roledescription', description);
    });
  }
  function addElControls(el, controls) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-controls', controls);
    });
  }
  function addElLabel(el, label) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-label', label);
    });
  }
  function addElId(el, id) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('id', id);
    });
  }
  function addElLive(el, live) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-live', live);
    });
  }
  function disableEl(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', true);
    });
  }
  function enableEl(el) {
    el = makeElementsArray(el);
    el.forEach(subEl => {
      subEl.setAttribute('aria-disabled', false);
    });
  }
  function onEnterOrSpaceKey(e) {
    if (e.keyCode !== 13 && e.keyCode !== 32) return;
    const params = swiper.params.a11y;
    const targetEl = e.target;
    if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
      if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;
    }
    if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {
      if (!(swiper.isEnd && !swiper.params.loop)) {
        swiper.slideNext();
      }
      if (swiper.isEnd) {
        notify(params.lastSlideMessage);
      } else {
        notify(params.nextSlideMessage);
      }
    }
    if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {
      if (!(swiper.isBeginning && !swiper.params.loop)) {
        swiper.slidePrev();
      }
      if (swiper.isBeginning) {
        notify(params.firstSlideMessage);
      } else {
        notify(params.prevSlideMessage);
      }
    }
    if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
      targetEl.click();
    }
  }
  function updateNavigation() {
    if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
    const {
      nextEl,
      prevEl
    } = swiper.navigation;
    if (prevEl) {
      if (swiper.isBeginning) {
        disableEl(prevEl);
        makeElNotFocusable(prevEl);
      } else {
        enableEl(prevEl);
        makeElFocusable(prevEl);
      }
    }
    if (nextEl) {
      if (swiper.isEnd) {
        disableEl(nextEl);
        makeElNotFocusable(nextEl);
      } else {
        enableEl(nextEl);
        makeElFocusable(nextEl);
      }
    }
  }
  function hasPagination() {
    return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
  }
  function hasClickablePagination() {
    return hasPagination() && swiper.params.pagination.clickable;
  }
  function updatePagination() {
    const params = swiper.params.a11y;
    if (!hasPagination()) return;
    swiper.pagination.bullets.forEach(bulletEl => {
      if (swiper.params.pagination.clickable) {
        makeElFocusable(bulletEl);
        if (!swiper.params.pagination.renderBullet) {
          addElRole(bulletEl, 'button');
          addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1));
        }
      }
      if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
        bulletEl.setAttribute('aria-current', 'true');
      } else {
        bulletEl.removeAttribute('aria-current');
      }
    });
  }
  const initNavEl = (el, wrapperId, message) => {
    makeElFocusable(el);
    if (el.tagName !== 'BUTTON') {
      addElRole(el, 'button');
      el.addEventListener('keydown', onEnterOrSpaceKey);
    }
    addElLabel(el, message);
    addElControls(el, wrapperId);
  };
  const handlePointerDown = () => {
    swiper.a11y.clicked = true;
  };
  const handlePointerUp = () => {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (!swiper.destroyed) {
          swiper.a11y.clicked = false;
        }
      });
    });
  };
  const handleFocus = e => {
    if (swiper.a11y.clicked) return;
    const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
    if (!slideEl || !swiper.slides.includes(slideEl)) return;
    const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
    const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
    if (isActive || isVisible) return;
    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
    if (swiper.isHorizontal()) {
      swiper.el.scrollLeft = 0;
    } else {
      swiper.el.scrollTop = 0;
    }
    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
  };
  const initSlides = () => {
    const params = swiper.params.a11y;
    if (params.itemRoleDescriptionMessage) {
      addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
    }
    if (params.slideRole) {
      addElRole(swiper.slides, params.slideRole);
    }
    const slidesLength = swiper.slides.length;
    if (params.slideLabelMessage) {
      swiper.slides.forEach((slideEl, index) => {
        const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;
        const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
        addElLabel(slideEl, ariaLabelMessage);
      });
    }
  };
  const init = () => {
    const params = swiper.params.a11y;
    if (swiper.isElement) {
      swiper.el.shadowEl.append(liveRegion);
    } else {
      swiper.el.append(liveRegion);
    }

    // Container
    const containerEl = swiper.el;
    if (params.containerRoleDescriptionMessage) {
      addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
    }
    if (params.containerMessage) {
      addElLabel(containerEl, params.containerMessage);
    }

    // Wrapper
    const wrapperEl = swiper.wrapperEl;
    const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;
    const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';
    addElId(wrapperEl, wrapperId);
    addElLive(wrapperEl, live);

    // Slide
    initSlides();

    // Navigation
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (nextEl) {
      nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));
    }
    if (prevEl) {
      prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];
      paginationEl.forEach(el => {
        el.addEventListener('keydown', onEnterOrSpaceKey);
      });
    }

    // Tab focus
    swiper.el.addEventListener('focus', handleFocus, true);
    swiper.el.addEventListener('pointerdown', handlePointerDown, true);
    swiper.el.addEventListener('pointerup', handlePointerUp, true);
  };
  function destroy() {
    if (liveRegion) liveRegion.remove();
    let {
      nextEl,
      prevEl
    } = swiper.navigation ? swiper.navigation : {};
    nextEl = makeElementsArray(nextEl);
    prevEl = makeElementsArray(prevEl);
    if (nextEl) {
      nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }
    if (prevEl) {
      prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));
    }

    // Pagination
    if (hasClickablePagination()) {
      const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];
      paginationEl.forEach(el => {
        el.removeEventListener('keydown', onEnterOrSpaceKey);
      });
    }

    // Tab focus
    swiper.el.removeEventListener('focus', handleFocus, true);
    swiper.el.removeEventListener('pointerdown', handlePointerDown, true);
    swiper.el.removeEventListener('pointerup', handlePointerUp, true);
  }
  on('beforeInit', () => {
    liveRegion = createElement('span', swiper.params.a11y.notificationClass);
    liveRegion.setAttribute('aria-live', 'assertive');
    liveRegion.setAttribute('aria-atomic', 'true');
  });
  on('afterInit', () => {
    if (!swiper.params.a11y.enabled) return;
    init();
  });
  on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {
    if (!swiper.params.a11y.enabled) return;
    initSlides();
  });
  on('fromEdge toEdge afterInit lock unlock', () => {
    if (!swiper.params.a11y.enabled) return;
    updateNavigation();
  });
  on('paginationUpdate', () => {
    if (!swiper.params.a11y.enabled) return;
    updatePagination();
  });
  on('destroy', () => {
    if (!swiper.params.a11y.enabled) return;
    destroy();
  });
}
;// ./node_modules/swiper/modules/history/history.js

function History({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    history: {
      enabled: false,
      root: '',
      replaceState: false,
      key: 'slides',
      keepQuery: false
    }
  });
  let initialized = false;
  let paths = {};
  const slugify = text => {
    return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  };
  const getPathValues = urlOverride => {
    const window = getWindow();
    let location;
    if (urlOverride) {
      location = new URL(urlOverride);
    } else {
      location = window.location;
    }
    const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');
    const total = pathArray.length;
    const key = pathArray[total - 2];
    const value = pathArray[total - 1];
    return {
      key,
      value
    };
  };
  const setHistory = (key, index) => {
    const window = getWindow();
    if (!initialized || !swiper.params.history.enabled) return;
    let location;
    if (swiper.params.url) {
      location = new URL(swiper.params.url);
    } else {
      location = window.location;
    }
    const slide = swiper.slides[index];
    let value = slugify(slide.getAttribute('data-history'));
    if (swiper.params.history.root.length > 0) {
      let root = swiper.params.history.root;
      if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);
      value = `${root}/${key ? `${key}/` : ''}${value}`;
    } else if (!location.pathname.includes(key)) {
      value = `${key ? `${key}/` : ''}${value}`;
    }
    if (swiper.params.history.keepQuery) {
      value += location.search;
    }
    const currentState = window.history.state;
    if (currentState && currentState.value === value) {
      return;
    }
    if (swiper.params.history.replaceState) {
      window.history.replaceState({
        value
      }, null, value);
    } else {
      window.history.pushState({
        value
      }, null, value);
    }
  };
  const scrollToSlide = (speed, value, runCallbacks) => {
    if (value) {
      for (let i = 0, length = swiper.slides.length; i < length; i += 1) {
        const slide = swiper.slides[i];
        const slideHistory = slugify(slide.getAttribute('data-history'));
        if (slideHistory === value) {
          const index = swiper.getSlideIndex(slide);
          swiper.slideTo(index, speed, runCallbacks);
        }
      }
    } else {
      swiper.slideTo(0, speed, runCallbacks);
    }
  };
  const setHistoryPopState = () => {
    paths = getPathValues(swiper.params.url);
    scrollToSlide(swiper.params.speed, paths.value, false);
  };
  const init = () => {
    const window = getWindow();
    if (!swiper.params.history) return;
    if (!window.history || !window.history.pushState) {
      swiper.params.history.enabled = false;
      swiper.params.hashNavigation.enabled = true;
      return;
    }
    initialized = true;
    paths = getPathValues(swiper.params.url);
    if (!paths.key && !paths.value) {
      if (!swiper.params.history.replaceState) {
        window.addEventListener('popstate', setHistoryPopState);
      }
      return;
    }
    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
    if (!swiper.params.history.replaceState) {
      window.addEventListener('popstate', setHistoryPopState);
    }
  };
  const destroy = () => {
    const window = getWindow();
    if (!swiper.params.history.replaceState) {
      window.removeEventListener('popstate', setHistoryPopState);
    }
  };
  on('init', () => {
    if (swiper.params.history.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.history.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHistory(swiper.params.history.key, swiper.activeIndex);
    }
  });
}
;// ./node_modules/swiper/modules/hash-navigation/hash-navigation.js


function HashNavigation({
  swiper,
  extendParams,
  emit,
  on
}) {
  let initialized = false;
  const document = getDocument();
  const window = getWindow();
  extendParams({
    hashNavigation: {
      enabled: false,
      replaceState: false,
      watchState: false,
      getSlideIndex(_s, hash) {
        if (swiper.virtual && swiper.params.virtual.enabled) {
          const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];
          if (!slideWithHash) return 0;
          const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);
          return index;
        }
        return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
      }
    }
  });
  const onHashChange = () => {
    emit('hashChange');
    const newHash = document.location.hash.replace('#', '');
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';
    if (newHash !== activeSlideHash) {
      const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
      if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;
      swiper.slideTo(newIndex);
    }
  };
  const setHash = () => {
    if (!initialized || !swiper.params.hashNavigation.enabled) return;
    const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
    const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';
    if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {
      window.history.replaceState(null, null, `#${activeSlideHash}` || '');
      emit('hashSet');
    } else {
      document.location.hash = activeSlideHash || '';
      emit('hashSet');
    }
  };
  const init = () => {
    if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
    initialized = true;
    const hash = document.location.hash.replace('#', '');
    if (hash) {
      const speed = 0;
      const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
      swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
    }
    if (swiper.params.hashNavigation.watchState) {
      window.addEventListener('hashchange', onHashChange);
    }
  };
  const destroy = () => {
    if (swiper.params.hashNavigation.watchState) {
      window.removeEventListener('hashchange', onHashChange);
    }
  };
  on('init', () => {
    if (swiper.params.hashNavigation.enabled) {
      init();
    }
  });
  on('destroy', () => {
    if (swiper.params.hashNavigation.enabled) {
      destroy();
    }
  });
  on('transitionEnd _freeModeNoMomentumRelease', () => {
    if (initialized) {
      setHash();
    }
  });
  on('slideChange', () => {
    if (initialized && swiper.params.cssMode) {
      setHash();
    }
  });
}
;// ./node_modules/swiper/modules/autoplay/autoplay.js
/* eslint no-underscore-dangle: "off" */
/* eslint no-use-before-define: "off" */

function Autoplay({
  swiper,
  extendParams,
  on,
  emit,
  params
}) {
  swiper.autoplay = {
    running: false,
    paused: false,
    timeLeft: 0
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3000,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  let timeout;
  let raf;
  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;
  let autoplayTimeLeft;
  let autoplayStartTime = new Date().getTime;
  let wasPaused;
  let isTouched;
  let pausedByTouch;
  let touchStartTimeout;
  let slideChanged;
  let pausedByInteraction;
  function onTransitionEnd(e) {
    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
    if (e.target !== swiper.wrapperEl) return;
    swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);
    resume();
  }
  const calcTimeLeft = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.autoplay.paused) {
      wasPaused = true;
    } else if (wasPaused) {
      autoplayDelayCurrent = autoplayTimeLeft;
      wasPaused = false;
    }
    const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
    swiper.autoplay.timeLeft = timeLeft;
    emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);
    raf = requestAnimationFrame(() => {
      calcTimeLeft();
    });
  };
  const getSlideDelay = () => {
    let activeSlideEl;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];
    } else {
      activeSlideEl = swiper.slides[swiper.activeIndex];
    }
    if (!activeSlideEl) return undefined;
    const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);
    return currentSlideDelay;
  };
  const run = delayForce => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    cancelAnimationFrame(raf);
    calcTimeLeft();
    let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;
    autoplayDelayTotal = swiper.params.autoplay.delay;
    autoplayDelayCurrent = swiper.params.autoplay.delay;
    const currentSlideDelay = getSlideDelay();
    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {
      delay = currentSlideDelay;
      autoplayDelayTotal = currentSlideDelay;
      autoplayDelayCurrent = currentSlideDelay;
    }
    autoplayTimeLeft = delay;
    const speed = swiper.params.speed;
    const proceed = () => {
      if (!swiper || swiper.destroyed) return;
      if (swiper.params.autoplay.reverseDirection) {
        if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
          swiper.slidePrev(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(swiper.slides.length - 1, speed, true, true);
          emit('autoplay');
        }
      } else {
        if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
          swiper.slideNext(speed, true, true);
          emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, speed, true, true);
          emit('autoplay');
        }
      }
      if (swiper.params.cssMode) {
        autoplayStartTime = new Date().getTime();
        requestAnimationFrame(() => {
          run();
        });
      }
    };
    if (delay > 0) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        proceed();
      }, delay);
    } else {
      requestAnimationFrame(() => {
        proceed();
      });
    }

    // eslint-disable-next-line
    return delay;
  };
  const start = () => {
    swiper.autoplay.running = true;
    run();
    emit('autoplayStart');
  };
  const stop = () => {
    swiper.autoplay.running = false;
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    emit('autoplayStop');
  };
  const pause = (internal, reset) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    clearTimeout(timeout);
    if (!internal) {
      pausedByInteraction = true;
    }
    const proceed = () => {
      emit('autoplayPause');
      if (swiper.params.autoplay.waitForTransition) {
        swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);
      } else {
        resume();
      }
    };
    swiper.autoplay.paused = true;
    if (reset) {
      if (slideChanged) {
        autoplayTimeLeft = swiper.params.autoplay.delay;
      }
      slideChanged = false;
      proceed();
      return;
    }
    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
    autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
    proceed();
  };
  const resume = () => {
    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
    autoplayStartTime = new Date().getTime();
    if (pausedByInteraction) {
      pausedByInteraction = false;
      run(autoplayTimeLeft);
    } else {
      run();
    }
    swiper.autoplay.paused = false;
    emit('autoplayResume');
  };
  const onVisibilityChange = () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    const document = ssr_window_esm_getDocument();
    if (document.visibilityState === 'hidden') {
      pausedByInteraction = true;
      pause(true);
    }
    if (document.visibilityState === 'visible') {
      resume();
    }
  };
  const onPointerEnter = e => {
    if (e.pointerType !== 'mouse') return;
    pausedByInteraction = true;
    pause(true);
  };
  const onPointerLeave = e => {
    if (e.pointerType !== 'mouse') return;
    if (swiper.autoplay.paused) {
      resume();
    }
  };
  const attachMouseEvents = () => {
    if (swiper.params.autoplay.pauseOnMouseEnter) {
      swiper.el.addEventListener('pointerenter', onPointerEnter);
      swiper.el.addEventListener('pointerleave', onPointerLeave);
    }
  };
  const detachMouseEvents = () => {
    swiper.el.removeEventListener('pointerenter', onPointerEnter);
    swiper.el.removeEventListener('pointerleave', onPointerLeave);
  };
  const attachDocumentEvents = () => {
    const document = ssr_window_esm_getDocument();
    document.addEventListener('visibilitychange', onVisibilityChange);
  };
  const detachDocumentEvents = () => {
    const document = ssr_window_esm_getDocument();
    document.removeEventListener('visibilitychange', onVisibilityChange);
  };
  on('init', () => {
    if (swiper.params.autoplay.enabled) {
      attachMouseEvents();
      attachDocumentEvents();
      autoplayStartTime = new Date().getTime();
      start();
    }
  });
  on('destroy', () => {
    detachMouseEvents();
    detachDocumentEvents();
    if (swiper.autoplay.running) {
      stop();
    }
  });
  on('beforeTransitionStart', (_s, speed, internal) => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (internal || !swiper.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on('sliderFirstMove', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    if (swiper.params.autoplay.disableOnInteraction) {
      stop();
      return;
    }
    isTouched = true;
    pausedByTouch = false;
    pausedByInteraction = false;
    touchStartTimeout = setTimeout(() => {
      pausedByInteraction = true;
      pausedByTouch = true;
      pause(true);
    }, 200);
  });
  on('touchEnd', () => {
    if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
    clearTimeout(touchStartTimeout);
    clearTimeout(timeout);
    if (swiper.params.autoplay.disableOnInteraction) {
      pausedByTouch = false;
      isTouched = false;
      return;
    }
    if (pausedByTouch && swiper.params.cssMode) resume();
    pausedByTouch = false;
    isTouched = false;
  });
  on('slideChange', () => {
    if (swiper.destroyed || !swiper.autoplay.running) return;
    slideChanged = true;
  });
  Object.assign(swiper.autoplay, {
    start,
    stop,
    pause,
    resume
  });
}
;// ./node_modules/swiper/modules/thumbs/thumbs.js


function Thumb({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    thumbs: {
      swiper: null,
      multipleActiveThumbs: true,
      autoScrollOffset: 0,
      slideThumbActiveClass: 'swiper-slide-thumb-active',
      thumbsContainerClass: 'swiper-thumbs'
    }
  });
  let initialized = false;
  let swiperCreated = false;
  swiper.thumbs = {
    swiper: null
  };
  function onThumbClick() {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const clickedIndex = thumbsSwiper.clickedIndex;
    const clickedSlide = thumbsSwiper.clickedSlide;
    if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
    if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
    let slideToIndex;
    if (thumbsSwiper.params.loop) {
      slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      slideToIndex = clickedIndex;
    }
    if (swiper.params.loop) {
      swiper.slideToLoop(slideToIndex);
    } else {
      swiper.slideTo(slideToIndex);
    }
  }
  function init() {
    const {
      thumbs: thumbsParams
    } = swiper.params;
    if (initialized) return false;
    initialized = true;
    const SwiperClass = swiper.constructor;
    if (thumbsParams.swiper instanceof SwiperClass) {
      swiper.thumbs.swiper = thumbsParams.swiper;
      Object.assign(swiper.thumbs.swiper.originalParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      Object.assign(swiper.thumbs.swiper.params, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper.update();
    } else if (isObject(thumbsParams.swiper)) {
      const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
      Object.assign(thumbsSwiperParams, {
        watchSlidesProgress: true,
        slideToClickedSlide: false
      });
      swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
      swiperCreated = true;
    }
    swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
    swiper.thumbs.swiper.on('tap', onThumbClick);
    return true;
  }
  function update(initial) {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

    // Activate thumbs
    let thumbsToActivate = 1;
    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
    if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
      thumbsToActivate = swiper.params.slidesPerView;
    }
    if (!swiper.params.thumbs.multipleActiveThumbs) {
      thumbsToActivate = 1;
    }
    thumbsToActivate = Math.floor(thumbsToActivate);
    thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));
    if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i}"]`).forEach(slideEl => {
          slideEl.classList.add(thumbActiveClass);
        });
      }
    } else {
      for (let i = 0; i < thumbsToActivate; i += 1) {
        if (thumbsSwiper.slides[swiper.realIndex + i]) {
          thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);
        }
      }
    }
    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
      const currentThumbsIndex = thumbsSwiper.activeIndex;
      let newThumbsIndex;
      let direction;
      if (thumbsSwiper.params.loop) {
        const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];
        newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
        direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
      } else {
        newThumbsIndex = swiper.realIndex;
        direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
      }
      if (useOffset) {
        newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
      }
      if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
        if (thumbsSwiper.params.centeredSlides) {
          if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
          } else {
            newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
          }
        } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {
          // newThumbsIndex = newThumbsIndex - slidesPerView + 1;
        }
        thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
      }
    }
  }
  on('beforeInit', () => {
    const {
      thumbs
    } = swiper.params;
    if (!thumbs || !thumbs.swiper) return;
    if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {
      const document = getDocument();
      const getThumbsElementAndInit = () => {
        const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;
        if (thumbsElement && thumbsElement.swiper) {
          thumbs.swiper = thumbsElement.swiper;
          init();
          update(true);
        } else if (thumbsElement) {
          const onThumbsSwiper = e => {
            thumbs.swiper = e.detail[0];
            thumbsElement.removeEventListener('init', onThumbsSwiper);
            init();
            update(true);
            thumbs.swiper.update();
            swiper.update();
          };
          thumbsElement.addEventListener('init', onThumbsSwiper);
        }
        return thumbsElement;
      };
      const watchForThumbsToAppear = () => {
        if (swiper.destroyed) return;
        const thumbsElement = getThumbsElementAndInit();
        if (!thumbsElement) {
          requestAnimationFrame(watchForThumbsToAppear);
        }
      };
      requestAnimationFrame(watchForThumbsToAppear);
    } else {
      init();
      update(true);
    }
  });
  on('slideChange update resize observerUpdate', () => {
    update();
  });
  on('setTransition', (_s, duration) => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    thumbsSwiper.setTransition(duration);
  });
  on('beforeDestroy', () => {
    const thumbsSwiper = swiper.thumbs.swiper;
    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
    if (swiperCreated) {
      thumbsSwiper.destroy();
    }
  });
  Object.assign(swiper.thumbs, {
    init,
    update
  });
}
;// ./node_modules/swiper/modules/free-mode/free-mode.js

function freeMode({
  swiper,
  extendParams,
  emit,
  once
}) {
  extendParams({
    freeMode: {
      enabled: false,
      momentum: true,
      momentumRatio: 1,
      momentumBounce: true,
      momentumBounceRatio: 1,
      momentumVelocityRatio: 1,
      sticky: false,
      minimumVelocity: 0.02
    }
  });
  function onTouchStart() {
    if (swiper.params.cssMode) return;
    const translate = swiper.getTranslate();
    swiper.setTranslate(translate);
    swiper.setTransition(0);
    swiper.touchEventsData.velocities.length = 0;
    swiper.freeMode.onTouchEnd({
      currentPos: swiper.rtl ? swiper.translate : -swiper.translate
    });
  }
  function onTouchMove() {
    if (swiper.params.cssMode) return;
    const {
      touchEventsData: data,
      touches
    } = swiper;
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: utils_now()
    });
  }
  function onTouchEnd({
    currentPos
  }) {
    if (swiper.params.cssMode) return;
    const {
      params,
      wrapperEl,
      rtlTranslate: rtl,
      snapGrid,
      touchEventsData: data
    } = swiper;
    // Time diff
    const touchEndTime = utils_now();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeMode.momentum) {
      if (data.velocities.length > 1) {
        const lastMoveEvent = data.velocities.pop();
        const velocityEvent = data.velocities.pop();
        const distance = lastMoveEvent.position - velocityEvent.position;
        const time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || utils_now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeMode.momentumVelocityRatio;
      data.velocities.length = 0;
      let momentumDuration = 1000 * params.freeMode.momentumRatio;
      const momentumDistance = swiper.velocity * momentumDuration;
      let newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      let doBounce = false;
      let afterBouncePosition;
      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
      let needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeMode.momentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeMode.sticky) {
        let nextSlide;
        for (let j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        once('transitionEnd', () => {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeMode.sticky) {
          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeMode.sticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeMode.momentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        utils_elementTransitionEnd(wrapperEl, () => {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(() => {
            swiper.setTranslate(afterBouncePosition);
            utils_elementTransitionEnd(wrapperEl, () => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          utils_elementTransitionEnd(wrapperEl, () => {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeMode.sticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      emit('_freeModeNoMomentumRelease');
    }
    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
  }
  Object.assign(swiper, {
    freeMode: {
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }
  });
}
;// ./node_modules/swiper/modules/grid/grid.js
function Grid({
  swiper,
  extendParams
}) {
  extendParams({
    grid: {
      rows: 1,
      fill: 'column'
    }
  });
  let slidesNumberEvenToRows;
  let slidesPerRow;
  let numFullColumns;
  const getSpaceBetween = () => {
    let spaceBetween = swiper.params.spaceBetween;
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
    } else if (typeof spaceBetween === 'string') {
      spaceBetween = parseFloat(spaceBetween);
    }
    return spaceBetween;
  };
  const initSlides = slidesLength => {
    const {
      slidesPerView
    } = swiper.params;
    const {
      rows,
      fill
    } = swiper.params.grid;
    numFullColumns = Math.floor(slidesLength / rows);
    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
    }
    if (slidesPerView !== 'auto' && fill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
    }
    slidesPerRow = slidesNumberEvenToRows / rows;
  };
  const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
    const {
      slidesPerGroup
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows,
      fill
    } = swiper.params.grid;
    // Set slides order
    let newSlideOrderIndex;
    let column;
    let row;
    if (fill === 'row' && slidesPerGroup > 1) {
      const groupIndex = Math.floor(i / (slidesPerGroup * rows));
      const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
      const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
      row = Math.floor(slideIndexInGroup / columnsInGroup);
      column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
      newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
      slide.style.order = newSlideOrderIndex;
    } else if (fill === 'column') {
      column = Math.floor(i / rows);
      row = i - column * rows;
      if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
        row += 1;
        if (row >= rows) {
          row = 0;
          column += 1;
        }
      }
    } else {
      row = Math.floor(i / slidesPerRow);
      column = i - row * slidesPerRow;
    }
    slide.row = row;
    slide.column = column;
    slide.style[getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';
  };
  const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {
    const {
      centeredSlides,
      roundLengths
    } = swiper.params;
    const spaceBetween = getSpaceBetween();
    const {
      rows
    } = swiper.params.grid;
    swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
    swiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
    if (centeredSlides) {
      const newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid.splice(0, snapGrid.length);
      snapGrid.push(...newSlidesGrid);
    }
  };
  swiper.grid = {
    initSlides,
    updateSlide,
    updateWrapperSize
  };
}
;// ./node_modules/swiper/shared/effect-init.js
function effect_init_effectInit(params) {
  const {
    effect,
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams,
    perspective,
    recreateShadows,
    getEffectParams
  } = params;
  on('beforeInit', () => {
    if (swiper.params.effect !== effect) return;
    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
    if (perspective && perspective()) {
      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
    }
    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
    Object.assign(swiper.params, overwriteParamsResult);
    Object.assign(swiper.originalParams, overwriteParamsResult);
  });
  on('setTranslate', () => {
    if (swiper.params.effect !== effect) return;
    setTranslate();
  });
  on('setTransition', (_s, duration) => {
    if (swiper.params.effect !== effect) return;
    setTransition(duration);
  });
  on('transitionEnd', () => {
    if (swiper.params.effect !== effect) return;
    if (recreateShadows) {
      if (!getEffectParams || !getEffectParams().slideShadows) return;
      // remove shadows
      swiper.slides.forEach(slideEl => {
        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());
      });
      // create new one
      recreateShadows();
    }
  });
  let requireUpdateOnVirtual;
  on('virtualUpdate', () => {
    if (swiper.params.effect !== effect) return;
    if (!swiper.slides.length) {
      requireUpdateOnVirtual = true;
    }
    requestAnimationFrame(() => {
      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
        setTranslate();
        requireUpdateOnVirtual = false;
      }
    });
  });
}
;// ./node_modules/swiper/shared/effect-target.js

function effect_target_effectTarget(effectParams, slideEl) {
  const transformEl = utils_getSlideTransformEl(slideEl);
  if (transformEl !== slideEl) {
    transformEl.style.backfaceVisibility = 'hidden';
    transformEl.style['-webkit-backface-visibility'] = 'hidden';
  }
  return transformEl;
}
;// ./node_modules/swiper/shared/effect-virtual-transition-end.js

function effect_virtual_transition_end_effectVirtualTransitionEnd({
  swiper,
  duration,
  transformElements,
  allSlides
}) {
  const {
    activeIndex
  } = swiper;
  const getSlide = el => {
    if (!el.parentElement) {
      // assume shadow root
      const slide = swiper.slides.filter(slideEl => slideEl.shadowEl && slideEl.shadowEl === el.parentNode)[0];
      return slide;
    }
    return el.parentElement;
  };
  if (swiper.params.virtualTranslate && duration !== 0) {
    let eventTriggered = false;
    let transitionEndTarget;
    if (allSlides) {
      transitionEndTarget = transformElements;
    } else {
      transitionEndTarget = transformElements.filter(transformEl => {
        const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;
        return swiper.getSlideIndex(el) === activeIndex;
      });
    }
    transitionEndTarget.forEach(el => {
      utils_elementTransitionEnd(el, () => {
        if (eventTriggered) return;
        if (!swiper || swiper.destroyed) return;
        eventTriggered = true;
        swiper.animating = false;
        const evt = new window.CustomEvent('transitionend', {
          bubbles: true,
          cancelable: true
        });
        swiper.wrapperEl.dispatchEvent(evt);
      });
    });
  }
}
;// ./node_modules/swiper/modules/effect-fade/effect-fade.js




function EffectFade({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    fadeEffect: {
      crossFade: false
    }
  });
  const setTranslate = () => {
    const {
      slides
    } = swiper;
    const params = swiper.params.fadeEffect;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = swiper.slides[i];
      const offset = slideEl.swiperSlideOffset;
      let tx = -offset;
      if (!swiper.params.virtualTranslate) tx -= swiper.translate;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
      }
      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
      const targetEl = effect_target_effectTarget(params, slideEl);
      targetEl.style.opacity = slideOpacity;
      targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => utils_getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
    });
    effect_virtual_transition_end_effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  effect_init_effectInit({
    effect: 'fade',
    swiper,
    on,
    setTranslate,
    setTransition,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
;// ./node_modules/swiper/modules/effect-cube/effect-cube.js


function EffectCube({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    cubeEffect: {
      slideShadows: true,
      shadow: true,
      shadowOffset: 20,
      shadowScale: 0.94
    }
  });
  const createSlideShadows = (slideEl, progress, isHorizontal) => {
    let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = utils_createElement('div', `swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`);
      slideEl.append(shadowBefore);
    }
    if (!shadowAfter) {
      shadowAfter = utils_createElement('div', `swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`);
      slideEl.append(shadowAfter);
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // create new ones
    const isHorizontal = swiper.isHorizontal();
    swiper.slides.forEach(slideEl => {
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      createSlideShadows(slideEl, progress, isHorizontal);
    });
  };
  const setTranslate = () => {
    const {
      el,
      wrapperEl,
      slides,
      width: swiperWidth,
      height: swiperHeight,
      rtlTranslate: rtl,
      size: swiperSize,
      browser
    } = swiper;
    const params = swiper.params.cubeEffect;
    const isHorizontal = swiper.isHorizontal();
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let wrapperRotate = 0;
    let cubeShadowEl;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl = swiper.slidesEl.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = utils_createElement('div', 'swiper-cube-shadow');
          swiper.slidesEl.append(cubeShadowEl);
        }
        cubeShadowEl.style.height = `${swiperWidth}px`;
      } else {
        cubeShadowEl = el.querySelector('.swiper-cube-shadow');
        if (!cubeShadowEl) {
          cubeShadowEl = utils_createElement('div', 'swiper-cube-shadow');
          el.append(cubeShadowEl);
        }
      }
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let slideIndex = i;
      if (isVirtual) {
        slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);
      }
      let slideAngle = slideIndex * 90;
      let round = Math.floor(slideAngle / 360);
      if (rtl) {
        slideAngle = -slideAngle;
        round = Math.floor(-slideAngle / 360);
      }
      const progress = Math.max(Math.min(slideEl.progress, 1), -1);
      let tx = 0;
      let ty = 0;
      let tz = 0;
      if (slideIndex % 4 === 0) {
        tx = -round * 4 * swiperSize;
        tz = 0;
      } else if ((slideIndex - 1) % 4 === 0) {
        tx = 0;
        tz = -round * 4 * swiperSize;
      } else if ((slideIndex - 2) % 4 === 0) {
        tx = swiperSize + round * 4 * swiperSize;
        tz = swiperSize;
      } else if ((slideIndex - 3) % 4 === 0) {
        tx = -swiperSize;
        tz = 3 * swiperSize + swiperSize * 4 * round;
      }
      if (rtl) {
        tx = -tx;
      }
      if (!isHorizontal) {
        ty = tx;
        tx = 0;
      }
      const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
      if (progress <= 1 && progress > -1) {
        wrapperRotate = slideIndex * 90 + progress * 90;
        if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
      }
      slideEl.style.transform = transform;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress, isHorizontal);
      }
    }
    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
    wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;
    if (params.shadow) {
      if (isHorizontal) {
        cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;
      } else {
        const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
        const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
        const scale1 = params.shadowScale;
        const scale2 = params.shadowScale / multiplier;
        const offset = params.shadowOffset;
        cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;
      }
    }
    const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;
    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;
    wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);
  };
  const setTransition = duration => {
    const {
      el,
      slides
    } = swiper;
    slides.forEach(slideEl => {
      slideEl.style.transitionDuration = `${duration}ms`;
      slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {
        subEl.style.transitionDuration = `${duration}ms`;
      });
    });
    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
      const shadowEl = el.querySelector('.swiper-cube-shadow');
      if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
    }
  };
  effect_init_effectInit({
    effect: 'cube',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.cubeEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      resistanceRatio: 0,
      spaceBetween: 0,
      centeredSlides: false,
      virtualTranslate: true
    })
  });
}
;// ./node_modules/swiper/shared/create-shadow.js

function create_shadow_createShadow(params, slideEl, side) {
  const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}`;
  const shadowContainer = utils_getSlideTransformEl(slideEl);
  let shadowEl = shadowContainer.querySelector(`.${shadowClass}`);
  if (!shadowEl) {
    shadowEl = utils_createElement('div', `swiper-slide-shadow${side ? `-${side}` : ''}`);
    shadowContainer.append(shadowEl);
  }
  return shadowEl;
}
;// ./node_modules/swiper/modules/effect-flip/effect-flip.js





function EffectFlip({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    flipEffect: {
      slideShadows: true,
      limitRotation: true
    }
  });
  const createSlideShadows = (slideEl, progress, params) => {
    let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
    let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
    if (!shadowBefore) {
      shadowBefore = create_shadow_createShadow(params, slideEl, swiper.isHorizontal() ? 'left' : 'top');
    }
    if (!shadowAfter) {
      shadowAfter = create_shadow_createShadow(params, slideEl, swiper.isHorizontal() ? 'right' : 'bottom');
    }
    if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
  };
  const recreateShadows = () => {
    // Set shadows
    const params = swiper.params.flipEffect;
    swiper.slides.forEach(slideEl => {
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      createSlideShadows(slideEl, progress, params);
    });
  };
  const setTranslate = () => {
    const {
      slides,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.flipEffect;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      let progress = slideEl.progress;
      if (swiper.params.flipEffect.limitRotation) {
        progress = Math.max(Math.min(slideEl.progress, 1), -1);
      }
      const offset = slideEl.swiperSlideOffset;
      const rotate = -180 * progress;
      let rotateY = rotate;
      let rotateX = 0;
      let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let ty = 0;
      if (!swiper.isHorizontal()) {
        ty = tx;
        tx = 0;
        rotateX = -rotateY;
        rotateY = 0;
      } else if (rtl) {
        rotateY = -rotateY;
      }
      slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
      if (params.slideShadows) {
        createSlideShadows(slideEl, progress, params);
      }
      const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      const targetEl = effect_target_effectTarget(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => utils_getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    effect_virtual_transition_end_effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements
    });
  };
  effect_init_effectInit({
    effect: 'flip',
    swiper,
    on,
    setTranslate,
    setTransition,
    recreateShadows,
    getEffectParams: () => swiper.params.flipEffect,
    perspective: () => true,
    overwriteParams: () => ({
      slidesPerView: 1,
      slidesPerGroup: 1,
      watchSlidesProgress: true,
      spaceBetween: 0,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
;// ./node_modules/swiper/modules/effect-coverflow/effect-coverflow.js




function EffectCoverflow({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    coverflowEffect: {
      rotate: 50,
      stretch: 0,
      depth: 100,
      scale: 1,
      modifier: 1,
      slideShadows: true
    }
  });
  const setTranslate = () => {
    const {
      width: swiperWidth,
      height: swiperHeight,
      slides,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.coverflowEffect;
    const isHorizontal = swiper.isHorizontal();
    const transform = swiper.translate;
    const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
    const rotate = isHorizontal ? params.rotate : -params.rotate;
    const translate = params.depth;
    // Each slide offset from center
    for (let i = 0, length = slides.length; i < length; i += 1) {
      const slideEl = slides[i];
      const slideSize = slidesSizesGrid[i];
      const slideOffset = slideEl.swiperSlideOffset;
      const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
      const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;
      let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
      let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
      // var rotateZ = 0
      let translateZ = -translate * Math.abs(offsetMultiplier);
      let stretch = params.stretch;
      // Allow percentage to make a relative stretch for responsive sliders
      if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
        stretch = parseFloat(params.stretch) / 100 * slideSize;
      }
      let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
      let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
      let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

      // Fix for ultra small values
      if (Math.abs(translateX) < 0.001) translateX = 0;
      if (Math.abs(translateY) < 0.001) translateY = 0;
      if (Math.abs(translateZ) < 0.001) translateZ = 0;
      if (Math.abs(rotateY) < 0.001) rotateY = 0;
      if (Math.abs(rotateX) < 0.001) rotateX = 0;
      if (Math.abs(scale) < 0.001) scale = 0;
      const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
      const targetEl = effect_target_effectTarget(params, slideEl);
      targetEl.style.transform = slideTransform;
      slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
      if (params.slideShadows) {
        // Set shadows
        let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');
        let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');
        if (!shadowBeforeEl) {
          shadowBeforeEl = create_shadow_createShadow(params, slideEl, isHorizontal ? 'left' : 'top');
        }
        if (!shadowAfterEl) {
          shadowAfterEl = create_shadow_createShadow(params, slideEl, isHorizontal ? 'right' : 'bottom');
        }
        if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
        if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => utils_getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
  };
  effect_init_effectInit({
    effect: 'coverflow',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true
    })
  });
}
;// ./node_modules/swiper/modules/effect-creative/effect-creative.js





function EffectCreative({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    creativeEffect: {
      limitProgress: 1,
      shadowPerProgress: false,
      progressMultiplier: 1,
      perspective: true,
      prev: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      },
      next: {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        opacity: 1,
        scale: 1
      }
    }
  });
  const getTranslateValue = value => {
    if (typeof value === 'string') return value;
    return `${value}px`;
  };
  const setTranslate = () => {
    const {
      slides,
      wrapperEl,
      slidesSizesGrid
    } = swiper;
    const params = swiper.params.creativeEffect;
    const {
      progressMultiplier: multiplier
    } = params;
    const isCenteredSlides = swiper.params.centeredSlides;
    if (isCenteredSlides) {
      const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
      wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
    }
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
      let originalProgress = progress;
      if (!isCenteredSlides) {
        originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
      }
      const offset = slideEl.swiperSlideOffset;
      const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];
      const r = [0, 0, 0];
      let custom = false;
      if (!swiper.isHorizontal()) {
        t[1] = t[0];
        t[0] = 0;
      }
      let data = {
        translate: [0, 0, 0],
        rotate: [0, 0, 0],
        scale: 1,
        opacity: 1
      };
      if (progress < 0) {
        data = params.next;
        custom = true;
      } else if (progress > 0) {
        data = params.prev;
        custom = true;
      }
      // set translate
      t.forEach((value, index) => {
        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
      });
      // set rotates
      r.forEach((value, index) => {
        r[index] = data.rotate[index] * Math.abs(progress * multiplier);
      });
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const translateString = t.join(', ');
      const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
      const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
      const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
      const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;

      // Set shadows
      if (custom && data.shadow || !custom) {
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl && data.shadow) {
          shadowEl = create_shadow_createShadow(params, slideEl);
        }
        if (shadowEl) {
          const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
          shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
        }
      }
      const targetEl = effect_target_effectTarget(params, slideEl);
      targetEl.style.transform = transform;
      targetEl.style.opacity = opacityString;
      if (data.origin) {
        targetEl.style.transformOrigin = data.origin;
      }
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => utils_getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    effect_virtual_transition_end_effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements,
      allSlides: true
    });
  };
  effect_init_effectInit({
    effect: 'creative',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => swiper.params.creativeEffect.perspective,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
;// ./node_modules/swiper/modules/effect-cards/effect-cards.js





function EffectCards({
  swiper,
  extendParams,
  on
}) {
  extendParams({
    cardsEffect: {
      slideShadows: true,
      rotate: true,
      perSlideRotate: 2,
      perSlideOffset: 8
    }
  });
  const setTranslate = () => {
    const {
      slides,
      activeIndex,
      rtlTranslate: rtl
    } = swiper;
    const params = swiper.params.cardsEffect;
    const {
      startTranslate,
      isTouched
    } = swiper.touchEventsData;
    const currentTranslate = rtl ? -swiper.translate : swiper.translate;
    for (let i = 0; i < slides.length; i += 1) {
      const slideEl = slides[i];
      const slideProgress = slideEl.progress;
      const progress = Math.min(Math.max(slideProgress, -4), 4);
      let offset = slideEl.swiperSlideOffset;
      if (swiper.params.centeredSlides && !swiper.params.cssMode) {
        swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
      }
      if (swiper.params.centeredSlides && swiper.params.cssMode) {
        offset -= slides[0].swiperSlideOffset;
      }
      let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
      let tY = 0;
      const tZ = -100 * Math.abs(progress);
      let scale = 1;
      let rotate = -params.perSlideRotate * progress;
      let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
      const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;
      const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
      const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
      if (isSwipeToNext || isSwipeToPrev) {
        const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
        rotate += -28 * progress * subProgress;
        scale += -0.5 * subProgress;
        tXAdd += 96 * subProgress;
        tY = `${-25 * subProgress * Math.abs(progress)}%`;
      }
      if (progress < 0) {
        // next
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;
      } else if (progress > 0) {
        // prev
        tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;
      } else {
        tX = `${tX}px`;
      }
      if (!swiper.isHorizontal()) {
        const prevY = tY;
        tY = tX;
        tX = prevY;
      }
      const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;

      /* eslint-disable */
      const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
      /* eslint-enable */

      if (params.slideShadows) {
        // Set shadows
        let shadowEl = slideEl.querySelector('.swiper-slide-shadow');
        if (!shadowEl) {
          shadowEl = createShadow(params, slideEl);
        }
        if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
      }
      slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
      const targetEl = effectTarget(params, slideEl);
      targetEl.style.transform = transform;
    }
  };
  const setTransition = duration => {
    const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));
    transformElements.forEach(el => {
      el.style.transitionDuration = `${duration}ms`;
      el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {
        shadowEl.style.transitionDuration = `${duration}ms`;
      });
    });
    effectVirtualTransitionEnd({
      swiper,
      duration,
      transformElements
    });
  };
  effectInit({
    effect: 'cards',
    swiper,
    on,
    setTranslate,
    setTransition,
    perspective: () => true,
    overwriteParams: () => ({
      watchSlidesProgress: true,
      virtualTranslate: !swiper.params.cssMode
    })
  });
}
;// ./node_modules/swiper/swiper.esm.js
/**
 * Swiper 9.4.1
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2023 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: June 13, 2023
 */


























/***/ }),

/***/ 9034:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(1602);
var Iterators = __webpack_require__(2228);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 9085:
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ 9206:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(2886);
var global = __webpack_require__(200);
var isObject = __webpack_require__(5335);
var createNonEnumerableProperty = __webpack_require__(7712);
var objectHas = __webpack_require__(1883);
var shared = __webpack_require__(9310);
var sharedKey = __webpack_require__(5904);
var hiddenKeys = __webpack_require__(7708);

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 9304:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(2074);
var getPrototypeOf = __webpack_require__(7970);
var createNonEnumerableProperty = __webpack_require__(7712);
var has = __webpack_require__(1883);
var wellKnownSymbol = __webpack_require__(1602);
var IS_PURE = __webpack_require__(6926);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 9310:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);
var setGlobal = __webpack_require__(5975);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 9720:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var global = __webpack_require__(200);

module.exports = global;


/***/ }),

/***/ 9838:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-iterator-helpers
var $ = __webpack_require__(1605);
var iterate = __webpack_require__(2929);
var anObject = __webpack_require__(3938);

$({ target: 'Iterator', proto: true, real: true }, {
  forEach: function forEach(fn) {
    iterate(anObject(this), fn, { IS_ITERATOR: true });
  }
});


/***/ }),

/***/ 9868:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var anObject = __webpack_require__(3938);

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),

/***/ 9965:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var store = __webpack_require__(9310);

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ })

}]);
//# sourceMappingURL=chunk-vendors.f63489a8.js.map